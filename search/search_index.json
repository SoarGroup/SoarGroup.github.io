{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Soar Homepage","text":"<p>Soar is a general cognitive architecture for developing systems that exhibit intelligent behavior. For more in-depth information, see our about page, or J.E. Laird's 2012 book, The Soar Cognitive Architecture, available from Amazon and MIT Press.</p> <p>To get started, download Soar and follow the quick start guide.</p> <p>If you are looking for help or discussion, please see our support page.</p>"},{"location":"#news-and-announcements","title":"News and Announcements","text":"<ul> <li>Soar 9.6.4 available for download: This release of Soar contains lots of stability and ergonomics improvements to VisualSoar and the Soar debugger, as well as newly-added support for LTI aliases.</li> <li> <p>This year's Soar workshop (45th) held on May 5, 2025 was a success! We had broad participation from various projects using Soar, including a remarkable presentation from our guest speaker Professor Jonathan Cohen of Princeton. Recordings and supporting information from all the 2025 workshop talks can be found here.</p> </li> <li> <p><code>soar_ros</code>, a ROS2 package by Moritz Schmidt that enables integration between ROS and Soar, is now available on GitHub.</p> </li> <li>Engineer's Guide to Soar: A 14-part course on programming Soar for engineers, by Bryan Stearns is now available on GitHub.</li> </ul>"},{"location":"development/","title":"Soar Development Topics","text":"<p>This section provides help articles for developing Soar agents and the Soar kernel. You might wish to first check out the FAQ for answers to common questions.</p>"},{"location":"development/BuildingSoarRos/","title":"ROS 1","text":"","tags":["ROS","compile","how-to"]},{"location":"development/BuildingSoarRos/#build-soar-with-ros-1","title":"Build Soar with ROS 1","text":"Soar for ROS 2 <p>For ROS 2, a package called <code>soar_ros</code> is available from GitHub that includes documentation. The last ROS 1 distribution is end of life (EOL) as of May 2025.</p>","tags":["ROS","compile","how-to"]},{"location":"development/BuildingSoarRos/#requirements","title":"Requirements","text":"<ul> <li>Ubuntu 18.04.4 LTS Bionic THIS IS NOT OPTIONAL. NO OTHER LINUX DISTRO WORKS</li> <li>Relatively recent GPU YOUR COMPUTER MUST HAVE A DISPLAY</li> <li>ROS Melodic ONLY MELODIC WILL WORK</li> <li>Gazebo 9 MUST BE 9</li> <li>Point Cloud Library version 1.8.1 Must be 1.8.1</li> </ul> <p>ROS Installation (from http://wiki.ros.org/melodic/Installation/Ubuntu):</p> <pre><code>sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" &gt; /etc/apt/sources.list.d/ros-latest.list'\nsudo apt-key adv --keyserver 'hkp://keyserver.ubuntu.com:80' --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654\nsudo apt update\nsudo apt install ros-melodic-desktop-full\necho \"source /opt/ros/melodic/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre> <p>Point Cloud Library should also be installed. Run sudo apt install libpcl-dev to make sure.</p>","tags":["ROS","compile","how-to"]},{"location":"development/BuildingSoarRos/#download-and-build-soar","title":"Download and Build Soar","text":"<pre><code>git clone https://github.com/SoarGroup/Soar.git -b svs_overhaul\nsudo apt install build-essential swig openjdk-8-jdk python-all-dev\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$SOAR_HOME:/opt/ros/melodic/lib/\nexport CPATH=$CPATH:/usr/include/pcl-1.8/:/opt/ros/melodic/include/\ncd Soar\npython2 scons/scons.py all --use-ros\n</code></pre> <p>If you want Python 3 support, replace step 4 with:</p> <pre><code>which python3\n</code></pre> <p>Copy the file path returned</p> <pre><code>python2 scons/scons.py all --use-ros --python=&lt;insert/path/copied/above&gt;\n</code></pre> <p>Recommended: If you want to use Lizzie's svs_utils ROS package to make a world with a Fetch robot, follow these steps: Install the Fetch ROS and Gazebo packages: sudo apt install ros-melodic-fetch-ros ros-melodic-fetch-gazebo Create a catkin workspace: mkdir ~/svs_utils_ws/src</p> <pre><code>cd ~/svs_utils_ws\ncatkin_make\ncd src\ngit clone https://[your_username]@bitbucket.org/emgoeddel/svs_util.git (Ask Lizzie for access to the Bitbucket)\ncd ..\ncatkin_make\necho \"source ~/svs_util_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre>","tags":["ROS","compile","how-to"]},{"location":"development/SoarTechnicalFAQ/","title":"Technical FAQ","text":"","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#soar-technical-faq","title":"Soar Technical FAQ","text":"","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#getting-soar","title":"Getting Soar","text":"","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#where-are-the-latest-soar-releases","title":"Where are the latest Soar releases?","text":"<p>Check the downloads page for pointers to downloads and release notes. Alternatively you can check out the development trunk from git. See the build documents for more information.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#running-soar","title":"Running Soar","text":"","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-do-i-run-soar","title":"How do I run Soar?","text":"<p>If you downloaded a Soar release, navigate inside the extracted archive and run the shell scripts or batch files to run the various Soar components. The scripts set essential environment variables so the different Soar components can find their libraries and resources.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#java-what-jresjdks-can-i-use","title":"Java: What JREs/JDKs can I use?","text":"<p>Use Sun JDK 6+. Other versions and vendors may work but we do not support them.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#using-the-soar-java-debugger","title":"Using the Soar Java Debugger","text":"","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#what-command-line-options-does-the-debugger-accept","title":"What command line options does the debugger accept?","text":"<p>Command line options:</p> <ul> <li>remote =&gt; use a remote connection (with default ip and port values)</li> <li>ip xxx =&gt; use this IP value (implies remote connection)</li> <li>port ppp =&gt; use this port (implies remote connection)     Without any remote options we start a local kernel</li> <li>agent =&gt; on a remote connection select this agent as initial agent</li> <li>agent =&gt; on a local connection use this as the name of the initial agent</li> <li>source \"\" =&gt; load this file of productions on launch (only valid for local kernel)</li> <li>listen port =&gt; use this port to listen for remote connections (only valid for a local kernel)</li> <li>maximize =&gt; start with maximized window</li> <li>width =&gt; start with this window width</li> <li>height =&gt; start with this window height</li> <li>x -y =&gt; start with this window position (Providing width/height/x/y =&gt; not a maximized window)</li> </ul>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#if-i-run-the-debugger-for-a-while-it-starts-to-slow-down-stutter-and-then-crashes-or-runs-out-of-memory","title":"If I run the debugger for a while, it starts to slow down, stutter, and then crashes, or runs out of memory","text":"<p>The problem here is that the trace window in the debugger is using more and more memory over time, since it doesn't get rid of old stuff until you clear the window. Especially at <code>watch 5</code>, there's a lot of text being stored (even if it's mostly hidden). Long before your OS runs out of memory, though, Java runs out of heap space. You can allocate more heap space to most Java implementations using the -Xmxm flag when executing Java. For example:</p> <pre><code>java -Xmx512m -jar SoarJavaDebugger.jar\n</code></pre> <p>This will allocate 512 megs of memory for Java's heap (the default is 64 megs), and should allow you to run the debugger significantly longer.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-do-i-use-the-debugger-with-the-graphical-demos-like-javatoh-and-javamissionaries-or-any-other-soar-application","title":"How do I use the debugger with the graphical demos like JavaTOH and JavaMissionaries? (or any other Soar application)?","text":"<ol> <li>Start the application</li> <li>Start the debugger (in Linux the debugger must be started after the    application--order doesn't matter in Windows)</li> <li>In the debugger, on the top menuBar, pull down the \"Kernel\" selection and    choose \"Connect to Remote Soar...\"</li> <li>In the popup window \"Would you like to shutdown the local kernel now\" enter    \"OK\"</li> <li>In the next popup window, if the application is on your local machine, press    \"OK\" to use the default settings. If your application is running on another    machine, enter the IP addr and press \"OK\"</li> <li>If the connection succeeds, then you can use the debugger and the application    interchangeably to control the agent. If the connection fails, then the    application either is not properly configured for SML, or no agent currently    exists in the application.</li> </ol>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-can-i-copypaste-a-production-into-the-debugger","title":"How can I copy/paste a production into the debugger?","text":"<p>There are several ways to do this:</p> <ul> <li>You can paste a production into the trace window.</li> <li>You can use the \"edit_production\" window in the lower-right corner. If you     supply the name of an existing production, it will fill in the window with that     production. You can then edit it and load the new version using the \"Load     Production\" button.</li> <li>If your production is in Visual Soar, you can do \"Soar Runtime\" -&gt; \"Connect\"     to connect to the debugger. Then, open the file with your production and do     \"Runtime\" -&gt; \"Send Production\" or \"Send File\" to load your production(s) into     Soar.</li> </ul>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#developing-soar","title":"Developing Soar","text":"","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#scons-is-adding-a-lot-of-ridiculous-include-directories-and-the-build-fails","title":"SCons is adding a lot of ridiculous include directories and the build fails","text":"<p>Seeing something like this means you should define <code>JAVA_HOME</code>:</p> <pre><code>g++ -o Core/CLI/CommandLineInterface.o -c -DSCONS -fvisibility=hidden -g3 -Wall -Werror -O3 -m64 -fPIC -ICore/CLI/src -ICore/CLI/include -ICore/SoarKernel/include -ICore/ElementXML/include -ICore/ConnectionSML/include -ICore/KernelSML/include -ICore/shared -I/usr/include -I/usr/include/netatalk -I/usr/include/netinet -I/usr/include/protocols -I/usr/include/dbus-1.0 -I/usr/include/blkid -I/usr/include/netax25 -I/usr/include/nfs -I/usr/include/rdma -I/usr/include/netpacket -I/usr/include/X11 -I/usr/include/c++ -I/usr/include/neteconet -I/usr/include/xen -I/usr/include/rpc -I/usr/include/gnu -I/usr/include/netash -I/usr/include/asm -I/usr/include/sound -I/usr/include/mtd -I/usr/include/asm-generic -I/usr/include/netrom -I/usr/include/compiz -I/usr/include/arpa -I/usr/include/net -I/usr/include/rpcsvc -I/usr/include/netiucv -I/usr/include/linux -I/usr/include/netrose -I/usr/include/video -I/usr/include/bits -I/usr/include/netipx -I/usr/include/uuid -I/usr/include/python2.5 -I/usr/include/sys -I/usr/include/python2.6\n</code></pre> <p>See the build document for more details.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-do-i-get-the-trace-for-the-initial-s1-creation","title":"How do I get the trace for the initial S1 creation?","text":"<p>The initial state is created right after the agent is created but before the agent pointer is passed back to the client. Therefore, if you create the client and then register for print (or xml) output, you do not ever see the initial S1 creation.</p> <p>To get these initial print callbacks, you need to register for the after-agent-created event and register your print handlers in that function. This callback fires right after the agent is created but before S1 is created.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-can-i-look-up-a-wme-on-the-input-link-if-i-know-its-attribute","title":"How can I look up a wme on the input link if I know its attribute?","text":"<p>Use the <code>Indentifier::FindByAttribute</code> method like this:</p> <pre><code>pAgent-&gt;GetInputLink()-&gt;FindByAttribute(\"location\", 0);\n</code></pre> <p>This works for any identifier, not just at the top level of the input link.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-do-i-increase-the-performance-of-my-sml-application","title":"How do I increase the performance of my SML application?","text":"<p>It is often desirable to maximize the performance of your SML application. This section assumes that you just want to make things as fast as possible after you have finished debugging your application. Debugging is an inherently slow process, so these tips will be less helpful while you\u2019re still debugging.</p> <p>Compile with optimizations turned on. In Visual Studio this means doing a release build. On Linux and OS X, the default settings are probably sufficient, but you can experiment with new settings if you want (let us know if you find better settings).</p> <p>Put primary application and Soar in the same process. That is, use <code>CreateInNewThread</code> or <code>CreateInCurrentThread</code>, not <code>CreateRemoteConnection</code>. Using a remote kernel means socket communication is used, which is slow.</p> <p>Don\u2019t register for unnecessary events. Every event that is registered for causes extra work to be done. Try to find an appropriate event to register for so you don\u2019t end up getting more event calls than you actually need \u2013 that is, try to avoid registering for events which occur more frequently than you need and then filtering them on the application side.</p> <p>Don\u2019t connect the debugger. Connecting the debugger creates a remote connection and also registers for several events. Set <code>watch level 0</code>. Even if you don\u2019t have a client registered for any of the print or XML events, work is still done internally to generate some of the information that would have been sent out. Setting <code>watch level 0</code> avoids this work.</p> <p>Disable monitor productions. Again, even if no client is registered to print out the text of monitor productions, work is still done internally to prepare the text. Monitor productions can be disabled by excising them or commenting them out, but an easier method is to have each monitor production test a debug flag in working memory which is set by some initialization production or operator. Thus all of the monitor productions can be turned on or off by changing one line of code.</p> <p>Disable timers. Soar uses timers internally to generate the output of the stats command. If you don\u2019t need this information, you can use the <code>timers \u2013off</code> command to disable this bookkeeping. This can make a significant difference in the <code>watch 0</code> case.</p> <p>Avoid running agents separately. Instead of calling <code>RunSelf</code> or <code>RunSelfTilOutput</code> on each agent, just call RunAllAgents? on the kernel itself. This runs all agents together and avoids the overhead of running them separately. The absolute best you can do is to call <code>RunAllAgentsForever</code> as described in section 2.4 \u2013 this avoids repeatedly calling the <code>run</code> functions at all and will make it easier to stop and restart your application from the debugger (or other clients).</p> <p>In the case where the absolute best performance under SML is desired, use <code>CreateKernelInCurrentThread</code> instead of <code>CreateKernelInNewThread</code> and set the \u201coptimized\u201d flag to true in the parameters passed to <code>CreateKernelInCurrentThread</code>. This means Soar will execute in the same thread as your application. Without this each call to and from the Soar kernel requires a context switch (assuming a single processor machine). This method also eliminates the thread which polls for new events. This means you must poll for the events yourself by periodically calling <code>CheckForIncommingCommands</code>, which is a little more work for the programmer.</p> <p>Turn off <code>autocommits</code>. By default, SML sends WME changes to the kernel as soon as they are requested. Performance can be improved by telling SML to buffer all WME changes until an explicit call is made to commit the changes. Turning off <code>autocommits</code> is done via a call to <code>mykernel-&gt;SetAutoCommit(false)</code>. Explicitly committing WME changes is done via a call to <code>myagent-&gt;Commit()</code>. Sending all the changes at once will give a small performance boost in cases where Soar and the environment are in the same process, and a large performance boost when they are communicating over sockets. Be careful, though - the agent won't see any WMEs until they have been committed (and then not until the next input phase, as usual), and all WMEs must be committed before doing an <code>init-soar</code>, which generally means before giving the user control (since someone could call <code>init-soar</code> from an attached debugger). This typically means committing all WMEs after updating an agent's <code>input-link</code>.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#when-can-i-safely-make-changes-to-the-input-link","title":"When can I safely make changes to the input-link?","text":"<p>A Soar agent only receives input during the input phase and it does this through an input phase callback while the agent is running. SML allows the environment to change the input-link at other times and those changes are buffered until the next input phase. This means you have several options for handling input: You can register for <code>smlEVENT_BEFORE_INPUT_PHASE</code> and make changes to the input link at that time. This is very close to the way the kernel naturally handles input but will often be relatively slow if Soar is running a lot faster than the environment is changing (a common situation) as this event needs to be sent each decision cycle for each agent, generating a lot of communications traffic.</p> <p>Another option is to register for an update event (<code>smlEVENT_AFTER_ALL_OUTPUT_PHASES</code> and <code>smlEVENT_AFTER_ALL_GENERATED_OUTPUT</code>), check for output at that time and create new inputs immediately. These events are called after the output phase has completed and the new input link changes will be buffered until the next input phase. This is the most common choice in existing SML environments.</p> <p>A third option is to register an output event handler, which looks for a particular attribute to be added to the output link and only then calls the registered function. This handler will be called during the output phase and again, new input will be collected and buffered until the next input phase of the agent. In general, any run event (<code>smlRunEventId</code>) or update event (<code>smlUpdateEventId</code>) is a good candidate to use for changing the input-link. Other events may not be appropriate to use. One particular example is <code>smlEVENT_BEFORE_AGENT_REINITIALIZED</code> and <code>smlEVENT_AFTER_AGENT_REINITIALIZED</code>. These events fire during an init-soar call and are dangerous to use because the system is actively destroying the entire input link and then recreating it to match the last structure defined by the environment. This happens automatically and gives the agent its best chance to continue executing again. However, if you register for these events yourself and try to change the input link during those events, the resulting behavior is likely to depend on whether the system callback occurs before or after your callback. With care this can probably all work out correctly, but you should be aware of what's going on. Similarly, making changes to I/O in response to a production firing or other such events is potentially dangerous as you might be changing input within a given execution phase rather than before or after it, leading to unpredictable results. These events are best used for monitoring Soar's behavior rather than changing it.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#what-do-i-need-to-know-about-threads-in-my-sml-applications","title":"What do I need to know about threads in my SML applications?","text":"<p>You generally want to keep all interactions with the kernel in a single thread. You can make calls from other threads, but they will block if Soar is busy doing something else - like running - until the command completes. This requirement raises a few issues: If you're working with a GUI, then the handler for a \"run button\" shouldn't just call run on the kernel. If it does the GUI will wait for the run to complete before responding. This is usually not acceptable as requests to repaint the screen, other button presses etc. will be ignored. The solution is to create a new thread and run Soar in that thread. Now that Soar is running on a separate thread, when the user presses a \"stop\" button if you try to call Stop on the kernel from the UI thread it'll block. What you need to do instead is set a flag within the thread that is running Soar and use an event to check whether that flag has been set and if so call Stop then. The <code>smlEVENT_INTERRUPT_CHECK</code> event is a good candidate for this as it fires infrequently and generates little overhead.</p> <p>Similarly, as the environment changes you'll want to update the input link in the thread that is running Soar.</p> <p>The normal way to do this is again inside an event handler. The update family of events (<code>smlEVENT_AFTER_ALL_OUTPUT_PHASES</code> and <code>smlEVENT_AFTER_ALL_GENERATED_OUTPUT</code>) are good candidates to consider.</p> <p>If all of this seems a bit confusing, take a look at the Java Towers of Hanoi example that's included in the release. It demonstrates all of this behavior and is a good model to follow. If you're working on a command line application without a GUI, then the TestCommandLine application is a good reference as it demonstrates how to support interruption in a single-threaded application.</p> <p>A detailed explanation about threads in Soar is provided here.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-do-i-properly-manage-memory-in-my-sml-application","title":"How do I properly manage memory in my SML application?","text":"<p>Memory management is actually really easy. Generally, the only objects you should explicitly delete are the kernel object and any objects you directly allocated through a call to new. In Java and Tcl, this generally means you can just let things go out of scope when you\u2019re done with them. There are a couple special cases you should be aware of, though: Agent objects are automatically deleted when the owning Kernel object is deleted (actually, when the call to <code>Kernel::Shutdown</code> is made, which you should always make before deleting the kernel). If you want to destroy an agent earlier, you can by making a call to <code>Kernel:destroyAgent</code>. Under no circumstances should you delete (in the C++ sense) an Agent object.</p> <p>In Java if you create a <code>ClientXML</code> object through <code>xml = new ClientXML()</code> you should call <code>xml.delete()</code> on it when you're done. This isn't strictly required (the garbage collector will get it eventually) but is good practice and will avoid messages about leaked memory when the application shuts down. As per the general rule, in C++ if you create it with new you\u2019re responsible for destroying it with delete.</p> <p>Since there can be multiple clients interacting with the same kernel and agents, your application needs to be listening for the appropriate events so if some other client deletes/destroys a kernel or agent your application is using, you don\u2019t crash. Specifically, listen for the <code>BEFORE_AGENT_DESTOYED</code> and <code>BEFORE_SHUTDOWN</code> events so you can clean things up as needed in your application.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#what-are-the-differences-in-the-sml-interface-between-c-and-java-and-other-languages","title":"What are the differences in the SML interface between C++ and Java (and other languages)?","text":"<p>For the most part, the exact same classes and methods are available in all languages. In some cases there are differences with obvious mappings -- for example, in C++ a method might take a char whereas in Java it takes a String. One exception to this rule is in the way event callbacks are handled. The callbacks look very similar from language to language, but some languages have constraints that make a direct conversion of the C++ style impossible. In C++, event callbacks are global functions.</p> <p>In Java, it's not possible to have global functions, so the callback must belong to some class. Thus, for Java we provide an interface for each event type that the class containing the callback method must implement, and then the handling object is passed in as part of the registration. You can look at any of the example Java code to see examples of this (e.g. TestJavaSML or JavaTOH are good places to start).</p> <p>Another important difference is that in C++ and Tcl, the kernel object must be explicitly deleted after <code>Shutdown()</code>. In C++ this is just calling <code>delete mykernel;</code> whereas in Tcl it takes the form <code>$kernel -delete</code>. In Java and C#, deletion is handled internally by the <code>Shutdown()</code> method (this isn't done in C++ to make debugging easier).</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-should-i-get-started-on-my-first-cjava-sml-application","title":"How should I get started on my first C++/Java SML application?","text":"<p>See the HelloWorld document for simple example environments Start by building and running these and then replace the code with your code. Also don't forget to read the SMLQuickStartGuide. The complete documentation for the SML interface is provided in the ClientSML C++ headers (which are thoughly commented). Using a different language - don't worry, the interface is virtually the same.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#how-do-i-make-a-copy-of-an-existing-project","title":"How do I make a copy of an existing project?","text":"<p>Go into the SoarSuite\\Tools folder and copy the TestClientSML folder as MyProject Within that folder, rename <code>TestClientSML.vcproj</code> as <code>MyProject.vcproj</code> Open the <code>SoarSuite\\SML.sln</code> solution file (or make a copy of this file and open that) Select \"File | Add Project | Existing Project\" and add the <code>MyProject.vcproj</code> to the solution It will be added as \"TestClientSML\". Select it in Solution Explorer, right click and choose Rename to rename it as MyProject. (Make sure you're not accidentally renaming the real TestClientSML project - you can open the TestClientSML.cpp file in the editor and then move your mouse over the tab at the top of the editor window for the open file to see the path just to be sure).</p> <p>At this point you should be able to build the project to create MyProject.exe Remove TestClientSML.cpp from the project and start adding your own code. What are the required Visual Studio project settings for my SML application?</p> <p>Your project needs to reference the <code>!ClientSML</code>, <code>!ConnectionSML</code>, and <code>!ElementXML</code> projects. Additionally, add the include directories for the src folder of each of those projects.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#the-java-virtual-machine-segfaults-when-running-soar","title":"The Java Virtual Machine segfaults when running Soar","text":"<p>See the next question.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/SoarTechnicalFAQ/#sml-wmelementidentifierstringelementintelementfloatelement-pointers-become-invalid-without-my-knowledge","title":"SML WMElement/Identifier/StringElement/IntElement/FloatElement pointers become invalid without my knowledge","text":"<p>First, usage of <code>WMElement</code> in this answer refers to any of <code>WMElement</code>/<code>Identifier</code>/<code>StringElement</code>/<code>IntElement</code>/<code>FloatElement</code> (all of which are or extend <code>WMElement</code>).</p> <p>A few things to remember about WMElement pointers returned by SML methods such as CreateIdentifier:</p> <ul> <li><code>WMElement</code> objects returned by pointers are owned by SML (don't delete them),</li> <li>Pointers to <code>WMElement</code> objects may be destroyed without calling <code>DestroyWME</code>,</li> <li>Pointers to <code>WMElement</code> objects may be destroyed by SML triggered by the agent as it runs.</li> <li>A general rule: you need to keep track of whether or not a <code>WMElement</code> is valid before you use it. It will stay valid if</li> <li>You do not call <code>DestroyWME</code> on it or on a WME that causes it to get disconnected,</li> <li>You do not return control back to Soar letting it run.</li> <li>If you call <code>DestroyWME</code>, you need to be sure that you don't hang on to any     WMElement objects that the WME you destroyed was keeping valid. Most of the time     your working memory structure is a tree so you only need to keep track of the     children of any Identifier you destroy.</li> </ul> <p>In Java/Python/Tcl/CSharp, <code>WMElement ConvertToIdentifier</code> or other Convert- function returns something that should be equal to something else but isn't.</p> <p>In our language interfaces covered by SWIG, such as Java, Python, Tcl, and CSharp, <code>ConvertToIdentifier</code>, <code>ConvertToStringElement</code>, <code>ConvertToIntElement</code>, and <code>ConvertToFloatElement</code> issue references to objects that wrap pointers. If these pointers were compared, they would be equal. Unfortunately, comparing references to these objects wrapping equivalent pointers returns <code>false</code> - that they are unequal.</p> <p>A workaround is to not compare references, or use other language supported reference equality in this case. Instead, compare the <code>time tags</code> by calling <code>GetTimeTag</code> on the reference.</p>","tags":["Java","C++","agent development","sml","kernel programming"]},{"location":"development/agents/DesignDogma/","title":"Design Dogma","text":"","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#soar-design-dogma","title":"Soar Design Dogma","text":"","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#introduction","title":"Introduction","text":"<p>This document contains a collection of Soar wisdom gathered during a series of conversations between John Laird and myself as I mounted the Soar learning curve over the course of my first year as a graduate student at the University of Michigan. My hope was that by writing these guidelines down I might ease the curve for future Soar users. To get the most value from this document, I recommend you read it once at the beginning of your Soar experience and then read it again once you've started using Soar in earnest.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#golden-rule-beware-the-devil-of-character-efficiency","title":"Golden Rule: Beware the Devil of Character Efficiency","text":"<p>Focus on creating short productions with only a few conditions and actions. As a rule of thumb, a production should have less than a handful (i.e., five) of each. If you have a production that's too big, it's a sign that you should examine that production and see if it should be broken up into multiple smaller productions.</p> <p>A production with too many conditions often has a subset of conditions that define a separate \"concept\" that should be identified with a separate elaboration. When counting conditions, you should only count those that actually test a WME for its value not to reach other WMEs. For example, the condition <code>(&lt;s&gt; ^io.input-link &lt;il&gt;)</code> likely doesn't count because it's probably being used to reach and test another WME on the input link.</p> <p>If a rule has too many actions usually some of those actions are not truly related. Consider separating it into multiple productions with the same or similar conditions. When counting actions, you should only count those that actually add or remove a WME in working memory. Exception: Initialization rules can often have a very large number of actions and this is ok.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example","title":"Example","text":"<p>The rule shown at left (below) was taken from TankSoar. It has a total of six conditions. This is not necessarily too big. However, if you study this production (and you are familiar with TankSoar), you'll see that it is really testing three high level conditions:</p> <ul> <li>Am I in the state <code>tankSoar</code>?</li> <li>Am I low on health (less than 300)?</li> <li>Am I in danger?</li> </ul> <p>Adding an elaboration to detect \"in-danger\" not only makes the rule easier to read but also provides a potentially useful WME for use by other productions. The revised production and its companion elaboration are shown in the second example.</p> <pre><code>sp {propose*recharge*health-BAD\n   (state &lt;s&gt; ^name tanksoar\n              ^io.input-link &lt;il&gt;)\n   (&lt;il&gt; ^radar.tank.distance &gt; 0\n         ^health &lt; 300\n        -^smell.distance &lt; 4\n        -^sound\n        -^incoming)\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name recharge-health)\n}\n</code></pre> <pre><code>sp {elaborate*in-danger\n   (state &lt;s&gt; ^name tanksoar\n              ^io.input-link &lt;il&gt;)\n   (&lt;il&gt; ^radar.tank.distance &gt; 0\n        -^smell.distance &lt; 4\n        -^sound\n        -^incoming)\n--&gt;\n   (&lt;s&gt; ^in-danger yes)\n}\n\nsp {propose*recharge*health\n   (state &lt;s&gt; ^name tanksoar\n              ^in-danger yes\n              ^io.input-link &lt;il&gt;)\n   (&lt;il&gt; ^health &lt; 300)\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name recharge-health)\n}\n</code></pre>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification","title":"Justification","text":"<p>Smaller productions are easier to re-use and easier to understand when you return to them later. Smaller rules also lead to more general chunks. Instead of watching for a specific combination of data, the chunk will learn to watch for only one matching augmentation on the state. Productions with lots of conditions often produce many partial matches on the RETE network (see the memories command in the Soar Manual) that will noticeably slow down performance. Productions with lots of actions can lead to unwanted or unexpected side effects as the program evolves.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#only-include-the-conditions-you-need","title":"Only include the conditions you need","text":"<p>When proposing an operator, don't compute information that won't be needed until application. Exception: It's ok to attach matched values that were already required for the conditions of the proposal rule.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_1","title":"Example","text":"<p>Your TankSoar tank needs to turn on its radar whenever it turns. You've cleverly decided to set the range of the radar based upon the tank's distance from the wall it is facing in order to save energy. Rather than calculate this range in the proposal rule, use a separate elaboration to add the range data once the operator has been selected.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_1","title":"Justification","text":"<p>Clearly this practice reduces rule size and provides a small savings in execution time. It also prevents operators from being rejected and re-proposed when the extraneous data changes.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#consider-all-your-options","title":"Consider all your options","text":"<p>Operator proposal rules should fire whenever an operator is legitimate, not just when it is appropriate. Exception: If limiting the agent's options will significantly improve its performance you may consider violating this guideline.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_2","title":"Example","text":"<p>You decide to modify your Eater so that it never moves back to the square it just came from. Rather than only proposing moves to new squares, propose moves to all adjacent squares and use selection operators to assign a less or least preference to the undesired direction.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_2","title":"Justification","text":"<p>You never know when your worst option is also your best. Deciding what to do is the job of operator preference rules. You should not short-circuit this mechanism without good reason. Also, as stated above, additional conditions for operator proposal may cause unnecessary operator retraction and re-proposal.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#one-action-per-operator","title":"One action per operator","text":"<p>The name of the operator should indicate specifically what actions you are taking. In particular, avoid \"multi-use\" operators that perform similar actions for significantly different reasons depending upon what augmentations they have.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_3","title":"Example","text":"<p>Your agent needs to be able to navigate to a waypoint or a given <code>x, y, z</code> position. The move-to-waypoint operators could be implemented as a special case of the move-to-xyz operator. However, this is probably poor practice.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_3","title":"Justification","text":"<p>When an operator is vaguely named or has multiple behaviors your Soar program will be difficult to debug because you aren't certain what the agent is doing. You can get the same effect by having additional augmentations on the operator that trigger the general actions. For example, you could have <code>^type</code> move on the above operators and there can be selection and application rules that test for the type (but not the name).</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#dont-force-operator-proposals","title":"Don't force operator proposals","text":"<p>If you find yourself adding operators that put o-supported data on the top state for the sole purpose of causing another rule to fire and not be retracted when the original data changes you're probably doing something wrong.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_4","title":"Example","text":"<p>In a real time system, you want the agent to turn toward an object. First, you write your proposal operator to match the heading (angle off) to the object and then turn to it. Unfortunately, since you must turn to reach the new heading, the angle off to the object changes and the operator retracts before you complete. You decide to have on operator record the angle off on the top state and a second operator turn to that angle off as recorded.</p> <p>A better solution: Create an I-supported augmentation that records that the object is to the agent's right, left or directly in front. Have your agent turn in the specified direction until the object is in front of the agent.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_4","title":"Justification","text":"<p>Having operators depend on transient, yet o-supported top state augmentations can cause problems if the operator that removes that augmentation is interrupted.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#avoid-assumptions","title":"Avoid assumptions","text":"<p>Whenever you remove a WME in the actions of a rule, test that WME exists in the conditions of a rule.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_5","title":"Example","text":"<pre><code>sp {apply*remove-foo\n   (state &lt;s&gt; ^name my-state\n              ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name remove-foo)\n--&gt;\n   (&lt;s&gt; ^foo bar -)           # BAD!\n}\n</code></pre> <pre><code>sp {apply*remove-foo\n   (state &lt;s&gt; ^name my-state\n              ^operator &lt;o&gt;\n              ^foo bar)       # Correct\n   (&lt;o&gt; ^name remove-foo)\n--&gt;\n   (&lt;s&gt; ^foo bar -)\n}\n</code></pre>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_5","title":"Justification","text":"<p>The purpose of a rule is to minimize implicit assumptions.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#establish-a-proper-context-for-o-support","title":"Establish a Proper Context for O-Support","text":"<p>When the operator application rule of a substate modifies a superstate, the rule should always include an attribute of that superstate in its conditions. The best way to do this is to reference the state(s) that will be modified by name if possible. (See the next section.)</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_6","title":"Example","text":"<p>You create a generic rule that adds a \"last-action\" WME to the top state (i.e., the last action taken by the agent). To create this generic rule you only match on actions on the output-link.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_6","title":"Justification","text":"<p>O-support means \"permanent\" only in the context of the state(s) that were tested to create it. Once those state(s) cease to exist, the o-supported WMEs are removed even if they are used to augment a state that has not been removed. Specifically, Soar establishes the context of an o-supported attribute by examining the states that are tested in the operator proposal rule for the operator that created the attribute. Therefore, if an operator proposal rule does not test any part of the state it intends to modify, then o-supported attributes that are created by applying that operator will vanish as soon as you leave the current state.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#use-state-names","title":"Use State Names","text":"<p>If possible, refer to a state or states by name in the LHS of operator proposal rules.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_7","title":"Example","text":"<pre><code>sp {my-rule\n   (state &lt;s&gt; ^name mystate)\n# etc...\n</code></pre>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_7","title":"Justification","text":"<p>By being specific about the context of a rule, you prevent it from firing when least expected! This also often prevents more subtle problems like vanishing o-supported WMEs (see previous section).</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#an-agent-has-only-one-state","title":"An Agent has only one State","text":"<p>When possible, avoid rules that test multiple states.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_8","title":"Example","text":"<pre><code>sp {my-rule\n   (state &lt;s&gt; ^name state1)\n   (state &lt;s&gt; ^name state2)\n# etc...\n</code></pre>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_8","title":"Justification","text":"<p>This creates multiple matches on the RETE and may, as a result, create performance bottlenecks.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#use-an-ide-like-visualsoar","title":"Use an IDE like VisualSoar","text":"<p>Write your Soar code using VisualSoar. If so, maintain and use your VisualSoar data map!</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_9","title":"Example","text":"<p>N/A</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_9","title":"Justification","text":"<p>Much like comments on code, VisualSoar's enforced structure and data map is exceptionally helpful for people who are examining code they have not themselves written. VisualSoar provides helpful functionality like syntax highlighting and identifier completion. It also helps you catch bugs in your code by watching for rules that match unspecified WMEs. Such bugs (particularly typos involving nearly identical letters like l and 1) can sometimes require significant effort to discover.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#dont-sacrifice-semantics-for-syntax","title":"Don't Sacrifice Semantics for Syntax","text":"<p>Only write rules that perform standard problem space functions: state elaboration, operator proposal, operator comparison, operator elaboration, and operator application. Do not write rules that:</p> <ul> <li>Test a selected operator in a rule that creates a preference for another operator.</li> <li>Test a for a currently proposed operator in the condition of another operator proposal rule.</li> <li>Test a proposed operator in the conditions of a rule that modify a state (outside of the operator).</li> </ul>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_10","title":"Example","text":"<pre><code>sp {xxyyzz\n   (state &lt;s&gt; ^att &lt;v&gt;\n              ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name xxyyzz\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name dance)\n}\n</code></pre>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_10","title":"Justification","text":"<p>By violating the intent of the Soar language you will likely achieve undesirable results. There is almost certainly a better way of doing what you are trying to do.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#one-thing-at-a-time","title":"One Thing at a Time","text":"<p>Don't mix different problem space functions in the same rule except operator proposal and selection. It is ok to propose an operator and create a unary preference at the same time.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#example_11","title":"Example","text":"<pre><code>sp {xxyyzz\n   (state &lt;s&gt; ^att &lt;v&gt;\n              ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name xxyyzz\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +\n        ^att &lt;v&gt; -)\n   (&lt;o&gt; ^name dance)\n}\n</code></pre>","tags":["agent debugging","agent development"]},{"location":"development/agents/DesignDogma/#justification_11","title":"Justification","text":"<p>By violating the intent of the Soar language you will likely achieve undesirable results. There is almost certainly a better way of doing what you are trying to do.</p>","tags":["agent debugging","agent development"]},{"location":"development/agents/HowToCompileSmlClients/","title":"How to compile SML Clients","text":"","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#how-to-compile-sml-clients","title":"How to compile SML Clients","text":"","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#introduction","title":"Introduction","text":"<p>The SML API is the standard method to get Soar agents to communicate with external environments, such as simulations or games. The API was written natively in C++, but has Java, Python, and Tcl bindings generated via SWIG. This page lays out the steps required to compile C++, Java, and Python SML client programs successfully on Linux/OSX/Windows. These instructions are for the 9.3.2 and later releases. Previous releases required a slightly more complex compilation process.</p> <p>Building a program to call the SML API is conceptually straightforward in any language. Usually, only one or two dependencies must be specified. In practice, this can still be painful because the operating system must be told where to look for the dependencies. All dependencies are located in a single directory or one of its subdirectories. This will be SoarSuite/bin if you are using a pre-built release distribution of Soar, or (by default) SoarSuite/out if you built Soar yourself.</p> <p>For all languages, compilers and operating systems, please make sure that you link 32-bit programs to the 32-bit version of Soar, and likewise for the 64-bit version. The error messages compilers produce for mismatched instruction sets tend to be cryptic, and you probably won't realize what the problem is from reading them.</p>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#c","title":"C++","text":"<p>To use the SML API in a C++ program, you must include the header file \"smlClient.h\" and link to the Soar shared library. If you are using the pre-built release package, the Soar shared library will be in SoarSuite/bin, named _libSoar.so (Linux), libSoar.dylib (OSX), or Soar.dll (Windows). The header will be in SoarSuite/bin/include. If you are building Soar from source, by default the build script will put the shared library in SoarSuite/out, and the headers in SoarSuite/out/include. Also note that when building from source, you need to build the \"kernel\" target (built by default) to get the shared library, and the \"headers\" target (not built by default) to produce the include directory. See the BuildSconsScript for more information. For the rest of this section, we will assume the reader is using the pre-built release package.</p> <p>For convenience, here's a Hello World program that you can use to test your compilation process:</p> <pre><code>#include &lt;iostream&gt;\n#include \"sml_Client.h\"\n\nusing namespace std;\nusing namespace sml;\n\nint main(int argc, char *argv[]) {\n        Kernel *k = Kernel::CreateKernelInNewThread();\n        Agent *a = k-&gt;CreateAgent(\"soar\");\n        cout &lt;&lt; a-&gt;ExecuteCommandLine(\"echo Hello World\") &lt;&lt; endl;\n\n        string dummy;\n        cin &gt;&gt; dummy;\n        return 0;\n}\n</code></pre>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#linux-mac-os-x","title":"Linux / Mac OS X","text":"<p>It's fairly straightforward to compile an SML client program from a shell using g++ or clang++. Both compilers take the same arguments. Supposing you unpacked the release into /home/user/SoarSuite, the compilation command should be:</p> <pre><code>g++ -L/home/user/SoarSuite/bin -I/home/user/SoarSuite/bin/include your_program.cpp -lSoar\n</code></pre> <p><code>-L</code> specifies additional library search directories, <code>-I</code> specifies additional include search directories, and <code>-l</code> specifies libraries to link to. The linker automatically figures out that -lSoar refers to the file libSoar.so on Linux or libSoar.dylib on OSX. Note that even though the linker can find the Soar shared library at link-time, the OS will still not know where it is at run-time (unless you use the RPATH feature). Therefore, you still need to set the environment variables <code>LD_LIBRARY_PATH</code> on Linux and <code>DYLD_LIBRARY_PATH</code> on OSX to <code>/home/user/SoarSuite/bin</code> when running your compiled program. More details can be found in BuildLibrarySearchPaths.</p>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#windows-with-visual-studio","title":"Windows with Visual Studio","text":"<p>Compiling an SML program using Visual Studio is a little more tedious because you have to navigate its cryptic configuration GUI. Here we present step-by-step instructions for setting up a new C++ project. These steps were tested using MSVC++ 2010 Express, but should be very similar or identical for other versions of Visual Studio. We assume you extracted the release into C:\\SoarSuite.</p> <ol> <li>In the menu, select File/New/Project...</li> <li>Choose the \"Empty Project\" template. Enter a name for the project.</li> <li>In the Solution Explorer, under the newly created project, there should be a \"Source Files\" folder. Right click it, choose Add/New Item... Choose \"C++ File\" in the template selection window that pops up, and give the file a name. You need to do this now so that the Properties window will show options for compiling C++ programs. I also copied the contents of the above Hello World program into the new file, but you don't have to.</li> <li>Right click on the new project (NOT the solution) in the Solution Explorer, choose Properties.</li> <li>Click on \"Configuration Manager\" in the upper right corner of the Properties window. Make sure that your project's Platform matches the version of Soar you downloaded/compiled. That means if you have a 32-bit version of Soar.dll, you need to use the \"Win32\" platform, and if you have a 64-bit version, you need to use the \"x64\" platform. VC++ Express doesn't include a 64-bit compiler, so if you are using it, you must use the 32-bit Soar. When you are done, close the Configuration Manager.</li> <li>In the \"Configuration\" drop-down box in the top left corner of the properties window, select \"All Configurations\" so that the changes you make apply to both debug and release configurations.</li> <li>Under Configuration Properties / Debugging / Environment, enter <code>PATH=C:\\SoarSuite\\out</code>. This will set the PATH environment variable to find Soar.dll when you run your program from within the IDE.</li> <li>Under Configuration Properties / C/C++ / General / Additional Include Directories, add the entry <code>C:\\SoarSuite\\bin\\include</code>.</li> <li>Under Configuration Properties / Linker / General / Additional Library Directories, add the entry <code>C:\\SoarSuite\\bin</code>.</li> <li>Under Configuration Properties / Linker / Input / Additional Dependencies, add <code>Soar.lib</code>.</li> <li>Click \"Okay\" in the Properties window to save the changes.</li> </ol> <p>Now you should be able to build and run your project. Remember that if you want to run the program outside of the Visual Studio IDE, you need to add C:\\SoarSuite\\bin to your PATH environment variable, discussed in more detail in BuildLibrarySearchPaths.</p>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#static-linking","title":"Static Linking","text":"<p>You can compile Soar as a static library, as described in BuildSconsScript. To link your program to a static Soar library, the only change you have to make is to define the macro <code>STATIC_LINKED</code> before you include sml_Client.h. There are macros in the Soar headers that will expand to different values depending on whether <code>STATIC_LINKED</code> is defined. Specifically, the prefix declspec (dllimport) is prepended to all SML API functions when compiling with MSVC++. More information is available here, but you don't need to understand it to compile successfully.</p> <ul> <li>With g++ and clang++, the easiest way to do this is to pass in the flag <code>-DSTATIC_LINKED</code>.</li> <li>In Windows/VC++, go to the Properties window for the project. Under   Configuration Properties / C/C++ / Preprocessor / Preprocessor Definitions, add   the text <code>STATIC_LINKED</code>. Click \"Apply\", then look under Configuration Properties   / C/C++ / Command Line. You should see/D \"STATIC_LINKED\" somewhere in the   command.</li> </ul>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#java","title":"Java","text":"<p>The only requirement for compiling a Java SML client is that the file sml.jar be in your class path. This file should be located inSoarSuite/bin/java in the release, and SoarSuite/out/java if you built Soar yourself and included the target sml_java (built by default).</p> <p>In the following, I assume you're compiling a source file HelloWorld.java with the following contents:</p> <pre><code>import sml.Kernel;\nimport sml.Agent;\n\npublic class HelloWorld {\n        public static void main(String[] args) {\n                Kernel k = Kernel.CreateKernelInNewThread();\n                Agent a = k.CreateAgent(\"soar\");\n                System.out.println(a.ExecuteCommandLine(\"echo Hello World\"));\n        }\n}\n</code></pre> <p>To compile your program using javac directly from the command line, add sml.jar to the class path using the -cp flag. The command is essentially the same for all operating systems:</p> <pre><code>javac -cp /home/user/SoarSuite/bin/java/sml.jar HelloWorld.java (for Linux/OSX)\njavac -cp C:\\SoarSuite\\bin\\java\\sml.jar HelloWorld.java (for Windows)\n</code></pre> <p>This should produce a file HelloWorld.class.</p> <p>Oddly enough, running a Java SML client program is trickier than compiling it. The classes in sml.jar use JNI to call the C++ API under the hood. The JNI functions are compiled into a native shared library named libJava_sml_ClientInterface.so (Linux),libJava_sml_ClientInterface.dylib (OSX), or Java_sml_ClientInterface.dll (Windows). This file should be in SoarSuite/bin orSoarSuite/out. When you run your program, you have to make sure the Java virtual machine can locate this library as well as the Soar shared library. This is explained in BuildLibrarySearchPaths.</p> <p>After you set the library path correctly, you can run HelloWorld.class using the JVM. When you run the program, sml.jar should also be in the class path. Assuming HelloWorld.class is in the current directory, the command to run the program is:</p> <pre><code>java -cp /home/user/SoarSuite/bin/java/sml.jar:. HelloWorld (for Linux/OSX)\njava -cp C:\\SoarSuite\\bin\\java\\sml.jar;. HelloWorld (for Windows)\n</code></pre> <p>You should see \"Hello World\" printed to the console. If you didn't set the library search path correctly, running your program will produce an error that looks something like this:</p> <pre><code>java.lang.UnsatisfiedLinkError: no Java_sml_ClientInterface in java.library.path\nException in thread \"main\" java.lang.UnsatisfiedLinkError: no Java_sml_ClientInterface in java.library.path\n        at java.lang.ClassLoader.loadLibrary(ClassLoader.java:1856)\n        at java.lang.Runtime.loadLibrary0(Runtime.java:845)\n        at java.lang.System.loadLibrary(System.java:1084)\n        at sml.smlJNI.&lt;clinit&gt;(smlJNI.java:15)\n        at sml.Kernel.CreateKernelInNewThread(Kernel.java:133)\n        at HelloWorld.main(HelloWorld.java:6)\n</code></pre>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#eclipse","title":"Eclipse","text":"<p>Many Java programmers use the Eclipse IDE. Here are the steps to create an SML project in Eclipse. Note that Eclipse is a general purpose IDE and comes in many different variations. These instructions were written for \"Eclipse IDE for Java Developers\". Remember that all we are doing here is getting Eclipse to find sml.jar at compile time and the JNI shared libraries at run time.</p> <ol> <li> <p>In the main menu bar, choose File / New / Java Project. Give the project a    name, then click Next.</p> </li> <li> <p>Choose the Libraries tab, then click \"Add External JARs\". Choose    SoarSuite/bin/java/sml.jar in the file selection dialog. Click Finish.</p> </li> <li> <p>In the \"Package Explorer\", right click on the \"src\" folder under your project    and choose New / Class, and create a class with a main function. For example,    you can create a HelloWorld class and paste in the contents of the Hello World    program above.</p> </li> <li> <p>Again in the \"Package Explorer\", right click on your project, choose    Properties. Then choose \"Run/Debug Settings\", and click the \"New...\" button on    the right. Choose \"Java Application\" in the pop-up window. In the configuration    properties window that comes up, click \"Search...\" and choose the class you    created with the main function.</p> </li> <li> <p>In the same window, select the \"Environment\" tab, click \"New...\" to add a new    environment variable. For the Name field in the pop-up, enter <code>LD_LIBRARY_PATH</code>    if you're in Linux, <code>DYLD_LIBRARY_PATH</code> if in OSX, or PATH if in Windows. For    the Value, enter the full path to your SoarSuite/bin directory. This will help    the JVM find the JNI shared library when you run your project.</p> </li> <li> <p>Click OK, then OK again to close the configuration properties window.</p> </li> </ol> <p>Now you should be able to run your project by choosing Run / Run in the main menu bar.</p>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/HowToCompileSmlClients/#python","title":"Python","text":"<p>To call SML via Python, you need to import the module <code>Python_sml_ClientInterface</code>, defined in the file <code>Python_sml_ClientInterface.py</code>. This file should be in SoarSuite/bin in the release, and SoarSuite/out in your own build, if you built the target sml_python. Like the Java SML bindings, the Python bindings also depend on a native library, called <code>_Python_sml_ClientInterface.so</code> (Linux), <code>_Python_sml_ClientInterface.dylib</code> (OSX), or <code>_Python_sml_ClientInterface.dll</code> (Windows). Note the leading underscore in all versions. This file should also be in SoarSuite/bin in the release or SoarSuite/out in your own build. We will assume the reader is using the pre-built release package and both files are in SoarSuite/bin. There are two ways to make the Python interpreter locate these files.</p> <ol> <li>Set the environment variable <code>PYTHONPATH</code> to include SoarSuite/bin. The    Python interpreter will search SoarSuite/bin for modules for any program you    run.</li> <li>Append SoarSuite/bin to the variable <code>sys.path</code> in the script itself    before <code>importing Python_sml_ClientInterface</code>. This method is local to the script    you applied it to, and is recommended if you have multiple versions of Soar on    your computer.</li> </ol> <p>Here is the Hello World program in Python, using the second method:</p> <pre><code>import sys\nsys.path.append('/home/user/SoarSuite/bin')\nimport Python_sml_ClientInterface as sml\n\nk = sml.Kernel.CreateKernelInNewThread()\na = k.CreateAgent('soar')\nprint a.ExecuteCommandLine('echo hello world')\n</code></pre> <p>If you use the first method to modify the search path, the first two lines of the script are not needed. In any case, you should be able to run the script like a normal Python program:</p> <pre><code>$ python helloworld.py\nhello world\n</code></pre>","tags":["compile","sml","agent development","C++","Java","Python"]},{"location":"development/agents/SMLOutputLinkGuide/","title":"SML Output Link Guide","text":"","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#sml-output-link-guide","title":"SML Output Link Guide","text":"<p>General Advice: Read the output link after the agent's output phase but before the next decision cycle's input phase.</p> <p>This is usually accomplished by registering for an event that fires in this range and reading the output link in there.</p> <p>Exercise care if you save commands (or other working memory elements on the output-link) to use later and return control back to Soar.</p> <p>Working memory elements can be removed by the Soar agent and freed by SML. Referring to them (to add, say ^status complete) will cause a segmentation fault.</p> <p>Be careful not to dereference working memory elements you have disconnected with <code>DestroyWME</code>.</p> <p>Destroyed pointers are freed by SML and will cause a segmentation fault if used.</p>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#events-during-which-output-may-be-read","title":"Events During Which Output May Be Read","text":"<p>Recommended: Register for the Update event <code>smlEVENT_AFTER_ALL_OUTPUT_PHASES</code>.</p> <p>Run Events (agent-specific; register using <code>Agent::RegisterForRunEvent</code>):</p> <ul> <li>smlEVENT_AFTER_OUTPUT_PHASE   # All three of these are essentially equivalent</li> <li>smlEVENT_AFTER_DECISION_PHASE</li> <li>smlEVENT_AFTER_DECISION_CYCLE</li> </ul> <p>Update Events (register using <code>Kernel::RegisterForUpdateEvent</code>):</p> <ul> <li>smlEVENT_AFTER_ALL_OUTPUT_PHASES    # Fires after all agents' output phases are done</li> <li>smlEVENT_AFTER_ALL_GENERATED_OUTPUT # Fires as above but only after all agents also have output or reached max-nil-output-cycles</li> </ul>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#reading-the-output-link","title":"Reading the Output Link","text":"<p>There are a number of different ways to read information from the output link, each with pros and cons. Choose whichever method seems easiest to you.</p> <p>Examine In Detail</p> <ul> <li>Use <code>GetOutputLink</code>, <code>GetNumberChildren</code>, <code>GetChild</code>, and other similar   methods to examine working memory in its raw state.</li> <li>Can't use <code>IsJustAdded</code> and <code>AreChildrenModified</code> - these require   <code>SetTrackOutputLinkChanges</code> true</li> </ul> <p>Advantages:</p> <ul> <li>Most flexible.</li> <li>Can disable change tracking <code>Agent::SetTrackOutputLinkChanges(false)</code></li> </ul> <p>Disadvantages:</p> <ul> <li>Most verbose.</li> </ul>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#command-interface","title":"Command Interface","text":"<p>Use Commands, <code>GetCommand</code>, and <code>GetParamValue</code> to get top level WMEs that have been added since the last cycle.</p> <p>This method is closest to the original SGIO and should be sufficient for most cases. \"Commands\" used in this context refer to identifier WMEs on the top-level of the output link. \"Parameters\" refer to valued attributes that are children of a top-level command (identifier).</p> <p>Advantages:</p> <ul> <li>Easiest.</li> </ul> <p>Disadvantages:</p> <ul> <li>Do not save identifiers and return control back to Soar - they could be deleted.</li> <li>Not good for commands that span multiple decision cycles, retained so that   <code>^status</code> complete can be added.</li> <li>Must follow \"command\" format: top level identifier.</li> </ul> <pre><code># \"Command\" format\n&lt;s&gt; ^io.output-link &lt;ol&gt;\n&lt;ol&gt; ^move &lt;c&gt;            # Command name \"move\"\n&lt;c&gt; ^direction north      # Parameter \"direction\"\n\n# Not \"Command\" format\n&lt;s&gt; ^io.output-link &lt;ol&gt;\n&lt;ol&gt; ^move north\n</code></pre>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#changes-interface","title":"Changes Interface","text":"<p>Use <code>GetNumberOutputLinkChanges</code>, <code>GetOutputLinkChange</code>, and <code>IsOutputLinkChangeAdd</code> to get the list of all WMEs added and removed since the last decision cycle.</p> <p>All WMEs count as an output link change.</p> <p>Advantages:</p> <ul> <li>Full access to output link.</li> <li>Output link removals can be detected using <code>IsOutputLinkChangeAdd() == false</code></li> <li>Great for commands that can span multiple decision cycles because of removal   notification.</li> </ul> <p>Disadvantages:</p> <ul> <li>Need to parse changes to figure out what's attached to what.</li> </ul> <pre><code># This structure:\n&lt;s&gt; ^io.output-link &lt;ol&gt;\n&lt;ol&gt; ^move &lt;c&gt;            # Command name \"move\"\n&lt;c&gt; ^direction north      # Parameter \"direction\"\n\n# ... generates these two separate changes:\n(I3 ^move M1)\n(M1 ^direction north)\n</code></pre>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#output-handler","title":"Output Handler","text":"<p>Use <code>AddOutputHandler</code> to register functions that are called when a specific attributes are added to the output link.</p> <p>Here you specify specific attributes that fire events when added.</p> <p>Advantages:</p> <ul> <li>Other update events do not need to be registered (such as smlEVENT_AFTER_ALL_OUTPUT_PHASES)</li> <li>Event handling model, can be very clear.</li> </ul> <p>Disadvantages:</p> <ul> <li>Full command set needs to be known before hand (only get events when   identifiers with registered attributes are added to the output link).</li> <li>Do not save identifiers and return control back to Soar--they could be   deleted.</li> <li>Not good for commands that span multiple decision cycles, retained so that   <code>^status</code> complete can be added.</li> <li>Must follow \"command\" format: top level identifier. See Command Interface   above.</li> </ul>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SMLOutputLinkGuide/#io-without-event-handlers","title":"IO Without Event Handlers","text":"<p>Not recommended. Reading the output link without event registration is possible. Generalized steps for this are:</p> <ol> <li>Set the stop phase to before-input.</li> <li>Call <code>RunTillOutput</code> or Run (one step only - multiple steps will lose tracked    changes).</li> <li>Read the output link.</li> </ol>","tags":["io","event","sml","agent development"]},{"location":"development/agents/SoarProgrammersGuide/","title":"Soar Programmer's Guide","text":"<p>This is similar to the design dogma, but written by Bob Marinier at Soartech and more up to date: Soar Programmer's Guide.</p>","tags":["agent development"]},{"location":"development/soar/BasicKernelTerminology/","title":"Basic Kernel Terminology","text":"","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#basic-kernel-terminology","title":"Basic Kernel Terminology","text":"<p>This is a document that defines some of the basic data structures, files and terminology used in the Soar kernel code. It is very incomplete but a good starting point for understanding the kernel.</p> <p>\"But where can I start?\"</p> <p>In a nutshell: The Soar Kernel is a very object-oriented, structured set of code. If you don't understand the basic Soar execution cycle and its phases, the source code won't help you. You should start by reading the introductory material in the Soar Tutorials that are bundled with the releases (in the Documents directory). Then read the first four chapters of the Soar Manual, \"Introduction\" thru \"Learning\" Basic code execution</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#data-structures","title":"Data Structures","text":"<p>All of the structures are well-commented in the header files. In earlier versions of Soar (up thru 8.3.5), the single header file \"soarkernel.h\" defined all the common structures used throughout the code. I still find it the easiest place to search for information even though it's a very large file as code goes. In 8.6. and later, the header file was separated by function into many smaller files which can be found in \"Core/SoarKernel/include\".</p> <p>The <code>agent_struct</code> defined in agent.h includes all the system parameters, counters, variables, and pointers to all the other structures used by an agent (WMEs, productions, hash tables, memory_pools, formats, etc etc). It's a BIG structure, tough to read, and includes a lot of detailed comments. But if it isn't defined or allocated here, the agent doesn't know about it.</p> <p>Chances are you will never modify any structures in the rete, lexer, hash tables, or backtracing facilities, but you should know that they exist. If you do start to muck with these structures, you better know what you are doing. Changes here can greatly impact performance and even whether or not Soar will run properly. Several structures require their members to be defined in specific order and are commented appropriately.</p> <p>Structures that you should familiarize yourself with are symbols (a typedef'd union!!), wmes, productions, instantiations, preferences, and (eventually) memory pools.</p> <ul> <li><code>symbol_struct</code> is in <code>symtab.h</code>, everything in Soar boils down to some kind of symbol.</li> <li><code>wme_struct</code> is in <code>wmem.h</code>, defines the working memory elements of an agent</li> <li><code>production_struct</code> is in <code>production.h</code>, these are the productions as loaded into Soar and stored in the rete. instantiations are in instantiation.h, these store the bindings of productions as they are matched in the rete. Instantiations whose conditions all match are fired during specific phases - meaning their actions are executed: preferences are asserted to create wmes, and/or RHS actions are executed.</li> <li><code>preference_struct</code> is defined in <code>preference.h</code>, stores a pointer to the instantiation that created it, and when the instantiation no longer matches,the preference is retracted.</li> </ul>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#i-want-to-add-a-new-link","title":"I want to add a new link!","text":"<p>Existing links include input/output and reward links. Instructions on how to make your own are HowTo: IO and reward links.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#things-to-add","title":"Things to add","text":"<p>A lot of topics are in the Soar FAQ</p> <ul> <li>Basic structure of how critical code works (e.g. decision procedure is a big     switch statement, how printing/XML generation works)</li> <li>Locations of critical code (e.g. decision procedure, preference procedure, scheduler)</li> <li>Union basics (most people don't know what unions are)<ul> <li>see Kernigan and Ritchie</li> <li>Unions are a data structure that can have multiple data-dependent ways of     storing and accessing information, much like (but better than) overloading     methods in C++.</li> </ul> </li> <li>Explain how sysparams work (e.g. how they are set/used, how to add a new one)</li> <li>sysparams are just an array of agent parameters that store settings for     runtime switches. Most of the sysparams are either True/False, or can take on     some enum value. Setting a sysparam is easy, cf. init_soar.c for     initializing and setting values. Search the code for \"set_sysparams\" to see     examples.</li> <li>To add a sysparam, see gsysparams.h (although that file MUST be renamed or     folded into another header when gSKI removed). The code depends on looping over     HIGHEST_SYSPARAM, so make sure it's always equal to the last one in the set of     definitions.</li> <li>When is it a sysparam, and when is it part of the agent struct? Depends what     you are using it for, and whether it needs to be exposed for the user interface.     If its a user-controlled setting, it should definitely be a sysparam.</li> <li>What is a slot</li> </ul> <p>From John:</p> <p>\"We used to select more than just the operator (state, problem space, and goal) and all together this was the context. Slots were for things that can be selected, so there was a slot for each of those. Now there is just a slot for the operator and although some of that language might have bled over to selection of values for non-operator attributes. In general they are an out of date terminology.\"</p> <ul> <li>Basics of how wme changes are done in parallel (i.e. explain do_buffered_wm_and_ownership_changes)</li> <li>Difference between wme and input_wme (and any other wmes there might be)</li> <li>Where/how to add new links (e.g. ep-mem link, RL link, etc)</li> <li> <p>Explain memory pool basics</p> </li> <li> <p>Basics of bit manipulations that are used (unless this is rete-only, in which     case don't bother)</p> <ul> <li>I think the rete is the only place bit manipulations occur. Bit     manipulations are extremely fast. If you can guarantee your raw data     structure, you can shift registers instead of calling complex instructions     to go very fast. Compilers hide this from you, but don't always know when     they can optimize.</li> </ul> </li> <li>Explain transitive closure and tc_num</li> <li>What all the Soar kernel STL-like data structures are (e.g. lists, hash tables, growable strings, others?) and how to use them. Ref counting (link to Tracking down memory leaks)</li> </ul>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#some-definitions","title":"Some Definitions","text":"","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#slot","title":"slot","text":"<p>From John Laird:</p> <p>We used to select more than just the operator (state, problem space, and goal) all together this was the context. Slots were for things that can be selected, so there was a slot for each of those. Now there is just a slot for the operator, although some of that language might have bled over to selection of values for non-operator attributes. In general they are an out of date terminology.</p> <p>Slots are contained by identifiers, and hold all the preferences associated with the identifier, including acceptable wme preferences. Each identifier can have multiple slots, which can be accessed via the prev and next fields in the slot structure. Operator preferences are held incontext slots, which are identified by the isa_context_slot flag.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#tc","title":"tc","text":"<p>transitive closure</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#match-goal","title":"match goal","text":"<p>The lowest goal (biggest number after the \"S\") that an instantiation of the LHS of a production matches on. Part of the instantiation structure.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#potential","title":"potential","text":"<p>Also referred to as backtracing.</p> <p>condition whose id is instantiated on a symbol linked from both the current goal and a higher goal, and is tested for in the production's LHS using a path from the current goal.</p> <p>For example, if the following wmes are in working memory</p> <pre><code>(S1 ^foo F1)\n(S2 ^bar F1)\n(F1 ^baz B1)\n(S2 ^superstate S1)\n\nand this production was backtraced through\nCode:\nsp {example\n   (&lt;s&gt; ^bar &lt;b&gt;)\n   (&lt;b&gt; ^baz &lt;z&gt;)\n--&gt;\n   ...}\n</code></pre> <p>then <code>(&lt;b&gt; ^baz &lt;z&gt;)</code> would be a potential condition.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#potential-life","title":"potential (life)","text":"<p>abstract invented concept that actually has no real meaning.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#tm","title":"tm","text":"<p>temporary memory. I believe that any preference that is currently valid in Soar (either they are o-supported or the instantiation that generated them still matches) is in temporary memory. Once a preference is no longer valid, it is taken out of temporary memory (which involves setting the in_tm flag to false, and taking them off the preferences array and all_preferences lists on the slot they're on).</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#clone-preference","title":"clone (preference)","text":"<p>a copy of a preference that is the result of a subgoal. While the inst pointer of the original preference points to the instantiation of the rule that fired in the subgoal to create the result, the inst pointer of the clone points to the newly created chunk or justification. Therefore, the preference and its clone exist on different match goals, and hence different match goal levels.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#instantiation","title":"instantiation","text":"<p>a particular match of a production in working memory, and the preferences generated</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#debug_memory","title":"DEBUG_MEMORY","text":"<p>if this flag is defined, the contents of freed memory locations in the memory pools are memset to <code>0xBB</code></p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#refraction","title":"Refraction","text":"<p>Via Wikipedia:</p> <p>Each production instance will fire only once, at most, during any one match-resolve-act cycle. This characteristic is termed refraction.</p> <p>Refracting a fired instance means to prevent it from firing again.</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#rete-structures","title":"Rete Structures","text":"","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#cn","title":"CN","text":"<p>Conjunctive negation</p>","tags":["kernel programming"]},{"location":"development/soar/BasicKernelTerminology/#nvn","title":"NVN","text":"<p>Node variable names</p>","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/","title":"CLI Parsing Code","text":"","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#command-line-interface-parsing-code","title":"Command Line Interface Parsing Code","text":"","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#overview","title":"Overview","text":"<p>The command line interface (CLI) described in this document has no relation to the lexer/parser inside the Soar kernel. CLI often refers to the actual object instance (a member of KernelSML) but sometimes can refer to the whole component.</p> <p>The CLI takes an arbitrary string and transforms it into method calls providing a general interface to Soar as described by the help document on the Soar wiki (on Google Code).</p> <p>A command line in this context can actually be many commands, or an entire file. In this document it will be called a command line. The syntax of what is legal closely follows the Tcl language and is spelled out in the Doxygen help in Core/shared/tokenizer.h. These rules are reprinted below.</p> <p>The command line enters the CLI at CommandLineInterface:: DoCommand. Some quick state is updated but then it is passed to Source (defined in cli_source.cpp), a same function used by the source command in Soar. This is why command lines and files are interchangeable.</p> <p>Source then uses the tokenizer utility to split out the command name and its arguments. The critical piece used by tokenizer to do this is the parser instance (cli::Parser, cli_Parser.h, a member of CLI) which knows what all the commands and aliases are.</p> <p>The parser expands aliases, performs a partial match if necessary and then, if there is no ambiguity, calls the appropriate command's Parse function with a vector of the tokens used for the command. Sometimes this vector is only of length 1 (the command name). Again, Tcl rules are used to tokenize each command (and to split commands).</p> <p>These commands' parse methods are defined in cli_Commands.h and registered with the parser with the CLI is first created. The parser is also aware of aliases, which are initially defined in the Aliases constructor executed when the parser is first created. Aliases can change down the road when commands access the parser's aliases member.</p> <p>The purpose of the parse function is to process the command's options (if any) and report syntax errors as necessary. Some input checking is done here but most is saved for the next step (below). Few commands (such as dirs) have no parsing--most have plenty of stuff to do in this phase. No actual processing should happen here, the functions called as a result of parsing should be able to be called directly elsewhere for the same effect without parsing. Example of a command that takes no arguments:</p> <pre><code>dirs\n</code></pre> <p>Some commands just need to test for the presence of and get an argument or two off of the command line before proceeding. An example of this is the max-elaborations command. These commands are simple - the vector of tokens can be inspected and used directly.</p> <p>Example of command that has arguments:</p> <pre><code>max-elaborations 15\nNon-option argument: 15\n</code></pre> <p>Other commands have options which are handled using the option utilities on the Parser instance, sometimes in addition to other, non-option arguments.</p> <p>More common commands (with options):</p> <ul> <li>echo-commands -y</li> <li>Option (short): y</li> <li>learn --off</li> <li>Option (long): off</li> <li>echo -n Hello world!</li> <li>Option (short): n</li> <li>Arguments: Hello, world!</li> <li>watch --chunks -L print</li> <li>Option (long): chunks</li> <li>Option (short) with argument: L, print</li> <li>Options always have both long and short forms, and a required argument,   optional argument, or no argument setting expected. These are all defined in the   top of the Parse function before the option handling code is called.</li> </ul> <p>Once the command and options are parsed, a function call is made to actually process the command. These are all declared initially on the Cli-interface defined in cli_Cli.h. This interface exists to facilitate context-free testing of the command parsing. By convention, these processing functions all start with Do so they are easily spotted on the CLI.</p> <p>The CLI implements this interface, and defines the functions and their related helper functions in their own files. DoSource, for example, is defined in cli_source.cpp.</p> <p>The meat of the command happens in these Do functions. The function signatures vary depending on what the commands need. Enumerations are used to pass modes from the parsing step to the Do step. Null pointers are used often when some parameter is optional, to indicate that it was omitted. Bit vectors are often used to pass a number of flags from the parsing step to the processing step.</p> <p>The motivation behind splitting the parsing from the processing in the commands is both for testing and so that other parts of Soar/SML can call-these interface functions directly without having to render command lines.</p> <p>When commands complete, they return text to be printed after they execute. Traditionally, little or nothing is printed when there is success.</p> <p>There is support for more structured output for commands so that callers can pull specific values out of command results (instead of parsing the stringified results). This mode is optional (skip doing this until you know you need it) and is tested by checking the m_RawOutput member on the CLI. Structured output is built up using a form of XML.</p>","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#tokenizing-rules","title":"Tokenizing Rules","text":"<p>The tokenizer used by the CLI follows most of the rules of Tcl. Here they are, copied from the tokenizer header (Core/shared/tokenizer.h):</p> <p>[1] A Tcl script is a string containing one or more commands. Semi-colons and newlines are command separators unless quoted as described below. Close brackets are command terminators during command substitution (see below) unless quoted. [Square brackets have no special meaning in this parser.]</p> <p>[2] A command is evaluated in two steps. First, the Tcl interpreter breaks the command into words and performs substitutions as described below. These substitutions are performed in the same way for all commands. [The first word of the command has no special meaning in this parser.] All of the words of the command are passed to the command procedure [via a callback interface]. The command procedure is free to interpret each of its words in any way it likes, such as an integer, variable name, list, or Tcl script. Different commands interpret their words differently.</p> <p>[3] Words of a command are separated by white space (except for newlines, which are command separators).</p> <p>[4] If the first character of a word is double-quote (\") then the word is terminated by the next double-quote character. If semi-colons, close brackets, or white space characters (including newlines) appear between the quotes then they are treated as ordinary characters and included in the word. Backslash substitution [but not command substitution or variable substitution] is performed on the characters between the quotes as described below. The double-quotes are not retained as part of the word.</p> <p>[5] If the first character of a word is an open brace ({) then the word is terminated by the matching close brace (}). Braces nest within the word: for each additional open brace there must be an additional close brace (however, if an open brace or close brace within the word is quoted with a backslash then it is not counted in locating the matching close brace). No substitutions are performed on the characters between the braces except for backslash-newline substitutions described below, nor do semi-colons, newlines, close brackets, or white space receive any special interpretation. The word will consist of exactly the characters between the outer braces, not including the braces themselves.</p> <p>[6] [Square brackets are not special in this parser. No command substitution.]</p> <p>[7] [Dollar signs are not special in this parser. No variable substitution.]</p> <p>[8] If a backslash <code>\\</code> appears within a word then backslash substitution occurs. In all cases but those described below the backslash is dropped and the following character is treated as an ordinary character and included in the word. This allows characters such as double quotes, and close brackets [and dollar signs but they aren't special characters in this parser] to be included in words without triggering special processing. The following table lists the backslash sequences that are handled specially, along with the value that replaces each sequence.</p> <ul> <li><code>\\a</code> Audible alert (bell) (0x7).</li> <li><code>\\b</code> Backspace (0x8).</li> <li><code>\\f</code> Form feed (0xc).</li> <li><code>\\n</code> Newline (0xa).</li> <li><code>\\r</code> Carriage-return (0xd).</li> <li><code>\\t</code> Tab (0x9).</li> <li><code>\\v</code> Vertical tab (0xb).</li> <li><code>\\n</code>whiteSpace</li> </ul> <p>A single space character replaces the backslash, newline, and all spaces and tabs after the newline. This backslash sequence is unique in that [...] it will be replaced even when it occurs between braces, and the resulting space will be treated as a word separator if it isn't in braces or quotes. \\ Backslash (``\\''). [Not implemented: \\ooo The digits ooo (one, two, or three of them) give the octal value of the character.] [Not implemented: \\xhh The hexadecimal digits hh give the hexadecimal value of the character. Any number of digits may be present.]</p> <p>Backslash substitution is not performed on words enclosed in braces, except for backslash-newline as described above.</p> <p>[9] If a hash character (#) appears at a point where Tcl is expecting the first character of the first word of a command, then the hash character and the characters that follow it, up through the next newline, are treated as a comment and ignored. The comment character only has significance when it appears at the beginning of a command.</p> <p>[10] [Talks about details regarding substitution and generally does not apply to this parser.]</p> <p>[11] [Talks about details regarding substitution and generally does not apply to this parser.]</p>","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#parsing","title":"Parsing","text":"<p>The first token of a command is used to find its parser implementation. The command parsers are defined in cli_Commands.h and implementParserCommand. The rest of the tokens are either options, option arguments, or non-option arguments. Options</p> <p>Options start with dashes. One dash followed by one or more letters is interpreted as one or more short options.</p> <ul> <li><code>-f</code>: Option f</li> <li><code>-for</code>: Options f o r</li> </ul> <p>Two dashes are followed by one long option</p> <ul> <li><code>--foo</code>: Option foo</li> </ul> <p>All options have a short form and a long form.</p> <p><code>--level</code> and <code>-l</code> both represent the \"level\" option in the watch command.</p> <p>Options can have arguments associated with them. The argument, if it accepts one, can be required or optional. This is specified when the option is defined in its parse function:</p> <pre><code>// Short option, long option, one of none, optional, required\n{'f', \"fullwmes\", OPTARG_NONE},\n{'b', \"backtracing\", OPTARG_OPTIONAL},\n{'l', \"level\", OPTARG_REQUIRED},\n</code></pre> <p>Options with arguments generally accept whatever comes after them as its argument. Optional arguments are trickier, refer to cli_Options.h for details.</p> <ul> <li><code>--level 4</code>: level takes a required argument, 4 is consumed as its argument.</li> </ul> <p>Options can occur anywhere in the command line, except after special option - which forces an end to option parsing. Options and any of their arguments are moved to the beginning of the token vector, keeping their same relative order. The number of options remaining can be obtained with <code>GetNonOptionArguments()</code> and the actual options starting with the length of the token vector.</p> <pre><code>cli::Options opt; // Option parsing utility instance\n\n// ... define options, parse options\n\nint remain = opt.GetNonOptionArguments(); // Number of non-option arguments remaining\n\n// ... assuming remain &gt; 0\n\nint i = argv.size() - remain; // Index of first non-option argument\nargv[i];\n</code></pre> <p>Processing options and their arguments has a lot of boiler plate code, something that could totally be improved. Write tests first.</p> <pre><code>cli::Options opt; // Option parsing utility instance\n\nOptionsData optionsData[] =\n{\n// Options definitions\n{'f', \"fullwmes\", OPTARG_NONE}\n{'f', \"full-wmes\", OPTARG_NONE}, // multiple long options OK\n{'b', \"backtracing\", OPTARG_OPTIONAL},\n{'l', \"level\", OPTARG_REQUIRED},\n{0, 0, OPTARG_NONE} // terminate with this, sorry\n};\n\nfor (;;) // most compilers won't complain about this kind of forever\n{\n// this returns false only on major error\nif (!opt.ProcessOptions(argv, optionsData)) return false;\n\n    // this will be -1 if option parsing is complete\n    if (opt.GetOption() == -1) break;\n\n    switch (opt.GetOption())\n    {\n        case 'f':\n            // remember this flag is flipped\n            break;\n        case 'b':\n            // remember this flag is flipped\n            if (!opt.GetOptionArgument.empty())\n                opt.GetOptionArgument(); // Here's the optional argument\n            break;\n        case 'l':\n            // remember this flag is flipped\n            opt.GetOptionArgument(); // Here's the argument\n            break;\n    }\n\n}\n\nif (opt.GetNonOptionArguments())\nint i = argv.size() - opt.GetNonOptionArguments(); // index to argument\n</code></pre> <p>Non-options are often tested for existance, count, there's a utility function for that:</p> <pre><code>// returns true if there is one or no non-option argument\nopt.CheckNumNonOptArgs(0, 1); // min, max\n\n// returns true if there are three non-option arguments\nopt.CheckNumNonOptArgs(3, 3);\n</code></pre>","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#executing","title":"Executing","text":"<p>Once a command and its options are parsed, a function is called to Do the work. Looking at the excise command definition (cli_Cli.h):</p> <pre><code>// parsing distills the command line options down to this list\nenum eExciseOptions\n{\nEXCISE_ALL,\nEXCISE_CHUNKS,\nEXCISE_DEFAULT,\nEXCISE_RL,\nEXCISE_TASK,\nEXCISE_TEMPLATE,\nEXCISE_USER,\nEXCISE_NUM_OPTIONS, // must be last\n};\n\n// and stores them in this type\ntypedef std::bitset&lt;EXCISE_NUM_OPTIONS&gt; ExciseBitset;\n\n/\\*\\*\n\n- @brief excise command\n- @param options The various options set on the command line\n- @param pProduction A production to excise, optional\n  _/ virtual bool DoExcise(const ExciseBitset&amp; options, const std::string_ pProduction = 0) = 0;\n</code></pre> <p>This excise function takes a bitset of option flags parsed from the command line, and optionally a pointer to a string of a specific production to excise. A pointer is used because it is optional, and null can be passed when all of the command's state is contained in the options set.</p>","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#errors","title":"Errors","text":"<p>Command implementations should return true if the command is successful, false if there is an error condition. Before returning false, error state should be set so that the user can try and figure out what went wrong. Call SetError() on the cli::Cli instance to set the error text. Return false. SetError() always returns false so you can just return that.</p> <pre><code>// during parsing, you should have a reference to cli\nif (argv.size() &gt; 2)\nreturn cli.SetError(\"Only one argument (a directory) is allowed. Paths with spaces should be enclosed in quotes.\");\n\n// during execution, you are the cli\nif (!pScheduler-&gt;VerifyStepSizeForRunType(forever, runType, interleave))\nreturn SetError(\"Run type and interleave setting incompatible.\");\n</code></pre>","tags":["kernel programming"]},{"location":"development/soar/CLIParsingCode/#implementing-new-command-checklist","title":"Implementing New Command Checklist","text":"<p>Open cli_Cli.h and define your command's functional interface. Open cli_Commands.h and create a new cli::ParserCommand instance for your command. Find a similar command and copy and paste it, changing what you need, or use a template:</p> <pre><code>// no option parsing\nclass TheCommand : public cli::ParserCommand\n{\npublic:\nTheCommand(cli::Cli&amp; cli) : cli(cli), ParserCommand() {}\n\n    // always virtual destructor\n    virtual ~TheCommand() {}\n\n    // the token that chooses this command\n    virtual const char* GetString() const { return \"the\"; }\n\n    // help string look at other commands for examples\n    virtual const char* GetSyntax() const\n    {\n        return \"Syntax: the [syntax]\";\n    }\n\n    // the meat\n    virtual bool Parse(std::vector&lt; std::string &gt;&amp;argv)\n    {\n        // possibly do something with argv\n\n        // call the function declared in Cli\n        return cli.DoThe();\n    }\n\nprivate:\ncli::Cli&amp; cli;\n\n    // no copy\n    TheCommand&amp; operator=(const TheCommand&amp;);\n\n};\n// option parsing\nclass TheCommand : public cli::ParserCommand\n{\npublic:\nTheCommand(cli::Cli&amp; cli) : cli(cli), ParserCommand() {}\n\n    // always virtual destructor\n    virtual ~TheCommand() {}\n\n    // the token that chooses this command\n    virtual const char* GetString() const { return \"the\"; }\n\n    // help string look at other commands for examples\n    virtual const char* GetSyntax() const\n    {\n        return \"Syntax: the [syntax]\";\n    }\n\n    // the meat\n    virtual bool Parse(std::vector&lt; std::string &gt;&amp;argv)\n    {\n        cli::Options opt;\n\n        // define options\n        OptionsData optionsData[] =\n        {\n            //{'a', \"alpha\", OPTARG_NONE},\n            //{'b', \"bravo\", OPTARG_OPTIONAL},\n            //{'c', \"charlie\", OPTARG_REQUIRED},\n            {0, 0, OPTARG_NONE}\n        };\n\n        // declare state here to save during parsing\n\n        // loop through args\n        for (;;)\n        {\n            if (!opt.ProcessOptions(argv, optionsData))\n                return cli.SetError(opt.GetError());\n\n            if (opt.GetOption() == -1) break;\n\n            switch (opt.GetOption())\n            {\n                case 'a':\n                    break;\n                case 'b':\n                    if (!opt.GetOptionArgument.empty())\n                        opt.GetOptionArgument(); // Here's the optional argument\n                    break;\n                case 'c':\n                    opt.GetOptionArgument(); // Here's the argument\n                    break;\n            }\n        }\n\n        // call the function declared in Cli\n        return cli.DoThe();\n    }\n\nprivate:\ncli::Cli&amp; cli;\n\n    // no copy\n    TheCommand&amp; operator=(const TheCommand&amp;);\n\n};\n</code></pre> <p>Open up cli_CommandLineInterface.cpp and add your command in the constructor. Create cli_the.cpp for your command and implement the command execution.</p>","tags":["kernel programming"]},{"location":"development/soar/IOAndRewardLinks/","title":"IO and Reward Links","text":"","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#io-and-reward-links","title":"I/O and Reward Links","text":"","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#introduction","title":"Introduction","text":"<p>Soar provides several links on various states: the io, input-link, and output-link exist on the top state, whereas a reward-link exists on every state. This page will describe how to add your own link, using the emotion link as an example (since that's what I'm working on at the moment). Note that this is actually a couple links (like io has a couple links) and it's only on the top state. If you only want a single link and/or you want links on all states, just search the code for reward-link to see how that's different (most of the differences for reward-link are because it is on every state).</p> <p>When adding a new link, there are several things you need to deal with:</p> <ul> <li>adding the link on agent creation</li> <li>removing the link on agent destruction</li> <li>recreating the link during an init-soar</li> </ul> <p>Depending on what the link is for, you may also need to deal with:</p> <ul> <li>reading things off of the link</li> <li>putting things on the link</li> </ul>","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#adding-the-link-on-agent-creation","title":"Adding the link on agent creation","text":"<p>Adding a new link involves several steps:</p> <ul> <li>Creating and saving the link symbols and WMEs</li> </ul>","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#creating-and-saving-the-link-symbols-and-wmes","title":"Creating and saving the link symbols and WMEs","text":"<p>Commonly-used symbols are often created once and stored on the agent structure. This includes link names (the attribute of the link wme). Let's suppose I want the following link structure (I'm using concrete identifiers for clarity; the actual identifiers that get created may be different):</p> <pre><code>S1 [COLOR=#666600]^[/COLOR]emotion E1 E1 [COLOR=#666600]^[/COLOR]appraisal[COLOR=#666600]-[/COLOR]link A1 [COLOR=#666600]^[/COLOR]feeling[COLOR=#666600]-[/COLOR]link F1\n</code></pre> <p>I need to create and save symbols for \"emotion\", \"appraisal-link\" and \"feeling-link\", and the WMEs that contain those symbols. To do this, go to the agent structure (agent.h) and find the section labeled \"Predefined Symbols\". At the end of this section, add a Symbol pointer for each new symbol:</p> <pre><code>[COLOR=#660066]Symbol[/COLOR] [COLOR=#666600]*[/COLOR] emotion_symbol[COLOR=#666600];[/COLOR]\n[COLOR=#660066]Symbol[/COLOR] [COLOR=#666600]*[/COLOR] appraisal_link_symbol[COLOR=#666600];[/COLOR]\n[COLOR=#660066]Symbol[/COLOR] [COLOR=#666600]*[/COLOR] feeling_link_symbol[COLOR=#666600];[/COLOR]\n</code></pre> <p>Now find the part of the agent structure labeled \"I/O stuff\" and add the Symbols corresponding to the identifier values of the WMEs and the wme structures themselves (generally speaking, you only need to save the WMEs that you plan on directly manipulating in other code):</p> <pre><code>Symbol            * emotion_header;\nwme               * emotion_header_link;\n\nSymbol            * emotion_header_appraisal;\nSymbol            * emotion_header_feeling;\n</code></pre> <p>Now go to the <code>create_predefined_symbols</code> function (in symtab.cpp) and create your symbols at the end:</p> <pre><code>thisAgent-&gt;emotion_symbol = make_sym_constant (thisAgent, \"emotion\");\nthisAgent-&gt;appraisal_link_symbol = make_sym_constant( thisAgent, \"appraisal-link\" );\nthisAgent-&gt;feeling_link_symbol = make_sym_constant( thisAgent, \"feeling-link\" );\n</code></pre> <p>Finally, go to the init_agent_memory function in init_soar.cpp and create the identifier values and WMEs corresponding to the desired structure:</p> <pre><code>thisAgent-&gt;emotion_header = get_new_io_identifier (thisAgent, 'E'); // E1\nthisAgent-&gt;emotion_header_appraisal = get_new_io_identifier (thisAgent, 'A');  // A1\nthisAgent-&gt;emotion_header_feeling = get_new_io_identifier (thisAgent, 'F'); // F1\n\n// (S1 ^emotion E1)\nthisAgent-&gt;emotion_header_link = add_input_wme (thisAgent,\n                                                thisAgent-&gt;top_state,\n                                                thisAgent-&gt;emotion_symbol,\n                                                thisAgent-&gt;emotion_header);\n// (E1 ^appraisal-link A1)\nadd_input_wme (thisAgent, thisAgent-&gt;emotion_header,\n               thisAgent-&gt;appraisal_link_symbol,\n               thisAgent-&gt;emotion_header_appraisal);\n// (E1 ^feeling-link F1)\nadd_input_wme (thisAgent, thisAgent-&gt;emotion_header,\n               thisAgent-&gt;feeling_link_symbol,\n               thisAgent-&gt;emotion_header_feeling);\n</code></pre>","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#removing-the-link-on-agent-destruction","title":"Removing the link on agent destruction","text":"<p>On agent destruction, we need to remove all of those symbols we saved on the agent structure. To do this, go to the release_predefined_symbols function (in symtab.cpp) and add the following to the end:</p> <pre><code>release_helper( thisAgent, &amp;( thisAgent-&gt;emotion_symbol ) );\nrelease_helper( thisAgent, &amp;( thisAgent-&gt;appraisal_link_symbol ) );\nrelease_helper( thisAgent, &amp;( thisAgent-&gt;feeling_link_symbol ) );\n</code></pre> <p>Note that this function is called from destroy_soar_agent in agent.cpp.</p> <p>In general, you do not need to explicitly release the WMEs, since those will automatically be cleaned up when the wme memory pool is cleaned up during agent destruction.</p>","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#recreating-the-link-during-an-init-soar","title":"Recreating the link during an init-soar","text":"<p>Perhaps counter-intuitively, link recreation is handled in the do_input_cycle function in io.cpp. (Historically, initial link creation was handled here as well). Basically, the reinitialize_soar function calls clear_goal_stack which destroys the entire state and then calls do_input_cycle to recreate the top state. Find the part of do_input_cycle inside the if clause labeled \"top state was just removed\" and release the identifier values we created and set the corresponding pointers (including to WMEs) on the agent structure to NIL:</p> <pre><code>release_io_symbol (thisAgent, thisAgent-&gt;emotion_header);\nrelease_io_symbol (thisAgent, thisAgent-&gt;emotion_header_appraisal);\nrelease_io_symbol (thisAgent, thisAgent-&gt;emotion_header_feeling);\nthisAgent-&gt;emotion_header = NIL;\nthisAgent-&gt;emotion_header_appraisal = NIL;\nthisAgent-&gt;emotion_header_feeling = NIL;\nthisAgent-&gt;emotion_header_link = NIL;\n</code></pre> <p>Failure to do this properly will result in memory leak warnings when you do an init-soar.</p>","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#reading-things-off-of-the-link","title":"Reading things off of the link","text":"<p>To read things off the link, you need to loop over any WMEs that might be on the link. In our example, suppose the following structure exists:</p> <pre><code>S1 ^emotion E1\nE1 ^appraisal-link A1\nA1 ^frame F1\nF1 ^conduciveness 1.0\n</code></pre> <p>We have a pointer to the appraisal-link on the agent structure already, so we can start there. First, make sure it exists (depending on when you call this function, it might not):</p> <pre><code>void get_appraisals(agent* thisAgent)\n{\n  if(!thisAgent-&gt;emotion_header_appraisal) return;\n</code></pre> <p>Next, we have to loop over the slots. Slots are simply a list of WMEs that have the same id and attribute - that is, they support multi-valued attributes. If you don't have any multi-valued attributes, then each slot will only have one wme.</p> <pre><code>slot* frame_slot = thisAgent-&gt;emotion_header_appraisal-&gt;id.slots;\nslot* appraisal_slot;\nwme *frame, *appraisal;\n\nif ( frame_slot )\n{\n  for ( ; frame_slot; frame_slot = frame_slot-&gt;next )\n{\n</code></pre> <p>Each slot has an id, attr, and list of WMEs. In this case, we are looking for the \"frame\" slot. We will skip any other slots we see:</p> <p>Code:</p> <pre><code>if(frame_slot-&gt;attr-&gt;sc.common_symbol_info.symbol_type == SYM_CONSTANT_SYMBOL_TYPE\n        &amp;&amp; !strcmp(frame_slot-&gt;attr-&gt;sc.name, \"frame\")) /* BADBAD: should store \"frame\" symbol in common symbols so can do direct comparison */\n{\n</code></pre> <p>When we find a \"frame\" slot, we will loop over its WMEs (each of which have the same id and the \"frame\" attribute). For the structure above, the only wme on this list will be A1 ^frame F1. For each wme that has an id value (just one in this case), we will loop over its slots and WMEs:</p> <pre><code>for ( frame = frame_slot-&gt;wmes ; frame; frame = frame-&gt;next)\n{\nif (frame-&gt;value-&gt;common.symbol_type == IDENTIFIER_SYMBOL_TYPE)\n{\n  for ( appraisal_slot = frame-&gt;value-&gt;id.slots; appraisal_slot; appraisal_slot = appraisal_slot-&gt;next )\n  {\n    for ( appraisal = appraisal_slot-&gt;wmes; appraisal; appraisal = appraisal-&gt;next )\n    {\n      // do stuff with the WMEs; in this example, will get the F1 ^conduciveness 1.0 wme here\n    }\n</code></pre> <p>Here's the complete example:</p> <pre><code>void get_appraisals(agent* thisAgent)\n{\n  if(!thisAgent-&gt;emotion_header_appraisal) return;\n\n  slot* frame_slot = thisAgent-&gt;emotion_header_appraisal-&gt;id.slots;\n  slot* appraisal_slot;\n  wme *frame, *appraisal;\n\n  if ( frame_slot )\n  {\n    for ( ; frame_slot; frame_slot = frame_slot-&gt;next )\n    {\n      if(    frame_slot-&gt;attr-&gt;sc.common_symbol_info.symbol_type == SYM_CONSTANT_SYMBOL_TYPE\n         &amp;&amp; !strcmp(frame_slot-&gt;attr-&gt;sc.name, \"frame\")) /* BADBAD: should store \"frame\" symbol in common symbols so can do direct comparison */\n      {\n        for ( frame = frame_slot-&gt;wmes ; frame; frame = frame-&gt;next)\n        {\n          if (frame-&gt;value-&gt;common.symbol_type == IDENTIFIER_SYMBOL_TYPE)\n          {\n            for ( appraisal_slot = frame-&gt;value-&gt;id.slots; appraisal_slot; appraisal_slot = appraisal_slot-&gt;next )\n            {\n              for ( appraisal = appraisal_slot-&gt;wmes; appraisal; appraisal = appraisal-&gt;next )\n              {\n                // do stuff with the WMEs; in this example, will get the F1 ^conduciveness 1.0 wme here\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre> <p>Of course, we need to call this function from somewhere. In this example, we'll read this link during the input phase, so we'll call it from do_input_cycle (in io.cpp), in the block of code marked \"if there is a top state, do the normal input cycle\":</p> <pre><code>/* --- if there is a top state, do the normal input cycle --- */\n\nif (thisAgent-&gt;top_state) {\n  soar_invoke_callbacks(thisAgent, INPUT_PHASE_CALLBACK, (soar_call_data) NORMAL_INPUT_CYCLE);\n\n  get_appraisals(thisAgent);  // added this line\n}\n</code></pre>","tags":["io","kernel programming"]},{"location":"development/soar/IOAndRewardLinks/#putting-things-on-the-link","title":"Putting things on the link","text":"<p>To put things on the link, you'll want to use these two functions: add_input_wme and remove_input_wme. In my example, I want to replace a wme that may exist on the feeling-link:</p> <pre><code>S1 ^emotion E1\nE1 ^feeling-link F1\nF1 ^frame F2  &lt;-- I want to blink this\n</code></pre> <p>First, let's suppose I already have a pointer to this wme saved on the agent structure:</p> <pre><code>wme * feeling_frame;\n</code></pre> <p>And also assume that I initialized this to 0 in init_agent_memory:</p> <pre><code>thisAgent-&gt;feeling_frame = 0;\n</code></pre> <p>Now I can update it like this:</p> <pre><code>void generate_feeling_frame(agent* thisAgent)\n{\n  // clear previous feeling frame (stored on agent structure)\n  if(thisAgent-&gt;feeling_frame) { remove_input_wme(thisAgent, thisAgent-&gt;feeling_frame); }\n\n  // generate new frame\n  thisAgent-&gt;feeling_frame = add_input_wme(thisAgent, thisAgent-&gt;emotion_header_feeling, make_sym_constant(thisAgent, \"frame\"), make_new_identifier(thisAgent, 'F', TOP_GOAL_LEVEL));\n}\n</code></pre> <p>Actually, that's not quite right - this will result in a memory leak (which will cause init-soar to fail, among other things). What will happen here is the call to make_sym_constant will create a new Symbol with a reference count of 1, and then add_input_wme will add another ref count to it. When this function is called later, remove_input_wme will decrement the ref count by 1, still leaving it with a non-zero ref count. The way to fix this is to decrement the ref count after we pass the Symbol off to add_input_wme (in effect, we are relinquishing control of the Symbol to the wme):</p> <pre><code>void generate_feeling_frame(agent* thisAgent)\n{\n  // clear previous feeling frame (stored on agent structure)\n  if(thisAgent-&gt;feeling_frame) { remove_input_wme(thisAgent, thisAgent-&gt;feeling_frame); }\n\n  // generate new frame\n  Symbol* frame_att = make_sym_constant(thisAgent, \"frame\");\n  thisAgent-&gt;feeling_frame = add_input_wme(thisAgent, thisAgent-&gt;emotion_header_feeling, frame_att, make_new_identifier(thisAgent, 'F', TOP_GOAL_LEVEL));\n  symbol_remove_ref(thisAgent, frame_att);\n}\n</code></pre> <p>Of course, we need to call this function from somewhere. In this example, we want to generate a new frame right after we read in the appraisals, so we call the function from the same block of code as above (in do_input_phase in io.cpp):</p> <pre><code>/* --- if there is a top state, do the normal input cycle --- */\n\nif (thisAgent-&gt;top_state) {\n  soar_invoke_callbacks(thisAgent, INPUT_PHASE_CALLBACK, (soar_call_data) NORMAL_INPUT_CYCLE);\n\n  get_appraisals(thisAgent);  // added this line above\n  generate_feeling_frame(thisAgent); // added this line\n}\n</code></pre>","tags":["io","kernel programming"]},{"location":"development/soar/MemoryLeakDebuggingWithVisualStudio/","title":"Memory Leak Debugging with Visual Studio","text":"","tags":["kernel programming"]},{"location":"development/soar/MemoryLeakDebuggingWithVisualStudio/#memory-leak-debugging-with-visual-studio","title":"Memory Leak Debugging with Visual Studio","text":"<p>This document summarizes one technique for fixing memory leaks in the Soar kernel using Visual Studio's Leak Detection tools.</p> <p>First, choose a program you will use for testing. I recommend TestCLI or TestClientSML or some other program that can repeatably cause leaks.</p> <p>At the top of the file containing main.cpp, add this:</p> <pre><code>#ifdef _MSC_VER\n// Use Visual C++'s memory checking functionality\n#define _CRTDBG_MAP_ALLOC\n#include &lt;crtdbg.h&gt;\n#endif // _MSC_VER\n</code></pre> <p>This enables the leak-detection versions of the memory allocation and de-allocation functions.</p> <p>At the beginning of the main function, add this code:</p> <pre><code>#ifdef _MSC_VER\n        //_crtBreakAlloc = 1828;\n        _CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );\n#endif // _MSC_VER\n</code></pre> <p>The #ifdef's make sure that we don't try this with any other compiler. The CrtSetDbgFlag line says \"report detected leaks when the program exits.\" This is the preferred method -- it is possible to put a similar line at the end of main that says \"report detected leaks now\", but this is subtly different -- objects allocated in the main function may not be deallocated yet, and dlls are not yet unloaded. This can lead to false leak reports. So do it the way I have shown.</p> <p>I will describe the purpose of the commented line in a moment.</p> <p>This is enough to get your test program to report any leaks. The program (and any code you're testing) needs to be compiled in Debug mode for this to work. A leak report will look something like this:</p> <pre><code>Detected memory leaks!\nDumping objects -&gt;\n{19907} normal block at 0x00B24688, 11 bytes long.\nData: &lt;    &lt;#d*1&gt; &gt; 0B 00 00 00 3C 23 64 2A 31 3E 00\n{19906} normal block at 0x00B60360, 104 bytes long.\n Data: &lt;                &gt; 00 00 00 00 01 00 00 00 00 CD CD CD CD CD CD CD\n{3840} normal block at 0x00B2B240, 12 bytes long.\n Data: &lt;    desired &gt; 0C 00 00 00 64 65 73 69 72 65 64 00\n{3839} normal block at 0x00B2B198, 104 bytes long.\n Data: &lt;                &gt; 00 00 00 00 01 00 00 00 02 CD CD CD CD CD CD CD\n{1828} normal block at 0x00AE4BC8, 8 bytes long.\n Data: &lt;H       &gt; 48 02 AF 00 00 00 00 00\n{1699} normal block at 0x00B195C0, 56 bytes long.\n Data: &lt;                &gt; 00 00 00 00 CD CD CD CD CD CD CD CD CD CD CD CD\n{1698} normal block at 0x00B19550, 48 bytes long.\n Data: &lt;@               &gt; 40 CD CD CD CD CD CD CD 00 00 00 00 00 00 00 00\nObject dump complete.\n</code></pre> <p>What this means is that there were 7 leaks in this run. The number in {} is the allocation number of the leaked memory (e.g. {1698} means the 1698th malloc wasn't freed). The leaks are reported in reverse order for some reason. The Data line can sometimes give you a clue as to what is leaking. But the key is the number in the {}. In the code you added at the beginning of main, change the number in the commented line to one of the leak numbers (e.g. 1698 in the above report) and uncomment the line. I recommend doing this in the order in which the leaks occur (i.e. start at the bottom of the list), because some leaks can cause others or appear many times, so if you fix them in order some of the later ones may go away.</p> <p>Now run the program again. The code will break on the allocation number you specified (I recommend running the code from within Visual Studio as this will make bringing up the line of code easier). It is very important that this run be exactly like the previous run so that the same allocations occur in the same order. Otherwise the code will break on some irrelevant allocation. This means removing any randomness in the code execution. For multithreaded code this can be a pain, so I recommend coming up with the simplest possible test case that reproduces the leak you're working on. Sometimes the leak number will change over time because of threading issues, but will remain the same for a while. So it's important to regenerate the report periodically to make sure the allocation number you're working with is still accurate.</p> <p>When the code breaks, it will probably dump you in a low-level system file like dgbheap.c where the actual malloc is taking place. This is probably not interesting to you. You want to look at your callstack and find the relevant place in your code that you can actually do something about.</p>","tags":["kernel programming"]},{"location":"development/soar/MemoryLeakDebuggingWithVisualStudio/#soar-kernel-gotchas","title":"Soar Kernel Gotchas","text":"<p>Most leaks reported in the kernel will be in the allocate_memory function. You will need to look higher up in the callstack to find the real source of the problem. This will often be in a call to a function like get_new_io_identifier or add_input_wme. Often, these functions return a pointer that is not saved, and thus cannot be released when it goes away or the agent is destroyed (much of the memory cleanup occurs in destroy_soar_agent).</p> <p>When working with Soar kernel code, some of the leak locations can be confusing. For example, if a hashtable is leaking, the reported leak may not occur where the hashtable was originally allocated, but rather where the hashtable was last resized. This kind of leak can appear to move around depending on what Soar code is run, because some code will require more allocations than others, but only the last one leaks. A similar thing can happen with memory pools (BTW, I believe all hashtable and memory pool leaks have been fixed now).</p> <p>It's also very common for symbols to leak. This is usually because the ref counts have not gone to zero for some reason, but it can also be because a pointer to the symbol was not saved so that it could be released. Most \"built-in\" symbols are released in the release_predefined_symbols function.</p>","tags":["kernel programming"]},{"location":"development/soar/MemoryLeakDebuggingWithVisualStudio/#finding-leaks-to-the-memory-pools","title":"Finding Leaks to the Memory Pools","text":"<p>Soar uses memory pools for efficiency. These pools are deallocated when the agent is destroyed. Thus, if code takes memory from the pool without returning it, the leak detection will not see this because all of the pool memory is returned to the OS at the end. These kinds of leaks can cause memory usage to climb while Soar is running, however.</p> <p>In order to find these leaks, the memory pools must be disabled. This will hurt performance, but it will allow the leaks to be detected.</p> <p>To disable the memory pools, find the functions allocate_with_pool and free_with_pool in mem.h. Comment out everything in those functions, and uncomment the last line. Now, calls to get memory from a pool and to release memory back to the pool will just do a standard malloc and free.</p> <p>It should be noted that this can sometimes uncover bad pointer bugs. When the pool is in use, memory returned to the pool is probably not overwritten immediately. So if a pointer to that released memory is accessed, there is a good chance that it will work. When the pools are disabled, though, that memory is overwritten (in a DEBUG build, at least), and so such accesses will fail. Thus, you should periodically disable the pools even if you aren't looking for leaks to check your code in this way.</p>","tags":["kernel programming"]},{"location":"development/soar/MemoryLeakDebuggingWithVisualStudio/#finding-leaks-in-dlls-and-modules-for-other-languages","title":"Finding leaks in DLLs and modules for other languages","text":"<p>If the .exe you are using has the memory leak detection code as described above and you are using Multithreaded Debug DLL code generation setting, then leaks in DLLs used by that .exe will also be reported.</p> <p>If the above conditions are not met and you want to check for leaks in a DLL, you need to add some special code to the DLL:</p> <pre><code>// Check for memory leaks\n#if defined(_DEBUG) &amp;&amp; defined(_WIN32)\n#define _CRTDBG_MAP_ALLOC\n#include &lt;stdlib.h&gt;\n#include &lt;crtdbg.h&gt;\n\nbool __stdcall DllMain( void _ hModule,\nunsigned long ul_reason_for_call,\nvoid _ lpReserved)\n{\n//_crtBreakAlloc = 1397;\n_CrtSetDbgFlag ( _CRTDBG_ALLOC_MEM_DF | _CRTDBG_LEAK_CHECK_DF );\nreturn 1;\n}\n#endif\n</code></pre> <p>This will report leaks for the DLL just as the .exe did before. Note that if you have the leak detection in both places, then the DLL leaks will get reported twice.</p> <p>For detecting leaks in programs written in other languages (e.g. Java), this code needs to be in the SWIG-generated DLL. We've already put it in there for you, so all you need is a debug build to see it (be sure to run from the command line so you can see this output at the end). The reported leaks should not be in the languages themselves, but rather in the SWIG or SML DLLs. Note that the Tcl and Python modules report lots of leaks (the SWIG people tell me this is because of the nature of memory management in those languages), so it may be difficult to pick out the leaks you are interested in for those languages.</p>","tags":["kernel programming"]},{"location":"development/soar/ThreadsInSML/","title":"Threads in SML","text":"","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#threads-in-sml","title":"Threads in SML","text":"<p>This document is intended to explain how threads are used in Soar 8.6 and later (this document is up-to-date as of 9.6). It assumes you already have a passing familiarity with both Soar and the SML interface language. This is advanced reading, for those who want to understand everything that's going on \"under the hood\".</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#what-threads-exist","title":"What Threads Exist","text":"<p>As with all things related to SML, we need to divide up the world into client-side threading and kernel-side threading. The kernel side threading is relatively simple. The kernel is either run in the client's thread or in its own separate thread. This choice is made by the client when it initializes the Soar kernel by calling either <code>Kernel::CreateKernelInCurrentThread()</code> or <code>Kernel::CreateKernelInNewThread()</code>. A remote connection (<code>Kernel::CreateRemoteConnection()</code>) doesn't affect the way the kernel is run; this is determined by the local client that created the kernel initially. If the kernel is running in its own thread, I will name this thread the Kernel Thread.</p> <p>The client side is potentially more complex. First, the client application may inherently be multi-threaded, such as a Java GUI app or it may be a simple single-threaded C++ program (e.g. a command line utility). Second, the calls to start Soar running (e.g. <code>RunAllAgentsForever</code>) block, so many clients will choose to execute this call in a separate thread in order to keep the rest of the application responsive. I'll call this the Run Thread, which means the thread where the run call is initiated. Finally, SML itself starts up (by default) a thread called the Event Thread. This thread is intended to keep the client responsive without a lot of work by the application developer.</p> <p>This gives us a picture of the overall set of threads:</p> Runs in Description Kernel Thread Kernel Keeps the kernel responsive to external commands (i.e. ones coming in over a socket connection). Event Thread Client SML Used to service incoming events sent by the kernel if Soar is not running (i.e. productions are not firing). This thread is optional but is created by default. Run Thread Client Point that run commands are executed. This thread is created by the client, either explicitly with a new thread or implicitly by calling run from the client's main thread. Client Threads Client Other threads that the client application may have for its own use. Typical examples are window manager threads in GUI apps.","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#why-have-multiple-threads-at-all","title":"Why Have Multiple Threads At All?","text":"<p>As we're about to dive into the complexity of the threading in SML, one obvious question is: why not just have a single thread and make everyone's life easier? Well, the answer is that that would make the SML/ kernel developer's life easier, but at the cost of making the client/application developer's life harder. Let me explain why that is more fully.</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#why-have-a-kernel-thread","title":"Why Have a Kernel Thread?","text":"<p>With Soar 9.6, a single Soar kernel can have multiple clients connected to it at once. A common situation is an environment in Java that has a local connection to the kernel itself. A debugger is connected remotely to the kernel and a logging application is also remotely connected. Commands can be sent to the kernel over a socket. The question is, how and when should the kernel check this socket for new commands?</p> <p>In the single-threaded model, the kernel is running in the same thread as the client that created it (in our example, the Java environment). In this case, the client is required to poll the socket periodically to see if new commands have arrived. This is exactly what the method <code>Kernel::CheckForIncomingCommands()</code> does, and clients that call <code>CreateKernelInCurrentThread()</code> are required to call this periodically. But making such periodic calls is often difficult for a client. In the case of the Java app the user would need to start some sort of timer and poll across to the kernel whenever it went off. If they fail to realize that this must be done, then the debugger would fail to function at all, leading to a lot of \"why doesn't the debugger respond\" problems. In other clients, making periodic calls may be really complicated. Simple command line utilities tend to take the form: get command from the user, do some work, print some results, get another command. Writing these would be much more challenging if the client is not allowed to block while getting input from the keyboard.</p> <p>So the result is that we recommend running the kernel in its own thread in most cases. That separate thread checks for new commands coming in from either the socket or the local client. In this model, commands are always run in the kernel's thread. That means that, if the local client calls <code>run</code>, what actually happens is that the <code>run</code> command is placed on a message queue and the kernel thread then pulls the command from that queue and executes it. That's important to understand if you're trying to debug a problem at the kernel level, since the client's function call just adds a message to a queue and you usually need to break the execution at the point that the kernel's thread has picked up the message (e.g. in <code>KernelSML::ProcessCommand()</code>). You won't see the client's triggering call higher up in the call stack at that point because it's in a different thread.</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#why-have-an-event-thread","title":"Why Have an Event Thread?","text":"<p>When Soar is running, it is constantly generating a stream of events. These events are posted to each client, allowing the client to know what's going on during the course of a run. The Event Thread exists to help clients remain responsive to these incoming events. The first thing to understand about Soar events is that they are synchronous calls. That is to say, the kernel blocks during the call to send each client a message that a particular event has occurred. The kernel only continues executing once that call completes. It may not be immediately obvious that events need to be synchronous (indeed early on we thought they might not be) but in turns out to be useful they must be. For example, consider an agent that wishes to take some action when a new phase starts so it registers for the start phase event. If the call is not synchronous, then by the time the event arrives the kernel may now be at a much later execution point. This would limit clients to knowing what had happened, but not doing things at particular times (and this turns out to be 95% of the actual usage).</p> <p>So given that event calls are synchronous and the kernel blocks waiting for them to complete, how do we ensure that clients are responsive?</p> <ul> <li> <p>In the case where the kernel and the client are running in the same thread   there is really no problem. The event call is just a function callback and the   callback executes in the kernel's thread.</p> </li> <li> <p>When the kernel and client are running in separate processes connected   by a socket, the client needs to check for new messages arriving on the socket.</p> <ul> <li> <p>As with the kernel thread, this could be done by requiring the client to   periodically poll for new events coming in on the socket (and again this   mode is supported by having clients call   <code>Kernel::CheckForIncomingEvents()</code>). But this periodic polling can be   complicated as explained earlier. In fact, the situation is even worse for   the client as it needs to be as fast as possible responding to incoming   events or the entire system's performance will degrade.</p> </li> <li> <p>This is where the EventThread comes in. Its job is to check the socket for new events and make the appropriate callback to the client code. This keeps the client responsive and most people will never stop to wonder how a callback inside one process is being triggered by a kernel running in another process without their doing anything.</p> </li> </ul> </li> </ul> <p>There is however a wrinkle in this behavior. When a run call is made by a client (on what we're calling the RunThread) that call blocks. While it is blocked it is checking for incoming messages and dispatching them, while it waits for the message to indicate that the run has completed to come through. This means that when a run is triggered by a client, callbacks will occur on the RunThread. When that client did not initiate the run (e.g. somebody typed run in the debugger) or when Soar is not running (e.g. during an init-soar event), events are handled by the EventThread. This means that callbacks can be called on different threads at different times.</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#callback-threading-and-blocking-on-run","title":"Callback Threading and Blocking on Run","text":"<p>Let's discuss that a little more. First of all, having the calls come back on different threads isn't ideal. It means a client developer could have different bugs that occur when Soar is run from the client or when Soar is run remotely because the threading is different. In practice, this hasn't really been an issue. On a larger front though it suggests maybe the run calls should not in fact block. If the run calls did not block, the client's life would be easier (they wouldn't need to create a thread when they started a run) and all callbacks would come in on the event thread. The fact that run does block is largely an artifact of how we used to design environments. The main run loop used to look something like:</p> <pre><code>while (!stopped)\n{\n    Run-agents-1-step()\n    Update-world()\n}\n</code></pre> <p>With this model we really want the run call to block so that each single step was a single call (writing this where <code>Run-agents-1-step</code> is non-blocking would be much harder). But, over the development of 8.6, we learned that we really didn't want this model and instead we now have a model more like this:</p> <pre><code>RegisterCallback(update-after-output-event, updateWorld)\nWhile (!stopped)\n{\n    Run-agents-forever()\n}\n</code></pre> <p>This new event driven model means that having <code>run-agents-forever</code> be a non-blocking call would be a possibility after all. In fact it would probably simplify matters for the client side developer. However, it's a very significant adjustment (breaking lots of existing code) and so far we haven't actively considered making the <code>run-agents-forver</code> call non-blocking.</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#locking-and-thread-safety","title":"Locking and Thread-Safety","text":"<p>Given that there are these multiple threads in the system you may need to understand how locking is implemented, to ensure thread safety across the system. The approach we've taken is to assume that the kernel is itself not thread-safe at all. E.g., we'll assume it's not safe to remove a production at the same time a preference is being created as the result of another production firing. Therefore, the approach is to only allow a single command to execute in the kernel at a time.</p> <p>In practical terms, this means even if multiple clients are connected through remote connections their commands are queued up, together with the commands that come from the local connection and executed one at a time. The code for this is in ReceiverThread.cpp. This ensures that the kernel side only executes one command at a time.</p> <p>We also assume that the messaging code is not necessarily thread safe, so we have the client block from sending two messages at the same time. This is achieved with the <code>m_ClientMutex</code> mutex object defined in the Connection class. This decision has a couple of implications.</p> <p>First, it allows the EventThread and the RunThread in the client to live in harmony. A run call will wait for the current event to be processed before it starts and once the run has begun, this lock forces the EventThread to wait for the run to complete. As a result, all events during a run (started by that client) come back on the RunThread and all events outside of a run come back on the EventThread.</p> <p>Second, the presence of a lock on the client makes interruption a bit tricky. If a client issues a stop command from a different thread than the RunThread, it will block, waiting for the run to complete. This is not very helpful. The solution is to have the client issue the stop in an event handler callback, as that callback will always occur on the RunThread if the client is currently running Soar. (If you really want to follow the different cases, the callback might be called by the EventThread but only if the client has not called run, in which case the stop call will go through because the RunThread will not be holding the lock or at least not holding it for a long time).</p> <p>You might wonder, given this model how does the debugger print out state information during a run (e.g. after every 5 decisions). The answer is that it does the work in a callback so the print commands execute on the same thread as the original run command.</p> <p>So while we do not support multiple commands being executed simultaneously (where a second command starts up at an arbitrary time during the first command), we do support multiple commands being executed in a stack (or with reentrancy) where one command is partially complete (such as a run) and another command is executed in the middle of the first command. The keys to this are that the run is paused while this happens (it's in an event handler to be more precise) and the second command executes at a known time (inside an event handler) so the state of the system is well defined. We often end up with large sequences of calls going back and forth inside an initial trigger (init-soar is famous for this) as one action triggers an event, which triggers another action and so on. But it's all within a single logical stack of commands, rather than having multiple simultaneous threads of execution.</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/ThreadsInSML/#best-practices","title":"Best Practices","text":"<p>From the constraints of the threading model we have arrived at these \"best practices\" which will help clients behave well:</p> Description Call <code>RunAllAgentsForever</code> in a new thread If you don't want your application to block waiting for the run call to complete, you should make that call in a new thread. Call stop from an event handler In order to interrupt a run you need to be on the same thread as the original run call (if your client issues the run). This can be ensured by issuing the stop from an event handler's callback. This is also good advice for any other SML call that you wish to make while the kernel is running (e.g. printing out current state information in the middle of a run). Don't make assumptions about the thread an event handler is called on The event handler may be called from the RunThread or from the EventThread depending on the situation. <p>If you have any concerns about how to follow these guidelines please take a look at the sample environments that we include with the distributions. E.g. search for <code>RunAllAgentsForever</code> and <code>Stop</code> to see examples of those behaviors.</p>","tags":["sml","threads","architecture"]},{"location":"development/soar/Timers/","title":"Timers","text":"","tags":["kernel programming"]},{"location":"development/soar/Timers/#timers","title":"Timers","text":"<p>This document describes how Soar's internal timers work.</p>","tags":["kernel programming"]},{"location":"development/soar/Timers/#preprocessor-symbols","title":"Preprocessor Symbols","text":"<p>Core/SoarKernel/src/kernel.h contains a few relevant preprocessor symbols:</p> <ul> <li><code>NO_TIMING_STUFF</code>: Defining this symbol removes most timer code from the kernel.     The stats command output will be much shorter as well, as it will not include     timing statistics.</li> <li><code>DETAILED_TIMING_STATS</code>: Only valid when <code>NO_TIMING_STUFF</code>     is not defined. Defining this turns on more timers for more detailed stats for     things like chunking and GDS. Compiling out timer code can result in much     faster runs. Timers are compiled-in by default, but not detailed timing stats.</li> </ul>","tags":["kernel programming"]},{"location":"development/soar/Timers/#stats-output","title":"Stats Output","text":"<p>Some more information regarding the stats command.</p> stats Output agent struct Detailed Description Total CPU Time timers_total_cpu_time No Most encompassing, includes some scheduling code and all callbacks. Kernel CPU Time timers_total_kernel_time No Total CPU minus callbacks and a few other smaller things. Kernel / Phase (table) timers_decision_cycle_phase[NUM_PHASE_TYPES] No Time spent in each phase but not in callbacks. Callbcks / Phase (table) timers_monitors_cpu_time[NUM_PHASE_TYPES] No Time spent in callbacks for each phase, but notINPUT_PHASE_CALLBACK or output functions. Input fn (table) timers_input_function_cpu_time No Time spent in INPUT_PHASE_CALLBACK. Outpt fn (table) timers_output_function_cpu_time No Time spent in output functions. stats --max timers_decision_cycle, max_dc_time_msec No Used to collect max per-cycle statistics. Essentially a sum of timers_decision_cycle_phase sml_Names::kParamStatsOwnershipTime...(XML only) timers_ownership_cpu_time Yes Time spent in do_buffered_link_changes. Included in the decision cycle phase timers. sml_Names::kParamStatsChunkingTime...(XML only) timers_chunking_cpu_time Yes Time spent chunking. Included in decision cycle phase timers. sml_Names::kParamStatsMatchTime...(XML only) timers_match_cpu_time Yes Time spent adding/removing WMEs to/from rete. Included in decision cycle phase timers. sml_Names::kParamStatsGDSTime... (XML only) timers_gds_cpu_time Yes Time spent in the GDS code. Included in the decision cycle phase timers.","tags":["kernel programming"]},{"location":"development/soar/Timers/#timers-command","title":"Timers Command","text":"<p>There is a timers command to enable/disable timers at run-time. This should result in a performance improvement but not as much as compiling out the timers completely by defining <code>NO_TIMING_STUFF</code> in kernel.h.</p>","tags":["kernel programming"]},{"location":"development/soar/Timers/#timer-implementation","title":"Timer Implementation","text":"<p>The timers are currently implemented using the STLSoft library. The STLSoft code is wrapped in another layer in Core/shared/misc.h which define <code>soar_wallclock_timer</code> and <code>soar_process_timer</code>. Here are the comments from that file:</p> <p>Code:</p> <pre><code>// Instantiate soar_wallclock_timer or soar_process_timer objects to measure\n// \"wall\" (real) time or process (cpu) time. Call reset if you are unsure of\n// the timer's state and want to make sure it is stopped. Call start and then\n// stop to deliniate a timed period, and then call get_usec to get the value\n// of that period's length, in microseconds. It is OK to call get_usec after\n// calling start again. Resolution varies by platform, and may be in the\n// millisecond range on some.\n//\n// Use soar_timer_accumulator to rack up multiple timer periods. Instead of\n// calling get_usec on the timer, simply pass the timer to a\n// soar_timer_accumulator instance with it's update call. Use reset to clear\n// the accumulated time.\n\n// Platform-specific inclusions and typedefs\n//\n// The STLSoft timers used in the kernel have platform-specific namespaces\n// even though they share very similar interfaces. The typedefs here\n// simplify the classes below by removing those namespaces.\n//\n// We are using two different types of timers from STLSoft,\n// performance_counter and processtimes_counter. The performance timer is\n// a high-performance wall-clock timer. The processtimes_counter is a cpu-\n// time timer. Keep in mind that as of 11/2010 the resolution of process-time\n// counters on windows is 16 milliseconds.\n</code></pre>","tags":["kernel programming"]},{"location":"development/soar/Timers/#simple-usage","title":"Simple Usage","text":"<pre><code>soar_process_timer timer;\nsoar_timer_accumulator stat;\n...\ntimer.reset(); // initialize/reset\nstat.reset();  // initialize/reset\n...\ntimer.start();\n// do stuff that takes time\ntimer.stop();\nstat.update(timer); // read the timer, add elapsed to stat\n...\nstat.get_sec(); // total time accumulated with update();\n</code></pre>","tags":["kernel programming"]},{"location":"development/soar/Timers/#increasing-resolution","title":"Increasing Resolution","text":"<p>By default, the<code>soar_process_timer</code> uses an STLSoft interface called <code>processtimes_counter</code>. This is fine on most systems, but has a somewhat unacceptable 16 millisecond resolution on Windows platforms. The other kind of timer available is performance_counter which is used by the <code>soar_wall</code> <code>clock_timer</code>. This counter has higher resolution but the timer itself takes more time to execute (on most systems). To increase resolution on Windows system, uncomment the symbol <code>USE_PERFORMANCE_FOR_BOTH</code> in Core/shared/misc.h so that<code>soar_process_timer</code> uses the performance_counter. Note that this higher-resolution timer is measuring things in different way than the process times_counter and the results should probably not be compared.</p>","tags":["kernel programming"]},{"location":"development/soar/Timers/#old-stats-comments-in-kernel","title":"Old Stats Comments in Kernel","text":"<pre><code>/*\nFor Soar 7, the timing code has been completely revamped.  When the compile\nflag NO_TIMING_STUFF is not set, statistics will be now be collected on the\ntotal cpu time, total kernel time, time spent in the individual phases of a\ndecision cycle, time spent executing the input and output functions, and time\nspent executing callbacks (or monitors).  When the DETAILED_TIMING_STATS flag\nis set, additional statistics will be collected for ownership, match, and\nchunking computations according to the phase in which they occur. (Notice\nthat DETAILED_TIMING_STATS can only be collected when NO_TIMING_STUFF is not\ntrue.)\n\nThe total_cpu_time is turned on when one of the run_&lt;x&gt; functions is\ninitiated.  This timer is not turned off while the do_one_top_level_phase()\nfunction is executing.  The total_kernel_time timer is turned on just after\nthe total_cpu_time timer and turned off just before the other is turned off.\nThis guarantees that the total kernel time -- including the time it takes to\nturn on and off the kernel timer -- is a part of the total cpu time.  The\ntotal_kernel_time is also turned off whenever a callback is initiated or when\nthe input and output functions are executing.\n\nThe decision_cycle_phase_timers measure the kernel time for each phase of the\ndecision cycle (ie, INPUT_PHASE, PREFERENCE_PHASE, WM_PHASE, OUTPUT_PHASE,\nand DECISION_PHASE).  Each is turned on at the beginning of its corresponding\nphase in do_one_top_level_phase and turned off at the end of that phase.\nThese timers are also turned off for callbacks and during the execution of\nthe input and output functions.\n\nThe monitors_cpu_time timers are also indexed by the current phase.  Whenever\na callback is initiated, both the total_kernel_time and\ndecision_cycle_phase_timer for the current phase are turned off and the\nmonitors_cpu_time turned on.  After the callback has terminated, the kernel\ntimers are turned back on.  Notice that the same relationship holds here as\nit did between the total_cpu_time and total_kernel_time timers.  The\ntotal_kernel_time is always turned off last and turned on first, in\ncomparison to the decision_cycle_phase_timer.  This means that turning the\ndecision_cycle_phase_timers on and off is included as part of the kernel time\nand helps ensure that the total_kernel_time is always greater than the sum of\nthe decision_cycle_timers.\n\nThe input_function_cpu_time and output_function_cpu_time timers measure the\ntime it takes to execute the input and output functions respectively.  Both\nthe total_kernel_time and decision_cycle_phase_timers are turned off when\nthese timers are turned on (with the same ordering as discussed previously).\nThe input function is a little tricky.  Because add-wme can be called by the\ninput routine, which then calls do_buffered_wm_and_ownership_changes, we\ncan't just turn off the kernel timers for input and expect to get numbers for\nboth match_time (see next para) and kernel time.  The solution implemented in\nthe 28.07.96 changes is to not turn off the kernel timers until the actual\nINPUT_PHASE_CALLBACK is initiated.  This takes care of all but direct\nadditions and removals of WMEs.  Since these are done through the add-wme and\nremove-wme commands, the input_timer is turned off there was well, and the\nkernel timers turned back on (for the buffered wm changes).  However, this is\na hack and may introduce problems when add-wme and remove-wme are used at the\ncommand line or someplace in the decision cycle other than input (probably\nrare but possible).\n\nThe DETAILED_TIMING_STATS flag enables collection of statistics on match,\nownership and chunking calculations performed in each part of the decision\ncycle.  An 'other' value is reported which is simply the difference between\nthe sum of the detailed timers and the kernel timer for some phase.  The other\nvalue should always be greater than or equal to zero.\n\nThe \"stats\" command (in soarCommandUtils) has been updated to report these\nnew timing values.  The output is provided in a spreadsheet-style format to\ndisplay the information in a succinct form.  There are also some derived\ntotals in that report.  The derived totals in the right column are simply the\nsum of the all the other columns in a particular row; for example, the\nderived total for the first row, kernel time, is just the sum of all the\ndecision_cycle_phase_timers.  The derived totals in the bottom row are the\nsum of all the basic timers in that row (i.e., no DETAILED statistics are\nincluded in the sum).  For example, the derived total under input is equal to\nthe sum of decision_cycle_phase_timer and the monitors_time for the\nINPUT_PHASE, and the input_function_cpu_time and represents the total time\nspent in the input phase for the current run.  The number in the lower\nright-hand corner is the sum of the derived totals above it in that right\ncolumn (and should always be equal to the numbers to the left of it in that\nrow).\n\nAlso reported with the stats command are the values of total_cpu_time and\ntotal_kernel_time.  If the ordering discussed above is strictly enforced,\ntotal_kernel_time should always be slightly greater than the derived total\nkernel time and total_cpu_time greater than the derived total CPU time. REW */\n</code></pre>","tags":["kernel programming"]},{"location":"development/soar/Waterfall/","title":"Waterfall","text":"","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#waterfall","title":"Waterfall","text":"<p>This document describes the \"Waterfall\" modifications made to to Soar.</p> <p>As described by Bob Marinier...</p> <p>\"Suppose I have a blocks world agent that is trying to accomplish \"put A on B\". Several moves might be required to do this, and the agent doesn't know what they are, so it goes into a subgoal and starts randomly moving blocks around. What we want is for the agent to get a positive reward on the substate's reward link when it succeeds. So we can have a rule that detects that A is on B and creates a reward when that happens. However, when A is on B, the subgoal's supporting operator proposal will retract. Even though this retraction could, in principle, occur in parallel with the reward rule firing, the, waterfall will cause the retraction to occur first, and thus the substate will go away before the reward rule gets to fire, so the agent won't get the reward. In our proposed modification, the reward rule and retraction would occur in parallel, and thus the agent would get the reward.\"</p>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#brief-description-in-manual","title":"Brief description in manual","text":"<p>Note: This mechanism is not referred to by any name in the manual, including waterfall. See the last paragraph of chapter 2.6.5:</p> <p>The second change when there are multiple substates is that at each phase, Soar goes through the substates, from oldest (highest) to newest (lowest), completing any necessary processing at that level for that phase before doing any processing in the next substate. When firing productions for the proposal or application phases, Soar processes the firing (and retraction) of rules, starting from those matching the oldest substate to the newest. Whenever a production fires or retracts, changes are made to working memory and preference memory, possibly changing which productions will match at the lower levels (productions firing within a given level are fired in parallel \u2013 simulated). Productions firings at higher levels can resolve impasses and thus eliminate lower states before the productions at the lower level ever fire. Thus, whenever a level in the state stack is reached, all production activity is guaranteed to be consistent with any processing that has occurred at higher levels.</p>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#definitions","title":"Definitions","text":"<p>Minor quiescence: no more i-assertions (or any retractions) ready to fire in the current goal</p> <p>Consistency check: making sure that the currently selected operator is still legal (e.g., it's still acceptable, it shouldn't be replaced by a better operator or an impasse)</p> <p>Available compile flags (in kernel.h)</p> <pre><code>/* For information on the consistency check routines */\n/* #define DEBUG_CONSISTENCY_CHECK */\n\n/* For information on aspects of determining the active level */\n/* #define DEBUG_DETERMINE_LEVEL_PHASE */\n</code></pre>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#available-kernel-functions","title":"Available kernel functions","text":"<p>highest_active_goal_propose: Find the highest goal of activity among the current i-assertions and retractions</p> <p>highest_active_goal_apply: Find the highest goal of activity among the current i-assertions, o-assertions and retractions</p> <p>active_production_type_at_goal: Returns IE_PRODS if i-assertions active, otherwise PE_PRODS</p> <p>initialize_consistency_calculations_for_new_decision: call before functions below?</p> <p>determine_highest_active_production_level_in_stack_apply: implements waterfall for apply phase (DETERMINE_LEVEL_PHASE)</p> <ul> <li>calls itself recursively</li> <li>called in do_one_top_level_phase (APPLY_PHASE, twice)</li> <li>if the next active goal     is lower in the stack than the previous one, but the stack is no longer     consistent up to the previous goal, then proceed to output</li> </ul> <p>determine_highest_active_production_level_in_stack_propose: implements waterfall for propose phase</p> <ul> <li>called in do_one_top_level_phase (PROPOSE_PHASE, twice)</li> </ul> <p>get_next_assertion (rete.cpp): gets next production/token/wme associated with the current goal (as determined by above) do_working_memory_phase: \"commits\" the changes at the end of a phase</p>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#implementation-thoughts","title":"Implementation thoughts","text":"<p>In do_one_top_level_phase, currently do this:</p> <ol> <li>determine highest active goal</li> <li>fire rules at that goal</li> <li>commit changes</li> <li>proceed to next phase</li> </ol> <p>Could change it to do this:</p> <ol> <li>determine highest active goal</li> <li>fire rules at that goal, tracking the highest goal with a change</li> <li>determine highest active goal below highest changed goal</li> <li>goto 2 until past bottom goal</li> <li>commit changes</li> <li>proceed to next phase</li> </ol>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#test-case","title":"Test Case","text":"<pre><code># Test case for revised waterfall model\n#\n# In Soar8/9.0.0 waterfall model, the change*substate rule will never fire. This is because the\n# change*top-state rule will fire first, which will cause the proposal to unmatch and thus the\n# substate will retract\n#\n# In the revised waterfall model, change*substate will fire in parallel with change*top-state, since\n# the effects cannot possibly conflict.\n\nlearn --off\n\nsp {propose*test\n(state  ^superstate nil\n          -^result true)\n--&gt;\n( ^operator  +)\n( ^name test)\n}\n\nsp {change*top-state\n(state  ^superstate )\n( ^operator.name test)\n--&gt;\n( ^result true)\n(write (crlf) |Changed top-state|)\n}\n\nsp {change*substate\n(state  ^superstate )\n( ^operator.name test\n      ^result true)\n--&gt;\n( ^substate changed)\n(write (crlf) |Changed substate|)\n}\n</code></pre>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#test-case-in-jsoar","title":"Test case in jSoar","text":"<p>The file <code>/jsoar/test/org/jsoar/kernel/FunctionalTests_testWaterJugLookAhead.soar</code> in the jSoar project contains the above code plus a (succeeded) rhs call that works with JUnit so that the test can succeed once the changes to the waterfall model work.</p>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#notes","title":"Notes","text":"<ul> <li>preference phase: the inner loop that processes assertions and retractions at     the active level and possibly below with new waterfall model</li> <li>matches: assertion/retraction, matches AND unmatches coming from the rete</li> <li>active_level: the highest level at which matches are waiting to be processed</li> <li>previous_active_level: the active_level at the start of the previous outer     preference loop</li> <li>change_level: lowest level affected by matches fired during previous iteration     of inner preference loop, always equal to or higher than active_level, matches     firing in next iteration cannot change this level or higher.</li> <li>next_change_level: lowest level affected by matches fired during this     iteration of inner preference loop, becomes change_level for next iteration</li> <li>high_match_change_level: highest level affected by a match's changes, compares     to change_level</li> <li>low_match_change_level: lowest level affected by a match's changes, sets     next_change_level</li> </ul>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#algorithm","title":"Algorithm","text":"<p>This describes one outer preference loop.</p> <ol> <li>Reset '''active_level'''=0, '''next_change_level'''=0.</li> <li>Set '''active_level'''.</li> <li>Set '''previous_active_level''' = '''active_level'''</li> <li> <p>Inner preference loop start:</p> <ol> <li>If '''active_level''' is invalid, break out of loop.</li> <li>Set '''change_level''' = '''next_change_level'''.</li> <li> <p>For each match at the '''active_level''':</p> <ol> <li>Determine '''high_match_change_level''' and '''low_match_change_level''' (see execute_action).</li> <li> <p>If the '''high_match_change_level''' &lt; '''change_level''':</p> <ol> <li>Fire the match (and be sure match is removed from match lists).</li> <li>Set '''next_change_level''' = min('''next_change_level''', '''low_match_change_level''')</li> </ol> </li> <li> <p>Else if '''high_match_change_level''' &gt;= '''change_level''':</p> <ol> <li>Do not fire the match (and be sure match is retained in match lists).</li> </ol> </li> </ol> </li> <li> <p>Set '''active_level''' to next lowest level that has activity (matches) below the current '''active_level'''.</p> </li> <li>Go to inner preference loop start.</li> </ol> </li> <li> <p>Set '''active_level''' = '''previous_active_level'''</p> </li> <li>Commit changes (do_working_memory_phase)</li> </ol>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>done in initialize_consistency_calculations_for_new_decision</li> <li>done in determine_highest_active_production_level_in_stack _apply/propose</li> <li>local variable in doApplyPhase, not yet implemented for propose</li> <li>current handling of this (in the apply phase) is to set current_phase to     Phase.OUTPUT. May need to actually check this though because we probably won't     be changing current_phase in 4.4.</li> </ul> <p>find out what level a match will change possibly out of date</p> <ol> <li>Call create_instantiation on the assertion</li> <li>Determine the highest level of any action (as reported by execute_action) (see solution above)</li> <li>If any action's level is higher than the safe active level<ol> <li>Don't create the instantiation (see below)</li> <li>Put the assertion back on the assertions list where we got it from (the    pointers should still be in the right places)</li> </ol> </li> <li>For each retraction at this goal, do something similar to above</li> </ol>","tags":["kernel programming","substate"]},{"location":"development/soar/Waterfall/#notes-on-only-firing-the-assertion","title":"Notes on only firing the assertion","text":"<p>create_instantiation is going to go through all of the actions, if we find midway through that an action is bad, we throw out the entire instantiation. This means execute_action needs to return this sort of failure code so that the effects of get_next_assertion on the rete listener can be undone, which is something like pushing the assertion back on to the list for the active goal. There are multiple lists of assertions for each goal, we need to put it back on the correct one.</p>","tags":["kernel programming","substate"]},{"location":"downloads/","title":"Downloads","text":"<ul> <li>Soar</li> <li>Agents</li> <li>Agent Development Tools</li> <li>Domains</li> <li>Examples and Unsupported</li> </ul>"},{"location":"downloads/agent_development_tools/","title":"Downloads: Agent Development Tools","text":"<p>In this category you'll find tools to help you develop your Soar agents. This includes IDEs for developing Soar agents, a variety of both real-time and offline debugging tools and some syntax coloring add-ons for certain text editors.</p> <ul> <li>Episodic Memory Size Tool</li> <li>QuickLink Input Simulator</li> <li>Soar Data Collector</li> <li>Soar Debugger</li> <li>SoarEditor</li> <li>SoarIDE</li> <li>SoarUnit</li> <li>State2Dot</li> <li>SublimeText Soar Tools Package</li> <li>UltraEdit Syntax Coloring Wordfile</li> <li>Vim Soar Plug-In</li> <li>VisualSoar</li> </ul>"},{"location":"downloads/agent_development_tools/episodic_memory_size_tool/","title":"Episodic Memory Size Tool","text":"<p>This tool is a command-line python script to determine the size of episodes in episodic memory.</p>","tags":["agent debugging","episodic memory"]},{"location":"downloads/agent_development_tools/episodic_memory_size_tool/#download-link","title":"Download Link","text":"<p>Episodic_Memory_Sizer.zip</p>","tags":["agent debugging","episodic memory"]},{"location":"downloads/agent_development_tools/episodic_memory_size_tool/#documentation","title":"Documentation","text":"<p>None</p>","tags":["agent debugging","episodic memory"]},{"location":"downloads/agent_development_tools/episodic_memory_size_tool/#developer","title":"Developer","text":"<p>Justin Li</p>","tags":["agent debugging","episodic memory"]},{"location":"downloads/agent_development_tools/episodic_memory_size_tool/#soar-versions","title":"Soar Versions","text":"<p>Any with episodic memory; version must match the one that produced the DB.</p>","tags":["agent debugging","episodic memory"]},{"location":"downloads/agent_development_tools/episodic_memory_size_tool/#language","title":"Language","text":"<p>Python</p>","tags":["agent debugging","episodic memory"]},{"location":"downloads/agent_development_tools/quicklink_input_simulator/","title":"QuickLink Input Simulator","text":"<p>The purpose of this tool is to give complete control of the input-link to the Soar programmer. QuickLink can be thought of as a way to \"fake\" an external application, such as a game or simulation, in order to test specific circumstances that are rare and/or hard to reproduce. QuickLink currently can only be operated through the use of a command line interface.</p>"},{"location":"downloads/agent_development_tools/quicklink_input_simulator/#download-links","title":"Download Links","text":"<ul> <li>QuickLink.zip</li> </ul>"},{"location":"downloads/agent_development_tools/quicklink_input_simulator/#documentation","title":"Documentation","text":"<p>QuickLink Tutorial</p>"},{"location":"downloads/agent_development_tools/quicklink_input_simulator/#associated-publications","title":"Associated Publications","text":"<p>None</p>"},{"location":"downloads/agent_development_tools/quicklink_input_simulator/#developers","title":"Developers","text":"<p>Taylor Lafrinere</p>"},{"location":"downloads/agent_development_tools/quicklink_input_simulator/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agent_development_tools/quicklink_input_simulator/#language","title":"Language","text":"<p>C++</p>"},{"location":"downloads/agent_development_tools/soar_data_collector/","title":"Soar Data Collector","text":"<p>A Java library for collecting performance statistics for a running Soar agent.</p> <p>Statistics are collected at configurable intervals during a run and include:</p> <ul> <li>cumulative cpu usage times</li> <li>number of productions fired</li> <li>working memory size, high and low water marks</li> <li>working memory deltas</li> <li>maximum/minimum decision cycle times, wm deltas, production firings</li> <li>epmem and smem statistics including memory, queries, stores, retrieves</li> </ul>"},{"location":"downloads/agent_development_tools/soar_data_collector/#downloads","title":"Downloads","text":"<p>No pre-built binaries are currently available for this project.</p> <ul> <li>The project repository is here</li> <li>A JSoar version is also available here</li> </ul>"},{"location":"downloads/agent_development_tools/soar_data_collector/#documentation","title":"Documentation","text":"<ul> <li>31st Soar Workshop presentation</li> </ul>"},{"location":"downloads/agent_development_tools/soar_data_collector/#developers","title":"Developers","text":"<p>Jonathan Voigt voigtjr@gmail.com</p>"},{"location":"downloads/agent_development_tools/soar_data_collector/#soar-versions","title":"Soar Versions","text":"<ul> <li>Tested with Soar 9.3.2</li> </ul>"},{"location":"downloads/agent_development_tools/soar_data_collector/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/agent_development_tools/soar_debugger/","title":"Soar Debugger","text":"<p>A powerful Soar debugger implemented in Java that interfaces with Soar via SML. The debugger can run a Soar agent within it or hook up remotely to agents running in an environment or another computer.</p>"},{"location":"downloads/agent_development_tools/soar_debugger/#download-links","title":"Download Links","text":"<p>The Soar debugger is included with the SoarSuite release. There is a batch or script file at the top level of the SoarSuite folder that will launch it.</p>"},{"location":"downloads/agent_development_tools/soar_debugger/#documentation","title":"Documentation","text":"<p>An introductory tutorial to the Soar debugger can be found at this page.</p>"},{"location":"downloads/agent_development_tools/soar_debugger/#developers","title":"Developers","text":"<ul> <li>Douglas Pearson</li> <li>Bob Marinier</li> <li>Jon Voigt</li> <li>Karen Coulter</li> <li>and many others!</li> </ul>"},{"location":"downloads/agent_development_tools/soar_debugger/#soar-versions","title":"Soar Versions","text":"<ul> <li>All Soar versions come bundled with the debugger</li> </ul>"},{"location":"downloads/agent_development_tools/soar_debugger/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/agent_development_tools/soareditor/","title":"SoarEditor","text":"<p>The SoarEditor is an Eclipse plugin that allows you to use the powerful Eclipse IDE for writing Soar agents. It provides syntax coloring, auto-indenting, data map construction and generation, attribute/value completion (using the data map) and agent file structure management.</p>"},{"location":"downloads/agent_development_tools/soareditor/#download-links","title":"Download Links","text":"<p>The SoarEditor is downloadable via Eclipse itself.</p> <ol> <li>Install the latest version of Eclipse.</li> <li>In Eclipse, go to Help &gt; Install New Software...</li> <li>Click on the Add... button to add a new update site.</li> <li>Under Name, enter whatever you like, something like \"Soar Editor\".</li> <li>Under Location, enter https://raw.github.com/mtinkerhess/Soar-Editor/master/Site/site.xml</li> <li>Click OK, and wait for a minute for Eclipse to download information about the plugin.</li> <li>Check the box next to \"Uncategorized\", and click Next.</li> <li>Click Next again.</li> <li>Select \"I accept the terms of the licence agreement\" and click Finish.</li> <li>When prompted, click OK to allow Eclipse to install unsigned content.</li> <li>Click Restart Now to finish installing the plugin.</li> </ol>"},{"location":"downloads/agent_development_tools/soareditor/#documentation","title":"Documentation","text":"<p>While there isn't much documentation yet, you can find a page on the basics here.</p>"},{"location":"downloads/agent_development_tools/soareditor/#developers","title":"Developers","text":"<p>Miller Tinkerhess, Soar Technology (it used code from the SoarIDE).</p>"},{"location":"downloads/agent_development_tools/soareditor/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/agent_development_tools/soaride/","title":"SoarIDE","text":"<p>The SoarIDE is an advanced editor for the Soar programming language based on the Eclipse platform, developed by Soar Technology. As an Eclipse plugin, the SoarIDE leverages all of the core features of Eclipse including a flexible UI, update manager, regex cross-file search, project organization, a diff tool with integrated version control and local file history, and much more!</p> <p>The SoarIDE provides:</p> <ul> <li>Syntax Highlighting</li> <li>Error and Warning Marking</li> <li>Content Assist and Code Completion</li> <li>Code Expansion Templates</li> <li>Hover Help</li> <li>Hyperlinking</li> <li>An interactive Soar datamap of working memory</li> <li>Dynamic Tcl code expansion</li> </ul>"},{"location":"downloads/agent_development_tools/soaride/#download-links","title":"Download Links","text":"<p>The SoarIDE is downloadable via this page.</p>"},{"location":"downloads/agent_development_tools/soaride/#documentation","title":"Documentation","text":"<p>Avaliable at download link.</p>"},{"location":"downloads/agent_development_tools/soaride/#developer","title":"Developer","text":"<p>Soar Technology</p>"},{"location":"downloads/agent_development_tools/soaride/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/agent_development_tools/soarunit/","title":"SoarUnit","text":"<p>SoarUnit is a framework for unit testing Soar code introduced in JSoar 0.10.1. It is implemented as part of JSoar, but it supports running code in either JSoar or CSoar 9.3.1. When run, SoarUnit scans a given directory for test cases (see below) and runs all of the tests that are found. It then reports the test results, either in a text format, or through a user interface similar to the JUnit view in Eclipse.</p>"},{"location":"downloads/agent_development_tools/soarunit/#download-links","title":"Download Links","text":"<p>SoarUnit is downloadable via this page.</p>"},{"location":"downloads/agent_development_tools/soarunit/#documentation","title":"Documentation","text":"<p>Extensive documentation is available on the download page.</p>"},{"location":"downloads/agent_development_tools/soarunit/#developer","title":"Developer","text":"<p>Dave Ray</p>"},{"location":"downloads/agent_development_tools/soarunit/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/agent_development_tools/state2dot/","title":"State2Dot","text":"<p>A command-line Python script to convert printed states (e.g. the output of <code>print -d 100 s1</code>) to a GraphViz DOT file. You can then use that DOT file with GraphViz to produce a graph that can help you visualize the working memory elements that compose the state.</p>"},{"location":"downloads/agent_development_tools/state2dot/#download-links","title":"Download Links","text":"<ul> <li>State2Dot.zip</li> </ul>"},{"location":"downloads/agent_development_tools/state2dot/#documentation","title":"Documentation","text":"<p>None</p>"},{"location":"downloads/agent_development_tools/state2dot/#developers","title":"Developers","text":"<p>Justin Li</p>"},{"location":"downloads/agent_development_tools/state2dot/#soar-versions","title":"Soar Versions","text":"<p>Any</p>"},{"location":"downloads/agent_development_tools/state2dot/#language","title":"Language","text":"<p>Python</p>"},{"location":"downloads/agent_development_tools/ultraedit_syntax_coloring_wordfile/","title":"UltraEdit Syntax Coloring Wordfile","text":"<p>This file allows you to edit Soar files in the cross-platform editor UltraEdit more easily. This file provides the following functionality:</p> <ul> <li>Automatic indentation</li> <li>Syntax coloring</li> <li>Mass commenting (select a block of text and un/comment them all in one step)</li> <li>Function lists (a list of all productions in a file will appear in the function list. Click on a function to immediately scroll to it.)</li> <li>Code folding (click on the plus sign next to a production and it will hide all of its contents except the first line)</li> </ul>"},{"location":"downloads/agent_development_tools/ultraedit_syntax_coloring_wordfile/#download-links","title":"Download Links","text":"<ul> <li>UltraEdit_Soar_Formatting_Wordfile.zip</li> </ul>"},{"location":"downloads/agent_development_tools/ultraedit_syntax_coloring_wordfile/#documentation","title":"Documentation","text":"<ul> <li>Version 15.00 and later: Download and save it into your \"wordfile\" directory which by default is <code>%appdata%\\IDMComp\\UltraEdit\\wordfiles</code>, unless you have specified a different directory. Further help and documentation is available here.</li> <li>Version 14.20 and previous: Visit this page for instructions.</li> </ul>"},{"location":"downloads/agent_development_tools/ultraedit_syntax_coloring_wordfile/#developers","title":"Developers","text":"<p>Mazin Assanie</p>"},{"location":"downloads/agent_development_tools/vim_soar_plug-in/","title":"Vim Soar Plug-In","text":"<p>This package allows you to edit your Soar files in vim more easily by providing the following capabilities:</p> <ul> <li>Syntax highlighting</li> <li>Auto-indenting</li> <li>Moving around by productions</li> <li>Toggling comment/uncomment productions</li> <li>Code folding (You can fold a production into a single line)</li> <li>Taglist support</li> </ul>"},{"location":"downloads/agent_development_tools/vim_soar_plug-in/#download-links","title":"Download Links","text":"<ul> <li>Vim_Soar_Formatting_Plugin.zip</li> </ul>"},{"location":"downloads/agent_development_tools/vim_soar_plug-in/#usage-instructions","title":"Usage Instructions","text":"<p>Download the archive and expand it into <code>$HOME/.vim</code> (<code>C:\\Documents and Settings\\user\\vimfiles</code> in Windows). You should have the following files:</p> File Description ftplugin/soar.vim main configuration file ftdetect/soar.vim makes vim recognize .soar files as filetype \"soar\" indent/soar.vim auto-indentation configuration syntax/soar.vim syntax highlighting configuration <p>Next, add the following lines to your <code>.vimrc</code> ( <code>_vimrc</code> on Windows):</p> <pre><code> filetype on            \" enable filetype detection\n filetype plugin on     \" run ftplugin/soar.vim for .soar files\n filetype indent on     \" enable custom indentation\n syntax on              \" enable syntax highlighting\n</code></pre> <p>Note that if you're using terminal vim in *nix, you may also need to enable colors with</p> <pre><code>set t_Co=256\n</code></pre> <p>Now any file you open with the <code>.soar</code> extension should be highlighted and auto-indented. You should also be able to fold and unfold single productions using the standard <code>zc</code> and <code>zo</code> commands (see <code>:help folding</code>). Furthermore, there are some convenient keyboard shortcuts defined:</p> <p>In normal mode:</p> Command Description Alt-k Move to the previous production Alt-j Move to the next production Alt-c Toggle commenting out the production Alt-a Create an application rule for the proposal rule the cursor is in <p>In insert mode, right after you finish typing a condition or action that ends with a variable, you can \"chain\" the variable into the next condition by pressing Alt-e. For example, if your cursor is at the location of the <code>X</code> here:</p> <pre><code>sp {test\n    (state &lt;s&gt; ^superstate &lt;ss&gt;)X\n</code></pre> <p>and you press Alt-e while in insert mode, the text will become:</p> <pre><code>sp {test\n    (state &lt;s&gt; ^superstate &lt;ss&gt;)\n    (&lt;ss&gt; ^X\n</code></pre> <p>and your cursor will have moved to the location of the <code>X</code>, ready for typing the attribute test.</p>"},{"location":"downloads/agent_development_tools/vim_soar_plug-in/#tag-lists","title":"Tag Lists","text":"<p>The taglist plugin for vim allows you to open a window that lists all the tags generated by the ctags program for files you're editing. With very little work it can be made to list productions in agent files. You can then jump to any production, even across different files, by navigating this list. This is quite useful when your productions are distributed across many files, for example if you created them with Visual Soar.</p> <ol> <li>Install Exuberant ctags from http://ctags.sourceforge.net or your Linux package manager.</li> <li>Install the taglist plugin from here.</li> <li>To get ctags to recognize Soar source code, add these lines into your <code>$HOME/.ctags</code> file (or <code>C:\\Documents and Settings\\user\\ctags.cnf</code> in Windows):</li> </ol> <pre><code>--langdef=soar\n --langmap=soar:.soar\n --regex-soar=/^[ \\t]*[gs]p[ \\t]*\\{[ \\t]*([-a-zA-Z0-9_\\*\\|]*)/\\1/p,production/\n</code></pre> <p>Note: Depending on your version of ctags, you may have to replace the escaped brace <code>\\{</code> with a regular brace. ctags should complain loudly about an unmatched brace if the syntax is wrong.</p> <p>Now when you're editing a <code>.soar</code> file, you should be able to run the command <code>:TlistOpen</code> and get a list of all the productions in the current file. You can also use <code>:TlistAddFiles *.soar</code> to add all files in the directory.</p>"},{"location":"downloads/agent_development_tools/vim_soar_plug-in/#developer","title":"Developer","text":"<p>Joseph Xu</p>"},{"location":"downloads/agent_development_tools/visualsoar/","title":"VisualSoar","text":"<p>VisualSoar is a development environment written in Java to aid in the creation of agents for use in Soar. It provides syntax coloring, auto-indenting, data map construction and generation, attribute/value completion (using the data map) and agent file structure management.</p>"},{"location":"downloads/agent_development_tools/visualsoar/#download-links","title":"Download Links","text":"<ul> <li>VisualSoar and a manual for it are included with the SoarSuite release. There is a batch or script file at the top level of the SoarSuite folder that will launch it VisualSoar.</li> <li>VisualSoar Source Code</li> </ul>"},{"location":"downloads/agent_development_tools/visualsoar/#documentation","title":"Documentation","text":"<p>In addition to the manual included with the SoarSuite release, the keyboard and mouse controls are documented here.</p>"},{"location":"downloads/agent_development_tools/visualsoar/#developers","title":"Developers","text":"<ul> <li>Jon Bauman</li> <li>Brad Jones</li> <li>Brian Harelton</li> <li>Andrew Nuxoll</li> <li>Douglas Pearson</li> </ul>"},{"location":"downloads/agent_development_tools/visualsoar/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/","title":"SublimeText Soar Tools Package","text":"<p>This extension allows the cross-platform editor SublimeText (http://www.sublimetext.com/) to provide Soar-specific functionality. This package provides the following:</p> <ul> <li>Automatic indentation</li> <li>Syntax coloring</li> <li>Code folding</li> <li>Production snippets that help you code faster</li> <li>The ability to run the Soar CLI from SublimeText if you have the SublimeREPL package installed</li> </ul>"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#download-links","title":"Download Links","text":"<ul> <li>SublimeText Soar Tools home page</li> <li>Soar Tools package control page</li> </ul>"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#documentation","title":"Documentation","text":""},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#installation","title":"Installation","text":"<p>After installing Package Control, use the Command Palette (Ctrl+Shift+P) to select Install Package and then search for \"Soar Tools\".</p>"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#current-functionality","title":"Current Functionality","text":""},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#syntax-highlighting","title":"Syntax Highlighting","text":"<p>Files with the <code>.soar</code> extension are assumed to be Soar files and are highlighted accordingly. Code folding is also provided but is irregular at the moment. The plugin highlights both Soar productions and other curly-braced sections, like <code>smem --add</code> commands:</p> Syntax highlighting"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#snippets","title":"Snippets","text":"<p>Production snippets help you code faster:</p> Production snippets <p>and SoarDoc snippets help you document faster:</p> SoarDoc snippets"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#soarunit-build-command","title":"SoarUnit Build Command","text":"<p>You can run SoarUnit on a single file or on an entire project as a build command (CTRL+B). See project Readme for setup details.</p>"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#soar-repl-integration","title":"Soar REPL Integration","text":"<p>You can run the Soar CLI from SublimeText if you have the SublimeREPL package installed (see the project Readme for setup details). Highlighting included!</p> Soar REPL"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#contributions-welcome","title":"Contributions Welcome","text":"<p>Suggestions or questions, patches and PR's are welcome. Speak your mind on the issues page!</p>"},{"location":"downloads/agent_development_tools/sublimetext_soar_tools_package/#developer","title":"Developer","text":"<p>Nathan Glenn</p>"},{"location":"downloads/agents/","title":"Downloads: Agents","text":"<p>In this category, you'll find a variety of agents developed for a wide range of different tasks and environments. You will find a full description of the agent, its capabilities and problem solving approach as well, as a download link. If the agent requires an environment, a link will be provided. We'd highly encourage you to submit your own agents for use by the greater Soar community. To do so, you can send your zipped up submission with a full description (try to include all of the type of information we include on each download page) to John Laird with the subject \"Soar Agent Submission\".</p> <ul> <li>15-Puzzle Agent</li> <li>8-Puzzle</li> <li>Algebra Solver</li> <li>Arithmetic</li> <li>Arithmetic (with Semantic Memory)</li> <li>Blocks-World (Hierarchical Look-Ahead)</li> <li>Blocks-World (Hierarchical)</li> <li>Blocks-World (Look-Ahead with RL)</li> <li>Blocks-World (Look-Ahead)</li> <li>Blocks-World (Reinforcement Learning)</li> <li>Blocks-World (Simple)</li> <li>Blocks-World (Subgoaling with RL)</li> <li>Blocks-World (Subgoaling)</li> <li>Counting Agent</li> <li>Eaters (Advanced Move)</li> <li>Eaters (Hello World Operator)</li> <li>Eaters (Hello World Rule)</li> <li>Eaters (Jump and Move)</li> <li>Eaters (Jump)</li> <li>Eaters (Move North 2)</li> <li>Eaters (Move North)</li> <li>Eaters (Move To Food)</li> <li>Eaters (Move)</li> <li>Eaters (Semantic Error Example)</li> <li>Eaters (Syntax Error Example)</li> <li>Episodic Memory Counting Agent</li> <li>Episodic Memory Tutorial Agent</li> <li>Graph Search</li> <li>Graph Search (with Semantic Memory)</li> <li>Infinite Mario RL</li> <li>Knowledge Base Agent</li> <li>Left-Right Reinforcement Learning Agent</li> <li>Missionaries and Cannibals (Planning)</li> <li>Missionaries and Cannibals (Simple)</li> <li>Reinforcement Learning Unit Test</li> <li>Semantic Memory Tutorial Agent</li> <li>Soar 7 Agents</li> <li>TankSoar (Mapping)</li> <li>TankSoar (Obscure Bot)</li> <li>TankSoar (Simple Sound)</li> <li>TankSoar (Simple)</li> <li>TankSoar (Wander)</li> <li>Taxi (Hierarchical Reinforcement Learning)</li> <li>Taxi (Reinforcement Learning)</li> <li>TextIO Example</li> <li>Tower of Hanoi (Recursive)</li> <li>Tower of Hanoi (Simple)</li> <li>Water Jug (Hierarchical Task Decomposition)</li> <li>Water Jug (Look-Ahead with State Evaluation)</li> <li>Water Jug (Look-Ahead)</li> <li>Water Jug (Reinforcement Learning)</li> <li>Water Jug (Simple)</li> </ul>"},{"location":"downloads/agents/15-puzzle/","title":"15-Puzzle Agent","text":"<p>This agent is a straightforward implementation of the fifteen-puzzle. It uses look-ahead search to solve the puzzle with a simple evaluation function. This agent also demonstrates chunking.</p> <p>The puzzle consists of fifteen sliding tiles, numbered by digits from 1 to 15 arranged in a 4 by 4 array of sixteen cells. One of the cells is always empty, and any adjacent tile can be moved into the empty cell. The initial state is some arbitrary arrangement of the tiles. The goal state is the arrangement of tiles such that they are ordered from lowest to highest value. The problem is to find a sequence of moves from the initial state to the goal state.</p>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Look-ahead subgoaling</li> <li>Chunking</li> </ul>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#download-links","title":"Download Links","text":"<ul> <li>Fifteen_Puzzle_Agent.zip</li> </ul>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#external-environment","title":"External Environment","text":"<p>None.</p>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#default-rules","title":"Default Rules","text":"<p>selection.soar</p>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#associated-publications","title":"Associated Publications","text":"<p>None</p>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#developer","title":"Developer","text":"<p>John Laird</p>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/15-puzzle/#project-type","title":"Project Type","text":"<p>VisualSoar</p>","tags":["chunking","look-ahead search"]},{"location":"downloads/agents/8-puzzle/","title":"8-Puzzle","text":"<p>This agent is a straightforward implementation of an eight-puzzle. It uses look-ahead search to solve the puzzle with a simple evaluation function. This agent also demonstrates chunking.</p> <p>The puzzle consists of eight sliding tiles, numbered by digits from 1 to 8 arranged in a 3 by 3 array of nine cells. One of the cells is always empty, and any adjacent tile can be moved into the empty cell. The initial state is some arbitrary arrangement of the tiles. The goal state is the arrangement of tiles such that they are ordered from lowest to highest value. The problem is to find a sequence of moves from the initial state to the goal state.</p>"},{"location":"downloads/agents/8-puzzle/#external-environment","title":"External Environment","text":"<p>None</p>"},{"location":"downloads/agents/8-puzzle/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Look-ahead subgoaling</li> <li>Chunking</li> </ul>"},{"location":"downloads/agents/8-puzzle/#download-links","title":"Download Links","text":"<ul> <li>Eight_Puzzle_Agent.zip</li> </ul>"},{"location":"downloads/agents/8-puzzle/#default-rules","title":"Default Rules","text":"<ul> <li>selection.soar</li> </ul>"},{"location":"downloads/agents/8-puzzle/#associated-publications","title":"Associated Publications","text":"<p>None</p>"},{"location":"downloads/agents/8-puzzle/#developer","title":"Developer","text":"<p>John Laird</p>"},{"location":"downloads/agents/8-puzzle/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/8-puzzle/#project-type","title":"Project Type","text":"<p>VisualSoar</p>"},{"location":"downloads/agents/algebra_solver/","title":"Algebra Solver","text":"<p>This is an agent that can solve simple algebra problems with one variable. It parses raw text input from Soar Text I/O into a tree structure, solves the problem in that representation and then prints out the answer.</p>"},{"location":"downloads/agents/algebra_solver/#external-environment","title":"External Environment","text":"<p>Soar TextIO</p>"},{"location":"downloads/agents/algebra_solver/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Hierarchical task decomposition</li> <li>Chunking</li> </ul>"},{"location":"downloads/agents/algebra_solver/#download-links","title":"Download Links","text":"<ul> <li>Algebra_Agent.zip</li> </ul>"},{"location":"downloads/agents/algebra_solver/#default-rules","title":"Default Rules","text":"<p>None</p>"},{"location":"downloads/agents/algebra_solver/#associated-publications","title":"Associated Publications","text":"<p>None</p>"},{"location":"downloads/agents/algebra_solver/#developer","title":"Developer","text":"<p>John Laird</p>"},{"location":"downloads/agents/algebra_solver/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/algebra_solver/#project-type","title":"Project Type","text":"<p>VisualSoar</p>"},{"location":"downloads/agents/arithmetic/","title":"Arithmetic","text":"<p>An agent that performs multi-column addition and subtraction with borrowing and carrying, all the way down to counting. No math functions are used.</p> <p>This program supports arithmetic ands subtraction between two multi-digit numbers. It formulates the problem in multiple columns. It does not use any math functions. As currently formulated, it uses a table of all single digit addition facts (for addition and one subtraction strategy) and tables of simple subtraction facts and addition by ten to single digits (for a second subtraction strategy). These facts can be converted to a semantic memory access (in the application of compute-result).</p> <p>Each primitive operator is relatively simple: without complex proposal conditions, control rules, lots of control flags or complex conditional operator applications. The actual execution trace is sometimes a bit tricky, especially for subtraction.</p> <p>The project supports the automatic generation of random 3 column addition and subtraction problems which are created in generate-problem. The project will execute N of these (set as the value of <code>^count</code> in <code>initialize-arithmetic</code>).</p> <p>The project checks that all answers are computed correctly by using Soar's math functions (computed in elaborations/Verify and finish-problem) if an incorrect answer is computed, it is printed out and Soar halts</p> <p>The two subtraction strategies differ in what initial facts they assume. One of the subtraction strategies assumes the same knowledge as addition (the sum of two single digit numbers and the resulting carry), but involves remapping that knowledge so that it is appropriate for subtraction. For example it knows that if 7 is subtracted from 6 that the answer is 9 and there must be a borrow from the column to the left.</p> <p>The second subtraction strategy assumes that the system knows how to subtract any single digit (0-9) from the numbers 0-18, and that it has facts to add ten to any single digit (0-9).</p> <p>The actual trace of a strategy arises from the available operator applications and impasses that arise. For example, in the second strategy, if a larger number is being subtracted from a smaller number, there is an operator no-change impasse because no fact is available for that situation. This is the standard american approach to subtraction. The key rules for this are in process-column/compute-result.soar</p> <p>The only differences between the two strategies are the available facts and a single rule in process-column that applies the process-column operator by accessing the facts (<code>process-column*apply*compute-result*subtraction</code>). There are rules that only are used by the second strategy (in the compute-result substate), but there is no explicit control to invoke them and they do not have to be disabled during addition or the other subtraction strategy.</p> <p>Works with chunking (<code>learn --on</code>).</p>"},{"location":"downloads/agents/arithmetic/#external-environment","title":"External Environment","text":"<p>None</p>"},{"location":"downloads/agents/arithmetic/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Hierarchical task decomposition</li> <li>Chunking</li> <li>Doing math with just symbol manipulation</li> </ul>"},{"location":"downloads/agents/arithmetic/#download-links","title":"Download Links","text":"<ul> <li>Arithmetic_Agent.zip</li> </ul>"},{"location":"downloads/agents/arithmetic/#default-rules","title":"Default Rules","text":"<p>None</p>"},{"location":"downloads/agents/arithmetic/#associated-publications","title":"Associated Publications","text":"<p>None</p>"},{"location":"downloads/agents/arithmetic/#developers","title":"Developers","text":"<p>John Laird</p>"},{"location":"downloads/agents/arithmetic/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 9.2+</li> </ul>"},{"location":"downloads/agents/arithmetic/#project-type","title":"Project Type","text":"<p>VisualSoar</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/","title":"Arithmetic (with Semantic Memory)","text":"<p>This agent demonstrates the use of semantic memory by extending the capabilities of the Arithmetic Agent. The description of that agent also applies here.</p> <p>This agent supports using semantic memory through in three different ways controlled by parameters set in initialize-arithmetic.</p> <ol> <li> <p>If the semantic or working memory is pre-loaded with problems, it will use those problems. If not it will generate problems at random.</p> <ul> <li>problems-5000.soar and problems-10000.soar contain the rules to generate the working memory problems.</li> <li>problems-5000-smem.soar contains the structure to initialize semantic memory.</li> <li>Controlled by loading one of those files at run time and setting ^parameters.problems-source [wm smem]</li> </ul> </li> <li> <p>Control whether arithmetic facts are computed/stored in working memory or semantic memory. If in semantic memory, will dynamically generated using counting (process-column/compute-result/add-via-counting)</p> <ul> <li>Controlled by parameters.fact-source [wm smem]</li> <li>To experiment with impact of semantic memory, can control whether facts are stored in semantic memory (or will always be counted) via parameters.store [yes no] and whether they are attempted to be retrieved parameters.retrieve [yes no]</li> <li>Number of problems attempted is set by count, which is usually 5000 or 10000.</li> </ul> </li> </ol> <p>Note: This agent does not currently work with Soar 9.6.0+ due to changes in the semantic memory model.</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#external-environment","title":"External Environment","text":"<p>None</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Semantic Memory</li> <li>Hierarchical task decomposition</li> <li>Chunking</li> </ul>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#download-links","title":"Download Links","text":"<ul> <li>Arithmetic-SMem_Agent.zip</li> </ul>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#default-rules","title":"Default Rules","text":"<p>None</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#associated-publications","title":"Associated Publications","text":"<p>None</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#developers","title":"Developers","text":"<p>John Laird</p>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 9.2 - 9.4.0</li> </ul>"},{"location":"downloads/agents/arithmetic_%28with_semantic_memory%29/#project-type","title":"Project Type","text":"<p>VisualSoar</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/","title":"Blocks-World (Hierarchical)","text":"<p>This project contains a version of blocks world that is formulated for hierarchical task decomposition. It involves three levels of problem spaces. There is sufficient evaluation knowledge so that there is no search/uncertainty at every level. The top level has a single operator: move-block, which moves a block (moving-block) to a destination. The destination can be the top of another block or the table.</p> <p>The next level consists of two operators: pick-up and put-down and they arise in an operator no-change for move-block. The rules for these are found under move-block. This level introduces the gripper, which can be holding a block or empty and is a structure on the top state.</p> <p>The bottom level has a variety of operators: open-gripper, close-gripper, move-gripper-above, move-gripper-down, and move-gripper-up. The structures manipulated by these operators are part of the gripper structure on the top state. These operators arise in an operator no-change for both pick-up and put-down and the rules for them are under pick-up.</p> <p>Includes gripper status to state. Execution is done through top-state rules that simulate changes to the io-link</p> <p>Works with chunking, which compiles the actions in the substates into rules that apply at the top-state. Use the command \"learn -e\" to turn on chunking, run the agent once, init-soar then run the agent again to see how the learned productions eliminate the need to subgoal in the second run.</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Hierarchical task composition via subgoaling</li> <li>Internally simulates external environment including an i/o link</li> <li>Can learn procedural knowledge (enable with 'learn always')</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#download-links","title":"Download Links","text":"<ul> <li>BlocksWorld_Hierarchical_Agent.zip</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#default-rules","title":"Default Rules","text":"<ul> <li>simple.soar</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#associated-publications","title":"Associated Publications","text":"<p>The Soar Cognitive Architecture: Chapter 4</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#developers","title":"Developers","text":"<p>John Laird</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical%29/#project-type","title":"Project Type","text":"<p>VisualSoar</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/","title":"Blocks-World (Hierarchical Look-Ahead)","text":"<p>This project augments the Blocks-World Hierarchical Agent with look-ahead state evaluation. The description of the original agent applies to this one. The main difference is that look-ahead is performed in the middle of the three problem spaces that it uses.</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#external-environment","title":"External Environment","text":"<p>None</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#soar-capabilities","title":"Soar Capabilities","text":"<ul> <li>Hierarchical task composition via subgoaling</li> <li>Look-ahead subgoaling</li> <li>Internally simulates external environment including an i/o link</li> <li>Can learn procedural knowledge (enable with <code>learn always</code>)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#download-links","title":"Download Links","text":"<ul> <li>BlocksWorld_Hierarchical_Lookahead_Agent.zip</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#default-rules","title":"Default Rules","text":"<ul> <li>simple.soar</li> <li>selection.soar</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#associated-publications","title":"Associated Publications","text":"<p>The Soar Cognitive Architecture: Chapter 4</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#developers","title":"Developers","text":"<p>John Laird</p>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28hierarchical_look-ahead%29/#project-type","title":"Project Type","text":"<p>VisualSoar</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/","title":"Blocks-World (Look-Ahead)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/","title":"Blocks-World (Look-Ahead with RL)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28look-ahead_with_rl%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/","title":"Blocks-World (Reinforcement Learning)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28reinforcement_learning%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/","title":"Blocks-World (Simple)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28simple%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28simple%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28simple%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28simple%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28simple%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/","title":"Blocks-World (Subgoaling)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/","title":"Blocks-World (Subgoaling with RL)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/blocks-world_%28subgoaling_with_rl%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/counting_agent/","title":"Counting Agent","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/counting_agent/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/counting_agent/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/counting_agent/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/counting_agent/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/counting_agent/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/counting_agent/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/counting_agent/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/counting_agent/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/counting_agent/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/counting_agent/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/counting_agent/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/","title":"Eaters (Advanced Move)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28advanced_move%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/","title":"Eaters (Hello World Operator)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_operator%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/","title":"Eaters (Hello World Rule)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28hello_world_rule%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28jump%29/","title":"Eaters (Jump)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28jump%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28jump%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28jump%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28jump%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28jump%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28jump%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28jump%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28jump%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28jump%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28jump%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28jump%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/","title":"Eaters (Jump and Move)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28jump_and_move%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move%29/","title":"Eaters (Move)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28move%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28move%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28move%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28move%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_north%29/","title":"Eaters (Move North)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_north%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/","title":"Eaters (Move North 2)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28move_north_2%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/","title":"Eaters (Move To Food)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28move_to_food%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/","title":"Eaters (Semantic Error Example)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28semantic_error_example%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/","title":"Eaters (Syntax Error Example)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/eaters_%28syntax_error_example%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/","title":"Episodic Memory Counting Agent","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/episodic_memory_counting_agent/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/episodic_memory_counting_agent/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/episodic_memory_counting_agent/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/episodic_memory_counting_agent/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/episodic_memory_counting_agent/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/","title":"Episodic Memory Tutorial Agent","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/episodic_memory_tutorial_agent/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/graph_search/","title":"Graph Search","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/graph_search/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/graph_search/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/graph_search/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/graph_search/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/graph_search/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/graph_search/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/graph_search/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/graph_search/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/graph_search/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/graph_search/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/graph_search/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/","title":"Graph Search (with Semantic Memory)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/graph_search_%28with_semantic_memory%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/infinite_mario_rl/","title":"Infinite Mario RL","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/infinite_mario_rl/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/infinite_mario_rl/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/infinite_mario_rl/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/infinite_mario_rl/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/infinite_mario_rl/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/infinite_mario_rl/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/infinite_mario_rl/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/infinite_mario_rl/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/infinite_mario_rl/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/infinite_mario_rl/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/infinite_mario_rl/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/knowledge_base_agent/","title":"Knowledge Base Agent","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/knowledge_base_agent/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/knowledge_base_agent/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/knowledge_base_agent/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/knowledge_base_agent/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/knowledge_base_agent/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/knowledge_base_agent/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/knowledge_base_agent/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/knowledge_base_agent/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/knowledge_base_agent/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/knowledge_base_agent/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/knowledge_base_agent/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/","title":"Left-Right Reinforcement Learning Agent","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/left-right_reinforcement_learning_agent/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/","title":"Missionaries and Cannibals (Planning)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28planning%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/","title":"Missionaries and Cannibals (Simple)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/missionaries_and_cannibals_%28simple%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/","title":"Reinforcement Learning Unit Test","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/reinforcement_learning_unit_test/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/","title":"Semantic Memory Tutorial Agent","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/semantic_memory_tutorial_agent/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/soar_7_agents/","title":"Soar 7 Agents","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/soar_7_agents/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/soar_7_agents/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/soar_7_agents/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/soar_7_agents/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/soar_7_agents/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/soar_7_agents/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/soar_7_agents/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/soar_7_agents/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/soar_7_agents/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/soar_7_agents/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/soar_7_agents/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/","title":"TankSoar (Mapping)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tanksoar_%28mapping%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/","title":"TankSoar (Obscure Bot)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tanksoar_%28obscure_bot%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/","title":"TankSoar (Simple)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28simple%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/","title":"TankSoar (Simple Sound)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tanksoar_%28simple_sound%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/","title":"TankSoar (Wander)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tanksoar_%28wander%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28wander%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tanksoar_%28wander%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tanksoar_%28wander%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tanksoar_%28wander%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/","title":"Taxi (Hierarchical Reinforcement Learning)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/taxi_%28hierarchical_reinforcement_learning%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/","title":"Taxi (Reinforcement Learning)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/taxi_%28reinforcement_learning%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/textio_example/","title":"TextIO Example","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/textio_example/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/textio_example/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/textio_example/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/textio_example/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/textio_example/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/textio_example/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/textio_example/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/textio_example/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/textio_example/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/textio_example/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/textio_example/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/","title":"Tower of Hanoi (Recursive)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28recursive%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/","title":"Tower of Hanoi (Simple)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/tower_of_hanoi_%28simple%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/","title":"Water Jug (Hierarchical Task Decomposition)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/water_jug_%28hierarchical_task_decomposition%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/","title":"Water Jug (Look-Ahead)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/","title":"Water Jug (Look-Ahead with State Evaluation)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/water_jug_%28look-ahead_with_state_evaluation%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/","title":"Water Jug (Reinforcement Learning)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/water_jug_%28reinforcement_learning%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28simple%29/","title":"Water Jug (Simple)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/agents</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/agents/water_jug_%28simple%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28simple%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/agents/water_jug_%28simple%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/agents/water_jug_%28simple%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/agents/water_jug_%28simple%29/#project-type","title":"Project Type","text":"<p>VisualSoar TODO (agents only)</p>"},{"location":"downloads/domains/","title":"Downloads: Domains","text":"<p>This category contains an extensive list of domains you can develop agents in. Some are game-like environment simulators while other provide access to an external knowledge source for your agent to process and manipulate, for example WordNet or SoarQnA. All of these domains are fully interfaced with Soar already.</p> <ul> <li>Dice</li> <li>Eaters</li> <li>General Game Player Translator</li> <li>Infinite Mario RL</li> <li>PDDL Translator</li> <li>RoomsWorld</li> <li>Soar QnA</li> <li>SoarText-IO</li> <li>TankSoar</li> <li>Taxi</li> <li>WordNet WSD</li> <li>WordNet WSD (with Parse Trees)</li> <li>Eaters</li> <li>General Game Player Translator</li> <li>Infinite Mario RL</li> <li>PDDL Translator</li> <li>RoomsWorld</li> <li>Soar QnA</li> <li>SoarText-IO</li> <li>TankSoar</li> <li>Taxi</li> <li>WordNet WSD</li> <li>WordNet WSD (with Parse Trees)</li> </ul>"},{"location":"downloads/domains/dice/","title":"Dice","text":"<p>Dice is a java implementation of a game often called Liar's Dice.</p> <p>Here is an abbreviated description of the rules used in our implementation of this domain:</p> <ul> <li>Each player gets five six-sided dice and a cup to conceal their dice from other players.</li> <li>To begin each round, all players roll their dice under their cups and look at their new 'hand' while keeping it concealed from the other players. The first player begins bidding, picking a quantity of a face number. The quantity states the player's opinion on how many of the chosen face have been rolled in total on the table.</li> <li>Each player has two choices during his turn: make a higher bid, or challenge the previous bid as being wrong. Raising the bid means either increasing the quantity, or the face value, or both, according to the specific bidding rules used.</li> <li>The 1s (\"aces\") are wild and count as two in a bid, for example to outbid a bid of 2 one's, you must bid at least 5 of a non-wild face.</li> <li>If the current player thinks the previous player's bid is wrong, he challenges it, and then all dice are revealed to determine whether the bid was valid. If the number of the relevant face revealed is at least as high as the bid, then the bid is valid, in which case the bidder wins. Otherwise, the challenger wins.</li> </ul> <p>* Description of game rules derived from its Wikipedia page and is released under the Creative Commons license.</p>"},{"location":"downloads/domains/dice/#environment-properties","title":"Environment Properties","text":"<ul> <li>Uncertainty</li> <li>incomplete knowledge</li> <li>multi-player</li> </ul>"},{"location":"downloads/domains/dice/#download-links","title":"Download Links","text":"<p>Dice.zip</p>"},{"location":"downloads/domains/dice/#associated-agents","title":"Associated Agents","text":"<p>A variety of agents is included in the environment download.</p>"},{"location":"downloads/domains/dice/#documentation","title":"Documentation","text":"<ul> <li> <p>Requires these jars on the classpath:</p> <ul> <li>sml.jar</li> <li>soar-qna-9.3.1.jar</li> <li>soar-smljava-9.3.1.jar</li> </ul> </li> <li> <p>Also needs the environment variables <code>SOAR_HOME</code> set and <code>LD_LIBRARY_PATH</code> on Linux (<code>DYLD_LIBRARY_PATH</code> on OSX, <code>PATH</code> on Windows) set to <code>$SOAR_HOME/lib</code>.</p> </li> <li> <p>To import into Eclipse, go to File &gt; New &gt; Java Project, un-check \"Use Default Location\" and under \"Location\" select the root directory of the project. All other default settings should be fine.</p> </li> <li> <p>To run, right-click on the SoarMatch?.java file and select Run As &gt; Java Application.</p> </li> </ul>"},{"location":"downloads/domains/dice/#io-link-specification","title":"IO link Specification","text":""},{"location":"downloads/domains/dice/#code","title":"Code","text":"<pre><code>input-link\n        dice-probability\n                id (any) copied from request\n                probability (float) (0..1)\n\noutput-link\n        compute-dice-probability\n                id (any) user-data to be copied to input-link to correlate result\n                number-of-dice (int) (1..)\n                number-of-faces (int) (1..) usually 3 (normal, ones wild) or 6 (ones or special rules)\n                count (int) (1..number-of-dice) Target number\n                predicate (string) (eq ne ge gt le lt)\n\nPredicate shorthand:\n        eq: equal ==\n        ne: not equal !=\n        ge: greater than or equal &gt;=\n        gt: greater than &gt;\n        le: less than or equal &lt;=\n        lt: less than &lt;\n</code></pre>"},{"location":"downloads/domains/dice/#examples","title":"Examples","text":"<pre><code>id: 1, number-of-dice: 3, number-of-faces: 6, count: 2, predicate: eq\nyields: id: 1, probability: 0.06944\n\nid: 2.0, number-of-dice: 5, number-of-faces: 3, count: 3, predicate: ge\nyields: id: 2.0, probability: 0.20988\n\nid: charlie, number-of-dice: 24, number-of-faces: 6, count: 6, predicate lt\nyields: id: charlie, probability: 0.80047\n\nQuick test using add-wme on empty agent:\naw i3 compute-dice-probability *\naw i4 id 1\naw i4 number-of-dice 5\naw i4 number-of-faces 3\naw i4 count 3\naw i4 predicate ge\n</code></pre>"},{"location":"downloads/domains/dice/#associated-publications","title":"Associated Publications","text":"<p>Pending</p>"},{"location":"downloads/domains/dice/#developer","title":"Developer","text":"<p>Miller Tinkerhess</p>"},{"location":"downloads/domains/dice/#soar-versions","title":"Soar Versions","text":"<p>Soar 9</p>"},{"location":"downloads/domains/dice/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/domains/eaters/","title":"Eaters","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/eaters/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/eaters/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/eaters/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/eaters/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/eaters/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/eaters/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/eaters/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/eaters/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/eaters/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/eaters/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/eaters/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/general_game_player_translator/","title":"General Game Player Translator","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/general_game_player_translator/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/general_game_player_translator/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/general_game_player_translator/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/general_game_player_translator/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/general_game_player_translator/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/general_game_player_translator/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/general_game_player_translator/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/general_game_player_translator/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/general_game_player_translator/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/general_game_player_translator/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/general_game_player_translator/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/infinite_mario_rl/","title":"Infinite Mario RL","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/infinite_mario_rl/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/infinite_mario_rl/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/infinite_mario_rl/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/infinite_mario_rl/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/infinite_mario_rl/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/infinite_mario_rl/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/infinite_mario_rl/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/infinite_mario_rl/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/infinite_mario_rl/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/infinite_mario_rl/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/infinite_mario_rl/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/pddl_translator/","title":"PDDL Translator","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/pddl_translator/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/pddl_translator/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/pddl_translator/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/pddl_translator/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/pddl_translator/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/pddl_translator/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/pddl_translator/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/pddl_translator/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/pddl_translator/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/pddl_translator/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/pddl_translator/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/roomsworld/","title":"RoomsWorld","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/roomsworld/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/roomsworld/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/roomsworld/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/roomsworld/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/roomsworld/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/roomsworld/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/roomsworld/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/roomsworld/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/roomsworld/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/roomsworld/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/roomsworld/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/soar_qna/","title":"Soar QnA","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/soar_qna/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/soar_qna/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/soar_qna/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/soar_qna/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/soar_qna/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/soar_qna/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/soar_qna/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/soar_qna/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/soar_qna/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/soar_qna/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/soar_qna/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/soartext-io/","title":"SoarText-IO","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/soartext-io/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/soartext-io/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/soartext-io/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/soartext-io/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/soartext-io/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/soartext-io/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/soartext-io/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/soartext-io/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/soartext-io/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/soartext-io/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/soartext-io/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/tanksoar/","title":"TankSoar","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/tanksoar/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/tanksoar/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/tanksoar/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/tanksoar/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/tanksoar/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/tanksoar/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/tanksoar/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/tanksoar/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/tanksoar/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/tanksoar/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/tanksoar/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/taxi/","title":"Taxi","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/taxi/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/taxi/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/taxi/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/taxi/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/taxi/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/taxi/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/taxi/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/taxi/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/taxi/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/taxi/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/taxi/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/wordnet_wsd/","title":"WordNet WSD","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/wordnet_wsd/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/wordnet_wsd/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/wordnet_wsd/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/wordnet_wsd/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/wordnet_wsd/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/wordnet_wsd/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/wordnet_wsd/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/wordnet_wsd/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/wordnet_wsd/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/wordnet_wsd/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/wordnet_wsd/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/","title":"WordNet WSD (with Parse Trees)","text":"<p>TODO: This page has not yet been migrated. You can view the original here: https://web.archive.org/web/20230324021432/https://soar.eecs.umich.edu/articles/downloads/domains</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#download-links","title":"Download Links","text":"<ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#associated-agents","title":"Associated Agents","text":"<p>None TODO (not for agents)</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#default-rules","title":"Default Rules","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#documentation","title":"Documentation","text":"<p>TODO</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#associated-publications","title":"Associated Publications","text":"<p>None</p> <ul> <li>TODO</li> </ul>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#developers","title":"Developers","text":"<p>TODO</p>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#soar-versions","title":"Soar Versions","text":"<p>TODO</p> <ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/domains/wordnet_wsd_%28with_parse_trees%29/#language","title":"Language","text":"<p>TODO (not for agents)</p>"},{"location":"downloads/examples_and_unsupported/","title":"Downloads: Examples and Unsupported","text":"<p>This category contains example code and wrapper functions to help you build your own environments in a variety of language, namely C++, PHP, Python, Java and C. This code is unsupported but may still work.</p> <ul> <li>C++ Command Line Filter Example</li> <li>Towers of Hanoi</li> <li>C++ Logger</li> <li>C# Interface Example</li> <li>Java Logger</li> <li>Missionaries and Cannibals</li> <li>PHP Interface Example</li> <li>Python Interface Example</li> <li>RL Command Line Interface</li> <li>Soar Obfuscator</li> <li>Soar on iOS</li> <li>Soar Scratch Pad</li> <li>Tcl Command Line Filter Example</li> <li>Tower of Hanoi SML Example</li> <li>Working Memory Activation Tracker</li> </ul>"},{"location":"downloads/examples_and_unsupported/c%2B%2B_logger/","title":"C++ Logger","text":"<p>This project contains an example of a C++ program that interfaces with Soar.</p> <p>This application shows an example of how to build a simple logging tool. To use it you would run a Soar kernel somewhere (in an environment or inside the debugger for example) and then run this logger. The logger listens for certain events and then creates a log file.</p> <p>The idea is that you could take this simple app and modify it to log what you need for your specific application, outputting the data in whatever format you want.</p>"},{"location":"downloads/examples_and_unsupported/c%2B%2B_logger/#download-links","title":"Download Links","text":"<ul> <li>LoggerWinC_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/c%2B%2B_logger/#documentation","title":"Documentation","text":"<p>None, but the code does have a good deal of comments.</p>"},{"location":"downloads/examples_and_unsupported/c%2B%2B_logger/#developers","title":"Developers","text":"<p>Douglas Pearson</p>"},{"location":"downloads/examples_and_unsupported/c%2B%2B_logger/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/c%2B%2B_logger/#language","title":"Language","text":"<p>C++</p>"},{"location":"downloads/examples_and_unsupported/cpp_command_line_filter_example/","title":"C++ Command Line Filter Example: FilterC","text":"<p>FilterC demonstrates how to write a client in C++ that intercepts commands to implement a simple command line.</p>","tags":["C++"]},{"location":"downloads/examples_and_unsupported/cpp_command_line_filter_example/#download-links","title":"Download Links","text":"<p>Soar_Filter_C_Example.zip</p>","tags":["C++"]},{"location":"downloads/examples_and_unsupported/cpp_command_line_filter_example/#documentation","title":"Documentation","text":"<p>While there is no explicit documentation, this example code is commented.</p>","tags":["C++"]},{"location":"downloads/examples_and_unsupported/cpp_command_line_filter_example/#developer","title":"Developer","text":"<p>Douglas Pearson</p>","tags":["C++"]},{"location":"downloads/examples_and_unsupported/cpp_command_line_filter_example/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>","tags":["C++"]},{"location":"downloads/examples_and_unsupported/cpp_command_line_filter_example/#language","title":"Language","text":"<p>C++</p>","tags":["C++"]},{"location":"downloads/examples_and_unsupported/csharp_interface_example/","title":"C# Interface Example","text":"<p>This project contains an example C# project that interfaces with Soar.</p>"},{"location":"downloads/examples_and_unsupported/csharp_interface_example/#download-links","title":"Download Links","text":"<ul> <li>CSharp_Interface_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/csharp_interface_example/#documentation","title":"Documentation","text":"<p>None, but the code is very heavily commented.</p>"},{"location":"downloads/examples_and_unsupported/csharp_interface_example/#developers","title":"Developers","text":"<p>Doug Pearson</p>"},{"location":"downloads/examples_and_unsupported/csharp_interface_example/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/csharp_interface_example/#language","title":"Language","text":"<p>C#</p>"},{"location":"downloads/examples_and_unsupported/java_logger/","title":"Java Logger","text":"<p>This project contains an example of a Java program that interfaces with Soar.</p> <p>This application shows an example of how to build a simple logging tool. To use it you would run a Soar kernel somewhere (in an environment or inside the debugger for example) and then run this logger. The logger listens for certain events and then creates a log file.</p> <p>The idea is that you could take this simple app and modify it to log what you need for your specific application, outputing the data in whatever format you want.</p>"},{"location":"downloads/examples_and_unsupported/java_logger/#download-links","title":"Download Links","text":"<ul> <li>LoggerJava_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/java_logger/#documentation","title":"Documentation","text":"<p>None, but the code does have a good deal of comments.</p>"},{"location":"downloads/examples_and_unsupported/java_logger/#developers","title":"Developers","text":"<p>Douglas Pearson</p>"},{"location":"downloads/examples_and_unsupported/java_logger/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/java_logger/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/","title":"Missionaries and Cannibals","text":"<p>The classic missionaries and cannibals puzzle implemented as an external, graphical environment using Java and interfaced with Soar via SML. To see how the agent performs the task, you must launch the Soar debugger and tell it to connect to a remote Soar agent.</p> <p>In the missionaries and cannibals problem, three missionaries and three cannibals must cross a river using a boat which can carry at most two people, under the constraint that, for both banks, if there are missionaries present on the bank, they cannot be outnumbered by cannibals (if they were, the cannibals would eat the missionaries.) The boat cannot cross the river by itself with no people on board.</p> <p>* Description of game rules derived from its Wikipedia page and is released under the Creative Commons license.</p>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#download-links","title":"Download Links","text":"<ul> <li>Java_Missionaries_and_Cannibals_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#associated-agents","title":"Associated Agents","text":"<ul> <li>There is one basic agent embedded within the environment that will automatically be sourced when you launch it.</li> </ul> <p>Note: You cannot run the many Missionary and Cannibals agents available in the Agents downloads section with this environment. Those ones are not designed to be run with this external environment.</p>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#documentation","title":"Documentation","text":"<p>While there is no explicit documentation, the Soar Debugger tutorial does have a section that explains how to hook up the debugger to this type of environment.</p>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#io-links-specification","title":"IO Links Specification","text":"<pre><code>(I2 ^left-bank L1 ^right-bank R4)\n  (L1 ^boat 1 ^cannibals 3 ^missionaries 3 ^other-bank R4)\n  (R4 ^boat 0 ^cannibals 0 ^missionaries 0 ^other-bank L1)\n\n(I3 ^move-boat M1)\n  (M1 ^boat 1 ^cannibals 2 ^from-bank L1)\n</code></pre>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#developers","title":"Developers","text":"<p>Taylor Lafrinere</p>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/missionaries_and_cannibals/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/examples_and_unsupported/php_interface_example/","title":"PHP Interface Example","text":"<p>This project contains an example PHP project that interfaces with Soar. It includes a sample agent that is a slight modification of the water-jug-rl demo agent included with Soar. The main difference is that the initialization application and the goal-detection elaboration rules condition upon server-side input-link structures to dynamically generate water-jug problem instances.</p>"},{"location":"downloads/examples_and_unsupported/php_interface_example/#download-links","title":"Download Links","text":"<ul> <li>PHP_Interface_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/php_interface_example/#documentation","title":"Documentation","text":"<p>For the PHP bindings to build correctly, SWIG Version 1.3.40 is required.</p> <p>For Soar to interact with PHP, there are a couple of required manual steps:</p> <ol> <li> <p>Open <code>php.ini</code> and set the <code>enable_dl = On</code></p> </li> <li> <p>Copy (or, preferably, create a symbolic link) of <code>libPHP_sml_ClientInterface?.so</code> (in lib) to the PHP <code>extension_dir</code> (sans the lib prefix). You can find this via <code>phpInfo()</code> (search for <code>extension_dir</code>) or <code>php-config --extension-dir</code>.</p> </li> </ol> <p>For Soar to work with Apache via PHP, there are a couple more required steps:</p> <ol> <li> <p>The module needs to be loaded by default. Open <code>php.ini</code> and add <code>extension=PHP_smlClientInterface.so</code> at the end of the list of extensions.</p> </li> <li> <p>The SML shared library (i.e. <code>libSoarKernelSML</code>) needs to be accessible to Apache. The easiest way to do this is to copy the library to system library path (i.e.  <code>/usr/local/lib</code> on Linux).</p> </li> </ol>"},{"location":"downloads/examples_and_unsupported/php_interface_example/#developers","title":"Developers","text":"<p>Nate Derbinsky</p>"},{"location":"downloads/examples_and_unsupported/php_interface_example/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/php_interface_example/#language","title":"Language","text":"<p>PHP</p>"},{"location":"downloads/examples_and_unsupported/python_interface_example/","title":"Python Interface Example","text":"<p>A Python library that contains wrappers for SML library calls that can be used for running Python domains and experiments.</p>"},{"location":"downloads/examples_and_unsupported/python_interface_example/#download-links","title":"Download Links","text":"<ul> <li>Python_Interface_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/python_interface_example/#documentation","title":"Documentation","text":"<p>None</p>"},{"location":"downloads/examples_and_unsupported/python_interface_example/#developers","title":"Developers","text":"<p>Justin Li</p>"},{"location":"downloads/examples_and_unsupported/python_interface_example/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/python_interface_example/#language","title":"Language","text":"<p>Python</p>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/","title":"RL Command Line Interface","text":"<p>This project contains an example of a C++ program, RlCli, that interfaces with Soar, which provides a command-line interface to collect reinforcement learning data. It is a good example of a minimal command-line application.</p>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#environment-properties","title":"Environment Properties","text":"<ul> <li>TODO (not for agents)</li> </ul>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#external-environment","title":"External Environment","text":"<p>None TODO (agents only)</p>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#soar-capabilities","title":"Soar Capabilities","text":"<p>TODO</p>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#download-links","title":"Download Links","text":"<ul> <li>RL_Command_Line_Interface_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#documentation","title":"Documentation","text":"<p>None</p>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#developers","title":"Developers","text":"<p>Jon Voigt voigtjr@gmail.com</p>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/rl_command_line_interface/#language","title":"Language","text":"<p>C++</p>"},{"location":"downloads/examples_and_unsupported/soar_obfuscator/","title":"Soar Obfuscator","text":"<p>This is a python script that does simple find and replaces to quickly (but weakly) obfuscate Soar code. It was originally developed to hide the workings of TankSoar agents developed for a TankSoar competition.</p>"},{"location":"downloads/examples_and_unsupported/soar_obfuscator/#download-links","title":"Download Links","text":"<ul> <li>Soar_Obfuscator.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_obfuscator/#documentation","title":"Documentation","text":"<p>None</p>"},{"location":"downloads/examples_and_unsupported/soar_obfuscator/#developers","title":"Developers","text":"<p>Jon Voigt voigtjr@gmail.com</p>"},{"location":"downloads/examples_and_unsupported/soar_obfuscator/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_obfuscator/#language","title":"Language","text":"<p>Python</p>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/","title":"Soar on iOS","text":"<p>This project demonstrates how you can run a Soar-enabled application on an iOS device like an iPhone or iPad.</p> <p>Note: This was originally published circa 2010, and is likely very out of date!</p>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#download-links","title":"Download Links","text":"<ul> <li>Soar931-iOS43: Contains all include files from the 9.3.1 release, as well as built libraries for the iOS simulator, armv6, and armv7 architectures. It has been tested with iOS 4.3.</li> <li>iSoar: A self-contained sample application that works out-of-the-box on the iOS simulator (it has copies of the includes and simulator libs from the previous link).</li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#documentation","title":"Documentation","text":"<p>Here are the basic steps, with more detail below:</p> <ol> <li>Add Soar includes to the XCode header search path</li> <li>Add static Soar libraries to the XCode project</li> <li>Rename appropriate source files to .mm (to enable C++)</li> <li>Include the appropriate headers in your source</li> </ol>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#soar-includes","title":"Soar Includes","text":"<p>The easiest way to do this is to download a release and point XCode to the <code>include</code> directory. In Build Path, look for \"Header Search Paths\".</p>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#soar-static-libraries","title":"Soar Static Libraries","text":"<p>The basic process is to compile Soar statically for an iPhone-specific architecture and SDK:</p> <ol> <li>Checkout Core from GitHub</li> <li><code>make ios-simulator</code> or <code>make ios-armv6</code> or <code>make ios-armv7</code></li> </ol> <p>All <code>lib*.a</code> files in the <code>out/lib</code> folder should be added to your project (drag+drop), except for SQLite.</p>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#rename-source-files","title":"Rename Source Files","text":"<p>XCode allows you to use C++ if your source file is named with a <code>.mm</code> (<code>vs.</code>, <code>.m</code>) extension. This will make for the easiest transition for non-Objective-C programmers.</p>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#include-headers","title":"Include Headers","text":"<p>In addition to the usual SML headers:</p> <ul> <li><code>sml_Connection.h</code></li> <li><code>sml_Client.h</code></li> <li><code>ElementXML.h</code></li> </ul> <p>XCode needs one more, which must go before the others:</p> <ul> <li><code>portability.h</code></li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#developers","title":"Developers","text":"<p>Nate Derbinsky</p>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_on_ios/#language","title":"Language","text":"<p>C++</p>"},{"location":"downloads/examples_and_unsupported/soar_scratch_pad/","title":"Soar Scratch Pad","text":"<p>This download contains the minimal C++ code needed to launch a Soar kernel using SML.</p>"},{"location":"downloads/examples_and_unsupported/soar_scratch_pad/#download-links","title":"Download Links","text":"<ul> <li>Soar_Scratch_Pad_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_scratch_pad/#documentation","title":"Documentation","text":"<p>None, but the code is fairly self-explanatory.</p>"},{"location":"downloads/examples_and_unsupported/soar_scratch_pad/#developers","title":"Developers","text":"<p>Jon Voigt voigtjr@gmail.com</p>"},{"location":"downloads/examples_and_unsupported/soar_scratch_pad/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/soar_scratch_pad/#language","title":"Language","text":"<p>C++</p>"},{"location":"downloads/examples_and_unsupported/tcl_command_line_filter_example/","title":"Tcl Command Line Filter Example","text":"<p>FilterTcl demonstrates how to write a client that intercepts commands to allow one to use Tcl from the command line (like earlier versions of Soar).</p> <p>To demonstrate its capabilities, it comes packaged with both TclEaters and the TSI (Tcl Soar Interface, i.e. the old Tcl-based Soar debugger.)</p> <p>Note: Soar now includes embedded Tcl support via TclSoarLib, which may provide a more recent example of Tcl interfacing.</p>"},{"location":"downloads/examples_and_unsupported/tcl_command_line_filter_example/#download-links","title":"Download Links","text":"<ul> <li>Soar_Filter_Tcl_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/tcl_command_line_filter_example/#documentation","title":"Documentation","text":"<p>While there is no explicit documentation, this example code is heavily commented.</p>"},{"location":"downloads/examples_and_unsupported/tcl_command_line_filter_example/#developers","title":"Developers","text":"<p>Douglas Pearson</p>"},{"location":"downloads/examples_and_unsupported/tcl_command_line_filter_example/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/tcl_command_line_filter_example/#language","title":"Language","text":"<p>Tcl</p>"},{"location":"downloads/examples_and_unsupported/tower_of_hanoi_sml_example/","title":"Tower of Hanoi SML Example","text":"<p>This project contains an example of a C++ based environment that interfaces with Soar. It implements a graphical version of the Towers of Hanoi. There is no option to load custom agents or interface to observe the agent trace. This project is an SML example, not a Towers of Hanoi test domain.</p> <p>The Towers of Hanoi is a puzzle that consists of three rods and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape. The objective of the puzzle is to move the entire stack to another rod, obeying the following rules: Only one disk may be moved at a time. Each move consists of taking the upper disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod. No disk may be placed on top of a smaller disk.</p> <ul> <li>Description of game rules derived from its Wikipedia page and is released under the Creative Commons license.</li> </ul>"},{"location":"downloads/examples_and_unsupported/tower_of_hanoi_sml_example/#download-links","title":"Download Links","text":"<ul> <li>Tower_Of_Hanoi_SML_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/tower_of_hanoi_sml_example/#documentation","title":"Documentation","text":"<p>None, but the code does have some comments.</p>"},{"location":"downloads/examples_and_unsupported/tower_of_hanoi_sml_example/#developers","title":"Developers","text":"<p>Mitchell Bloch</p>"},{"location":"downloads/examples_and_unsupported/tower_of_hanoi_sml_example/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/tower_of_hanoi_sml_example/#language","title":"Language","text":"<p>C++</p>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/","title":"Towers of Hanoi","text":"<p>The classic Towers of Hanoi puzzle implemented as an external, graphical environment using Java and interfaced with Soar via SML. To see how the agent performs the task, you must launch the Soar debugger and tell it to connect to a remote Soar agent.</p> <p>The Towers of Hanoi is a puzzle that consists of three rods and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape. The objective of the puzzle is to move the entire stack to another rod, obeying the following rules:</p> <ul> <li>Only one disk may be moved at a time.</li> <li>Each move consists of taking the upper disk from one of the rods and sliding it onto another rod, on top of the other disks that may already be present on that rod.</li> <li>No disk may be placed on top of a smaller disk.</li> </ul> <p>Description of game rules derived from\u00a0its Wikipedia page and is released under the\u00a0Creative Commons license.</p>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#download-links","title":"Download Links","text":"<ul> <li>Java_Tower_of_Hanoi_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#associated-agents","title":"Associated Agents","text":"<p>There is one basic agent embedded within the environment that will automatically be sourced when you launch it.</p> <p>Note: You cannot run the many Towers of Hanoi agents available in the Agents\u00a0downloads section with this environment. Those ones are not designed to be run with the I/O interface of this external environment.</p>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#documentation","title":"Documentation","text":"<p>While there is no explicit documentation, the Soar Debugger tutorial does have a section that explains how to hook up the debugger to this type of environment.</p>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#associated-publications","title":"Associated Publications","text":"<p>None</p>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#developers","title":"Developers","text":"<p>Taylor Lafrinere</p>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/towers_of_hanoi/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/","title":"Working Memory Activation Tracker","text":"<p>This is a simple pair of scripts to help debug/visualize working-memory activation values. The first script (<code>gen_wma.cpp</code>) runs a Soar agent for a fixed number of decisions, outputting working memory at each decision to a specially named file. The second script (<code>aggregate_wma.php</code>) takes these files and produces a CSV file where every working-memory element (columns) has an activation value for every decision (rows). This allows for easy graphing of activation in Excel, for instance.</p>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#download-links","title":"Download Links","text":"<ul> <li>Working_Memory_Activation_Tracker_Example.zip</li> </ul>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#documentation","title":"Documentation","text":""},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#usage-prerequisites","title":"Usage: Prerequisites","text":"<p>The first script is written in C++ (for speed reasons), whereas the second is in PHP. Thus, you will a Soar distribution to link the C++ program and the PHP CLI on the system to run.</p>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#usage-building","title":"Usage: Building","text":"<p>Included is a build script (build.sh) that works on Mac, assuming the <code>SOAR_HOME</code> environmental variable has been defined. This should also work on Linux. It has not been tested on Windows.</p>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#usage-running","title":"Usage: Running","text":"<p>The data producer (gen_wma.cpp) has hard-coded the agent file it's going to use (<code>agent.soar</code>). I've provided one such agent as an example, which simply counts and, using mods, has rules match WMEs on fixed patterns. It will output <code>wma#.txt</code> for each decision, where <code>#</code> refers to that decision number. The number of decisions to run is provided as a command-line parameter.</p> <p>The data consumer (<code>aggregate_wma.php</code>) also takes as a command-line parameter the number of decisions, looks for the corresponding set of <code>wma#.txt</code> files (for i=1..<code>#</code>). It outputs wma.csv after the analysis (beware of clobbering data!).</p> <p>I've provided a run script (<code>run.sh</code>) that takes as a command-line parameter the number of decisions to run. It calls the producer, then consumer, then cleans up the text files. It's a bash script, and so should run fine on Mac/Linux.</p>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#developers","title":"Developers","text":"<p>Nate Derbinsky</p>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#soar-versions","title":"Soar Versions","text":"<ul> <li>Soar 8</li> <li>Soar 9</li> </ul>"},{"location":"downloads/examples_and_unsupported/working_memory_activation_tracker/#language","title":"Language","text":"<p>PHP</p>"},{"location":"downloads/soar/","title":"Downloads: Soar","text":"<p>This section contains pre-compiled Soar binaries.</p> <ul> <li>Latest Soar Release</li> <li>Previous Soar Releases</li> <li>JSoar</li> </ul>"},{"location":"downloads/soar/archive/","title":"Archive of Previous Soar Releases","text":""},{"location":"downloads/soar/archive/#soar-9","title":"Soar 9","text":"<p>Releases of Soar 9.6.1 and later are available from the releases page on the Soar GitHub repository here.</p>"},{"location":"downloads/soar/archive/#soar-960","title":"Soar 9.6.0","text":"<ul> <li>SoarSuite_9.6.0-Multiplatform_64bit.zip</li> <li>SoarSuite_9.6.0-source.zip</li> <li>SoarTutorial_9.6.0-Multiplatform_64bit.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-950","title":"Soar 9.5.0","text":"<ul> <li>SoarSuite_9.5.0-Linux_32bit.zip</li> <li>SoarSuite_9.5.0-Linux_64bit.zip</li> <li>SoarSuite_9.5.0-OSX.zip</li> <li>SoarSuite_9.5.0-Windows_32bit.zip</li> <li>SoarSuite_9.5.0-Windows_64bit.zip</li> <li>SoarSuite_9.5.0-source.zip</li> <li>SoarTutorial_9.5.0-Linux_32bit.zip</li> <li>SoarTutorial_9.5.0-Linux_64bit.zip</li> <li>SoarTutorial_9.5.0-OSX.zip</li> <li>SoarTutorial_9.5.0-Windows_32bit.zip</li> <li>SoarTutorial_9.5.0-Windows_64bit.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-940","title":"Soar 9.4.0","text":"<ul> <li>SoarSuite_9.4.0-Linux_32bit.zip</li> <li>SoarSuite_9.4.0-Linux_64bit.zip</li> <li>SoarSuite_9.4.0-OSX.zip</li> <li>SoarSuite_9.4.0-Windows_32bit.zip</li> <li>SoarSuite_9.4.0-Windows_64bit.zip</li> <li>SoarSuite_9.4.0-source.zip</li> <li>SoarTutorial_9.4.0-Linux_32bit.zip</li> <li>SoarTutorial_9.4.0-Linux_64bit.zip</li> <li>SoarTutorial_9.4.0-OSX.zip</li> <li>SoarTutorial_9.4.0-Windows_32bit.zip</li> <li>SoarTutorial_9.4.0-Windows_64bit.zip</li> <li>TclSoarLib_9.4.0-Linux_32bit.zip</li> <li>TclSoarLib_9.4.0-Linux_64bit.zip</li> <li>TclSoarLib_9.4.0-OSX.zip</li> <li>TclSoarLib_9.4.0-Windows_32bit.zip</li> <li>TclSoarLib_9.4.0-Windows_64bit.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-934","title":"Soar 9.3.4","text":"<ul> <li>SoarSuite_9.3.4-Linux_32bit.zip</li> <li>SoarSuite_9.3.4-Linux_64bit.zip</li> <li>SoarSuite_9.3.4-OSX.zip</li> <li>SoarSuite_9.3.4-Windows_32bit.zip</li> <li>SoarSuite_9.3.4-Windows_64bit.zip</li> <li>SoarSuite_9.3.4-source.zip</li> <li>SoarTutorial_9.3.4-Linux_32bit.zip</li> <li>SoarTutorial_9.3.4-Linux_64bit.zip</li> <li>SoarTutorial_9.3.4-OSX.zip</li> <li>SoarTutorial_9.3.4-Windows_32bit.zip</li> <li>SoarTutorial_9.3.4-Windows_64bit.zip</li> <li>TclSoarLib_9.3.4-Linux_32bit.zip</li> <li>TclSoarLib_9.3.4-Linux_64bit.zip</li> <li>TclSoarLib_9.3.4-OSX.zip</li> <li>TclSoarLib_9.3.4-Windows_32bit.zip</li> <li>TclSoarLib_9.3.4-Windows_64bit.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-932","title":"Soar 9.3.2","text":"<ul> <li>SoarSuite_9.3.2-Linux_32bit.zip</li> <li>SoarSuite_9.3.2-Linux_64bit.zip</li> <li>SoarSuite_9.3.2-OSX.zip</li> <li>SoarSuite_9.3.2-Windows_32bit.zip</li> <li>SoarSuite_9.3.2-Windows_64bit.zip</li> <li>SoarSuite_9.3.2-source.zip</li> <li>SoarTutorial_9.3.2-Linux_32bit.zip</li> <li>SoarTutorial_9.3.2-Linux_64bit.zip</li> <li>SoarTutorial_9.3.2-OSX.zip</li> <li>SoarTutorial_9.3.2-Windows_32bit.zip</li> <li>SoarTutorial_9.3.2-Windows_64bit.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-931","title":"Soar 9.3.1","text":"<ul> <li>SoarManual931.pdf</li> <li>SoarSuite-9.3.1-linux-i686.tar.gz</li> <li>SoarSuite-9.3.1-linux-x86_64.tar.gz</li> <li>SoarSuite-9.3.1-osx-x86_64.tar.gz</li> <li>SoarSuite-9.3.1-source.tar.gz</li> <li>SoarSuite-9.3.1-win-i686.zip</li> <li>SoarSuite-9.3.1-win-x86_64.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-930","title":"Soar 9.3.0","text":"<ul> <li>Soar-Suite-9.3.0-linux-x86_64.tar.gz</li> <li>Soar-Suite-9.3.0-linux-x86.tar.gz</li> <li>Soar-Suite-9.3.0-osx-x86_64.zip</li> <li>Soar-Suite-9.3.0-osx-x86.zip</li> <li>Soar-Suite-9.3.0-source.tar.gz</li> <li>Soar-Suite-9.3.0-win-x86_64.zip</li> <li>Soar-Suite-9.3.0-win-x86.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-920","title":"Soar 9.2.0","text":"<ul> <li>Soar-Suite-9.2.0-linux-x64.tar.gz</li> <li>Soar-Suite-9.2.0-linux.tar.gz</li> <li>Soar-Suite-9.2.0-osx-x64.tar.gz</li> <li>Soar-Suite-9.2.0-osx.tar.gz</li> <li>Soar-Suite-9.2.0-windows-x64.zip</li> <li>Soar-Suite-9.2.0-windows.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-911","title":"Soar 9.1.1","text":"<ul> <li>Soar-Suite-9.1.1-linux-x64.tar.gz</li> <li>Soar-Suite-9.1.1-linux.tar.gz</li> <li>Soar-Suite-9.1.1-osx-x64.tar.gz</li> <li>Soar-Suite-9.1.1-osx.tar.gz</li> <li>Soar-Suite-9.1.1-windows-x64.zip</li> <li>Soar-Suite-9.1.1-windows.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-910","title":"Soar 9.1.0","text":"<ul> <li>Soar-Suite-9.1.0-beta-linux.tar.gz</li> <li>Soar-Suite-9.1.0-beta-osx-intel.tar.gz</li> <li>Soar-Suite-9.1.0-beta-osx-ppc.tar.gz</li> <li>Soar-Suite-9.1.0-beta-windows.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-901","title":"Soar 9.0.1","text":"<ul> <li>Soar-Suite-9.0.1-linux-x64.tar.gz</li> <li>Soar-Suite-9.0.1-linux.tar.gz</li> <li>Soar-Suite-9.0.1-osx-x64.tar.gz</li> <li>Soar-Suite-9.0.1-osx.tar.gz</li> <li>Soar-Suite-9.0.1-windows-x64.zip</li> <li>Soar-Suite-9.0.1-windows.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-900","title":"Soar 9.0.0","text":"<ul> <li>Soar-Suite-9.0.0-linux-fixed.tar.gz</li> <li>Soar-Suite-9.0.0-osx-intel.tar.gz</li> <li>Soar-Suite-9.0.0-windows.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-8","title":"Soar 8","text":""},{"location":"downloads/soar/archive/#soar-864","title":"Soar 8.6.4","text":"<ul> <li>SoarSuite-8.6.4-beta-linux.tgz</li> <li>SoarSuite-8.6.4-beta-osx.tgz</li> <li>SoarSuite-8.6.4-beta-win32.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-863","title":"Soar 8.6.3","text":"<ul> <li>Soar-Suite-8.6.3.exe</li> </ul>"},{"location":"downloads/soar/archive/#soar-862","title":"Soar 8.6.2","text":"<ul> <li>Soar-Suite-8.6.2-RL-alpha.exe</li> <li>Soar8.6.2RLa2.exe</li> </ul>"},{"location":"downloads/soar/archive/#soar-861","title":"Soar 8.6.1","text":"<ul> <li>Soar-Suite-8.6.1.dmg</li> <li>Soar-Suite-8.6.1.exe</li> <li>Soar-Suite-8.6.1.tar.bz2</li> <li>Soar8.6.1-libs.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-860","title":"Soar 8.6.0","text":"<ul> <li>Soar-Suite-8.6.0.exe</li> </ul>"},{"location":"downloads/soar/archive/#soar-851","title":"Soar 8.5.1","text":"<p>setup-soar-suite-8.5.1-w32.exe</p>"},{"location":"downloads/soar/archive/#soar-84","title":"Soar 8.4","text":"<ul> <li>README84.Macintosh</li> <li>README84.Unix</li> <li>README84.Win</li> <li>soar84-api-docs.tgz</li> <li>Soar84.RelNotes</li> <li>Soar84.sea</li> <li>Soar841.tgz</li> <li>Soar841.zip</li> </ul>"},{"location":"downloads/soar/archive/#soar-83","title":"Soar 8.3","text":"<ul> <li>README83.Unix</li> <li>README83.Win</li> <li>Soar-83RelNotes.pdf</li> <li>Soar83.EXE</li> <li>Soar83.tgz</li> <li>Soar83sol.tgz</li> </ul>"},{"location":"downloads/soar/archive/#soar-82","title":"Soar 8.2","text":"<ul> <li>README82.Macintosh</li> <li>README82.Unix</li> <li>README82.Win</li> <li>Soar82.EXE</li> <li>Soar82.RelNotes</li> <li>Soar82.sea.hqx</li> <li>Soar82.tgz</li> </ul>"},{"location":"downloads/soar/archive/#soar-7","title":"Soar 7","text":""},{"location":"downloads/soar/archive/#soar-73","title":"Soar 7.3","text":"<ul> <li>README73.Macintosh</li> <li>README73.Unix</li> <li>README73.Win</li> <li>Soar73.EXE</li> <li>Soar73.RelNotes</li> <li>Soar73.sea.hqx</li> <li>Soar73.tgz</li> </ul>"},{"location":"downloads/soar/archive/#soar-72","title":"Soar 7.2","text":"<ul> <li>README.Macintosh</li> <li>README.Unix</li> <li>README.Win</li> <li>README.win32-tcltk-patch</li> <li>Soar72.EXE</li> <li>Soar72.sea.hqx</li> <li>Soar72.tgz</li> <li>win32-tcltk-patch.zip</li> </ul>"},{"location":"downloads/soar/jsoar/","title":"JSoar","text":"<p>JSoar is a pure Java implementation of most of Soar. Periodic development efforts bring it up-to-date with the most recent version of Soar.</p> <p>While there may be a reduced feature set,there are a few benefits to a pure-Java implementation of Soar:</p> <ul> <li>Idiomatic Java API in contrast to CSoar's SWIG-generated bindings.</li> <li>\"Free\" multi-language support (JRuby, Jython, Rhino (JavaScript), Groovy,  Scala, Clojure, etc)</li> <li>A codebase and tools more friendly to rapid research prototyping</li> <li>No native libraries to deal with</li> <li>Cleaner integration with \"enterprisey\" systems</li> </ul>"},{"location":"downloads/soar/jsoar/#download","title":"Download","text":"<p>JSoar is downloadable from GitHub here.</p>"},{"location":"downloads/soar/jsoar/#documentation","title":"Documentation","text":"<ul> <li>Frequently Anticipated Questions</li> <li>JSoarUsersGuide -  Start here if you want to use JSoar in a project</li> <li>JSoarDevelopersGuide - Start here if you want to check out and compile the source code</li> <li>Javadoc</li> </ul>"},{"location":"downloads/soar/jsoar/#developer","title":"Developer","text":"<p>Dave Ray, SoarTech</p>"},{"location":"downloads/soar/jsoar/#language","title":"Language","text":"<p>Java</p>"},{"location":"downloads/soar/latest/","title":"Latest Soar Download","text":"<p>The current version of Soar is 9.6.4.</p> <ul> <li>Soar Release (see quick start guide for setup instructions)</li> </ul> <ul> <li>Soar Manual PDF</li> </ul> <ul> <li>VisualSoar Manual PDF</li> </ul> <p>If you would like to build Soar from the current source code, you'll need to acquire the source from our git repository on GitHub.</p>"},{"location":"downloads/soar/latest/#soar-964-release-notes","title":"Soar 9.6.4 Release Notes","text":""},{"location":"downloads/soar/latest/#new-features","title":"New Features","text":"<ul> <li>New special-purpose RHS functions for working with headings and range in navigation domains:<ul> <li><code>extrapolate-x-position</code></li> <li><code>extrapolate-y-position</code></li> <li><code>select-point-closest-to-vector</code></li> <li><code>haversine</code></li> </ul> </li> <li>Scene names (<code>S1</code>, <code>S2</code>, etc.) used in SVS commands are now case-insensitive, which is consistent with Soar's handling of state names (#426)</li> <li>Soar now supports LTI aliases. Thanks to Aaron Mininger!<ul> <li>This means you can assign permanent aliases to LTIs in commands such as <code>smem --add { (@test1 ^name test1 ^info @info1) (@info1 ^number 1) }</code>.</li> <li>These are then referenceable in commands such as <code>smem --query</code> and <code>smem --remove</code>.</li> <li>Also printed in the output of <code>print</code>, as well as <code>smem --history</code>, <code>smem --export</code> and <code>visualize smem</code>.</li> </ul> </li> <li>Java SML bindings: Don't throw exception in static block when Soar lib isn't found (#491)<ul> <li>Previous behavior was to throw an exception at class load time, which would completely prevent an application from loading</li> </ul> </li> </ul>"},{"location":"downloads/soar/latest/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fix compilation with <code>--no-scu</code> (#500). Thanks to James Boggs!</li> <li>Escape empty strings when printing symbols in productions, etc. (#484)<ul> <li>Without the escaping, productions printed this way are not correct Soar syntax and therefore are not sourceable!</li> </ul> </li> <li>Don't ignore duplicate justifications (#529)<ul> <li>O-supported justifications that are duplicates can be created when the state changes but returns to its original value again. Previously Soar would ignore duplicate justifications, which would then prevent the expected RHS changes from being applied. Now, the previous justification is removed and the new one is added.</li> </ul> </li> <li><code>cd</code> command with no parameters now works as documented in the manual (previous behavior was a simple segfault!) (#494)</li> </ul>"},{"location":"downloads/soar/latest/#infrastructure-improvements","title":"Infrastructure improvements","text":"<ul> <li>In-progress CMake-based build system (thanks to Moritz Schmidt!)</li> <li>Look specifically for Tcl 8 when building (Soar is not yet compatible with Tcl 9)</li> </ul>"},{"location":"downloads/soar/latest/#cruft-and-cleanup","title":"Cruft and cleanup","text":"<ul> <li>Lots of compiler warning fixes</li> <li>Compiler strictness increased</li> </ul>"},{"location":"downloads/soar/latest/#visualsoar","title":"VisualSoar","text":""},{"location":"downloads/soar/latest/#project-stability-improvements","title":"Project Stability Improvements","text":"<ul> <li>Newly designed JSON format for VisualSoar projects combining the datamap, operator hierarchy/project layout, and comment files into one file (#38, #5)<ul> <li>Far less likely to be corrupted</li> <li>More human-readable</li> <li>More machine readable (tool developers welcome!)</li> <li>More robust to collaboration (no non-deterministic output, fewer git conflicts, easier to resolve if they do occur)</li> <li>Handles arbitrary enum strings, attribute and operator names, etc.</li> <li>VisualSoar will write your project in the new format automatically, but will ask you to delete the old project files yourself. Effort was taken to eliminate any chance of data loss or other unwanted surprises.</li> </ul> </li> <li>Read/write project and config files atomically<ul> <li>Prevents corruption if an error occurs during read/write</li> </ul> </li> <li>Fix cross-platform incompatibility issues in config files</li> <li>Improve error messages, fewer hidden from users</li> <li>Improve undo stack management<ul> <li>Compound edits such as the comment/uncomment actions are now applied atomically, meaning they can be undone/redone in one step</li> <li>Fixed issues that caused the undo stack to be unexpectedly cleared</li> </ul> </li> <li>Improve close/save action workflows to reduce surprises (such as closing and saving everything without confirmation!)</li> </ul>"},{"location":"downloads/soar/latest/#cli-support","title":"CLI Support","text":"<p>VisualSoar can now run project datamap validation from the command line by passing the arguments <code>--check productionsAgainstDatamap --project &lt;path&gt;</code>, where <code>&lt;path&gt;</code> is the path to your project <code>.vsa</code> or <code>.vsa.json</code>.</p> <p>There is a also a new GitHub Action to enable you to check your projects automatically when you push to GitHub.</p>"},{"location":"downloads/soar/latest/#ergonomics-and-bug-fixes","title":"Ergonomics and Bug Fixes","text":"<ul> <li>Fix Soar Runtime menu functions (connect to kernel, source agent, etc.) (#33)</li> <li>Make comment/uncomment actions inverses of each other and fix issues with extra lines getting commented</li> <li>Display number of feedback messages in the status bar<ul> <li>A quick way to see if you are making progress on eliminating datamap errors</li> </ul> </li> <li>allow underscores in attribute names (#32)</li> <li>Support ctrl-A \"select all\" shortcut</li> <li>Fix undo/redo shortcuts</li> <li>Fix website links in help menu, and open the browser automatically</li> <li>Improve searchbox and related ergonomics (#57)<ul> <li>Wrap search by default</li> <li>Don't close the searchbox after searching</li> <li>Populate the searchbox with selected text (for the editor view)</li> <li>Fix shortcuts for searchbox and many other commands</li> <li>Use command on Mac instead of ctrl for all shortcuts</li> <li>Allow closing any dialog box with the escape key</li> </ul> </li> <li>New shortcut: ctrl/cmd-, to open preferences</li> <li>New preferences:<ul> <li>Save project when datamap check passes</li> <li>Run datamap check after saving project</li> </ul> </li> <li>ctrl/cmd-= and ctrl/cmd-- to increase/decrease font size</li> <li>Responsively re-tile all frames when main window is resized</li> <li>Better resizing of feedback list when the main window is resized</li> <li>Improved auto-complete UI</li> <li>Auto-complete for variables that match their attribute name</li> </ul>"},{"location":"downloads/soar/latest/#infrastructure","title":"Infrastructure","text":"<ul> <li>Add continuous integration (via GitHub actions)</li> <li>Introduce JUnit for unit testing</li> <li>Build native binaries in CI via jpackage</li> <li>Update to Java 11, which is already required by other Soar tools (#29)</li> </ul>"},{"location":"downloads/soar/latest/#debugger","title":"Debugger","text":"<ul> <li>Update links in help menu and open them in a browser automatically (#482)</li> <li>Add new \"Browse settings files...\" option in file menu</li> <li>Support select-all shortcut in all text windows via cmd/ctrl-a</li> <li>Copy/paste fixes<ul> <li>Paste directly into command box instead of the output window</li> <li>Fix issue causing paste of 'c' or 'v' into the command box upon copy/paste</li> </ul> </li> <li>Account for half-scrolled lines in right-click (#417)</li> <li>Fix preference file issues (#509)<ul> <li>Don't enter infinite loop when reading an incomplete XML file</li> <li>Read/write preference XML file atomically to avoid corruption</li> </ul> </li> <li>Fix broken <code>cd</code> button on Windows (#452)</li> <li>Improved CLI parameter handling for debugger (#510)<ul> <li>Parameters are now parsed with the <code>commons-cli</code> library</li> <li><code>--help</code> and incorrect parameters now show CLI parameter documentation, so users don't have to go to the website</li> </ul> </li> </ul>"},{"location":"home/About/","title":"What is Soar?","text":"<p>Soar is a general cognitive architecture for developing systems that exhibit intelligent behavior. Researchers all over the world, both from the fields of artificial intelligence and cognitive science, are using Soar for a variety of tasks. It has been in use since 1983, evolving through many different versions to where it is now Soar, Version 9.</p> <p>We intend ultimately to enable the Soar architecture to:</p> <ul> <li>work on the full range of tasks expected of an intelligent agent, from highly   routine to extremely difficult, open-ended problems</li> <li>represent and use appropriate forms of knowledge, such as procedural,   semantic, episodic, and iconic</li> <li>employ the full range of problem solving methods</li> <li>interact with the outside world, and</li> <li>learn about all aspects of the tasks and its performance on them.</li> </ul> <p>In other words, our intention is for Soar to support all the capabilities required of a general intelligent agent.</p> <p>The ultimate in intelligence would be complete rationality which would imply the ability to use all available knowledge for every task that the system encounters. Unfortunately, the complexity of retrieving relevant knowledge puts this goal out of reach as the body of knowledge increases, the tasks are made more diverse, and the requirements in system response time more stringent. The best that can be obtained currently is an approximation of complete rationality. The design of Soar can be seen as an investigation of one such approximation. Below is the primary principle which is the basis of Soar's design and which guides its attempt to approximate rational behavior.</p> <p>All decisions are made through the combination of relevant knowledge at run-time. In Soar, every decision is based on the current interpretation of sensory data, the contents of working memory created by prior problem solving, and any relevant knowledge retrieved from long-term memory. Decisions are never precompiled into uninterruptible sequences. For many years, a secondary principle has been that the number of distinct architectural mechanisms should be minimized. Through Soar 8, there has been a single framework for all tasks and subtasks (problem spaces), a single representation of permanent knowledge (productions), a single representation of temporary knowledge (objects with attributes and values), a single mechanism for generating goals (automatic subgoaling), and a single learning mechanism (chunking). We have revisited this assumption as we attempt to ensure that all available knowledge can be captured at runtime without disrupting task performance. This is leading to multiple learning mechanisms (chunking, reinforcement learning, episodic learning, and semantic learning), and multiple representations of long-term knowledge (productions for procedural knowledge, semantic memory, and episodic memory).</p> <p>Two additional principles that guide the design of Soar are functionality and performance. Functionality involves ensuring that Soar has all of the primitive capabilities necessary to realize the complete suite of cognitive capabilities used by humans, including, but not limited to reactive decision making, situational awareness, deliberate reasoning and comprehension, planning, and all forms of learning. Performance involves ensuring that there are computationally efficient algorithms for performing the primitive operations in Soar, from retrieving knowledge from long-term memories, to making decisions, to acquiring and storing new knowledge.</p> <p>For further background on Soar, we recommend Introduction to Soar at https://arxiv.org/abs/2205.03854 and The Soar Cognitive Architecture Laird, J.  E.(2012), The Soar Papers: Readings on Integrated Intelligence, Rosenbloom, Laird, and Newell (1993), and Unified Theories of Cognition, Newell (1990). Also available are Soar: A Functional Approach to General Intelligence and Soar: A comparison with Rule-Based Systems. There is also a full list of publications available. Entries on the Soar Knowledge Base and the older  Soar FAQ also provide answers to many common questions about Soar.</p> <p>We would like to extend a special thank you to DARPA, ONR and AFOSR for their continued support of Soar and projects related to Soar.</p>"},{"location":"home/CommercialSoarOrganizations/","title":"Commercial Soar Organizations","text":"","tags":["organizations"]},{"location":"home/CommercialSoarOrganizations/#commercial-organizations-using-soar","title":"Commercial Organizations Using Soar","text":"","tags":["organizations"]},{"location":"home/CommercialSoarOrganizations/#soar-technology-inc","title":"Soar Technology, Inc.","text":"<p>Soar Technology Inc. is utilizing advanced artificial intelligence, grounded in scientific principles of human-system interaction and implemented through sound software engineering, SoarTech develops intelligent autonomous agent software for modeling and simulation, command and control, information visualization, robotics, and intelligence analysis, for the U.S. Army, Navy, Air Force, DARPA, JFCOM, DMSO and the intelligence community.</p>","tags":["organizations"]},{"location":"home/CommercialSoarOrganizations/#cogniteam-ltd","title":"Cogniteam, Ltd.","text":"<p>Cogniteam is an Israeli company offering project development, consulting, and professional services in AI and robotics in general, and using Soar in particular. They work with major Israeli defense integrators, the Israeli Ministry of Defense, and universities.</p>","tags":["organizations"]},{"location":"home/OtherAcademicInstitutions/","title":"Academic Institutions","text":"","tags":["institutions"]},{"location":"home/OtherAcademicInstitutions/#other-academic-research-groups-using-soar","title":"Other Academic Research Groups Using Soar","text":"<p>University of Michigan: Our research focuses on extensions to the Soar architecture and the cognitive capabilities made possible by Soar. Recent architectural research includes work on reinforcement learning, episodic memory, semantic memory, mental imagery, and motor control. Our research on cognitive capabilities includes work on learning by situated interactive instruction, learning relational and continuous action models, and robot control. We work on a variety of domains that include video games, linguistics tasks, mobile robots, and planning tasks.</p> <p>Penn State: People in our lab help move the field of cognitive science. Our projects are focused on models that learn, ranging from how to provide models access to interfaces to analyzing the effects of caffeine on cognition to determining how children develop through the modeling of their development. Other projects include the development of the Psychological Soar Tutorial and the Soar FAQ. For more information contact frank.ritter at psu.edu.</p> <p>University of Portland: Research is in improving the effectiveness of the episodic memory system. Much of the work is done external to Soar while honoring architectural requirements of Soar. Recent projects include: a survey of forgetting mechanisms, using memories to build plans, using sequences of episodes to overcome state aliasing and using experience to discover the relative importance of various WMEs that comprise an agent's episodes. Many of the insights from this research have been embodied in an advanced episodic memory system called Ziggurat. Throughout this process, the hardest part of creating an effective episodic memory system remains the same: creating an effective, domain-independent algorithm to select the best memory from a given cue.</p> <p>Pace University: An Intelligent Soar Assistant for a Virtual World Abe Guerra has built an assistant for IBM's virtual world. His agent uses Soar to reason about what a user needs and guides the user through the virtual world. The assistant interacts with the user through typed natural language commands, and can also assist with commands for using the virtual world interface. Here is an introductory paper on his project. There is also a movie of his agent navigating and a movie of his agent assisting a customer. A Soar Agent for Playing Poker Bob Follek has implemented an architecture for an autonomous poker player. His SoarBot uses Soar to play poker with the poker server set up by the University of Alberta Computer Poker Research Group. Bob can be reached at bob@codeblitz.com Researchers use Soar to build an intelligent assistant for IBM's virtual world. Agent reasons about what a user needs and guides the user through the virtual world. The assistant interacts with the user through typed natural language commands, and can also assist with commands for using the virtual world interface. The research group also uses Soar to implement an architecture for an autonomous poker player. The agent uses Soar to play poker with the poker server set up by the University of Alberta Computer Poker Research Group.</p> <p>University of Southern California and the Institute for Creative Technologies</p> <p>Bar Ilan University, Israel is home to the MAVERICK group, which conducts research in social intelligence, multi-agent and multi-robot systems, and plan recognition.  Work in Soar has focused on developing Soar-based teamwork capabilities for modeling para-military units, multi-agent plan recognition and mirroring, and social comparison for groups.</p> <p>Prof. Dr. Claudia Meitinger's team at the Augsburg Technical University of Applied Sciences is utilizing Soar to enhance various aspects of human-machine interaction and problem-solving. In the B2X Beyond SalesBot project, the aim is to develop, validate, and generalize an AI-based tool for technical sales, using deburring tools as a case study. A Soar agent is used for the tool configuration process, determining the tool parameters based on the customer requirements, which are enquired step-by-step. Additionally, the research group on Human-Machine Interaction with Intelligent Systems focuses on developing a demonstrator for a use case where a collaborative grinding robot is delegated by shop floor workers. Soar is employed to facilitate human-machine interaction by providing an abstract communication level, contributing to knowledge base expansion and task inference based on delegated tasks.</p>","tags":["institutions"]},{"location":"home/Publications/","title":"Publications","text":"","tags":["research"]},{"location":"home/Publications/#publications","title":"Publications","text":"","tags":["research"]},{"location":"home/Publications/#2025","title":"2025","text":"<p>Schmidt, Moritz &amp; Meitinger, Claudia \u201cLeveraging Agent-Based Reasoning for\u00a0Natural Task Delegation on\u00a0the\u00a0Shop Floor,\u201d in Studies in Computational Intelligence, Cham: Springer Nature Switzerland, 2025, pp. 41\u201354. doi: 10.1007/978-3-031-85316-6_4.</p>","tags":["research"]},{"location":"home/Publications/#2023","title":"2023","text":"<p>N.Narayan, P. Ganeriwala, R. Jones, M. Matessa, S. Bhattacharyya, J. Davis, H. Purohit and S. Rollini (2023). Assuring Learning-Enabled Increasingly Autonomous System. IEEE SYSCON 2023.</p>","tags":["research"]},{"location":"home/Publications/#2022","title":"2022","text":"<p>Jones, Steven (2022). A Cognitive Architecture Realization of Event Cognition Capabilities, Dissertation.</p> <p>Assanie, Mazin (2022). Learning General and Correct Procedural Knowledge in a Cognitive Architecture, Dissertation.</p> <p>Li, Justin, &amp; Boyle, Bryce. (2022) Towards a Computational Model of a Dynamic Feeling of Knowing.</p> <p>Laird, J. E. (2022) Introduction to Soar. https://arxiv.org/abs/2205.03854</p> <p>Ying Zhao, Erik Hemberg, Nate Derbinsky, Gabino Mata, and Una-May O\u2019Reilly. (2021). Simulating a logistics enterprise using an asymmetrical wargame simulation with soar reinforcement learning and coevolutionary algorithms. In Proceedings of the Genetic and Evolutionary Computation Conference Companion (GECCO \u201921). Association for Computing Machinery, New York, NY, USA, 1907\u20131915.</p> <p>Schatz, J., Jones, S. J., &amp; Laird, J. E. (2022). Modeling the Remote Associates Test as Retrievals from Semantic Memory. Cognitive Science, 46(6), e13145</p> <p>M.A.\u00a0Rovbo, P.S. Sorokoumov. (2022). Symbolic Control System for a Mobile Robotic Platform Based on SOAR Cognitive Architecture Part of the Studies in Systems, Decision and Control book series (SSDC,volume 419).</p> <p>Lindes, Peter. (2022). Constructing Meaning, Piece by Piece: A Computational Cognitive Model of Human Sentence Comprehension, Dissertation.</p> <p>Fei Lou, Qin Zhou, Joel Fuentes, Weichao Ding, and Chunhau Gu (2022). A Soar-Based Space Exploration Algorithm for Mobile Robots, Entropy Journal.</p> <p>Aaron Mininger, John E. Laird (2022). A Demonstration of Compositional, Hierarchical Interactive Task Learnng, AAAI Conference.</p>","tags":["research"]},{"location":"home/Publications/#2021","title":"2021","text":"<p>John E. Laird (2021). An Analysis and Comparison of ACT-R and Soar, Proceedings of the Ninth Annual Conference on Advances in Cognitive Systems.</p> <p>Stearns, B. (2021). A Comprehensive Computational Model of PRIMs Theory for Task-Independent Procedural Learning, Dissertation.</p> <p>Preeti Ramaraj, Charles L. Ortiz, Jr., and Shiwali Mohan (2021). Unpacking Human Teachers\u2019 Intentions For Natural Interactive Task Learning, International Symposium on Robot and Human Interactive Communication (RO-MAN).</p> <p>Preeti Ramaraj (2021). Robots that Help Humans Build Better Mental Models of Robots, HRI Pioneers Workshop held at the ACM/IEEE International Conference on Human-Robot Interaction (HRI).</p> <p>Preeti Ramaraj (2021). Robots that Help Humans Build Better Mental Models of Robots, AAAI/SIGAI Doctoral Consortium collocated with the Thirty-Fifth Conference on Artificial Intelligence.</p> <p>Shiwali Mohan (2021). Exploring the Role of Common Model of Cognition in Designing Adaptive Coaching Interactions for Health Behavior Change, ACM Transactions on Interactive Intelligent Systems 11(1), 1-30.</p> <p>Andrea Stocco, Catherine Sibert, Zoe Steine-Hanson, Natalie Koh, John E. Laird, Christian J. Lebiere, Paul Rosenbloom (2021). Analysis of the human connectome data supports the notion of a \u201cCommon Model of Cognition\u201d for human and human-like intelligence across domains, NeuroImage 235(118035), 1-15.</p> <p>Mininger, A. (2021). Expanding Task Diversity in Explanation-Based Interactive Task Learning, Dissertation.</p>","tags":["research"]},{"location":"home/Publications/#2020","title":"2020","text":"<p>Li, Justin. (2020) Integrating Declarative Long-Term Memory Retrievals into Reinforcement Learning ACS 2020</p> <p>Hiatt, L., &amp; Jones, S. (2020). An associative learning account for retrieval-induced forgetting, CogSci.</p> <p>Mohan, S., Klenk, M., Shreve, M., Evans, K., Ang, A., and Maxwell, J. (2020). Characterizing an Analogical Concept Memory for Newellian Cognitive Architectures, Advances in Cognitive Systems.</p> <p>Lindes, P. (2020). Intelligence and Agency, Journal of Artificial General Intelligence 11(2), 47-49. doi:10.2478/jagi-2020-0003.</p> <p>Laird, J. E. (2020). Intelligence, Knowledge &amp; Human-like Intelligence, Journal of Artificial General Intelligence 11(2), 41-44. doi:10.2478/jagi-2020-0003.</p> <p>Ramaraj, P., Klenk, M. and Mohan, S. (2020). Understanding Intentions in Human Teaching to Design Interactive Task Learning Robots, RSS 2020 Workshop: AI &amp; Its Alternatives in Assistive &amp; Collaborative Robotics: Decoding Intent.</p> <p>Lindes, P. (2020). Constructing Meaning in Small Increments., Poster presented at CogSci 2020. (Handout),</p> <p>Stearns, B., &amp; Laird, J. E. (2020). Toward Unifying Cognitive Architecture and Neural Task Set Theories, In Proceedings of The 42nd Annual Conference of the Cognitive Science Society (CogSci-20)</p> <p>Gudwin, R., Rohmer, E., Paraense, A., Froes, E., Gibaut, W., Oliveira, I., Rocha, S., Raizer, K., &amp; Feljan, A. V. (2020). The TROCA Project: An autonomous transportation robot controlled by a cognitive architecture, Cognitive Systems Research, vol.\u00a059, pp.\u00a0179-197.</p>","tags":["research"]},{"location":"home/Publications/#2019","title":"2019","text":"<p>Jones, Steven, and John Laird. (2019). Anticipatory Thinking in Cognitive Architectures with Event Cognition Mechanisms, COGSAT@ AAAI Fall Symposium.</p> <p>Kirk, J. R., &amp; Laird, J. E. (2019). Learning hierarchical symbolic representations to support interactive task learning and knowledge transfer, Proceedings of the 28th International Joint Conference on Artificial Intelligence (pp.\u00a06095-6102). AAAI Press.</p> <p>Aaron Mininger and John E. Laird (2019). Using Domain Knowledge to Correct Anchoring Errors in a Cognitive Architecture, Advances in Cognitive Systems.</p> <p>Preeti Ramaraj, Saurav Sahay, Shachi H. Kumar, Walter S. Lasecki and John E. Laird. (2019). Towards using transparency mechanisms to build better mental models , Advances in Cognitive Systems 7th Goal Reasoning Workshop. Boston, MA.</p> <p>Peter Lindes (2019). Predictions of a Model of Language Comprehension Compared to Brain Data , Poster at the 17th International Conference on Cognitive Modeling. Abstract.</p> <p>Aaron Mininger and John E. Laird (2019). Using Domain Knowledge to Correct Anchoring Errors in a Cognitive Architecture , Proceedings of the Seventh Annual Conference on Advances in Cognitive Systems (pp.\u00a01\u201317). Boston, MA.</p> <p>Gluck, K. A. and J. E. Laird, eds.\u00a02019. Interactive Task Learning: Humans, Robots, and Agents Acquiring New Tasks through Natural Interactions , Str\u00fcngmann Forum Reports, vol.\u00a026, J. R. Lupp, series editor. Cambridge, MA: MIT Press.</p>","tags":["research"]},{"location":"home/Publications/#2018","title":"2018","text":"<p>Stocco, A., Laird, J. E., Lebiere, C., Rosenbloom, P. S. (2018). Empirical Evidence from Neuroimaging Data for a Standard Model of the Mind , Proceedings of the 2018 Cognitive Science Conference, Madison, WI.</p> <p>Peter Lindes (2018). The Common Model of Cognition and humanlike language comprehension , Postproceedings of the 9th Annual International Conference on Biologically Inspired Cognitive Architectures.</p> <p>Preeti Ramaraj and John E. Laird (2018). Establishing Common Ground for Learning Robots , RSS 2018: Workshop on Models and Representations for Natural Human-Robot Communication. Pittsburgh, PA.</p> <p>Bryan Stearns and John E. Laird (2018). Modeling Instruction Fetch in Procedural Learning , Proceedings of the 16th International Conference on Cognitive Modelling (ICCM). Madison, WI.</p> <p>Jule Schatz, Steven J. Jones, and John E. Laird (2018). An Architecture Approach to Modeling the Remote Associates Test , Proceedings of the 16th International Conference on Cognitive Modelling (ICCM). Madison, WI.</p> <p>Mininger, A. &amp; Laird J.E. (2018). Interactively Learning a Blend of Goal-Based and Procedural Tasks , National Conference on Artificial Intelligence, AAAI-2018.</p> <p>Laird, J. E., &amp; Mohan, S. (2018). Learning Fast and Slow: Levels of Learning in General Autonomous Intelligent Agents , National Conference on Artificial Intelligence, AAAI-2018. Senior Track, Winner of Blue Sky Award.</p> <p>Gudwin, R., Paraense, A., de Paula, S. M., Froes, E., Gibaut, W., Castro, E., Figueiredo, V., &amp; Raizer, K. (2018). An urban traffic controller using the MECA cognitive architecture, Biologically Inspired Cognitive Architectures.</p>","tags":["research"]},{"location":"home/Publications/#2017","title":"2017","text":"<p>Laird, J. E., Lebiere, C. &amp; Rosenbloom, P. S. (2017). A Standard Model for the Mind: Toward a Common Computational Framework across Artificial Intelligence, Cognitive Science, Neuroscience, and Robotics , AI Magazine 38(4).</p> <p>Lauren Naylor and John E. Laird (2017). Opportunities and Challenges for Incorporating Runtime Ethical Constraints into a Learning Agent . Ann Arbor, Michigan.</p> <p>Ying Zhao, Emily Mooren, and Nate Derbinsky (2017). \\ Reinforcement Learning for Modeling Large-Scale Cognitive Reasoning , Proceedings of the 9th International Joint Conference on Knowledge Discovery, Knowledge Engineering and Knowledge Management, 2, 233-238. Madeira, Portugal.</p> <p>John E. Laird, Kevin Gluck, John Anderson, Kenneth D. Forbus Odest Chadwicke Jenkins, Christian Lebiere, Dario Salvucci, Matthias Scheutz, Andrea Thomaz, Greg Trafton, Robert E. Wray, Shiwali Mohan, and James R. Kirk (2017). Interactive Task Learning , IEEE Intelligent Systems, 32(4), 6-21, (invited).</p> <p>Chien Van Dang, Tin Trung Tran, Ki-Jong Gil, Yong-Bin Shin, Jae-Won Choi, Geon-Soo Park, and Jong-Wook Kim (2017). Application of Soar Cognitive Agent Based on Utilitarian Ethics Theory for Home Service Robots. Proceedings of the 14th International Conference on Ubiquitous Robots and Ambient Intelligence (URAI). Jeju, Korea.</p> <p>Peter Lindes, Aaron Mininger, James R. Kirk, and John E. Laird (2017). Grounding Language for Interactive Task Learning. Proceedings of the 1st Workshop on Language Grounding for Robotics at ACL. (Supplemental Material).</p> <p>Bryan Stearns, Mazin Assanie, John E. Laird (2017). Applying Primitive Elements Theory For Procedural Transfer in Soar. Proceedings of the 15th International Conference on Cognitive Modelling (ICCM). Warwick, UK.</p> <p>Peter Lindes and John E. Laird (2017). Ambiguity Resolution in a Cognitive Model of Language Comprehension. Proceedings of the 15th International Conference on Cognitive Modelling (ICCM). Warwick, UK.</p> <p>Peter Lindes and John E. Laird (2017). Cognitive Modeling Approaches to Language Comprehension Using Construction Grammar. Proceedings of The AAAI Spring Symposium on Computational Construction Grammar and Natural Language Understanding.</p> <p>Emily M. Mooren (2017). Reinforcement learning applications to combat identification. Master\u2019s Thesis. Calhoun: The NPS Institutional Archive.</p> <p>Chien Van Dang, Tin Trung Tran, Trung Xuan Pham, Ki-Jong Gil, Yong-Bin Shin, and Jong-Wook Kim (2017). Implementation of a Refusable Human-Robot Interaction Task with Humanoid Robot by Connecting Soar and ROS. The Journal of Korea Robotics Society, Volume 12, Issue 1.</p>","tags":["research"]},{"location":"home/Publications/#2016","title":"2016","text":"<p>DiFilippo, N. M. (2016). Framework for the automated disassembly of electronic waste using the Soar cognitive architecture , University of Rhode Island.</p> <p>J P\u00e9rez, E Cerezo, FJ Ser\u00f3n (2016). E-VOX: A Socially Enhanced Semantic ECA. Proceedings of the International Workshop on Social Learning and Multimodal Interaction for Designing Artificial Agents. Tokyo, Japan \u2014 November 2016.</p> <p>Kirk, J., Mininger, A., Laird, J. (2016). Learning task goals interactively with visual demonstrations. Biologically Inspired Cognitive Architectures. New York, New York, 2016.</p> <p>Kirk, J. and Laird, J. (2016). Learning General and Efficient Representations of Novel Games Through Interactive Instruction. In Proceedings of the Fourth Annual Conference on Advances in Cognitive Systems. Evanston, Illinois</p> <p>Jones, S. J., Wandzel, A. R., Laird, J. E. (2016). Efficient Computation of Spreading Activation Using Lazy Evaluation. Proceedings of the 14th International Conference on Cognitive Modeling (ICCM). University Park, Pennsylvania</p> <p>Kirk, J., Mininger, A., and Laird, J. E. (2016). A demonstration of interactive task learning , In Proceedings of the Twenty-Fifth International Joint Conference on Artificial Intelligence.</p> <p>Mininger, A., and Laird, J. E. (2016). Interactively Learning Strategies for Handling References to Unseen or Unknown Objects. In Proceedings of the Fourth Annual Conference on Advances in Cognitive Systems.</p> <p>Lindes, Peter and John E. Laird (2016). Toward Integrating Cognitive Linguistics and Cognitive Language Processing. Proceedings of the 14th International Conference on Cognitive Modeling (ICCM). University Park, Pennsylvania.</p> <p>Li, J., Jones, S. J., Mohan, S., Derbinsky, N. (2016). Architectural Mechanisms for Mitigating Uncertainty during Long-Term Declarative Knowledge Access. Proceedings of the 4th Annual Conference on Advances in Cognitive Systems (ACS). Evanston, Illinois.</p>","tags":["research"]},{"location":"home/Publications/#2015","title":"2015","text":"<p>Shiwali Mohan (2015). From Verbs to Tasks: An Integrated Account of Learning Tasks from Situated Interactive Instruction. Ph.D.\u00a0Thesis, University of Michigan, 2015.</p> <p>Mohan, S., Kirk, J., Mininger, A., Laird, J. E., (2015). Agent Requirements for Effective and Efficient Task-Oriented Dialog. AAAI 2015 Fall Symposium Series, 2015.</p> <p>S. Bhattacharyya, J. Davis, T. Vogl, M. Fix, A. McLean, M. Matessa and L. Smith-Velazquez (2015). Enhancing Autonomy with Trusted Cognitive Modeling. Related presentation: Enhancing Autonomy with Trust: Pilot license to the autonomy.</p> <p>Li, J., and Laird, J. E. (2015). Spontaneous Retrieval for Prospective Memory: Effects of Encoding Specificity and Retention Interval. Proceedings of the 13th International Conference on Cognitive Modeling (ICCM). Groningen, The Netherlands.</p> <p>Li, J., and Laird, J. E. (2015). Spontaneous Retrieval from Long-Term Memory in a Cognitive Architecture. Proceedings of the 29th AAAI Conference on Artificial Intelligence (AAAI). Austin, TX.</p>","tags":["research"]},{"location":"home/Publications/#2014","title":"2014","text":"<p>Kirk, J., Laird, J. E. (2014). Interactive task learning for simple games. Advances in Cognitive Systems 3, 11-28.</p> <p>Laird, J. E., Mohan, S. (2014). A case study of knowledge integration across multiple memories in Soar. Biologically Inspired Cognitive Architectures, 8, 93-99.</p> <p>Mohan, S., Laird, J. (2014). Learning Goal-Oriented Hierarchical Tasks from Situated Interactive Instruction. Proceedings of the 27th AAAI Conference on Artificial Intelligence (AAAI).</p> <p>Laird et al.\u00a0(2014). Report on the NSF-funded Workshop on Interactive Task Learning **</p> <p>J.-Y. Puigbo, A. Pumarola, C. Angulo, and Ricardo Tellez (2014). Using a Cognitive Architecture for General-purpose Service Robot Control, Connection Science, Special Issue on AI and Cognition.</p>","tags":["research"]},{"location":"home/Publications/#2013","title":"2013","text":"<p>Joseph Z. Xu (2013). Learning Integrated Relational and Continuous Action Models for Continuous Domains. Ph.D.\u00a0Thesis, University of Michigan, 2013.</p> <p>Mohan, S., Mininger, A., Laird, J. E. (2013). Towards an Indexical model of situated comprehension for real-world cognitive agents. Advances in Cognitive Systems 3, 163-182.</p> <p>Kirk, J. and Laird J. E. (2013). Learning Task Formulations through Situated Interactive Instruction. Proceedings of the 2nd Conference on Advances in Cognitive Systems. Baltimore, Maryland</p> <p>Mohan, S., Mininger, A., Laird J. E. (2013). Towards an Indexical Model of Situated Language Comprehension for Real-World Cognitive Agents. Proceedings of the 2nd Conference on Advances in Cognitive Systems. Baltimore, Maryland</p> <p>Laird, J. E. (2013). Reflections on Abstractions for General Artificial Intelligence, AAAI Fall Symposium on Abstractions for Intelligence, Washington, D.C.</p> <p>Laird, J. E. and Mohan, S. (2013). A Case Study of Knowledge Integration Across Multiple Memories in Soar, AAAI Fall Symposium on Abstractions for Intelligence, Washington, D.C.</p> <p>Gunetti, P., Dodd, T., Thompson, H. (2013). Simulation of a Soar-Based Autonomous Mission Management System for Unmanned Aircraft, Journal of Aerospace Computing, Information, and Communication, Vol. 10,</p> <p>No.\u00a02, pp.\u00a053-70. AIAA link</p> <p>Li, J., Laird, J. (2013). The Computational Problem of Prospective Memory. Proceedings of the 17th International Conference on Cognitive Modeling. Ottawa, Canada</p> <p>Li, J., Laird, J. (2013). Preemptive Strategies for Overcoming the Forgetting of Goals. Proceedings of the 27th AAAI Conference on Artificial Intelligence. Bellevue, WA.</p> <p>Mohan, S., Kirk, J., Laird, J. (2013). A Computational Model of Situated Task Learning with Interactive Instruction. Proceedings of the 12th International Conference on Cognitive Modeling. Ottawa, Canada.</p> <p>Xu, J. Z., Laird, J. E. (2013). Learning Integrated Symbolic and Continuous Action Models for Continuous Domains. Proceedings of the 27th AAAI Conference on Artificial Intelligence. Bellevue, WA.</p>","tags":["research"]},{"location":"home/Publications/#2012","title":"2012","text":"<p>Derbinsky, N., Essl, G. (2012). Exploring Reinforcement Learning for Mobile Percussive Collaboration. Proceedings of the 12th International Conference on New Interfaces for Musical Expression (NIME). Ann Arbor, MI, USA.</p> <p>Derbinsky, N., Laird, J. E. (2012). Competence-Preserving Retention of Learned Knowledge in Soar\u2019s Working and Procedural Memories. Proceedings of the 11th International Conference on Cognitive Modeling (ICCM). Berlin, Germany.</p> <p>Derbinsky, N., Laird, J. E. (2012). Computationally Efficient Forgetting via Base-Level Activation. Proceedings of the 11th International Conference on Cognitive Modeling (ICCM). Berlin, Germany.</p> <p>Derbinsky, N., Li, J., Laird, J. E. (2012). A Multi-Domain Evaluation of Scaling in a General Episodic Memory. Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI). Toronto, Canada.</p> <p>Derbinsky, N., Li, J., Laird, J. E. (2012). Algorithms for Scaling in a General Episodic Memory (Extended Abstract). Proceedings of the 11th International Conference on Autonomous Agents and Multiagent Systems (AAMAS). Valencia, Spain.</p> <p>Laird, J. E., Kinkade, K. R., Mohan, S., and Xu, J. Z. (2012). Cognitive Robotics using the Soar Cognitive Architecture, 8th International Conference on Cognitive Robotics, (Cognitive Robotics Workshop, Twenty-Sixth Conference on Artificial Intelligence (AAAI-12)), Toronto, CA.</p> <p>Laird, J. E., Derbinsky, N. and Tinkerhess, M. (2012). Online Determination of Value-Function Structure and Action-value Estimates for Reinforcement Learning in a Cognitive Architecture, Advances in Cognitive Systems, Volume 2, December 2012, Palo Alto, California.</p> <p>Laird, J.E.: The Soar Cognitive Architecture, 2012, MIT Press.</p> <p>Laird, J.E. (2012). The Soar Cognitive Architecture, AISB Quarterly, \\#134.</p> <p>Li, J., Derbinsky, N., Laird, J. E. (2012). Functional Interactions between Memory and Recognition Judgments. Proceedings of the 26th AAAI Conference on Artificial Intelligence (AAAI). Toronto, Canada.</p> <p>Mohan, S. and Laird, J. E. (2012). Exploring Mixed-Initiative Interaction for Learning with Situated Instruction in Cognitive Agents, In Proceedings of the 26th AAAI Conference on Artificial Intelligence. (Extended Abstract).</p> <p>Mohan, S., and Laird, J. E.(2012). Situated Comprehension of Imperative Sentences in Embodied, Cognitive Agents, In The AAAI 2012 Workshop on Grounding Language for Physical Systems, Toronto CA.</p> <p>Mohan, S., Mininger, A., Kirk, J. and Laird, J. E. (2012). Acquiring Grounded Representations of Words with Situated Interactive Instruction, Advances in Cognitive Systems, Volume 2, December 2012, Palo Alto, California.</p> <p>Mohan, S., Mininger, A., Kirk, J. and Laird, J. E. (2012). Learning Grounded Language through Situated Interactive Instruction, In Papers from Robots Learning Interactively from Human Teachers (AAAI Fall Symposium Series), November 2012, Washington D.C.</p> <p>Nuxoll, A. M. Laird, J. E. (2012). Enhancing Intelligent Agents with Episodic Memory, Cognitive systems Research, 17-18,34-48.</p> <p>Shiquan Zhong, Hongwei Ma, Lizhen Zhou, Xuelian Wang, Shoufeng Ma, and Ning Jia (2012). Guidance Compliance Behavior on VMS Based on SOAR Cognitive Architecture. Mathematical Problems in Engineering, vol.\u00a02012, Article ID 530561, 21 pages.</p> <p>Stenger A., Fernando B., Heni M. (2012). Autonomous Mission Planning for UAVs: A Cognitive Approach, Proceedings des Deutschen Luft- und Raumfahrtkongress, Berlin, 10.09.-12.09.2012.</p> <p>Stensrud, B., Purcel, E., Fragomeni, G., Woods, A., Wintermute, S., and Garrity, P. (2012), No More Zombies! High-Fidelity Character Autonomy for Virtual Small-Unit Training, Proceedings of the Interservice/Industry Training, Simulation and Education Conference (I/ITSEC) 2012, Orlando, FL, December 3-6, 2012.</p> <p>Wintermute, S. (2012). Imagery in Cognitive Architecture: Representation and Control at Multiple Levels of Abstraction , Cognitive Systems Research, 19-20,1-29.</p>","tags":["research"]},{"location":"home/Publications/#2011","title":"2011","text":"<p>Derbinsky, N., Essl, G.: Cognitive Architecture in Mobile Music Interactions. Proceedings of the International Conference on New Interfaces for Musical Expression, 104-107. Oslo, Norway.</p> <p>Derbinsky, N., Laird, J. E.: A Functional Analysis of Historical Memory Retrieval Bias in the Word Sense Disambiguation Task. Proceedings of the 25th AAAI Conference on Artificial Intelligence, 663-668. San Francisco, CA.</p> <p>Derbinsky, N., Laird, J. E.: Effective and Efficient Management of Soar\u2019s Working Memory via Base-Level Activation. Papers from the 2011 AAAI Fall Symposium Series: Advances in Cognitive Systems. Arlington, VA.</p> <p>Derbinsky, N., Laird, J. E.: A Preliminary Functional Analysis of Memory in the Word Sense Disambiguation Task. Proceedings of the 2nd Symposium on Human Memory for Artificial Agents, AISB, 25-29. York, England.</p> <p>Gorski, N. A., Laird, J. E. (2011) Learning to use episodic memory Cognitive Systems Research, 12, 144-153. doi:10.1016/j.cogsys.2010.08.001</p> <p>Laird, J. E., Derbinsky, N. Tinkerhess, M.: A Case Study in Integrating Probabilistic Decision Making and Learning in a Symbolic Cognitive Architecture: Soar Plays Dice. Papers from the 2011 AAAI Fall Symposium Series: Advances in Cognitive Systems. Arlington, VA.</p> <p>Laird, J. E., Derbinsky, N., Voigt, J. (2011). Performance Evaluation of Declarative Memory Systems in Soar, Proceedings of the 20th Behavior Representation in Modeling &amp; Simulation Conference, 33-40. Sundance, UT.</p> <p>Li, J., Laird, J. E.: Preliminary Evaluation of Long-term Memories for Fulfilling Delayed Intentions. Papers from the 2011 AAAI Fall Symposium Series: Advances in Cognitive Systems. Arlington, VA.</p> <p>Mohan, S., Laird, J. E. (2011).An Object-Oriented Approach to Reinforcement Learning in an Action Game, Proceedings of 7th the Artificial Intelligence for Interactive Digital Entertainment Conference, AIIDE 2011</p> <p>Mohan, S., Laird, J. E. (2011).Towards Situated, Interactive, Instructable Agents in a Cognitive Architecture, Papers from the 2011 AAAI Fall Symposium Series: Advances in Cognitive Systems. Arlington, VA.</p> <p>Wang, Y. (2011). Hierarchical Functional Category Learning for Efficient Value Function Approximation in Object-Based Environments. PhD Thesis, University of Michigan</p> <p>Xu, J. Z., Laird, J. E. (2011). Combining Learned Discrete and Continuous Action Models. Proceedings of the 25th AAAI Conference on Artificial Intelligence. San Francisco, CA.</p> <p>Lathrop, S., Wintermute, S., Laird, J. E. (2011). Exploring the Functional Advantages of Spatial and Visual Cognition From an Architectural Perspective. Topics in Cognitive Science 3, 796\u2013818.</p>","tags":["research"]},{"location":"home/Publications/#2010","title":"2010","text":"<p>Derbinsky, N., Gorski, N.A.: Exploring the Space of Computational Memory Models. Proceedings of the 1st Symposium on Human Memory for Artificial Agents, AISB, 38-41. Leicester, England.</p> <p>Derbinsky, N., Laird, J. E., Smith, B.: Towards Efficiently Supporting Large Symbolic Declarative Memories. Proceedings of the 10th International Conference on Cognitive Modeling, 49-54. Philadelphia, PA.</p> <p>Derbinsky, N., Laird, J.E.: Extending Soar with Dissociated Symbolic Memories. Proceedings of the 1st Symposium on Human Memory for Artificial Agents, AISB, 31-37. Leicester, England.</p> <p>Gunetti, Dodd, Thompson, A Software Architecture for Autonomous Mission Management and Control, American Institute of Aeronautics and Astronautics, AIAA InfoTech? Aerospace Conference 2010, Paper No.\u00a02010-3305</p> <p>Gunetti, Thompson, Development and Evaluation of a Multi-Agent System for Gas-Turbine Engine Health Management, Automatic Control in Aerospace Online Journal, Year 3, Number 1, May 2010</p> <p>Laird, J. E., Wray III, R. E. (2010). Cognitive Architecture Requirements for Achieving AGI. Proceedings of the Third Conference on Artificial General Intelligence (AGI)</p> <p>Laird, J. E., Xu, J. Z., and Wintermute, S. (2010). Using Diverse Cognitive Mechanisms for Action Modeling. Proceedings of the Tenth International Conference on Cognitive Modeling, Philadelphia, PA.</p> <p>Wang, Y., Laird, J. E. (2010). Efficient Value Function Approximation with Unsupervised Hierarchical Categorization for a Reinforcement Learning Agent. International Conference on Intelligent Agent Technology (IAT-10), Toronto. (Best Paper Award Nomination)</p> <p>Wang, Y., Laird, J. E. (2010). A Computational Model of Functional Category Learning in a Cognitive Architecture. Proceedings of the Tenth International Conference on Cognitive Modeling (ICCM-10), Philadelphia, PA.</p> <p>Wintermute, S. (2010). Using Imagery to Simplify Perceptual Abstraction in Reinforcement Learning Agents. Proceedings of the Twenty-Fourth AAAI Conference on Artificial Intelligence (AAAI-10), Atlanta, Georgia</p> <p>Wintermute, S. (2010). Abstraction, Imagery, and Control in Cognitive Architecture. PhD Thesis, University of Michigan, Ann Arbor.</p> <p>Xu, J. Z., Laird, J. E. (2010). Instance-Based Online Learning of Deterministic Relational Action Models. Proceedings of the 24th AAAI Conference on Artificial Intelligence. Atlanta, GA.</p>","tags":["research"]},{"location":"home/Publications/#2009","title":"2009","text":"<p>Bloch, M.K. Hierarchical Reinforcement Learning in the Taxicab Domain. (Report No.\u00a0CCA-TR-2009-02). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan. (2009)</p> <p>Derbinsky, N., Laird, J.E.: Efficiently Implementing Episodic Memory. Proceedings of the 8th International Conference on Case-Based Reasoning, 403-417. Seattle, WA.</p> <p>Fridman, N. &amp; Kaminka, G.A. (2009). Comparing Human and Synthetic Group Behaviors: A Model Based on Social Psychology. Proceedings of the 9th International Conference on Cognitive Modeling (ICCM-09). Manchester, UK.</p> <p>Gorski, N.A., and Laird, J.E. (2009). Evaluating Evaluations: A Comparative Study of Metrics for Comparing Learning Performances (Report No.\u00a0CCA-TR-2009-05). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan.</p> <p>Gorski, N.A. &amp; Laird, J.E. (2009). Learning to Use Episodic Memory. Proceedings of the 9th International Conference on Cognitive Modeling (ICCM-09). Manchester, UK.</p> <p>Jones, R.M., Stensrud, B.S. and Taylor, G. (2009), Knowledge-Rich Intelligent Agents for Special Operations Forces (SOF) TrainingProceedings of the 2009 Special Operations Forces Industry Conference (SOFIC), Tampa, FL. June 2-4, 2009.</p> <p>Laird, J.E. (2009). Towards Cognitive Robotics, SPIE Defense and Sensing Conferences, Orlando, FL.</p> <p>Laird, J.E., Derbinsky, N.: A Year of Episodic Memory. Proceedings of the Workshop on Grand Challenges for Reasoning from Experiences, IJCAI, 7-10. Pasadena, CA.</p> <p>Laird, J.E., Wray, R.E., Marinier, R.P., Langley, P. (2009) Claims and Challenges in Evaluating Human-Level Intelligent Systems, Proceedings of the Second Conference on Artificial General Intelligence.</p> <p>Langley, P., Laird, J.E., &amp; Rogers, S. (2009). Cognitive architectures: Research issues and challenges. Cognitive Systems Research 10, 141-160.</p> <p>Lonsdale, D., McGhee, J., Hendrickson, R. &amp; Christensen, C. (2009). Incremental Processing and Resource Usage. Proceedings of the 9th International Conference on Cognitive Modeling (ICCM-09). Manchester, UK.</p> <p>Mohan, S., Laird, J.E.: Learning to Play Mario. (Report No.\u00a0CCA-TR-2009-03). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan. (2009)</p> <p>Rosenbloom, P.S. (2009). Towards a New Cognitive Hourglass: Uniform Implementation of a Cognitive Architecture via Factor Graphs.Proceedings of the 9th International Conference on Cognitive Modeling (ICCM-09). Manchester, UK.</p> <p>Wintermute, S. (2009). Integrating Reasoning and Action through Simulation. In Proceedings of the Second Conference on Artificial General Intelligence (AGI-09). Arlington, VA.</p> <p>Wintermute, S. (2009). An Overview of Spatial Processing in Soar/SVS (Report No.\u00a0CCA-TR-2009-01). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan.</p> <p>Wintermute, S. (2009). Representing Problems (and Plans) Using Imagery In Papers from the 2009 AAAI Fall Symposium Series: Multi-Representational Architectures for Human-Level Intelligence, Arlington, VA, November 2009. AAAI Press.</p> <p>Wintermute, S., and Laird, J.E. (2009). Imagery as Compensation for an Imperfect Abstract Problem Representation. In Proceedings of The 31st Annual Conference of the Cognitive Science Society (CogSci-09)</p> <p>Xu, J., Wintermute, S., Wang, Y. J., Laird, J. Transferring Learned Search Heuristics (Report No.\u00a0CCA-TR-2009-04). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan. (2009)</p>","tags":["research"]},{"location":"home/Publications/#2008","title":"2008","text":"<p>Gunetti, P., Thompson, H.: A Soar-Based Planning Agent for Gas-Turbine Engine Control and Health Management, Proceedings of the 17th IFAC World Congress, 2008, Volume \\# 17, part 1.</p> <p>Gunetti, Mills, Thompson, A Distributed Intelligent Agent architecture for Gas-Turbine Engine Health Monitoring, Proceedings of the 46th AIAA Aerospace Sciences Meeting and Exhibit, Reno, NV, 2008</p> <p>Laird, J. E. (2008). Extending the Soar Cognitive Architecture. In Proceedings of the First Conference on Artificial General Intelligence (AGI-08).</p> <p>Marinier, R. and Laird, J. E. (2008). Emotion-Driven Reinforcement Learning. CogSci 2008, Washington, D.C.</p> <p>Marinier, R., Laird, J. E., and Lewis, R. L. (2008). A Computational Unification of Cognitive Behavior and Emotion. Journal of Cognitive Systems Research.</p> <p>Stensrud, B., Taylor, G., Schricker, B., Montefusco, J. and Maddox, J. (2008), An Intelligent User Interface for Enhancing Computer Generated Forces Proceedings of the 2008 Fall Simulation Interoperability Workshop (SIW), Orlando, FL, September 15-19, 2008.</p> <p>Wintermute, S. and Laird, J. E. (2008). Bimodal Spatial Reasoning with Continuous Motion. Proceedings of the Twenty-Third AAAI Conference on Artificial Intelligence (AAAI-08), Chicago, Illinois</p> <p>Wintermute, S. and Lathrop, S.D. AI and Mental Imagery. In Papers from the 2008 AAAI Fall Symposium Series: Naturally Inspired AI, Arlington, VA, November 2008. AAAI Press.</p>","tags":["research"]},{"location":"home/Publications/#2007","title":"2007","text":"<p>Cohen, M. A., Ritter, F. E., Haynes, S. R. (2007). Using Reflective Learning to Master Opponent Strategy in a Competitive Environment.Proceedings of the Eighth International Conference on Cognitive Modeling. Ann Arbor, MI.</p> <p>Gorski, N. A. and Laird, J. E. (2007). Investigating Transfer Learning in the Urban Combat Testbed. (Report No.\u00a0CCA-TR-2007-02). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan.</p> <p>Hogewoning, E., Broekens, J., Eggermont, J., Bovenkamp, E.G.P. Strategies for Affect-Controlled Action-Selection in Soar-RL. Proceedings of the 2nd. International Work-Conference on the Interplay between Natural and Artificial Computation (IWINAC), 2007. Murcia, Spain. LNCS 4528 (pp.\u00a0501-510), Springer.</p> <p>Jones, R. M., Lebiere, C., &amp; Crossman, J. A. (2007). Comparing modeling idioms in ACT-R and Soar. Proceedings of the Eighth International Conference on Cognitive Modeling. Ann Arbor, MI.</p> <p>Lathrop, S.D., and Laird, J.E. (2007). Towards Incorporating Visual Imagery into a Cognitive Architecture. Proceedings of the Eighth International Conference on Cognitive Modeling. Ann Arbor, MI.</p> <p>Magerko, B. Evaluating Preemptive Story Direction in the Interactive Drama Architecture. Journal of Game Development, vol.\u00a03, 2007. In press.</p> <p>Marinier, R.P., Laird, J.E. 2007. Computational Modeling of Mood and Feeling from Emotion. CogSci 2007. Nashville, TN.</p> <p>Nuxoll, A. M. and Laird, J. E. (2007). Extending Cognitive Architecture with Episodic Memory. In Proceedings of the 22nd National Conference on Artificial Intelligence (AAAI).</p> <p>Pearson, D., Gorski, N. A., Lewis, R. L., and Laird, J. E. (2007). Storm: A Framework for Biologically-Inspired Cognitive Architecture Research.Proceedings of the 8th International Conference on Cognitive Modeling. Ann Arbor, MI.</p> <p>Taylor, G., Stensrud, B., Eitelman, S. and Dunham, C. (2007), Towards Automating Airspace Management, Proceedings of the Computational Intelligence for Security and Defense Applications (CISDA) Conference, Honolulu, Hi. April 1-5, 2007.</p> <p>Wang, Y., and Laird, J.E. 2007. The Importance of Action History in Decision Making and Reinforcement Learning.</p> <p>Wintermute, S. and Laird, J.E. Predicate Projection in a Bimodal Spatial Reasoning System. Proceedings of the Twenty-Second AAAI Conference on Artificial Intelligence (AAAI-07), Vancouver, Canada</p> <p>Wintermute, S., Xu, J., and Laird, J.E. SORTS: A Human-Level Approach to Real-Time Strategy AI. Proceedings of the Third Artificial Intelligence and Interactive Digital Entertainment Conference (AIIDE-07), Stanford, California</p> <p>Wintermute, S., Xu, J., Irizarry, J. 2007. SORTS: Integrating Soar with a Real-Time Strategy Game (Report No.\u00a0CCA-TR-2007-01). Ann Arbor, MI: Center for Cognitive Architecture, University of Michigan.</p> <p>Yakir, A., and Kaminka, G. (2007). An Integrated Development Environment and Architecture for Soar-Based Agents. Nineteenth Innovative Applications of Artificial Intelligence Conference (IAAI-07), Vancouver, B.C., Canada.</p>","tags":["research"]},{"location":"home/Publications/#2006","title":"2006","text":"<p>Gorski, N.A., and Laird, J.E. Experiments in Transfer Across Multiple Learning Mechanisms. Proceedings of the ICML-06 Workshop on Structural Knowledge Transfer for Machine Learning. Pittsburgh, PA.</p> <p>Jones, R. M., &amp; Wray, R. E. (2006). Comparative analysis of frameworks for knowledge-intensive agents. AI Magazine 27 (2), 45-56.</p> <p>Jones, R. M., Crossman, J. A., Lebiere, C., &amp; Best, B. J. (2006). An abstract language for cognitive modeling. Proceedings of the Seventh International Conference on Cognitive Modeling. Trieste, Italy: Edizioni Goliandiche.</p> <p>Kennedy, W.G., and Trafton, J.G. Long-Term Learning in Soar and ACT-R. Proceedings of the Seventh International Conference on Cognitive Modeling, (pp 162-168). Trieste, Italy: Edizioni Goliardiche.</p> <p>Konik, T., and Laird, J. 2006. Learning Goal Hierarchies from Structured Observations and Expert Annotations, Machine Learning. 64(1-3) 263-287.</p> <p>Lathrop, S., and Laird, J.E. 2006. Incorporating Visual Imagery into a Cognitive Architecture: An Initial Theory, Design and Implementation.</p> <p>Magerko, B., Stensrud, B., and Holt, L. Bringing the Schoolhouse Inside the Box - A Tool for Engaging, Individualized Training. 25th Army Science Conference, 2006. Orlando, FL.</p> <p>Marinier, R. and Laird, J. A Cognitive Architecture Theory of Comprehension and Appraisal. To be presented at Agent Construction and Emotion 2006, Vienna, Austria, April 2006.</p> <p>Ritter, F.E., Haynes, S. R., Cohen, M., Howes, A., John, B., Best, B., Lebiere, C., Jones, R. M., Crossman, J., Lewis, R. L., St.\u00a0Amant, R., McBride, S. P., Urbas, L., Leuchter, S., &amp; Vera, A. (2006). High-level behavior representation languages revisited. In /Proceedings of the Seventh International Conference on Cognitive Modeling,/ 404-407. Trieste, Italy: Edizioni Goliandiche.</p> <p>Rosenbloom, R. 2006, A Cognitive Odyssey: From the Power Law of Practice to a General Learning Mechanism and Beyond, in Tutorials in Quantitative Methods for Psychology, 2(2) 6-14.</p> <p>Stensrud, B., Taylor, G. and Crossman, J., (2006) IF-Soar: A Virtual, Speech-Enabled Agent for Indirect Fire Training, Proceedings of the 25th Army Science Conference, Orlando, FL.</p> <p>Wang, Y., and Laird, J.E. 2006. Integrating Semantic Memory into a Cognitive Architecture.</p>","tags":["research"]},{"location":"home/Publications/#2005","title":"2005","text":"<p>Chong, R.S., Wray, R.E. Inheriting constraint in hybrid cognitive architectures: Appyling the EASE architecture to performance and learning in a simplified air traffic control task. In K. Gluck and R. Pew, eds, Modeling Human Behavior with Integrated Cognitive Architectures: Comparison, Evaluation, and Validation, 237\u2013304. Lawrence Erlbaum Associates, 2005.</p> <p>Jones, R. M. (2005). An introduction to cognitive architectures for modeling and simulation. /Proceedings of the Interservice/Industry Training/Simulation and Education Conference 2005./ Orlando, FL.</p> <p>Magerko, B, Wray, RE, Holt, LS, Stensrud, B. Customizing interactive training through individualized content and increased engagement. In Proceedings of the Interservice/Industry Training, Simulation and Education Conference (I/ITSEC) 2005, Orlando, FL, Dec 2005. National Training Systems Association.</p> <p>Magerko, B. Story Representation and Interactive Drama. 1st Artificial Intelligence and Interactive Digital Entertainment Conference, 2005. Marina Del Rey, CA.</p> <p>Nason, S. and Laird, J. E. (2005). Soar-RL: Integrating Reinforcement Learning with Soar. Cognitive Systems Research, 6, 51-59.</p> <p>Pearson, D.J., Laird, J.E. Incremental Learning of Procedural Planning Knowledge in Challenging Environments. To appear in special issue of Computational Intelligence on \u201cLearning to Improve Reasoning\u201d.</p> <p>Wallace, S. A. S-Assess: A Library for Self-Assessment. In Proceedings of the Fourth International Conference on Autonomous Agents and Multiagent Systems (AAMAS-05). pp.\u00a0256-263. Utrecht, The Netherlands. 2005.</p> <p>Wray, R.E., Chong, R.S. Comparing cognitive models and human behavior representations: Computational tools for expressing human behavior. Proceedings of the Infotech@Aerospace 2005 Conference, Arlington, VA, Sep 2005. American Institute of Aeronautics and Astronautics.</p> <p>Wray, R.E., Jones, R.M. An introduction to Soar as an agent architecture. In, R. Sun (ed), Cognition and Multi-agent Interaction: From Cognitive Modeling to Social Simulation, Cambridge University Press, pp 53\u201378, 2005.</p> <p>Wray, R.E., Laird, J.E., Nuxoll, A., Stokes, D., Kerfoot, A. Synthetic adversaries for urban combat training. AI Magazine, 26(3):82\u201392, 2005.</p>","tags":["research"]},{"location":"home/Publications/#2004","title":"2004","text":"<p>Bovenkamp, E.G.P., Dijkstra, J., Bosch, J.G., and J.H.C. Reiber (2004). Multi-Agent segmentation of IVUS images. Pattern Recognition, 37, 647-663.</p> <p>Crossman, J., Wray, R. E., Jones, R. M., &amp; Lebiere, C. (2004). A High Level Symbolic Representation for Behavior Modeling. Paper presented at the 2004 Behavioral Representation in Modeling and Simulation, Arlington, VA.</p> <p>Jones, R. M. (2004). An introduction to cognitive architectures for modeling and simulation. /Proceedings of the Interservice/Industry Training/Simulation and Education Conference 2004./ Orlando, FL.</p> <p>Jones, R. M., &amp; Wray, R. E. (2004). Comparative Analysis of Frameworks for Knowledge-Intensive Intelligent Agents. Paper presented at the AAAI Fall Symposium Series on Achieving Human-level Intelligence through Integrated Systems and Research, Alexandria, VA.</p> <p>Jones, R. M., &amp; Wray, R. E. (2004). Toward an abstract machine architecture for intelligence. /Proceedings of the 2004 AAAI Workshop on Intelligent Agent Architectures: Combining the Strengths of Software Engineering and Cognitive Systems/.</p> <p>Jones, R. M., &amp; Wray, R. E. (2004). Toward an abstract machine architecture for intelligence. Paper presented at the AAAI Workshop on Intelligent Agent Architectures: Combining the Strengths of Software Engineering and Cognitive Systems, San Jose, CA.</p> <p>Jones, R. M., Wallace, A. J., &amp; Wessling, J. (2004). An intelligent synthetic wingman for army rotary wing aircraft. /Proceedings of the Interservice/Industry Training/Simulation and Education Conference 2004./ Orlando, FL.</p> <p>Konik, T., and Laird, J. (2004). Learning Goal Hierarchies from Structured Observations and Expert Annotations. In 14th International Conference on Inductive Logic Programming (ILP-2004), Lecture Notes in AI 3194. Springer</p> <p>Magerko, B. and Laird, J.E. Mediating the Tension Between Plot and Interaction. AAAI Workshop Series: Challenges in Game Artificial Intelligence, 2004. San Jose, California, 108-112.</p> <p>Magerko, B., Laird, J. E., Assanie, M., Kerfoot, A., Stokes, D., AI Characters and Directors for Interactive Computer Games, Proceedings of the 2004 Innovative Applications of Artificial Intelligence Conference, San Jose, CA, July 2004. AAAI Press.</p> <p>Marinier, R. and Laird, J. E. (2004). Towards a Comprehensive Computational Model of Emotions and Feelings. International Conference on Cognitive Modelling.</p> <p>Nason, S. and Laird, J. E., Soar-RL, Integrating Reinforcement Learning with Soar, International Conference on Cognitive Modeling, 2004.</p> <p>Nuxoll, A., Laird, J. E., A Cognitive Model of Episodic Memory Integrated With a General Cognitive Architecture, International Conference on Cognitive Modeling 2004.</p> <p>Nuxoll, A., Laird, J., James, M. Comprehensive Working Memory Activation in Soar. International Conference on Cognitive Modeling, Poster, 2004.</p> <p>Pearson, D. J., Laird, J. E. Redux: Example-Driven Diagrammatic Tools for Rapid Knowledge Acquisition, Proceedings of Behavior Representation in Modeling and Simulation, 2004, Washington, D.C.</p> <p>Taylor, G., &amp; Wray, R. E. (2004). Behavior Design Patterns: Engineering Human Behavior Models. Paper presented at the 2004 Behavioral Representation in Modeling and Simulation Conference, Arlington, VA.</p> <p>Wray, R. E., Laird, J. E., Nuxoll, A., Stokes, D., Kerfoot, A., Synthetic Adversaries for Urban Combat Training, Proceedings of the 2004 Innovative Applications of Artificial Intelligence Conference, San Jose, CA, July 2004. AAAI Press.</p> <p>Wray, R. E., Lisse, S., and Beard, J. Investigating ontology infrastructures for execution-oriented autonomous agents. Papers from the 2004 AAAI Spring Symposium Series: Knowledge Representation and Ontology for Autonomous Systems, Stanford, CA, March 2004. AAAI Press.</p>","tags":["research"]},{"location":"home/Publications/#2003","title":"2003","text":"<p>Biddle, E. S., Henninger, A., Franceschini, R., &amp; Jones, R. M. (2003). Emotion modeling to enhance behavior representation: A survey of approaches. /Proceedings of the Interservice/Industry Training/Simulation and Education Conference 2003. /Orlando, FL.</p> <p>Chong, R. S., and Wray, R. E. RULEX-EM: Incorporating exemplars and memory effects in a hypothesis-testing model of category learning. Proceedings of the First European Cognitive Science Conference, Osnabrueck, Germany, Sep 2003. Lawrence Erlbaum Associates.</p> <p>Henninger, A. E., Jones, R. M., &amp; Chown, E. (2003). Behaviors that emerge from emotion and cognition: Implementation and evaluation of a symbolic-connectionist architecture. /Proceedings of the Seventh International Conference on Autonomous Agents/.</p> <p>Jones, R. M., &amp; Wray, R. E., III. (2003). Design principles for heavy intelligent agents. /Proceedings of the Seventh International Conference on Autonomous Agents/. Melbourne, Australia.</p> <p>Kennedy, W.G., and De Jong, K.A. Characteristics of long-term learning in Soar and its application to the utility problem. In Proceedings of the fifth international conference on machine learning (pp.\u00a0337-344). Menlo Park: AAAI Press.</p> <p>Magerko, B. and Laird, J. \u201cBuilding an Interactive Drama Architecture\u201d 1st International Conference on Technologies for Interactive Digital Storytelling and Entertainment, Darmstadt, Germany, March 2003.</p> <p>Pearson, D. J., Laird, J. E. \u201cExample-driven Diagrammatic Tools For Rapid Knowledge Acquisition\u201d, Visualizing Information in Knowledge Engineering (2003). A workshop at K-CAP 2003 (Second International Conference on Knowledge Capture). Oct 2003.</p> <p>Wallace, S. Validating Complex Agent Behavior, Ph.D.\u00a0Thesis University of Michigan, Ann Arbor, MI, 2003.</p> <p>Wallace. S. A., Laird, J. E. Comparing Agents and Humans Using Behavioral Bounding. International Joint Conference on Artificial Intelligence (IJCAI-03).</p> <p>Wray, R.E., and Chong, R. S. Quantitative Explorations of Category Learning using Symbolic Concept Acquisition. Proceedings of the 5th International Conference on Cognitive Modeling. Bamberg, Germany. April, 2003.</p> <p>Wray, R.E., Laird, J. E. (2003) \u201cVariability in Human Behavior Modeling for Military Simulations\u201d, Behavior Representation in Modeling and Simulation Conference. Scottsdale, AZ.</p> <p>Wray, R.E., Laird, J. E. An architectural approach to consistency in hierarchical execution. Journal of Artificial Intelligence Research. 19. 355\u2013398. 2003.</p>","tags":["research"]},{"location":"home/Publications/#2002","title":"2002","text":"<p>Chown, E., Jones, R. M., &amp; Henninger, A. E. (2002). An architecture for emotional decision-making agents. /Proceedings of the Sixth International Conference on Autonomous Agents./ Bologna, Italy.</p> <p>Henninger, A. E., Jones, R. M., &amp; Chown, E. (2002). Behaviors that emerge from emotion and cognition: A first evaluation. /Proceedings of the Interservice/Industry Training /Simulation and Education Conference 2002/. Orlando, FL.</p> <p>Jones, R. M., Henninger, A. E., &amp; Chown, E. (2002). Interfacing behavior moderators with intelligent synthetic forces. /Proceedings of the Eleventh Conference on Computer Generated Forces and Behavior Representation./ Orlando, FL.</p> <p>Laird, J.E., Assanie, M., Bachelor, B., Benninghoff, N., Enam, S., Jones, B., Kerfoot, A., Lauver, C., Magerko, B., Sheiman, J. Stokes, D. Wallace, S. A Testbed for Developing Intelligent Synthetic Characters. In Artificial Intelligence and Interactive Entertainment: Papers from the 2002 AAAI Spring Symposium, 2002. Menlo Park, CA.</p> <p>Taylor, G. E., Jones, R. M., Goldstein, M. and Frederiksen, R. and Wray, R. E. VISTA: A Generic Toolkit for Visualizing Agent Behavior. Proceedings of the Eleventh Conference on Computer Generated Forces and Behavioral Representation. Institute for Simulation and Training. pp.\u00a0157\u2013167. May 2002.</p> <p>Wray, R. E., Beisaw, J. C., Jones, R. M., Koss, F. V., Nielsen, P. E. and Taylor, G. E. General, maintainable, extensible communications for computer generated forces. Proceedings of the Eleventh Conference on Computer Generated Forces and Behavioral Representation. Institute for Simulation and Training. pp.\u00a0563\u2013570. May 2002.</p> <p>Wray, R. E., Laird, J. E., Nuxoll, A., &amp; Jones, R. M. (2002). Intelligent opponents for virtual reality trainers. /Proceedings of the Interservice/Industry Training /Simulation and Education Conference 2002/. Orlando, FL.</p> <p>Zachary, W., Jones, R. M., &amp; Taylor, G. (2002). How to communicate to users what is inside a cognitive model. /Proceedings of the Eleventh Conference on Computer Generated Forces and Behavior Representation./ Orlando, FL.</p>","tags":["research"]},{"location":"home/Publications/#2001","title":"2001","text":"<p>Henninger, A. E., Jones, R. M., &amp; Chown, E. (2001). A symbolic-connectionist framework for representing emotions in computer generated forces. /Proceedings of the Interservice/Industry Training /Simulation and Education Conference 2001/. Orlando, FL.</p> <p>Jones, R. M., Chown, E., &amp; Henninger, A. E. (2001). A hybrid symbolic-connectionist approach to modeling emotions. /Emotional and intelligent II: The tangled knot of social cognition, /papers from the 2001 Fall symposium (Technical Report no. FS-01-02). Menlo Park, CA: AAAI Press.</p> <p>Wray, R. E. and Jones, R. M. Resolving contentions between initial and learned knowledge. In Proceedings of the 2001 International Conference on Artificial Intelligence, Las Vegas, NV, June 2001.</p>","tags":["research"]},{"location":"home/Publications/#2000","title":"2000","text":"<p>Jones, R. M., &amp; Kenny, P. G. (2000). Lessons learned from integrating STOW technology into an operational naval environment. /Proceedings of the 2000 Spring Simulation Interoperability Workshop/. Orlando, FL.</p> <p>Nielsen, P. E., Koss, F. V., Taylor, G. E., &amp; Jones, R. M. (2000). Communication with intelligent agents. /Proceedings of the Interservice/Industry Training Simulation and Education Conference 2000 /(pp.\u00a0824-834). Orlando, FL.</p>","tags":["research"]},{"location":"home/Publications/#1999","title":"1999","text":"<p>Jones, R. M. (1999). Graphical visualization of situational awareness and mental state for intelligent computer-generated forces. /Proceedings of the Eighth Conference on Computer Generated Forces and Behavioral Representation/, 219-222. Orlando, FL.</p> <p>Jones, R. M., Laird, J. E., Nielsen, P. E., Coulter, K. J., Kenny, P., &amp; Koss, F. V. (1999). Automated intelligent pilots for combat flight simulation. /AI Magazine, 20/(1), 27-41.</p> <p>Ritter, F. E., Jones, R. M., &amp; Baxter, G. D. (1999). Reusable models and graphical interfaces: Realising the potential of a unified theory of cognition. In U. Schmid, J. Krems, &amp; F. Wysotzki (Eds.), /Mind modeling: A cognitive science approach to reasoning, learning and discovery /(pp.\u00a083-109). Lengerich, Germany: Pabst Scientific.</p>","tags":["research"]},{"location":"home/Publications/#1998","title":"1998","text":"<p>Jones, R. M. (1998). A graphical user interface for human control of intelligent synthetic forces. /Proceedings of the Seventh Conference on Computer Generated Forces and Behavioral Representation/. Orlando, FL.</p> <p>Jones, R. M., Laird, J. E., &amp; Nielsen P. E. (1998). Automated intelligent pilots for combat flight simulation. /Proceedings of the Tenth Annual Conference on Innovative Applications of Artificial Intelligence/, 1047-1054. Menlo Park, CA: AAAI Press.</p> <p>Jones, R. M., Laird, J. E., &amp; Nielsen P. E. (1998). Real-time intelligent characters for a non-visual simulation environment. /Proceedings of the Computer Animation \u201998 Conference/.</p> <p>Jones, R. M., Neville, K., &amp; Laird, J. E. (1998). Modeling pilot fatigue with a synthetic behavior model. /Proceedings of the Seventh Conference on Computer Generated Forces and Behavioral Representation/. Orlando, FL.</p> <p>Laird, J. E., &amp; Jones R. M. (1998). Building advanced autonomous AI systems for large scale real time simulations. /Proceedings of the/ /Computer Game Developers Conference, /365-378. Long Beach, CA: Miller Freeman.</p> <p>Laird, J. E., Coulter, K. J., Jones, R. M., Kenny, P. G., Koss, F., &amp; Nielsen, P. E. (1998). Integrating intelligent computer generated forces in distributed simulations: TacAir-Soar in STOW-97. /Proceedings of the 1998 Spring Simulation Interoperability Workshop. Orlando, FL.</p> <p>Laird, J. E., Jones, R. M., &amp; Nielsen, P. E. (1998). Lessons learned from TacAir-Soar in STOW-97. /Proceedings of the Seventh Conference on Computer Generated Forces and Behavioral Representation/. Orlando, FL.</p> <p>Wray, R. E. and Laird, J. E. Maintaining consistency in hierarchical reasoning. In Proceedings of the Fifteenth National Conference on Artificial Intelligence, pages 928\u2013935, Madison, Wisconsin, 1998.</p>","tags":["research"]},{"location":"home/Publications/#1997","title":"1997","text":"<p>Jones, R. M., &amp; Laird, J. E. (1997). Constraints on the design of a high-level model of cognition. /Proceedings of the Nineteenth Annual Conference of the Cognitive Science Society.</p>","tags":["research"]},{"location":"home/Publications/#1996","title":"1996","text":"<p>Jones, R. M., Laird, J. E., &amp; Nielsen, P. E. (1996). Moving intelligent automated forces into theater-level scenarios. /Proceedings of the Sixth Conference on Computer Generated Forces and Behavioral Representation/, 113-117. Orlando, FL.</p> <p>Laird, J. E., Pearson, D. J., Jones, R. M., &amp; Wray, R. E., III. (1996). Dynamic knowledge integration during plan execution. /Plan execution: Problems and issues, /papers from the 1996 Fall symposium (Technical Report No.\u00a0FS-96-01). Menlo Park, CA: AAAI Press.</p>","tags":["research"]},{"location":"home/Publications/#1992","title":"1992","text":"<p>Brian G. Milnes, Garrett Pelton, Robert Doorenbos, Mike H Laird, Paul Rosenbloom, and Allen Newell. 1992. A Specification of the Soar Cognitive Architecture in Z. Technical Report. Carnegie Mellon Univ., Pittsburgh, PA, USA.</p>","tags":["research"]},{"location":"home/Publications/#the-soar-papers-volume-1","title":"The Soar Papers, Volume 1","text":"<p>Published in 1993, this collection comprises papers spanning the years 1969-1988.</p> <ul> <li>Introduction</li> <li>Index</li> </ul>","tags":["research"]},{"location":"home/Publications/#1969-1982","title":"1969-1982","text":"<ul> <li>Chapter 1</li> <li>Chapter 2</li> <li>Chapter 3</li> <li>Chapter 4</li> <li>Chapter 5</li> </ul>","tags":["research"]},{"location":"home/Publications/#1983-1985","title":"1983-1985","text":"<ul> <li>Chapter 6</li> <li>Chapter 7</li> <li>Chapter 8</li> <li>Chapter 9</li> </ul>","tags":["research"]},{"location":"home/Publications/#1986","title":"1986","text":"<ul> <li>Chapter 10</li> <li>Chapter 11</li> <li>Chapter 12</li> <li>Chapter 13</li> </ul>","tags":["research"]},{"location":"home/Publications/#1987","title":"1987","text":"<ul> <li>Chapter 14</li> <li>Chapter 15</li> <li>Chapter 16</li> <li>Chapter 17</li> <li>Chapter 18</li> <li>Chapter 19</li> </ul>","tags":["research"]},{"location":"home/Publications/#1988","title":"1988","text":"<ul> <li>Chapter 20</li> <li>Chapter 21</li> <li>Chapter 22</li> <li>Chapter 23</li> <li>Chapter 24</li> <li>Chapter 25</li> <li>Chapter 26</li> <li>Chapter 27</li> <li>Chapter 28</li> <li>Chapter 29</li> <li>Chapter 30</li> </ul>","tags":["research"]},{"location":"home/QuickStart/","title":"Soar Quick Start Guide","text":"<p>Pre-requisite: if you would like to use the graphical applications included with Soar, such as the debugger and VisualSoar, you will need Java version 11 or higher installed.</p> <ol> <li> <p>Download Soar Release archive here and extract to the location of your choice.</p> </li> <li> <p>Run the Soar debugger via one of the scripts included in this folder:</p> <ul> <li>Windows users can double-click on <code>SoarJavaDebugger.bat</code></li> <li>Linux/Mac users can run <code>./SoarJavaDebugger.sh</code> from the terminal</li> </ul> </li> </ol> <p>The other included applications are used in the tutorial, which is included under <code>documentation/</code>. The manuals for Soar and VisualSoar can be found there, as well.</p> <p>You can also build Soar from source if you'd like to work with the latest version or make changes to it.</p> <p>Once you have Soar running, you can follow the Soar Tutorial to learn how to use it.</p>"},{"location":"home/ResearchGroups/","title":"Research Groups","text":"","tags":["research"]},{"location":"home/ResearchGroups/#soar-research-groups","title":"Soar Research Groups","text":"<p>There are many institutions conducting Soar research all over the world. In the following subsections, you can find links to some of them:</p> <ul> <li>University of Michigan Soar Group   A full listing of all members of the University of Michigan Soar group and Alumnae</li> <li>Other Academic Institutions   A listing of various research groups around the world who use Soar in their work.</li> <li>Commercial Soar Organizations   A listing of companies that use Soar in commercial applications or consulting work.   Soar researchers keep in touch via the soar-group email mailing lists, which   you can join on this page.</li> </ul> <p>If you would like to have a link to your research group or company listed on these pages, please send a brief summary and the URL to [John Laird] (mailto:laird@umich.edu) with the subject \"Soar Research Group\".</p>","tags":["research"]},{"location":"home/tags/","title":"Tags","text":"<p>Following is a list of relevant tags:</p>"},{"location":"home/tags/#tag:c","title":"C++","text":"<ul> <li>            C++ Command Line Filter          </li> <li>            How to compile SML Clients          </li> <li>            Technical FAQ          </li> </ul>"},{"location":"home/tags/#tag:java","title":"Java","text":"<ul> <li>            How to compile SML Clients          </li> <li>            Technical FAQ          </li> </ul>"},{"location":"home/tags/#tag:python","title":"Python","text":"<ul> <li>            How to compile SML Clients          </li> </ul>"},{"location":"home/tags/#tag:ros","title":"ROS","text":"<ul> <li>            ROS 1          </li> </ul>"},{"location":"home/tags/#tag:agent-debugging","title":"agent debugging","text":"<ul> <li>            Design Dogma          </li> <li>            Episodic Memory Size Tool          </li> <li>            Java Soar Debugger Intro          </li> </ul>"},{"location":"home/tags/#tag:agent-development","title":"agent development","text":"<ul> <li>            Design Dogma          </li> <li>            How to compile SML Clients          </li> <li>            SML Output Link Guide          </li> <li>            Soar Programmer's Guide          </li> <li>            Technical FAQ          </li> </ul>"},{"location":"home/tags/#tag:architecture","title":"architecture","text":"<ul> <li>            Threads in SML          </li> </ul>"},{"location":"home/tags/#tag:chunking","title":"chunking","text":"<ul> <li>            15-Puzzle          </li> </ul>"},{"location":"home/tags/#tag:cli","title":"cli","text":"<ul> <li>            Command Line Options for Debugging and CLI          </li> </ul>"},{"location":"home/tags/#tag:compile","title":"compile","text":"<ul> <li>            How to compile SML Clients          </li> <li>            ROS 1          </li> </ul>"},{"location":"home/tags/#tag:debugger","title":"debugger","text":"<ul> <li>            Command Line Options for Debugging and CLI          </li> <li>            Java Soar Debugger Intro          </li> </ul>"},{"location":"home/tags/#tag:eaters","title":"eaters","text":"<ul> <li>            Tank and Eaters Configuration          </li> </ul>"},{"location":"home/tags/#tag:episodic-memory","title":"episodic memory","text":"<ul> <li>            Episodic Memory Size Tool          </li> </ul>"},{"location":"home/tags/#tag:event","title":"event","text":"<ul> <li>            SML Output Link Guide          </li> </ul>"},{"location":"home/tags/#tag:how-to","title":"how-to","text":"<ul> <li>            ROS 1          </li> </ul>"},{"location":"home/tags/#tag:institutions","title":"institutions","text":"<ul> <li>            Academic Institutions          </li> </ul>"},{"location":"home/tags/#tag:io","title":"io","text":"<ul> <li>            IO and Reward Links          </li> <li>            SML Output Link Guide          </li> </ul>"},{"location":"home/tags/#tag:kernel-programming","title":"kernel programming","text":"<ul> <li>            Basic Kernel Terminology          </li> <li>            CLI Parsing Code          </li> <li>            IO and Reward Links          </li> <li>            Memory Leak Debugging with Visual Studio          </li> <li>            Technical FAQ          </li> <li>            Timers          </li> <li>            Waterfall          </li> </ul>"},{"location":"home/tags/#tag:look-ahead-search","title":"look-ahead search","text":"<ul> <li>            15-Puzzle          </li> </ul>"},{"location":"home/tags/#tag:organizations","title":"organizations","text":"<ul> <li>            Commercial Soar Organizations          </li> </ul>"},{"location":"home/tags/#tag:research","title":"research","text":"<ul> <li>            Publications          </li> <li>            Research Groups          </li> </ul>"},{"location":"home/tags/#tag:sml","title":"sml","text":"<ul> <li>            How to compile SML Clients          </li> <li>            SML Output Link Guide          </li> <li>            SML Quick Start Guide          </li> <li>            Technical FAQ          </li> <li>            Threads in SML          </li> </ul>"},{"location":"home/tags/#tag:substate","title":"substate","text":"<ul> <li>            Waterfall          </li> </ul>"},{"location":"home/tags/#tag:threads","title":"threads","text":"<ul> <li>            Threads in SML          </li> </ul>"},{"location":"reference/","title":"Reference","text":""},{"location":"reference/CommandLineOptionsForDebuggerAndCLI/","title":"Command-Line Options for the Java Debugger and CLI","text":"","tags":["debugger","cli"]},{"location":"reference/CommandLineOptionsForDebuggerAndCLI/#soar-java-debugger-command-line-options","title":"Soar Java Debugger Command Line Options","text":"<ul> <li><code>-remote</code>: Use a remote connection (with default ip and port values)</li> <li><code>-ip &lt;ip&gt;</code>: Use the specified IP value (implies remote connection)</li> <li><code>-port &lt;port&gt;</code>: Use the specified port (implies remote connection)</li> <li><code>-agent &lt;name&gt;</code>: On a remote connection, select the specified agent as initial agent; on a local connection, assign the specified name to the initial agent</li> <li><code>-source &lt;path&gt;</code>: Source the specified .soar file on launch (only valid for local kernel)</li> <li><code>-quitonfinish</code>: When combined with <code>-source</code>, causes the debugger to exit after sourcing that one file</li> <li><code>-listen &lt;port&gt;</code>: Use the specified port to listen for remote connections (only valid for a local kernel)</li> <li><code>-maximize</code>: Start with maximized window</li> <li><code>-width &lt;width&gt;</code>: Start with the specified window width</li> <li><code>-height &lt;height&gt;</code>: Start with the specified window height</li> <li><code>-x &lt;x&gt; -y &lt;y&gt;</code>: Start with the specified window position</li> <li><code>-layout &lt;xml file&gt;</code>: Load the layout (window positions, types of windows etc.) from the specified XML file. You can also store the layout file in the debugger settings folder and refer to it by just the file name.</li> </ul>","tags":["debugger","cli"]},{"location":"reference/CommandLineOptionsForDebuggerAndCLI/#soar-cli-command-line-options","title":"Soar-CLI Command Line Options","text":"<ul> <li><code>-l</code>: Listen on, i.e. launches Soar kernel in new thread</li> <li><code>-n</code>: No syntax coloring</li> <li><code>-p &lt;port&gt;</code>: Listens on port <code>&lt;port&gt;</code></li> <li><code>-s &lt;file&gt;</code>: Sources file <code>&lt;file&gt;</code> on load</li> </ul> <p>To manage multiple agents, you can use the commands \"create\", \"list\", and \"switch\".</p>","tags":["debugger","cli"]},{"location":"reference/CommandLineOptionsForDebuggerAndCLI/#troubleshooting","title":"Troubleshooting","text":"<p>If you have problems with the debugger, try deleting any .soar files in your home directory. Corrupt settings can cause the java debugger to fail to launch.</p>","tags":["debugger","cli"]},{"location":"reference/VisualSoarKeyboardAndMouseControls/","title":"VisualSoar Keyboard and Mouse Controls","text":""},{"location":"reference/VisualSoarKeyboardAndMouseControls/#key-bindings","title":"Key Bindings","text":"<p>On Macs, the \u2318 key (\"command\") is used in place of the Ctrl key in the shortcuts below.</p>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#global-actions","title":"Global Actions","text":"<ul> <li>ESC Close open dialog</li> <li>Ctrl+Q Quit VisualSoar</li> <li>Ctrl+, Open the VisualSoar preferences</li> <li>Ctrl+= Increase font size</li> <li>Ctrl+- Decrease font size</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#project-level-actions","title":"Project Level Actions","text":"<ul> <li>Ctrl+N Open a new VisualSoar project</li> <li>Ctrl+O Open an existing VisualSoar project</li> <li>Ctrl+F Open a text file</li> <li>Alt+X Save all open documents and close VisualSoar</li> <li>Ctrl+T Tile windows horizontally</li> <li>Ctrl+shift+T Tile windows vertically</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#file-level-actions","title":"File Level Actions","text":"<ul> <li>Ctrl+S Save current file in the current window</li> <li>Ctrl+D Redraw color syntax in the current window</li> <li>Ctrl+J Rejustify text in the current window</li> <li>F7 Check all productions against the datamap</li> <li>Ctrl+F4 Close the current window</li> <li>Ctrl+F9 Minimize the current window</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#editing","title":"Editing","text":"<p>The VisualSoar rule editor uses all the default editing keystrokes for area selection, clipboard operations and basic editing:</p> <ul> <li>CTRL+C Copy the selected text to the clipboard</li> <li>Ctrl+X Cut the selected text to the clipboard</li> <li>Ctrl+V Paste the clipboard text at the current cursor location</li> <li>Ctrl+Z Undo the last editing operation</li> <li>Ctrl+shift+Z Redo the last editing operation</li> <li>Ctrl+A Select all text in the current window</li> </ul> <p>The following two editing command have been added:</p> <ul> <li>Ctrl+Enter Soar Complete</li> <li>Tab Justify the current line</li> <li>Ctrl+/ Comment out selected lines</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#search-and-replace","title":"Search and Replace","text":"<ul> <li>Ctrl+F Find text in the current file</li> <li>Ctrl+G Repeat last find</li> <li>Ctrl+R Find and replace text in the current file</li> <li>Ctrl+H Repeat last find and replace command</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#datamap-editing","title":"Datamap Editing","text":"<p>The datamap window supports clipboard operations (i.e., cut, copy and paste) as well as these keystrokes:</p> <ul> <li>Backspace Delete currently selected attribute</li> <li>Delete Delete currently selected attribute</li> <li>Enter Expand the current tree node</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#operator-window-editing","title":"Operator Window Editing","text":"<ul> <li>Backspace Delete currently selected node</li> <li>Delete Delete currently selected node</li> <li>Enter Expand the current tree node</li> </ul>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#mouse-controls","title":"Mouse Controls","text":""},{"location":"reference/VisualSoarKeyboardAndMouseControls/#context-menus","title":"Context menus","text":"<p>All windows in VisualSoar have context menus that accessible by pressing and holding the right mouse button.</p>"},{"location":"reference/VisualSoarKeyboardAndMouseControls/#datamap","title":"Datamap","text":"<ul> <li>Double-click: Expand the current tree node</li> <li>Drag and drop: Move a subtree to a new location</li> <li>Ctrl+ drag and drop: Copy a subtree to a new location</li> <li>Ctrl+shift + drag and drop: Link a subtree to a new location</li> </ul> <p>What is \"Drag and Drop\"?</p> <p>It's a common method for manipulating objects under a graphical user interface. The user moves the mouse pointer over an icon (or other object) and presses a mouse button. The user holds the button down while moving the pointer (\"dragging\" the object) to another place. The meaning of this action can often be modified by holding certain keys on the keyboard at the same time.</p> <p>When using drag and drop with the datamap you should note that the mouse cursor changes as you begin the operation (the drag part).</p>"},{"location":"reference/cli/","title":"Soar-Cli","text":"<p>Help files for the Soar command line interface</p> <p>When issuing commands, the command name can be shortened so long as there is no ambiguity (e.g., <code>pref</code> instead of <code>preferences</code>). Arbitrary aliases may also be assigned using the <code>alias</code> command. Some of the more common shortcuts are listed with each command's synopsis under \"Default Aliases\".</p>"},{"location":"reference/cli/cmd_alias/","title":"alias","text":"<p>Define a new alias of existing commands and arguments.</p>"},{"location":"reference/cli/cmd_alias/#synopsis","title":"Synopsis","text":"<pre><code>alias\nalias &lt;name&gt; [args]\nalias -r &lt;name&gt;\n</code></pre>"},{"location":"reference/cli/cmd_alias/#adding-a-new-alias","title":"Adding a new alias","text":"<p>This command defines new aliases by creating Soar procedures with the given name. The new procedure can then take an arbitrary number of arguments which are post-pended to the given definition and then that entire string is executed as a command. The definition must be a single command, multiple commands are not allowed. The alias procedure checks to see if the name already exists, and does not destroy existing procedures or aliases by the same name. Existing aliases can be removed by using the unalias command.</p>"},{"location":"reference/cli/cmd_alias/#removing-an-existing-alias","title":"Removing an existing alias","text":"<p>To undefine a previously created alias, use the <code>-r</code> argument along with the name of the alias to remove.</p> <p><code>alias -r existing-alias</code></p> <p>Note: If you are trying to create an alias for a command that also has a <code>-r</code> option, make sure to enclose it in quotes. For example:</p> <p><code>alias unalias \"alias -r\"</code></p>"},{"location":"reference/cli/cmd_alias/#printing-existing-aliases","title":"Printing Existing Aliases","text":"<p>With no arguments, <code>alias</code> returns the list of defined aliases. With only the name given, <code>alias</code> returns the current definition.</p>"},{"location":"reference/cli/cmd_alias/#examples","title":"Examples","text":"<p>The alias <code>wmes</code> is defined as:</p> <pre><code>alias wmes print -i\n</code></pre> <p>If the user executes a command such as:</p> <pre><code>wmes {(* ^superstate nil)}\n</code></pre> <p>... it is as if the user had typed this command:</p> <pre><code>print -i {(* ^superstate nil)}\n</code></pre> <p>To check what a specific alias is defined as, you would type</p> <pre><code>alias wmes\n</code></pre>"},{"location":"reference/cli/cmd_alias/#default-alias","title":"Default Alias","text":"<pre><code>a               alias\nunalias, un     alias -r\n</code></pre>"},{"location":"reference/cli/cmd_chunk/","title":"chunk","text":"<p>Sets the parameters for Soar's chunking algorithm, explanation-based behavior summarization (EBBS).</p>"},{"location":"reference/cli/cmd_chunk/#synopsis","title":"Synopsis","text":"<pre><code>===================================================\n           Chunk Commands and Settings\n===================================================\nchunk ? | help                                        Print all EBBS settings\nchunk stats                                           Print statistics on learning that has occurred\n------------------- Settings ----------------------\nalways | NEVER | only | except                        When Soar will learn new rules\nbottom-only                            [ on | OFF ]   Learn only from bottom sub-state\nnaming-style                     [ numbered | RULE]   Simple numeric chunk names or informational rule-based name\nmax-chunks                                 50         Maximum chunks that can be learned (per phase)\nmax-dupes                                   3         Maximum duplicate chunks (per rule, per phase)\n------------------- Debugging ---------------------\ninterrupt                              [ on | OFF ]   Stop Soar after learning from any rule\nexplain-interrupt                      [ on | OFF ]   Stop Soar after learning rule watched by explainer\nwarning-interrupt                      [ on | OFF ]   Stop Soar after detecting learning issue\n------------------- Fine Tune ---------------------\nsingleton                                             Print all WME singletons\nsingleton                &lt;type&gt; &lt;attribute&gt; &lt;type&gt;    Add a WME singleton pattern\nsingleton -r             &lt;type&gt; &lt;attribute&gt; &lt;type&gt;    Remove a WME singleton pattern\nautomatically-create-singletons        [ ON | off ]   Attempt creating singletons for every string attribute\n----------------- EBBS Mechanisms ------------------\nadd-ltm-links                          [ on | OFF ]   Recreate LTM links in original results\nadd-osk                                [ ON | off ]   Incorporate operator selection knowledge\n---------- Correctness Guarantee Filters ----------   Allow rules to form that...\nallow-local-negations                  [ ON | off ]   ...used local negative reasoning\nallow-opaque                           [ ON | off ]   ...used knowledge from a LTM recall\n---------------------------------------------------\n\nTo change a setting:                                  chunk &lt;setting&gt; [&lt;value&gt;]\nFor a detailed explanation of these settings:         help chunk\n</code></pre>"},{"location":"reference/cli/cmd_chunk/#description","title":"Description","text":"<p>The <code>chunk</code> command controls the parameters for explanation-based chunking. With no arguments, this command prints out a basic summary of the current learning parameters, how many rules have been learned and which states have learning active. With an <code>?</code> argument, it will list all sub-commands, options and their current values.</p>"},{"location":"reference/cli/cmd_chunk/#turning-on-explanation-based-chunking","title":"Turning on Explanation-Based Chunking","text":"<p>Chunking is disabled by default. Learning can be turned on or off at any point during a run. Also note that Soar uses most aspects of EBBS to create justifications as well, so many aspects of the chunking algorithm still occur even when learning is off.</p> <pre><code>chunk always:      Soar will always attempt to learn rules from sub-state\n                   problem-solving.\nchunk never:       Soar will never attempt to learn rules.\nchunk unflagged:   Chunking is on in all states _except_ those that have had RHS\n                   `dont-learn` actions executed in them.\nchunk flagged:     Chunking is off for all states except those that are flagged\n                   via a RHS `force-learn` actions.\n</code></pre> <p>The <code>flagged</code> argument and its companion <code>force-learn</code> RHS action allow Soar developers to turn learning on in a particular problem space, so that they can focus on debugging the learning problems in that particular problem space without having to address the problems elsewhere in their programs at the same time. Similarly, the <code>unflagged</code> flag and its companion <code>dont-learn</code> RHS action allow developers to temporarily turn learning off for debugging purposes. These facilities are provided as debugging tools, and do not correspond to any theory of learning in Soar.</p> <p>The <code>bottom-only</code> setting control when chunks are formed when there are multiple levels of subgoals. With bottom-up learning, chunks are learned only in states in which no subgoal has yet generated a chunk. In this mode, chunks are learned only for the \"bottom\" of the subgoal hierarchy and not the intermediate levels. With experience, the subgoals at the bottom will be replaced by the chunks, allowing higher level subgoals to be chunked.</p>"},{"location":"reference/cli/cmd_chunk/#debugging-explanation-based-chunking","title":"Debugging Explanation-Based Chunking","text":"<p>The best way to understand why and how rules formed is to use the <code>explain</code> command. It will create detailed snapshots of everything that existed when a rule or justification formed that you can interactively explore. See explain for more information. You can even use it in conjunction with the visualizer to create graphs depicting the dependency between rules in a sub-state.</p> <p>The <code>stats</code> command will print a detailed table containing statistics about all chunking activity during that run.</p> <p>The <code>interrupt</code> setting forces Soar to stop after forming any rule.</p> <p>The <code>explain-interrupt</code> setting forces Soar to stop when it attempts to form a rule from a production that is being watched by the explainer. See explain for more information.</p> <p>The <code>warning interrupts</code> setting forces Soar to stop when it attempts to form a rule but detects an issue that may be problematic.</p> <p>The <code>record-utility</code> command is a tool to determine how much processing may be saved by a particular learned rule. When enabled, Soar will detect that a chunk matched, but will not fire it. Assuming that the rule is correct, this should lead to an impasse that causes a duplicate chunk to form. The amount of time and decision cycles spent in that impasse are recorded and stored for the rule. Rules are also flagged if a duplicate is not detected or if an impasse is not generated.</p> <p>This feature is not yet implemented.</p>"},{"location":"reference/cli/cmd_chunk/#preventing-possible-correctness-issues","title":"Preventing Possible Correctness Issues","text":"<p>It is theoretically possible to detect nearly all of the sources of correctness issues and prevent rules from forming when those situations are detected. In Soar 9.6.0, though, only one filter is available, <code>allow-local-negations</code>. Future versions of Soar will include more correctness filters.</p> <p>Note that it is still possible to detect that your agent may have encountered a known source of a correctness issue by looking at the output of the chunk stats command. It has specific statistics for some of the sources, while others can be gleaned indirectly. For example, if the stats show that some rules required repair, you know that your agent is testing or augmenting a previous result in a substate.</p>"},{"location":"reference/cli/cmd_chunk/#chunk-allow-local-negations","title":"chunk allow-local-negations","text":"<p>The option <code>allow-local-negations</code> control whether or not chunks can be created that are derived from rules that check local WMEs in the substate don't exist. Chunking through local negations can result in overgeneral chunks, but disabling this ability will reduce the number of chunks formed. The default is to enable chunking through local negations.</p> <p>If chunking through local negations is disabled, to see when chunks are discarded (and why), set <code>watch --learning print</code> (see trace command).</p> <p>The following commands are not yet enabled. Soar will currently allow all of these situations.</p>"},{"location":"reference/cli/cmd_chunk/#allow-missing-osk","title":"allow-missing-osk","text":"<p>Used operator selection rules to choose operator</p>"},{"location":"reference/cli/cmd_chunk/#allow-opaque","title":"allow-opaque","text":"<p>Used knowledge from opaque knowledge retrieval</p>"},{"location":"reference/cli/cmd_chunk/#allow-uncertain-operators","title":"allow-uncertain-operators","text":"<p>Used operators selected probabilistically</p>"},{"location":"reference/cli/cmd_chunk/#allow-conflated-reasoning","title":"allow-conflated-reasoning","text":"<p>Tests a WME that has multiple reasons it exists</p>"},{"location":"reference/cli/cmd_chunk/#other-settings-that-control-when-rules-are-learned","title":"Other Settings that Control WHEN Rules are Learned","text":""},{"location":"reference/cli/cmd_chunk/#chunk-max-chunks","title":"chunk max-chunks","text":"<p>The <code>max-chunks</code> command is used to limit the maximum number of chunks that may be created during a decision cycle. The initial value of this variable is 50; allowable settings are any integer greater than 0.</p> <p>The chunking process will end after max-chunks chunks have been created, even if there are more results that have not been backtraced through to create chunks, and Soar will proceed to the next phase. A warning message is printed to notify the user that the limit has been reached.</p> <p>This limit is included in Soar to prevent getting stuck in an infinite loop during the chunking process. This could conceivably happen because newly-built chunks may match immediately and are fired immediately when this happens; this can in turn lead to additional chunks being formed, etc.</p> <p>Important note:</p> <p>If you see this warning, something is seriously wrong; Soar will be unable to guarantee consistency of its internal structures. You should not continue execution of the Soar program in this situation; stop and determine whether your program needs to build more chunks or whether you've discovered a bug (in your program or in Soar itself).</p>"},{"location":"reference/cli/cmd_chunk/#chunk-max-dupes","title":"chunk max-dupes","text":"<p>The <code>max-dupes</code> command is used to limit the maximum number of duplicate chunks that can form from a particular rule in a single decision cycle. The initial value of this variable is 3; allowable settings are any integer greater than 0. Note that this limit is per-rule, per-state. With the default value, each rule can match three times in a sub-state and create two duplicate, reject rules before Soar will stop attempting to create new rules based on that rule. The limit is reset the next decision cycle.</p> <p>This limit is included in Soar to prevent slowing down when multiple matches of a rule in a substate produce the same general rule. Explanation-based chunking can now produce very general chunks, so this can happen in problem states in which the logic leads to multiple matches, which leads to results being created multiple times in the same decision cycle.</p>"},{"location":"reference/cli/cmd_chunk/#settings-that-alter-the-mechanisms-that-ebbs-uses","title":"Settings that Alter the Mechanisms that EBBS Uses","text":""},{"location":"reference/cli/cmd_chunk/#chunk-add-osk","title":"chunk add-osk","text":"<p>The option <code>add-osk</code> control whether or not operator selection knowledge is backtraced through when creating justifications and chunks. When this option is disabled, only requirement preferences (requires and prohibits) will be added backtraced through. When this option is enabled, relevant desirability prefs (better, best, worse, worst, indifferent) will also be added, producing more specific and possibly more correct chunks. This feature is still experimental and incurs a performance penalty, so the default is to not include operator selection knowledge.</p> <p>The following commands are not yet enabled. Soar will always use the EBBS mechanisms listed below.</p>"},{"location":"reference/cli/cmd_chunk/#variablize-identity","title":"variablize-identity","text":"<p>Variablize symbols based on identity analysis</p>"},{"location":"reference/cli/cmd_chunk/#variablize-rhs-funcs","title":"variablize-rhs-funcs","text":"<p>Variablize and compose RHS functions</p>"},{"location":"reference/cli/cmd_chunk/#enforce-constraints","title":"enforce-constraints","text":"<p>Track and enforce transitive constraints</p>"},{"location":"reference/cli/cmd_chunk/#repair","title":"repair","text":"<p>Repair rules that aren't fully connected</p>"},{"location":"reference/cli/cmd_chunk/#merge","title":"merge","text":"<p>Merge redundant conditions</p>"},{"location":"reference/cli/cmd_chunk/#user-singletons","title":"user-singletons","text":"<p>Unify identities using domain-specific singletons</p> <p>If backtracing traces through the same WME multiple times via different backtrace paths, a resulting chunk may have duplicate conditions for that WME. This could be undesirable. Enabling user-singletons allows the user to specify duplicate conditions that should be merged.</p> <p>Singletons are defined using the <code>chunk singleton &lt;type&gt; &lt;attr&gt; &lt;type&gt;</code> command, where <code>&lt;type&gt;</code> is either \"state\", \"identifier\", or \"constant\", and <code>&lt;attr&gt;</code> is the domain-specific attribute to unify within chunks.</p>"},{"location":"reference/cli/cmd_chunk/#chunk-naming-style","title":"Chunk Naming Style","text":"<p>The numbered style for naming newly-created chunks is:</p> <pre><code>&lt;prefix&gt;&lt;chunknum&gt;\n</code></pre> <p>The rule-based (default) style for naming chunks is:</p> <pre><code>&lt;prefix&gt;*&lt;original-rule-name&gt;*&lt;impassetype&gt;*&lt;dc&gt;-&lt;dcChunknum&gt;\n</code></pre> <p>where:</p> <ul> <li>prefix is either chunk or justification, depending on whether learning was     on for that state,</li> <li>chunknum is a counter starting at 1 for the first chunk created,</li> <li>original-rule-name is the name of the production that produced the result     that resulted in this chunk,</li> <li>dc is the number of the decision cycle in which the chunk was formed,</li> <li>impassetype is one of Tie, Conflict, Failure, StateNoChange, OpNoChange,</li> <li>dcChunknum is the number of the chunk within that specific decision cycle.</li> </ul> <p>Note that when using the rule-based naming format, a chunk based on another chunk will have a name that begins with prefix followed by <code>-xN</code>, for example <code>chunk-x3*apply-rule*42-2</code>.</p>"},{"location":"reference/cli/cmd_chunk/#default-aliases","title":"Default Aliases","text":"<pre><code>learn    chunk\ncs       chunk --stats\n</code></pre>"},{"location":"reference/cli/cmd_chunk/#see-also","title":"See Also","text":"<ul> <li>explain</li> <li>trace</li> <li>visualize</li> </ul>"},{"location":"reference/cli/cmd_debug/","title":"debug","text":"<p>Contains commands that provide access to Soar's internals. Most users will not need to access these commands.</p>"},{"location":"reference/cli/cmd_debug/#synopsis","title":"Synopsis","text":"<pre><code>======================================================================\n                     Debug Commands and Settings\n======================================================================\nallocate [pool blocks]         Allocates extra memory to a memory pool\ninternal-symbols                                   Prints symbol table\nport                                             Prints listening port\ntime &lt;command&gt; [args]           Executes command and prints time spent\n</code></pre>"},{"location":"reference/cli/cmd_debug/#debug-allocate","title":"debug allocate","text":"<pre><code>debug allocate [pool blocks]\n</code></pre> <p>This <code>allocate</code> command allocates additional blocks of memory for a specified memory pool. Each block is 32 kilobyte.</p> <p>Soar allocates blocks of memory for its memory pools as it is needed during a run (or during other actions like loading productions). Unfortunately, this behavior translates to an increased run time for the first run of a memory-intensive agent. To mitigate this, blocks can be allocated before a run by using this command.</p> <p>Issuing the command with no parameters lists current pool usage, exactly like stats command's memory flag.</p> <p>Issuing the command with part of a pool's name and a positive integer will allocate that many additional blocks for the specified pool. Only the first few letters of the pool's name are necessary. If more than one pool starts with the given letters, which pool will be chosen is unspecified.</p> <p>Memory pool block size in this context is approximately 32 kilobytes, the exact size determined during agent initialization.</p>"},{"location":"reference/cli/cmd_debug/#debug-internal-symbols","title":"debug internal-symbols","text":"<p>The <code>internal-symbols</code> command prints information about the Soar symbol table. Such information is typically only useful for users attempting to debug Soar by locating memory leaks or examining I/O structure.</p>"},{"location":"reference/cli/cmd_debug/#debug-port","title":"debug port","text":"<p>The <code>port</code> command prints the port the kernel instance is listening on.</p>"},{"location":"reference/cli/cmd_debug/#debug-time","title":"debug time","text":"<pre><code>debug time command [arguments]\n</code></pre> <p>The <code>time</code> command uses a system clock timer to record the time spent while executing a command. The most common use for this is to time how long an agent takes to run.</p>"},{"location":"reference/cli/cmd_debug/#see-also","title":"See Also","text":"<ul> <li>stats</li> </ul>"},{"location":"reference/cli/cmd_decide/","title":"decide","text":"<p>Commands and settings related to the selection of operators during the Soar decision process</p>"},{"location":"reference/cli/cmd_decide/#synopsis","title":"Synopsis","text":"<pre><code>=============================================================================\n-                      Decide Sub-Commands and Options                      -\n=============================================================================\ndecide                          [? | help]\n-----------------------------------------------------------------------------\ndecide numeric-indifferent-mode [--avg --sum]\n-----------------------------------------------------------------------------\ndecide indifferent-selection\ndecide indifferent-selection   &lt;policy&gt;\n                               &lt;policy&gt; = [--boltzmann | --epsilon-greedy |\n                                           --first | --last | -- softmax ]\ndecide indifferent-selection   &lt;param&gt; [value]\n                               &lt;param&gt; = [--epsilon --temperature]\ndecide indifferent-selection   [--reduction-policy| -p] &lt;param&gt; [&lt;policy&gt;]\ndecide indifferent-selection   [--reduction-rate| -r] &lt;param&gt; &lt;policy&gt; [&lt;rate&gt;]\ndecide indifferent-selection   [--auto-reduce] [setting]\ndecide indifferent-selection   [--stats]\n----------------------------------------------------------------------------\ndecide predict\ndecide select                  &lt;operator ID&gt;\n-----------------------------------------------------------------------------\ndecide set-random-seed         [&lt;seed&gt;]\n-----------------------------------------------------------------------------\nFor a detailed explanation of sub-commands:    help decide\n</code></pre>"},{"location":"reference/cli/cmd_decide/#summary-screen","title":"Summary Screen","text":"<p>Using the <code>decide</code> command without any arguments will display key elements of Soar's current decision settings:</p> <pre><code>=======================================================\n                     Decide Summary\n=======================================================\nNumeric indifference mode:                          sum\n-------------------------------------------------------\nExploration Policy:                             softmax\nAutomatic Policy Parameter Reduction:               off\nEpsilon:                                       0.100000\nEpsilon Reduction Policy:                   exponential\nTemperature:                                  25.000000\nTemperature Reduction Policy:               exponential\n-------------------------------------------------------\n\nUse 'decide ?' for a command overview or 'help decide' for the manual page.\n</code></pre>"},{"location":"reference/cli/cmd_decide/#decide-numeric-indifferent-mode","title":"decide numeric-indifferent-mode","text":"<p>The <code>numeric-indifferent-mode</code> command sets how multiple numeric indifferent preference values given to an operator are combined into a single value for use in random selection.</p> <p>The default procedure is <code>--sum</code> which sums all numeric indifferent preference values given to the operator, defaulting to 0 if none exist. The alternative <code>--avg</code> mode will average the values, also defaulting to 0 if none exist.</p>"},{"location":"reference/cli/cmd_decide/#decide-indifferent-selection","title":"decide indifferent-selection","text":"<p>The <code>indifferent-selection</code> command allows the user to set options relating to selection between operator proposals that are mutually indifferent in preference memory.</p> <p>The primary option is the exploration policy (each is covered below). When Soar starts, softmax is the default policy.</p> <p>Note: As of version 9.3.2, the architecture no longer automatically changes the policy to epsilon-greedy the first time Soar-RL is enabled.</p> <p>Some policies have parameters to temper behavior. The indifferent-selection command provides basic facilities to automatically reduce these parameters exponentially and linearly each decision cycle by a fixed rate. In addition to setting these policies/rates, the auto-reduce option enables the automatic reduction system (disabled by default), for which the Soar decision cycle incurs a small performance cost.</p>"},{"location":"reference/cli/cmd_decide/#indifferent-selection-options","title":"indifferent-selection options","text":"Option Description <code>-s, --stats</code> Summary of settings <code>policy</code> Set exploration policy <code>parameter [exploration policy parameters]</code> Get/Set exploration policy parameters (if value not given, returns the current value) <code>parameter [reduction_policy](value]</code> Get/Set exploration policy parameter reduction policy (if policy not given, returns the current) <code>parameter reduction_policy [exploration policy parameter]</code> Get/Set exploration policy parameter reduction rate for a policy (if rate not give, returns the current) <code>-a, --auto-reduce [on,off](reduction-rate]</code> Get/Set auto-reduction setting (if setting not provided, returns the current)"},{"location":"reference/cli/cmd_decide/#indifferent-selection-exploration-policies","title":"indifferent-selection exploration policies","text":"Option Description <code>-b, --boltzmann</code> Tempered softmax (uses temperature) <code>-g, --epsilon-greedy</code> Tempered greedy (uses epsilon) <code>-x, --softmax</code> Random, biased by numeric indifferent values (if a non-positive value is encountered, resorts to a uniform random selection) <code>-f, --first</code> Deterministic, first indifferent preference is selected <code>-l, --last</code> Deterministic, last indifferent preference is selected"},{"location":"reference/cli/cmd_decide/#indifferent-selection-exploration-policy-parameters","title":"indifferent-selection exploration policy parameters","text":"Parameter Name Acceptable Values Default Value <code>-e, --epsilon</code> <code>[0, 1]</code> <code>0.1</code> <code>-t, --temperature</code> <code>(0, inf)</code> <code>25</code>"},{"location":"reference/cli/cmd_decide/#indifferent-selection-auto-reduction-policies","title":"indifferent-selection auto-reduction policies","text":"Parameter Name Acceptable Values Default Value <code>exponential default</code> <code>[0, 1]</code> <code>1</code> <code>linear</code> <code>[0, inf]</code> <code>0</code>"},{"location":"reference/cli/cmd_decide/#decide-predict","title":"decide predict","text":"<p>The predict command determines, based upon current operator proposals, which operator will be chosen during the next decision phase. If predict determines an operator tie will be encountered, \"tie\" is returned. If predict determines no operator will be selected (state no-change), \"none\" is returned. If predict determines a conflict will arise during the decision phase, \"conflict\" is returned. If predict determines a constraint failure will occur, \"constraint\" is returned. Otherwise, predict will return the id of the operator to be chosen. If operator selection will require probabilistic selection, and no alterations to the probabilities are made between the call to predict and decision phase, predict will manipulate the random number generator to enforce its prediction.</p>"},{"location":"reference/cli/cmd_decide/#decide-select","title":"decide select","text":"<p>The select command will force the selection of an operator, whose id is supplied as an argument, during the next decision phase. If the argument is not a proposed operator in the next decision phase, an error is raised and operator selection proceeds as if the select command had not been called. Otherwise, the supplied operator will be selected as the next operator, regardless of preferences. If select is called with no id argument, the command returns the operator id currently forced for selection (by a previous call to select), if one exists.</p>"},{"location":"reference/cli/cmd_decide/#example","title":"Example","text":"<p>Assuming operator \"O2\" is a valid operator, this would select it as the next operator to be selected:</p> <pre><code>decide select O2\n</code></pre>"},{"location":"reference/cli/cmd_decide/#decide-set-random-seed","title":"decide set-random-seed","text":"<p>Seeds the random number generator with the passed seed. Calling <code>decide set-random-seed</code> (or equivalently, <code>decide srand</code>) without providing a seed will seed the generator based on the contents of /dev/urandom (if available) or else based on time() and clock() values. If provided, the seed value is parsed as an unsigned 32-bit integer; values that are too large are set to the largest possible value, or 4,294,967,295, and negative values are unparseable.</p>"},{"location":"reference/cli/cmd_decide/#example_1","title":"Example","text":"<pre><code>decide set-random-seed 23\n</code></pre>"},{"location":"reference/cli/cmd_decide/#default-aliases","title":"Default Aliases","text":"<pre><code>inds           indifferent-selection\nsrand          set-random-seed\n</code></pre>"},{"location":"reference/cli/cmd_decide/#see-also","title":"See Also","text":"<ul> <li>rl</li> </ul>"},{"location":"reference/cli/cmd_echo/","title":"echo","text":"<p>Print a string to the current output device.</p>"},{"location":"reference/cli/cmd_echo/#synopsis","title":"Synopsis","text":"<pre><code>echo [--nonewline] [string]\n</code></pre>"},{"location":"reference/cli/cmd_echo/#options","title":"Options","text":"Option Description <code>string</code> The string to print. <code>-n, --nonewline</code> Supress printing of the newline character"},{"location":"reference/cli/cmd_echo/#description","title":"Description","text":"<p>This command echos the args to the current output stream. This is normally stdout but can be set to a variety of channels. If an arg is <code>--nonewline</code> then no newline is printed at the end of the printed strings. Otherwise a newline is printed after printing all the given args. Echo is the easiest way to add user comments or identification strings in a log file.</p>"},{"location":"reference/cli/cmd_echo/#example","title":"Example","text":"<p>This example will add these comments to the screen and any open log file.</p> <pre><code>echo This is the first run with disks = 12\n</code></pre>"},{"location":"reference/cli/cmd_echo/#see-also","title":"See Also","text":"<ul> <li>clog</li> </ul>"},{"location":"reference/cli/cmd_epmem/","title":"epmem","text":"<p>Control the behavior of episodic memory.</p>"},{"location":"reference/cli/cmd_epmem/#synopsis","title":"Synopsis","text":"<pre><code>epmem\nepmem -e|--enable|--on\nepmem -d|--disable|--off\nepmem -i|--init\nepmem -c|--close\nepmem -g|--get &lt;parameter&gt;\nepmem -s|--set &lt;parameter&gt; &lt;value&gt;\nepmem -S|--stats [&lt;statistic&gt;]\nepmem -t|--timers [&lt;timer&gt;]\nepmem -v|--viz &lt;episode id&gt;\nepmem -p|--print &lt;episode id&gt;\nepmem -b|--backup &lt;file name&gt;\n</code></pre>"},{"location":"reference/cli/cmd_epmem/#options","title":"Options","text":"Option Description <code>-e, --enable, --on</code> Enable episodic memory. <code>-d, --disable, --off</code> Disable episodic memory. <code>-i, --init</code> Re-initialize episodic memory <code>-c, --close</code> Disconnect from episodic memory <code>-g, --get</code> Print current parameter setting <code>-s, --set</code> Set parameter value <code>-S, --stats</code> Print statistic summary or specific statistic <code>-t, --timers</code> Print timer summary or specific statistic <code>-v, --viz</code> Print episode in graphviz format <code>-p, --print</code> Print episode in user-readable format <code>-b, --backup</code> Creates a backup of the episodic database on disk"},{"location":"reference/cli/cmd_epmem/#description","title":"Description","text":"<p>The <code>epmem</code> command is used to change all behaviors of the episodic memory module, except for watch output, which is controlled by the <code>trace --epmem</code> command.</p>"},{"location":"reference/cli/cmd_epmem/#parameters","title":"Parameters","text":"<p>Due to the large number of parameters, the <code>epmem</code> command uses the <code>--get|--set &lt;parameter&gt; &lt;value&gt;</code> convention rather than individual switches for each parameter. Running <code>epmem</code> without any switches displays a summary of the parameter settings.</p>"},{"location":"reference/cli/cmd_epmem/#main-parameters","title":"Main Parameters","text":"Parameter Description Possible values Default <code>append</code> Controls whether database is overwritten or appended when opening or re-initializing <code>on</code>, <code>off</code> <code>off</code> <code>balance</code> Linear weight of match cardinality (1) vs. working memory activation (0) used in calculating match score <code>[</code>0, 1<code>]</code> 1 <code>database</code> Database storage method <code>file</code>, <code>memory</code> <code>memory</code> <code>exclusions</code> Toggle the exclusion of an attribute string constant any string <code>epmem, smem</code> <code>force</code> Forces episode encoding/ignoring in the next storage phase <code>ignore</code>, <code>remember</code>, <code>off</code> <code>off</code> <code>learning</code> Episodic memory enabled <code>on</code>, <code>off</code> <code>off</code> <code>merge</code> Controls how retrievals interact with long-term identifiers in working memory <code>none</code>, <code>add</code> <code>none</code> <code>path</code> Location of database file empty, some path empty <code>phase</code> Decision cycle phase to encode new episodes and process epmem link commands <code>output</code>, <code>selection</code> <code>output</code> <code>trigger</code> How episode encoding is triggered <code>dc</code>, <code>output</code>, <code>none</code> <code>output</code>"},{"location":"reference/cli/cmd_epmem/#performance-parameters","title":"Performance Parameters","text":"Parameter Description Possible values Default <code>cache-size</code> Number of memory pages used in the SQLite cache 1, 2, ... 10000 <code>graph-match</code> Graph matching enabled <code>on</code>, <code>off</code> <code>on</code> <code>graph-match-ordering</code> Ordering of identifiers during graph match <code>undefined</code>, <code>dfs</code>, <code>mcv</code> <code>undefined</code> <code>lazy-commit</code> Delay writing semantic store changes to file until agent exits <code>on</code>, <code>off</code> <code>on</code> <code>optimization</code> Policy for committing data to disk <code>safety</code>, <code>performance</code> <code>performance</code> <code>page-size</code> Size of each memory page used in the SQLite cache 1k, 2k, 4k, 8k, 16k, 32k, 64k 8k <code>timers</code> Timer granularity <code>off</code>, <code>one</code>, <code>two</code>, <code>three</code> <code>off</code> <p>The <code>learning</code> parameter turns the episodic memory module on or off. When <code>learning</code> is set to <code>off</code>, no new episodes are encoded and no commands put on the epmem link are processed. This is the same as using the enable and disable commands.</p> <p>The <code>phase</code> parameter determines which decision cycle phase episode encoding and retrieval will be performed.</p> <p>The <code>trigger</code> parameter controls when new episodes will be encoded. When it is set to <code>output</code>, new episodes will be encoded only if the agent made modifications to the output-link during that decision cycle. When set to 'dc', new episodes will be encoded every decision cycle.</p> <p>The <code>exclusions</code> parameter can be used to prevent episodic memory from encoding parts of working memory into new episodes. The value of <code>exclusions</code> is a list of string constants. During encoding, episodic memory will walk working memory starting from the top state identifier. If it encounters a WME whose attribute is a member of the <code>exclusions</code> list, episodic memory will ignore that WME and abort walking the children of that WME, and they will not be included in the encoded episode. Note that if the children of the excluded WME can be reached from top state via an alternative non-excluded path, they will still be included in the encoded episode. The <code>exclusions</code> parameter behaves differently from other parameters in that issuing <code>epmem --set exclusions &lt;val&gt;</code> does not set its value to <code>&lt;val&gt;</code>. Instead, it will toggle the membership of <code>&lt;val&gt;</code> in the <code>exclusions</code> list.</p> <p>The <code>path</code> parameter specifies the file system path the database is stored in. When <code>path</code> is set to a valid file system path and database mode is set to file, then the SQLite database is written to that path.</p> <p>The append parameter will determine whether all existing episodes recorded in a database on disk will be erased when epmem loads it. Note that this affects episodic memory re-initialization also, i.e. if the append setting is off, all episodic memories stored to disk will be lost when an init-soar is performed. Note that episodic memory cannot currently append to an in-memory database. If you perform an init-soar while using an in-memory database, all current episodes stored will be cleared.</p> <p>Note that changes to database, path and append will not have an effect until the database is used after an initialization. This happens either shortly after launch (on first use) or after a database initialization command is issued. To switch databases or database storage types after running, set your new parameters and then perform an <code>epmem --init</code>.</p> <p>The <code>epmem --backup</code> command can be used to make a copy of the current state of the database, whether in memory or on disk. This command will commit all outstanding changes before initiating the copy.</p> <p>When the database is stored to disk, the <code>lazy-commit</code> and <code>optimization</code> parameters control how often cached database changes are written to disk. These parameters trade off safety in the case of a program crash with database performance. When <code>optimization</code> is set to <code>performance</code>, the agent will have an exclusive lock on the database, meaning it cannot be opened concurrently by another SQLite process such as SQLiteMan. The lock can be relinquished by setting the database to memory or another database and issuing init-soar/<code>epmem --init</code> or by shutting down the Soar kernel.</p> <p>The <code>balance</code> parameter sets the linear weight of match cardinality vs. cue activation. As a performance optimization, when the value is 1 (default), activation is not computed. If this value is not 1 (even close, such as 0.99), and working memory activation is enabled, this value will be computed for each leaf WME, which may incur a noticeable cost, depending upon the overall complexity of the retrieval.</p> <p>The <code>graph-match-ordering</code> parameter sets the heuristic by which identifiers are ordered during graph match (assuming <code>graph-match</code> is <code>on</code>). The default, <code>undefined</code>, does not enforce any order and may be sufficient for small cues. For more complex cues, there will be a one-time sorting cost, during each retrieval, if the parameter value is changed. The currently available heuristics are depth-first search (<code>dfs</code>) and most-constrained variable (<code>mcv</code>). It is advised that you attempt these heuristics to improve performance if the <code>query_graph_match</code> timer reveals that graph matching is dominating retrieval time.</p> <p>The <code>merge</code> parameter controls how the augmentations of retrieved long-term identifiers (LTIs) interact with an existing LTI in working memory. If the LTI is not in working memory or has no augmentations in working memory, this parameter has no effect. If the augmentation is in working memory and has augmentations, by default (<code>none</code>), episodic memory will not augment the LTI. If the parameter is set to <code>add</code> then any augmentations that augmented the LTI in a retrieved episode are added to working memory.</p>"},{"location":"reference/cli/cmd_epmem/#statistics","title":"Statistics","text":"<p>Episodic memory tracks statistics over the lifetime of the agent. These can be accessed using <code>epmem --stats &lt;statistic&gt;</code>. Running <code>epmem --stats</code> without a statistic will list the values of all statistics. Unlike timers, statistics will always be updated. Available statistics are:</p> Name Label Description <code>time</code> Time Current episode ID <code>db-lib-version</code> SQLite Version SQLite library version <code>mem-usage</code> Memory Usage Current SQLite memory usage in bytes <code>mem-high</code> Memory Highwater High SQLite memory usage watermark in bytes <code>queries</code> Queries Number of times the query command has been processed <code>nexts</code> Nexts Number of times the next command has been processed <code>prevs</code> Prevs Number of times the previous command has been processed <code>ncb-wmes</code> Last Retrieval WMEs Number of WMEs added to working memory in last reconstruction <code>qry-pos</code> Last Query Positive Number of leaf WMEs in the query cue of last cue-based retrieval <code>qry-neg</code> Last Query Negative Number of leaf WMEs in the neg-query cue of the last cue-based retrieval <code>qry-ret</code> Last Query Retrieved Episode ID of last retrieval <code>qry-card</code> Last Query Cardinality Match cardinality of last cue-based retrieval <code>qry-lits</code> Last Query Literals Number of literals in the DNF graph of last cue-based retrieval"},{"location":"reference/cli/cmd_epmem/#timers","title":"Timers","text":"<p>Episodic memory also has a set of internal timers that record the durations of certain operations. Because fine-grained timing can incur runtime costs, episodic memory timers are off by default. Timers of different levels of detail can be turned on by issuing <code>epmem --set timers &lt;level&gt;</code>, where the levels can be <code>off</code>, <code>one</code>, <code>two</code>, or <code>three</code>, <code>three</code> being most detailed and resulting in all timers being turned on. Note that none of the episodic memory statistics nor timing information is reported by the <code>stats</code> command.</p> <p>All timer values are reported in seconds.</p> <p>Level one</p> Timer Description <code>_total</code> Total epmem operations <p>Level two</p> Timer Description <code>epmem_api</code> Agent command validation <code>epmem_hash</code> Hashing symbols <code>epmem_init</code> Episodic store initialization <code>epmem_ncb_retrieval</code> Episode reconstruction <code>epmem_next</code> Determining next episode <code>epmem_prev</code> Determining previous episode <code>epmem_query</code> Cue-based query <code>epmem_storage</code> Encoding new episodes <code>epmem_trigger</code> Deciding whether new episodes should be encoded <code>epmem_wm_phase</code> Converting preference assertions to working memory changes <p>Level three</p> Timer Description <code>ncb_edge</code> Collecting edges during reconstruction <code>ncb_edge_rit</code> Collecting edges from relational interval tree <code>ncb_node</code> Collecting nodes during reconstruction <code>ncb_node_rit</code> Collecting nodes from relational interval tree <code>query_cleanup</code> Deleting dynamic data structures <code>query_dnf</code> Building the first level of the DNF <code>query_graph_match</code> Graph match <code>query_result</code> Putting the episode in working memory <code>query_sql_edge</code> SQL query for an edge <code>query_sql_end_ep</code> SQL query for the end of the range of an edge <code>query_sql_end_now</code> SQL query for the end of the now of an edge <code>query_sql_end_point</code> SQL query for the end of the point of an edge <code>query_sql_start_ep</code> SQL query for the start of the range of an edge <code>query_sql_start_now</code> SQL query for the start of the now of an edge <code>query_sql_start_point</code> SQL query for the start of the point of an edge <code>query_walk</code> Walking the intervals <code>query_walk_edge</code> Expanding edges while walking the intervals <code>query_walk_interval</code> Updating satisfaction while walking the intervals"},{"location":"reference/cli/cmd_epmem/#visualization","title":"Visualization","text":"<p>When debugging agents using episodic memory it is often useful to inspect the contents of individual episodes. Running <code>epmem --viz &lt;episode id&gt;</code> will output the contents of an episode in graphviz format. For more information on this format and visualization tools, see http://www.graphviz.org. The <code>epmem --print</code> option has the same syntax, but outputs text that is similar to using the <code>print</code> command to get the substructure of an identifier in working memory, which is possibly more useful for interactive debugging.</p>"},{"location":"reference/cli/cmd_epmem/#see-also","title":"See Also","text":"<ul> <li>trace</li> <li>wm</li> </ul>"},{"location":"reference/cli/cmd_explain/","title":"explain","text":"<p>Allows you to explore how rules were learned.</p>"},{"location":"reference/cli/cmd_explain/#synopsis","title":"Synopsis","text":"<pre><code>======= Explainer Commands and Settings =======\nexplain ?                                             Print this help listing\n---------------- What to Record ---------------\nall                                    [ on | OFF ]   Record all rules learned\njustifications                         [ on | OFF ]   Record justifications\nrecord &lt;chunk-name&gt;                                   Record specific rule\nlist-chunks                                           List all rules learned\nlist-justifications                                   List all justifications\n----------- Starting an Explanation -----------\nchunk [&lt;chunk name&gt; | &lt;chunk id&gt; ]                    Start discussing chunk\nformation                                             Describe formation\n----------- Browsing an Explanation -----------\ninstantiation &lt;inst id&gt;                               Explain instantiation\nexplanation-trace                                     Switch explanation trace\nwm-trace                                              Switch to WM trace\n------------ Supporting Analysis --------------\nconstraints                                           Display extra transitive\n                                                       constraints required by\n                                                       problem-solving\nidentity                                              Display identity to\n                                                       identity set mappings\nstats                                                 Display statistics about\n                                                       currently discussed chunk\n------------------ Settings -------------------\nafter-action-report                    [ on | OFF ]   Print statistics to file\n                                                       on init and exit\nonly-chunk-identities                  [ ON | off ]   Identity analysis only\n                                                       prints identities sets\n                                                       found in chunk\n-----------------------------------------------\n\nTo change a setting:                               explain &lt;setting&gt; [&lt;value&gt;]\nFor a detailed explanation of these settings:      help explain\n</code></pre>"},{"location":"reference/cli/cmd_explain/#summary-screen","title":"Summary Screen","text":"<p>Using the <code>explain</code> command without any arguments will display a summary of which rule firings the explainer is watching for learning. It also shows which chunk or justification the user has specified is the current focus of its output, i.e. the chunk being discussed.</p> <p>Tip: This is a good way to get a chunk id so that you don't have to type or paste in a chunk name.</p> <pre><code>=======================================================\n                   Explainer Summary\n=======================================================\nWatch all chunk formations                            Yes\nExplain justifications                                No\nNumber of specific rules watched                      0\n\nChunks available for discussion:                      chunkx2*apply2 (c 14)\n                                                      chunk*apply*o (c 13)\n                                                      chunkx2*apply2 (c 12)\n                                                      chunk*apply*d (c 11)\n                                                      chunkx2*apply2 (c 6)\n                                                      chunk*apply* (c 15)\n                                                      chunkx2*apply (c 8)\n                                                      chunk*apply*c (c 5)\n                                                      chunkx2*apply (c 10)\n                                                      chunk*apply (c 1)\n\n* Note:  Printed the first 10 chunks. 'explain list' to see other 6 chunks.\n\nCurrent chunk being discussed:                        chunk*apply*down-gripper(c 3)\n\nUse 'explain chunk [ &lt;chunk-name&gt; | id ]' to discuss the formation of that chunk.\nUse 'explain ?' to learn more about explain's sub-command and settings.\n</code></pre>"},{"location":"reference/cli/cmd_explain/#explain-chunk","title":"explain chunk","text":"<p>This starts the process.</p> <p>Tip: Use <code>c</code>, which is an alias to <code>explain chunk</code>, to quickly start discussing a chunk, for example:</p> <pre><code>soar % c 3\nNow explaining chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1.\n- Note that future explain commands are now relative\n  to the problem-solving that led to that chunk.\n\nExplanation Trace                                     Using variable identity IDs                  Shortest Path to Result Instantiation\n\nsp {chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1\n1:    (&lt;s1&gt; ^top-state &lt;s2&gt;)                          ([140] ^top-state [162])\n     -{\n2:    (&lt;s1&gt; ^operator &lt;o*1&gt;)                          ([140] ^operator [141])\n3:    (&lt;o*1&gt; ^name evaluate-operator)                 ([141] ^name evaluate-operator)\n     }\n4:    (&lt;s2&gt; ^gripper &lt;g1&gt;)                            ([162] ^gripper [156])                       i 30 -&gt; i 31\n5:    (&lt;g1&gt; ^position up)                             ([156] ^position up)                         i 30 -&gt; i 31\n6:    (&lt;g1&gt; ^holding nothing)                         ([156] ^holding nothing)                     i 30 -&gt; i 31\n7:    (&lt;g1&gt; ^above &lt;t1&gt;)                              ([156] ^above [157])                         i 30 -&gt; i 31\n8:    (&lt;s2&gt; ^io &lt;i2&gt;)                                 ([162] ^io [163])                            i 31\n9:    (&lt;i2&gt; ^output-link &lt;i1&gt;)                        ([163] ^output-link [164])                   i 31\n10:   (&lt;i1&gt; ^gripper &lt;g2&gt;)                            ([164] ^gripper [165])                       i 31\n11:   (&lt;s2&gt; ^clear { &lt;&gt; &lt;t1&gt; &lt;b1&gt; })                  ([162] ^clear { &lt;&gt;[161]  [161] })            i 30 -&gt; i 31\n12:   (&lt;s1&gt; ^operator &lt;o1&gt;)                           ([140] ^operator [149])\n13:   (&lt;o1&gt; ^moving-block &lt;b1&gt;)                       ([149] ^moving-block [161])\n14:   (&lt;o1&gt; ^name pick-up)                            ([149] ^name pick-up)\n      --&gt;\n1:    (&lt;g2&gt; ^command move-gripper-above +)            ([165] ^command move-gripper-above +)\n2:    (&lt;g2&gt; ^destination &lt;c1&gt; +)                      ([165] ^destination [161] +)\n}\n</code></pre>"},{"location":"reference/cli/cmd_explain/#explain-formation","title":"explain formation","text":"<p><code>explain formation</code> provides an explanation of the initial rule that fired which created a result. This is what is called the 'base instantiation' and is what led to the chunk being learned. Other rules may also be base instantiations if they previously created children of the base instantiation's results. They also will be listed in the initial formation output.</p> <pre><code>soar % explain formation\n------------------------------------------------------------------------------------\nThe formation of chunk 'chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1' (c 1)\n------------------------------------------------------------------------------------\n\nInitial base instantiation (i 31) that fired when apply*move-gripper-above*pass*top-state matched at level 3 at time 6:\n\nExplanation trace of instantiation # 31            (match of rule apply*move-gripper-above*pass*top-state at level 3)\n (produced chunk result)\n                                                   Identities instead of variables       Operational    Creator\n\n1:    (&lt;s&gt; ^operator &lt;op&gt;)                         ([159] ^operator [160])                   No         i 30 (pick-up*propose*move-gripper-above)\n2:    (&lt;op&gt; ^name move-gripper-above)              ([160] ^name move-gripper-above)          No         i 30 (pick-up*propose*move-gripper-above)\n3:    (&lt;op&gt; ^destination &lt;des&gt;)                    ([160] ^destination [161])                No         i 30 (pick-up*propose*move-gripper-above)\n4:    (&lt;s&gt; ^top-state &lt;t*1&gt;)                       ([159] ^top-state [162])                  No         i 27 (elaborate*state*top-state)\n5:    (&lt;t*1&gt; ^io &lt;i*1&gt;)                            ([162] ^io [163])                         Yes        Higher-level Problem Space\n6:    (&lt;i*1&gt; ^output-link &lt;o*1&gt;)                   ([163] ^output-link [164])                Yes        Higher-level Problem Space\n7:    (&lt;o*1&gt; ^gripper &lt;gripper&gt;)                   ([164] ^gripper [165])                    Yes        Higher-level Problem Space\n   --&gt;\n1:    (&lt;gripper&gt; ^command move-gripper-above +)    ([165] ^command move-gripper-above +)\n2:    (&lt;gripper&gt; ^destination &lt;des&gt; +)             ([165] ^destination [161] +)\n------\n</code></pre> <p>This chunk summarizes the problem-solving involved in the following 5 rule firings:</p> <pre><code>   i 27 (elaborate*state*top-state)\n   i 28 (elaborate*state*operator*name)\n   i 29 (pick-up*elaborate*desired)\n   i 30 (pick-up*propose*move-gripper-above)\n   i 31 (apply*move-gripper-above*pass*top-state)\n</code></pre>"},{"location":"reference/cli/cmd_explain/#explain-instantiation","title":"explain instantiation","text":"<p>This is probably one of the most common things you will do while using the explainer. You are essentially browsing the instantiation graph one rule at a time.</p> <p>Tip: Use <code>i</code>, which is an alias to <code>explain instantiation</code>, to quickly view an instantiation, for example:</p> <pre><code>soar % i 30\nExplanation trace of instantiation # 30            (match of rule pick-up*propose*move-gripper-above at level 3)\n- Shortest path to a result: i 30 -&gt; i 31\n                                                   Identities instead of variables       Operational    Creator\n\n1:    (&lt;s&gt; ^name pick-up)                          ([152] ^name pick-up)                     No         i 28 (elaborate*state*operator*name)\n2:    (&lt;s&gt; ^desired &lt;d*1&gt;)                         ([152] ^desired [153])                    No         i 29 (pick-up*elaborate*desired)\n3:    (&lt;d*1&gt; ^moving-block &lt;mblock&gt;)               ([153] ^moving-block [154])               No         i 29 (pick-up*elaborate*desired)\n4:    (&lt;s&gt; ^top-state &lt;ts&gt;)                        ([152] ^top-state [155])                  No         i 27 (elaborate*state*top-state)\n5:    (&lt;ts&gt; ^clear &lt;mblock&gt;)                       ([155] ^clear [154])                      Yes        Higher-level Problem Space\n6:    (&lt;ts&gt; ^gripper &lt;g&gt;)                          ([155] ^gripper [156])                    Yes        Higher-level Problem Space\n7:    (&lt;g&gt; ^position up)                           ([156] ^position up)                      Yes        Higher-level Problem Space\n8:    (&lt;g&gt; ^holding nothing)                       ([156] ^holding nothing)                  Yes        Higher-level Problem Space\n9:    (&lt;g&gt; ^above { &lt;&gt; &lt;mblock&gt; &lt;a*1&gt; })           ([156] ^above { &lt;&gt;[154]  [157] })         Yes        Higher-level Problem Space\n   --&gt;\n1:    (&lt;s&gt; ^operator &lt;op1&gt; +)                      ([152] ^operator [158] +)\n2:    (&lt;op1&gt; ^name move-gripper-above +)           ([158] ^name move-gripper-above +)\n3:    (&lt;op1&gt; ^destination &lt;mblock&gt; +)              ([158] ^destination [154] +)\n</code></pre>"},{"location":"reference/cli/cmd_explain/#explain-explanation-trace-and-wm-trace","title":"explain explanation-trace and wm-trace","text":"<p>In most cases, users spend most of their time browsing the explanation trace. This is where chunking learns most of the subtle relationships that you are likely to be debugging. But users will also need to examine the working memory trace to see the specific values matched.</p> <p>To switch between traces, you can use the <code>explain e</code> and the <code>explain w</code> commands.</p> <p>Tip: Use <code>et</code> and 'wt', which are aliases to the above two commands, to quickly switch between traces.</p> <pre><code>soar % explain w\nWorking memory trace of instantiation # 30     (match of rule pick-up*propose*move-gripper-above at level 3)\n1:    (S9 ^name pick-up)                               No         i 28 (elaborate*state*operator*name)\n2:    (S9 ^desired D6)                                 No         i 29 (pick-up*elaborate*desired)\n3:    (D6 ^moving-block B3)                            No         i 29 (pick-up*elaborate*desired)\n4:    (S9 ^top-state S1)                               No         i 27 (elaborate*state*top-state)\n5:    (S1 ^clear B3)                                   Yes        Higher-level Problem Space\n6:    (S1 ^gripper G2)                                 Yes        Higher-level Problem Space\n7:    (G2 ^position up)                                Yes        Higher-level Problem Space\n8:    (G2 ^holding nothing)                            Yes        Higher-level Problem Space\n9:    (G2 ^above { &lt;&gt; B3 T1 })                         Yes        Higher-level Problem Space\n   --&gt;\n1:    (S9 ^operator O9) +\n2:    (O9 ^name move-gripper-above) +\n3:    (O9 ^destination B3) +\n</code></pre>"},{"location":"reference/cli/cmd_explain/#explain-constraints","title":"explain constraints","text":"<p>This feature explains any constraints on the value of variables in the chunk that were required by the problem-solving that occurred in the substate. If these constraints were not met, the problem-solving would not have occurred.</p> <p>Explanation-based chunking tracks constraints as they apply to identity sets rather than how they apply to specific variables or identifiers. This means that sometimes constraints that appear in a chunk may have been a result of conditions that tested sub-state working memory element. Such conditions don't result in actual conditions in the chunk, but they can provide constraints. <code>explain constraints</code> allows users to see where such constraints came from.</p> <p>This feature is not yet implemented. You can use <code>explain stats</code> to see if any transitive constraints were added to a particular chunk.</p>"},{"location":"reference/cli/cmd_explain/#explain-identity","title":"explain identity","text":"<p><code>explain identity</code> will show the mappings from variable identities to identity sets. If available, the variable in a chunk that an identity set maps to will also be displayed. (Requires a debug build because of efficiency cost.)</p> <p>Variable identities are the ID values that are displayed when explaining an individual chunk or instantiation. An identity set is a set of variable identities that were unified to a particular variable mapping. The null identity set indicates identities that should not be generalized, i.e. they retain their matched literal value even if the explanation trace indicates that the original rule had a variable in that element.</p> <p>By default, only identity sets that appear in the chunk will be displayed in the identity analysis. To see the identity set mappings for other sets, change the <code>only-chunk-identities</code> setting to <code>off</code>.</p> <pre><code>soar % explain identity\n=========================================================================\n-             Variablization Identity to Identity Set Mappings          -\n=========================================================================\n\n-== NULL Identity Set ==-\n\nThe following variable identities map to the null identity set and will\nnot be generalized: 282 301 138 291 355 336 227 309 328 318 128 218 345\n\n-== How variable identities map to identity sets ==-\n\nVariablization IDs      Identity     CVar    Mapping Type\n\nInstantiation 36:\n  125 -&gt; 482          | IdSet 12  | &lt;s&gt;       | New identity set\n  126 -&gt; 493          | IdSet 11  | &lt;o&gt;       | New identity set\nInstantiation 38:\nInstantiation 41:\n  146 -&gt; 482          | IdSet 12  | &lt;s&gt;       | New identity set\n  147 -&gt; 493          | IdSet 11  | &lt;o&gt;       | New identity set\nInstantiation 42:\n  151 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | New identity set\n  149 -&gt; 482          | IdSet 12  | &lt;s&gt;       | New identity set\n  150 -&gt; 493          | IdSet 11  | &lt;o&gt;       | New identity set\n  307 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  187 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  334 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  173 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  280 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\nInstantiation 53:\n  219 -&gt; 489          | IdSet 15  | &lt;b&gt;       | New identity set\nInstantiation 61:\nInstantiation 65:\n  319 -&gt; 492          | IdSet 20  | &lt;t&gt;       | New identity set\n</code></pre>"},{"location":"reference/cli/cmd_explain/#explain-stats","title":"explain stats","text":"<p><code>explain stats</code> prints statistics about the chunk being discussed.</p> <pre><code>===========================================================\nStatistics for 'chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1' (c 1):\n===========================================================\nNumber of conditions                                       14\nNumber of actions                                          2\nBase instantiation                                         i 31 (apply*move-gripper-above*pass*top-state)\n\n===========================================================\n                 Generality and Correctness\n===========================================================\n\nTested negation in local substate                          No\nLHS required repair                                        No\nRHS required repair                                        No\nWas unrepairable chunk                                     No\n\n===========================================================\n                      Work Performed\n===========================================================\nInstantiations backtraced through                          5\nInstantiations skipped                                     6\nConstraints collected                                      1\nConstraints attached                                       0\nDuplicates chunks later created                            0\nConditions merged                                          2\n</code></pre>"},{"location":"reference/cli/cmd_explain/#after-action-reports","title":"After-Action Reports","text":"<p>The explainer has an option to create text files that contain statistics about the rules learned by an agent during a particular run. When enabled, the explainer will write out a file with the statistics when either Soar exits or a <code>soar init</code> is executed. This option is still considered experimental and in beta.</p>"},{"location":"reference/cli/cmd_explain/#explaining-learned-procedural-knowledge","title":"Explaining Learned Procedural Knowledge","text":"<p>While explanation-based chunking makes it easier for people to now incorporate learning into their agents, the complexity of the analysis it performs makes it far more difficult to understand how the learned rules were formed. The explainer is a new module that has been developed to help ameliorate this problem. The explainer allows you to interactively explore how rules were learned.</p> <p>When requested, the explainer will make a very detailed record of everything that happened during a learning episode. Once a user specifies a recorded chunk to \"discuss\", they can browse all of the rule firings that contributed to the learned rule, one at a time. The explainer will present each of these rules with detailed information about the identity of the variables, whether it tested knowledge relevant to the the superstate, and how it is connected to other rule firings in the substate. Rule firings are assigned IDs so that user can quickly choose a new rule to examine.</p> <p>The explainer can also present several different screens that show more verbose analyses of how the chunk was created. Specifically, the user can ask for a description of (1) the chunk\u2019s initial formation, (2) the identities of variables and how they map to identity sets, (3) the constraints that the problem-solving placed on values that a particular identity can have, and (4) specific statistics about that chunk, such as whether correctness issues were detected or whether it required repair to make it fully operational.</p> <p>Finally, the explainer will also create the data necessary to visualize all of the processing described in an image using the new \u2019visualize\u2019 command. These visualizations are the easiest way to quickly understand how a rule was formed.</p> <p>Note that, despite recording so much information, a lot of effort has been put into minimizing the cost of the explainer. When debugging, we often let it record all chunks and justifications formed because it is efficient enough to do so.</p> <p>Use the explain command without any arguments to display a summary of which rule firings the explainer is watching. It also shows which chunk or justification the user has specified is the current focus of its output, i.e. the chunk being discussed.</p> <p>Tip: This is a good way to get a chunk id so that you don\u2019t have to type or paste in a chunk name.</p>"},{"location":"reference/cli/cmd_explain/#visualizing-an-explanation","title":"Visualizing an Explanation","text":"<p>Soar's <code>visualize</code> command allows you to create images that represent processing that the explainer recorded. There are two types of explainer-related visualizations.</p> <p>(1) The visualizer can create an image that shows the entire instantiation graph at once and how it contributed to the learned rule. The graph includes arrows that show the dependencies between actions in one rule and conditions in others. This image is one of the most effective ways to understand how a chunk was formed, especially for particularly complex chunks. To use this feature, first choose a chunk for discussion. You can then issue the <code>visualize</code> command with the appropriate settings.</p> <p>(2) The visualizer can also create an image that shows how identities were joined during identity analysis. This can be useful in determining why two elements were assigned the same variable.</p>"},{"location":"reference/cli/cmd_explain/#default-aliases","title":"Default Aliases","text":"<pre><code>c    explain chunk\ni    explain instantiation\n\nef   explain formation\nei   explain identities\nes   explain stats\n\net   explain explanation-trace\nwt   explain wm-trace\n</code></pre>"},{"location":"reference/cli/cmd_explain/#see-also","title":"See Also","text":"<ul> <li>chunk</li> <li>visualize</li> </ul>"},{"location":"reference/cli/cmd_file_system/","title":"File System","text":"<p>Soar can handle the following Unix-style file system navigation commands</p>"},{"location":"reference/cli/cmd_file_system/#pwd","title":"pwd","text":"<p>Print the current working directory.</p>"},{"location":"reference/cli/cmd_file_system/#ls","title":"ls","text":"<p>List the contents of the current working directory.</p>"},{"location":"reference/cli/cmd_file_system/#cd","title":"cd","text":"<p>Change the current working directory. If run with no arguments, returns to the directory that the command line interface was started in, often referred to as the home directory.</p>"},{"location":"reference/cli/cmd_file_system/#dirs","title":"dirs","text":"<p>This command lists the directory stack. Agents can move through a directory structure by pushing and popping directory names. The dirs command returns the stack.</p>"},{"location":"reference/cli/cmd_file_system/#pushd","title":"pushd","text":"<p>Push the directory on to the stack. Can be relative path name or a fully specified one.</p>"},{"location":"reference/cli/cmd_file_system/#popd","title":"popd","text":"<p>Pop the current working directory off the stack and change to the next directory on the stack. Can be relative pathname or a fully specified path.</p>"},{"location":"reference/cli/cmd_file_system/#default-aliases","title":"Default Aliases","text":"<pre><code>chdir        cd\ndir          ls\ntopd         pwd\n</code></pre>"},{"location":"reference/cli/cmd_gp/","title":"gp","text":"<p>Generate productions according to a specified pattern.</p>"},{"location":"reference/cli/cmd_gp/#synopsis","title":"Synopsis","text":"<pre><code>gp { production_body }\n</code></pre>"},{"location":"reference/cli/cmd_gp/#description","title":"Description","text":"<p>The gp command defines a pattern used to generate and source a set of Soar productions. <code>production_body</code> is a single argument that looks almost identical to a standard Soar rule that would be used with the sp command. Indeed, any syntax that is allowed in sp is also allowed in gp.</p> <p>Patterns in gp are specified with sets of whitespace-seprated values in square brackets. Every combination of values across all square-bracketed value lists will be generated. Values with whitespaces can be used if wrapped in pipes. Characters can also be escaped with a backslash (so string literals with embedded pipes and spaces outside of string literals are both possible).</p> <p>gp is primarily intended as an alternative to <code>:template</code> rules for reinforcement learning. <code>:template</code> rules generate new rules as patterns occur at run time. Unfortunately, this incurs a high run time cost. If all possible values are known in advance, then the rules can be generated using gp at source time, thus allowing code to run faster. gp is not appropriate when all possible values are not known or if the total number of possible rules is very large (and the system is likely to encounter only a small subset at run time). It is also possible to combine gp and <code>:template</code> (e.g., if some of the values are known and not others). This should reduce the run time cost of <code>:template</code>.</p> <p>There is nothing that actually restricts gp to being used for RL, although for non-RL rules, a disjunction list (using <code>&lt;&lt;</code> and <code>&gt;&gt;</code>) is better where it can be used. More esoteric uses may include multiple bracketed value lists inside a disjunction list, or even variables in bracketed value lists.</p> <p>Each rule generated by gp has <code>*integer</code> appended to its name (where <code>integer</code> is some incrementing number).</p>"},{"location":"reference/cli/cmd_gp/#examples","title":"Examples","text":"<p>Template version of rule:</p> <pre><code>sp {water-jug*fill\n   :template\n   (state &lt;s1&gt; ^name water-jug ^operator &lt;op&gt; +\n               ^jug &lt;j1&gt; &lt;j2&gt;)\n   (&lt;op&gt; ^name fill ^fill-jug.volume &lt;fvol&gt;)\n   (&lt;j1&gt; ^volume 3 ^contents &lt;c1&gt;)\n   (&lt;j2&gt; ^volume 5 ^contents &lt;c2&gt;)\n--&gt;\n   (&lt;s1&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <p><code>gp</code> version of rule (generates 144 rules):</p> <pre><code>gp {water-jug*fill\n   (state &lt;s1&gt; ^name water-jug ^operator &lt;op&gt; +\n               ^jug &lt;j1&gt; &lt;j2&gt;)\n   (&lt;op&gt; ^name fill ^fill-jug.volume [3 5])\n   (&lt;j1&gt; ^volume 3 ^contents [0 1 2 3])\n   (&lt;j2&gt; ^volume 5 ^contents [0 1 2 3 4 5])\n--&gt;\n   (&lt;s1&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <p>Esoteric example (generates 24 rules):</p> <pre><code>gp {strange-example\n   (state &lt;s1&gt; ^&lt;&lt; [att1 att2] [att3 att4] &gt;&gt; [ val |another val| |strange val\\|| ])\n--&gt;\n   (&lt;s1&gt; ^foo [bar &lt;bar&gt;])\n}\n</code></pre> <p>testgp.soar contains many more examples.</p>"},{"location":"reference/cli/cmd_gp/#see-also","title":"See Also","text":"<ul> <li>sp</li> </ul>"},{"location":"reference/cli/cmd_help/","title":"help","text":"<p>Provide formatted usage information about Soar commands.</p>"},{"location":"reference/cli/cmd_help/#synopsis","title":"Synopsis","text":"<pre><code>help [command_name]\n</code></pre>"},{"location":"reference/cli/cmd_help/#default-aliases","title":"Default Aliases","text":"<ul> <li><code>?</code></li> <li><code>man</code></li> </ul>"},{"location":"reference/cli/cmd_help/#description","title":"Description","text":"<p>This command prints formatted help for the given command name. Issue alone to see what topics have help available.</p>"},{"location":"reference/cli/cmd_load/","title":"load","text":"<p>Loads soar files, rete networks, saved percept streams and external libraries.</p>"},{"location":"reference/cli/cmd_load/#synopsis","title":"Synopsis","text":"<pre><code>============================================================\n-               Load Sub-Commands and Options              -\n============================================================\nload                            [? | help]\n------------------------------------------------------------\nload file                       [--all --disable] &lt;filename&gt;\nload file                       [--verbose]     ]\n------------------------------------------------------------\nload library                    &lt;filename&gt; &lt;args...&gt;\n------------------------------------------------------------\nload rete-network               --load &lt;filename&gt;\n------------------------------------------------------------\nload percepts                   --open &lt;filename&gt;\nload percepts                   --close\n------------------------------------------------------------\n</code></pre>"},{"location":"reference/cli/cmd_load/#load-file","title":"load file","text":"<p>Load and evaluate the contents of a file. The <code>filename</code> can be a relative path or a fully qualified path. The source will generate an implicit push to the new directory, execute the command, and then pop back to the current working directory from which the command was issued. This is traditionally known as the source command.</p>"},{"location":"reference/cli/cmd_load/#options","title":"Options","text":"Option Description <code>filename</code> The file of Soar productions and commands to load. <code>-a, --all</code> Enable a summary for each file sourced <code>-d, --disable</code> Disable all summaries <code>-v, --verbose</code> Print excised production names"},{"location":"reference/cli/cmd_load/#summaries","title":"Summaries","text":"<p>After the source completes, the number of productions sourced and excised is summarized:</p> <pre><code>agent&gt; source demos/mac/mac.soar\n******************\nTotal: 18 productions sourced.\nSource finished.\nagent&gt; source demos/mac/mac.soar\n#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\nTotal: 18 productions sourced. 18 productions excised.\nSource finished.\n</code></pre> <p>This can be disabled by using the <code>-d</code> flag.</p>"},{"location":"reference/cli/cmd_load/#multiple-summaries","title":"Multiple Summaries","text":"<p>A separate summary for each file sourced can be enabled using the <code>-a</code> flag:</p> <pre><code>agent&gt; source demos/mac/mac.soar -a\n_firstload.soar: 0 productions sourced.\nall_source.soar: 0 productions sourced.\n**\ngoal-test.soar: 2 productions sourced.\n***\nmonitor.soar: 3 productions sourced.\n****\nsearch-control.soar: 4 productions sourced.\ntop-state.soar: 0 productions sourced.\nelaborations_source.soar: 0 productions sourced.\n_readme.soar: 0 productions sourced.\n**\ninitialize-mac.soar: 2 productions sourced.\n*******\nmove-boat.soar: 7 productions sourced.\nmac_source.soar: 0 productions sourced.\nmac.soar: 0 productions sourced.\nTotal: 18 productions sourced.\nSource finished.\n</code></pre>"},{"location":"reference/cli/cmd_load/#listing-excised-productions","title":"Listing Excised Productions","text":"<pre><code>agent&gt; source demos/mac/mac.soar -d\n******************\nSource finished.\nagent&gt; source demos/mac/mac.soar -d\n#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\nSource finished.\n</code></pre> <p>A list of excised productions is available using the <code>-v</code> flag:</p> <pre><code>agent&gt; source demos/mac/mac.soar -v\n#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*\nTotal: 18 productions sourced. 18 productions excised.\nExcised productions:\n        mac*detect*state*success\n        mac*evaluate*state*failure*more*cannibals\n        monitor*move-boat\n        monitor*state*left\n...\n</code></pre> <p>Combining the <code>-a</code> and <code>-v</code> flags add excised production names to the output for each file.</p>"},{"location":"reference/cli/cmd_load/#load-rete-network","title":"load rete-network","text":"<p>The <code>load rete-network</code> command loads a Rete net previously saved. The Rete net is Soar's internal representation of production memory; the conditions of productions are reordered and common substructures are shared across different productions. This command provides a fast method of saving and loading productions since a special format is used and no parsing is necessary. Rete-net files are portable across platforms that support Soar.</p> <p>If the filename contains a suffix of <code>.Z</code>, then the file is compressed automatically when it is saved and uncompressed when it is loaded. Compressed files may not be portable to another platform if that platform does not support the same uncompress utility.</p>"},{"location":"reference/cli/cmd_load/#usage","title":"Usage","text":"<pre><code>load rete-network -l &lt;filename&gt;\n</code></pre>"},{"location":"reference/cli/cmd_load/#load-percepts","title":"load percepts","text":"<p>Replays input stored using the capture-input command. The replay file also includes a random number generator seed and seeds the generator with that.</p>"},{"location":"reference/cli/cmd_load/#synopsis_1","title":"Synopsis","text":"<pre><code>load percepts --open filename\nload percepts --close\n</code></pre>"},{"location":"reference/cli/cmd_load/#options_1","title":"Options","text":"Option Description <code>filename</code> Open filename and load input and random seed. <code>-o, --open</code> Reads captured input from file in to memory and seeds the random number generator. <code>-c, --close</code> Stop replaying input."},{"location":"reference/cli/cmd_load/#load-library","title":"load library","text":"<p>Load a shared library into the local client (for the purpose of, e.g., providing custom event handling).</p>"},{"location":"reference/cli/cmd_load/#options_2","title":"Options","text":"Option Description <code>library_name</code> The root name of the library (without the .dll or .so extension; this is added for you depending on your platform). <code>arguments</code> Whatever arguments the library's initialization function is expecting, if any."},{"location":"reference/cli/cmd_load/#technical-details","title":"Technical Details","text":"<p>Sometimes, a user will want to extend an existing environment. For example, the person may want to provide custom RHS functions, or register for print events for the purpose of logging trace information. If modifying the existing environment is cumbersome or impossible, then the user has two options: create a remote client that provides the functionality, or use load library. <code>load library</code> creates extensions in the local client, making it orders of magnitude faster than a remote client.</p> <p>To create a loadable library, the library must contain the following function:</p> <pre><code>#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n    EXPORT char* sml_InitLibrary(Kernel* pKernel, int argc, char** argv) {\n        // Your code here\n    }\n\n#ifdef __cplusplus\n} // extern \"C\"\n#endif\n</code></pre> <p>This function is called when <code>load library</code> loads your library. It is responsible for any initialization that you want to take place (e.g. registering custom RHS functions, registering for events, etc).</p> <p>The <code>argc</code> and <code>argv</code> arguments are intended to mirror the arguments that a standard SML client would get. Thus, the first argument is the name of the library, and the rest are whatever other arguments are provided. This is to make it easy to use the same codebase to create a loadable library or a standard remote SML client (e.g. when run as a standard client, just pass the arguments main gets into <code>sml_InitLibrary</code>).</p> <p>The return value of <code>sml_InitLibrary</code> is for any error messages you want to return to the load-library call. If no error occurs, return a zero-length string.</p> <p>An example library is provided in the <code>Tools/TestExternalLibraryLib</code> project. This example can also be compiled as a standard remote SML client. The <code>Tools/TestExternalLibraryExe</code> project tests loading the <code>TestExternalLibraryLib</code> library.</p>"},{"location":"reference/cli/cmd_load/#load-library-examples","title":"Load Library Examples","text":"<p>To load <code>TestExternalLibraryLib</code>:</p> <pre><code>load library TestExternalLibraryLib\n</code></pre> <p>To load a library that takes arguments (say, a logger):</p> <pre><code>load library my-logger -filename mylog.log\n</code></pre>"},{"location":"reference/cli/cmd_load/#default-aliases","title":"Default aliases","text":"<pre><code>source               load file\nrete-net, rn         load rete-network\nreplay-input         load input\nload-libarary        load library\n</code></pre>"},{"location":"reference/cli/cmd_load/#see-also","title":"See Also","text":"<ul> <li>file system</li> <li>decide</li> <li>production</li> <li>save</li> </ul>"},{"location":"reference/cli/cmd_output/","title":"output","text":"<p>Controls settings related to Soar's output</p>"},{"location":"reference/cli/cmd_output/#synopsis","title":"Synopsis","text":"<pre><code>=======================================================\n-           Output Sub-Commands and Options           -\n=======================================================\noutput                                       [? | help]\n-------------------------------------------------------\nenabled                                              on   Globally toggle all output\nconsole                                             off   Send output to std::out for debugging\ncallbacks                                            on   Send output to standard print callback\n-------------------------------------------------------\nagent-logs                  &lt;channel-number&gt; [ON | off]   Whether agent log channel prints\nagent-writes                                         on   Allow RHS-funtion output\n-------------------------------------------------------\noutput log                   [--append | -A] &lt;filename&gt;   Log all output to file\noutput log                               --add &lt;string&gt;\noutput log                                    [--close]\n-------------------------------------------------------\noutput command-to-file         [-a] &lt;file&gt; &lt;cmd&gt; [args]   Log output from single command\n-------------------------------------------------------\necho-commands                                       off   Echo commands to debugger\nprint-depth                                           1   Default print depth\nwarnings                                             on   Print all warnings\n-------------------------------------------------------\nTo view/change a setting:                                 output &lt;setting&gt; [&lt;value&gt;]\n\nFor a detailed explanation of these settings:             help output\n</code></pre>"},{"location":"reference/cli/cmd_output/#summary-screen","title":"Summary Screen","text":"<p>Using the <code>output</code> command without any arguments will display some key output settings:</p> <pre><code>=======================================================\n-                   Output Status                     -\n=======================================================\nPrinting enabled                                    Yes\nPrinting to std::out                                Yes\n-------------------------------------------------------\nAgent RHS write output                               on\nAll agent log channels enabled.\n-------------------------------------------------------\nWarnings                                             on\n-------------------------------------------------------\nSoar release compilation                            OFF\nDebug printing                                       ON\n-------------------------------------------------------\n</code></pre>"},{"location":"reference/cli/cmd_output/#output-command-to-file","title":"output command-to-file","text":"<p>This command logs a single command. It is almost equivalent to opening a log using clog, running the command, then closing the log, the only difference is that input isn't recorded.</p> <p>Running this command while a log is open is an error. There is currently not support for multiple logs in the command line interface, and this would be an instance of multiple logs.</p> <p>This command echoes output both to the screen and to a file, just like clog.</p>"},{"location":"reference/cli/cmd_output/#options","title":"Options","text":"Option Description <code>-a, --append</code> Append if file exists. <code>filename</code> The file to log the results of the command to <code>command</code> The command to log <code>args</code> Arguments for command"},{"location":"reference/cli/cmd_output/#output-log","title":"output log","text":"<p>The <code>output log</code> command allows users to save all user-interface input and output to a file. When Soar is logging to a file, everything typed by the user and everything printed by Soar is written to the file (in addition to the screen).</p> <p>Invoke <code>output log</code> with no arguments to query the current logging status. Pass a filename to start logging to that file (relative to the command line interface's home directory). Use the <code>close</code> option to stop logging.</p>"},{"location":"reference/cli/cmd_output/#usage","title":"Usage","text":"<pre><code>output log [-A] filename\noutput log --add string\noutput log --close\n</code></pre>"},{"location":"reference/cli/cmd_output/#options_1","title":"Options","text":"Option Description <code>filename</code> Open filename and begin logging. <code>-c, --close</code> Stop logging, close the file. <code>-a, --add string</code> Add the given string to the open log file. <code>-A, --append</code> Opens existing log file named <code>filename</code> and logging is added at the end of the file."},{"location":"reference/cli/cmd_output/#examples","title":"Examples","text":"<p>To initiate logging and place the record in foo.log:</p> <pre><code>output log foo.log\n</code></pre> <p>To append log data to an existing foo.log file:</p> <pre><code>output log -A foo.log\n</code></pre> <p>To terminate logging and close the open log file:</p> <pre><code>output log -c\n</code></pre>"},{"location":"reference/cli/cmd_output/#known-issues-with-log","title":"Known Issues with log","text":"<p>Does not log everything when structured output is selected.</p>"},{"location":"reference/cli/cmd_output/#general-output-settings","title":"General Output Settings","text":"<p>Invoke a sub-command with no arguments to query the current setting. Partial commands are accepted.</p> Option Valid Values Default <code>echo-commands</code> yes or no off <code>print-depth</code> &gt;= 1 1 <code>verbose</code> yes or no no <code>warnings</code> yes or no yes"},{"location":"reference/cli/cmd_output/#output-agent-logs","title":"output agent-logs","text":"<p>A Soar agent has 100 log channels available. By default, all are turned on. The <code>log</code> RHS-function allows printing as with the <code>write</code> function, but limits output to only the specified log channel.</p>"},{"location":"reference/cli/cmd_output/#output-echo-commands","title":"output echo-commands","text":"<p><code>output echo-commands</code> will echo typed commands to other connected debuggers. Otherwise, the output is displayed without the initiating command, and this can be confusing.</p>"},{"location":"reference/cli/cmd_output/#output-print-depth","title":"output print-depth","text":"<p>The <code>print-depth</code> command reflects the default depth used when working memory elements are printed (using the print). The default value is <code>1</code>. This default depth can be overridden on any particular call to the print command by explicitly using the <code>--depth</code> flag, e.g. <code>print --depth 10 args</code>.</p> <p>By default, the print command prints objects in working memory, not just the individual working memory element. To limit the output to individual working memory elements, the <code>--internal</code> flag must also be specified in the print command. Thus when the print depth is <code>0</code>, by default Soar prints the entire object, which is the same behavior as when the print depth is <code>1</code>. But if <code>--internal</code> is also specified, then a depth of <code>0</code> prints just the individual WME, while a depth of <code>1</code> prints all WMEs which share that same identifier. This is true when printing timetags, identifiers or WME patterns.</p> <p>When the depth is greater than <code>1</code>, the identifier links from the specified WME's will be followed, so that additional substructure is printed. For example, a depth of <code>2</code> means that the object specified by the identifier, wme-pattern, or timetag will be printed, along with all other objects whose identifiers appear as values of the first object. This may result in multiple copies of the same object being printed out. If <code>--internal</code> is also specified, then individuals WMEs and their timetags will be printed instead of the full objects.</p>"},{"location":"reference/cli/cmd_output/#output-verbose","title":"output verbose","text":"<p>The <code>verbose</code> command enables tracing of a number of low-level Soar execution details during a run. The details printed by <code>verbose</code> are usually only valuable to developers debugging Soar implementation details.</p>"},{"location":"reference/cli/cmd_output/#output-warnings","title":"output warnings","text":"<p>The <code>warnings</code> command enables and disables the printing of warning messages. At startup, warnings are initially enabled. If warnings are disabled using this command, then some warnings may still be printed, since some are considered too important to ignore.</p> <p>The warnings that are printed apply to the syntax of the productions, to notify the user when they are not in the correct syntax. When a lefthand side error is discovered (such as conditions that are not linked to a common state or impasse object), the production is generally loaded into production memory anyway, although this production may never match or may seriously slow down the matching process. In this case, a warning would be printed only if warnings were <code>on</code>. Righthand side errors, such as preferences that are not linked to the state, usually result in the production not being loaded, and a warning regardless of the warnings setting.</p>"},{"location":"reference/cli/cmd_output/#default-aliases","title":"Default Aliases","text":"<pre><code>ctf                        output command-to-file\nclog                       output log\ndefault-wme-depth          output print-depth\necho-commands              output echo-commands\nverbose                    output verbose\nwarnings                   output warnings\n</code></pre>"},{"location":"reference/cli/cmd_preferences/","title":"preferences","text":"<p>Examine details about the preferences that support the specified identifier and attribute.</p>"},{"location":"reference/cli/cmd_preferences/#synopsis","title":"Synopsis","text":"<pre><code>preferences [options] [identifier [attribute]]\n</code></pre>"},{"location":"reference/cli/cmd_preferences/#options","title":"Options","text":"Option Description <code>-0, -n, --none</code> Print just the preferences themselves <code>-1, -N, --names</code> Print the preferences and the names of the productions that generated them <code>-2, -t, --timetags</code> Print the information for the <code>--names</code> option above plus the timetags of the wmes matched by the LHS of the indicated productions <code>-3, -w, --wmes</code> Print the information for the <code>--timetags</code> option above plus the entire WME matched on the LHS. <code>-o, --object</code> Print the support for all the WMEs that comprise the object (the specified identifier). <code>identifier</code> Must be an existing Soar object identifier. <code>attribute</code> Must be an existing attribute of the specified identifier."},{"location":"reference/cli/cmd_preferences/#description","title":"Description","text":"<p>The <code>preferences</code> command prints all the preferences for the given object identifier and attribute. If identifier and attribute are not specified, they default to the current state and the current operator. The Soar syntax attribute caret (<code>^</code>) is optional when specifying the attribute. The optional arguments indicates the level of detail to print about each preference.</p> <p>This command is useful for examining which candidate operators have been proposed and what relationships, if any, exist among them. If a preference has o-support, the string, <code>:O</code> will also be printed.</p> <p>When only the identifier is specified on the command line, if the identifier is a state, Soar uses the default attribute <code>^operator</code>. If the identifier is not a state, Soar prints the support information for all WMEs whose value is the identifier.</p> <p>When an identifier and the <code>--object</code> flag are specified, Soar prints the preferences / WME support for all WMEs comprising the specified identifier.</p> <p>For the time being, numeric-indifferent preferences are listed under the heading <code>binary indifferents:</code>.</p> <p>By default, using the <code>--wmes</code> option with a WME on the top state will only print the timetags. To change this, the kernel can be recompiled with <code>DO_TOP_LEVEL_REF_CTS</code>, but this has other consequences (see comments in <code>kernel.h</code>).</p>"},{"location":"reference/cli/cmd_preferences/#examples","title":"Examples","text":"<p>This example prints the preferences on <code>(S1 ^operator)</code> and the production names which created the preferences:</p> <pre><code>soar&gt; preferences S1 operator --names\nPreferences for S1 ^operator:\n\nacceptables:\n  O2 (fill) + :I\n    From water-jug*propose*fill\n\n  O3 (fill) + :I\n    From water-jug*propose*fill\n\n\nunary indifferents:\n  O2 (fill) = :I\n    From water-jug*propose*fill\n\n  O3 (fill) = :I\n    From water-jug*propose*fill\n\n\nselection probabilities:\n  O3 (fill) + =0. :I (50.0%)\n    From water-jug*propose*fill\n\n  O2 (fill) + =0. :I (50.0%)\n    From water-jug*propose*fill\n</code></pre> <p>If the current state is <code>S1</code>, then the above syntax is equivalent to:</p> <pre><code>preferences -n\n</code></pre> <p>This example shows the support for the WMEs with the ^jug attribute:</p> <pre><code>soar&gt; preferences s1 jug\n\nPreferences for S1 ^jug:\n\nacceptables:\n  (S1 ^jug I4)  :O\n  (S1 ^jug J1)  :O\n</code></pre> <p>This example shows the support for the WMEs with value <code>J1</code>, and the productions that generated them:</p> <pre><code>soar&gt; pref J1 -1\n\nSupport for (33: O3 ^fill-jug J1)\n  (O3 ^fill-jug J1)  =0. :I (100.0%)\n    From water-jug*propose*fill\n\nSupport for (22: S1 ^jug J1)\n  (S1 ^jug J1)  =0. :O (100.0%)\n    From water-jug*apply*initialize-water-jug\n</code></pre> <p>This example shows the support for all WMEs that make up the object <code>S1</code>:</p> <pre><code>soar&gt; pref -o s1\n\nSupport for S1 ^name:\n  (S1 ^name water-jug)  :O\nSupport for S1 ^jug:\n  (S1 ^jug I4)  :O\n  (S1 ^jug J1)  :O\nSupport for S1 ^svs:\nPreferences for S1 ^operator:\nacceptables:\n  O2 (fill) + :I\n  O3 (fill) + :I\n\nunary indifferents:\n  O2 (fill) = :I\n  O3 (fill) = :I\nSupport for S1 ^smem:\nSupport for S1 ^epmem:\nSupport for S1 ^reward-link:\nArch-created wmes for S1 :\n(2: S1 ^superstate nil)\n(1: S1 ^type state)\nInput (IO) wmes for S1 :\n(15: S1 ^io I1)\n</code></pre>"},{"location":"reference/cli/cmd_preferences/#default-aliases","title":"Default Aliases","text":"<ul> <li><code>pref</code></li> </ul>"},{"location":"reference/cli/cmd_preferences/#see-also","title":"See Also","text":"<ul> <li>decide</li> </ul>"},{"location":"reference/cli/cmd_print/","title":"print","text":"<p>Print items in working memory or production memory.</p>"},{"location":"reference/cli/cmd_print/#synopsis","title":"Synopsis","text":"<pre><code>print [options] [production_name]\nprint [options] identifier|timetag|pattern\nprint [--gds --stack]\n</code></pre>"},{"location":"reference/cli/cmd_print/#options","title":"Options","text":""},{"location":"reference/cli/cmd_print/#production-printing-options","title":"Production printing options","text":"Option Description <code>-a, --all</code> print the names of all productions currently loaded <code>-c, --chunks</code> print the names of all chunks currently loaded <code>-D, --defaults</code> print the names of all default productions currently loaded <code>-j, --justifications</code> print the names of all justifications currently loaded. <code>-r, --rl</code> Print Soar-RL rules <code>-T, --template</code> Print Soar-RL templates <code>-u, --user</code> print the names of all user productions currently loaded <code>production_name</code> print the production named <code>production-name</code>"},{"location":"reference/cli/cmd_print/#production-print-formatting","title":"Production print formatting","text":"Option Description <code>-f, --full</code> When printing productions, print the whole production. This is the default when printing a named production. <code>-F, --filename</code> also prints the name of the file that contains the production. <code>-i, --internal</code> items should be printed in their internal form. For productions, this means leaving conditions in their reordered (rete net) form. <code>-n, --name</code> When printing productions, print only the name and not the whole production. This is the default when printing any category of productions, as opposed to a named production."},{"location":"reference/cli/cmd_print/#working-memory-printing-options","title":"Working memory printing options","text":"Option Description <code>-d, --depth n</code> This option overrides the default printing depth (see the default-wme-depth command for more detail). <code>-e, --exact</code> Print only the wmes that match the pattern <code>-i, --internal</code> items should be printed in their internal form. For working memory, this means printing the individual elements with their timetags and activation, rather than the objects. <code>-t, --tree</code> wmes should be printed in in a tree form (one wme per line). <code>-v, --varprint</code> Print identifiers enclosed in angle brackets. <code>identifier</code> print the object <code>identifier</code>. <code>identifier</code> must be a valid Soar symbol such as S1 <code>pattern</code> print the object whose working memory elements matching the given <code>pattern</code>. See Description for more information on printing objects matching a specific <code>pattern</code>. <code>timetag</code> print the object in working memory with the given <code>timetag</code>"},{"location":"reference/cli/cmd_print/#subgoal-stack-printing-options","title":"Subgoal stack printing options","text":"Option Description <code>-s, --stack</code> Specifies that the Soar goal stack should be printed. By default this includes both states and operators. <code>-o, --operators</code> When printing the stack, print only operators. <code>-S, --states</code> When printing the stack, print only states."},{"location":"reference/cli/cmd_print/#printing-the-goal-dependency-set","title":"Printing the Goal Dependency Set","text":"<p><code>print --gds</code></p> <p>The Goal Dependency Set (GDS) is described in a subsection of the The Soar Architecture chapter of the manual. This command is a debugging command for examining the GDS for each goal in the stack. First it steps through all the working memory elements in the rete, looking for any that are included in any goal dependency set, and prints each one. Then it also lists each goal in the stack and prints the wmes in the goal dependency set for that particular goal.  This command is useful when trying to determine why subgoals are disappearing unexpectedly: often something has changed in the goal dependency set, causing a subgoal to be regenerated prior to producing a result.</p> <p><code>print --gds</code> is horribly inefficient and should not generally be used except when something is going wrong and you need to examine the Goal Dependency Set.</p>"},{"location":"reference/cli/cmd_print/#description","title":"Description","text":"<p>The print command is used to print items from production memory or working memory. It can take several kinds of arguments. When printing items from working memory, the Soar objects are printed unless the <code>--internal</code> flag is used, in which case the wmes themselves are printed.</p> <pre><code>(identifier ^attribute value [activation] [+])\n</code></pre> <p>The activation value is only printed if activation is turned on. See wm.</p> <p>The pattern is surrounded by parentheses. The <code>identifier</code>, <code>attribute</code>, and <code>value</code> must be valid Soar symbols or the wildcard symbol <code>*</code> which matches all occurrences. The optional <code>+</code> symbol restricts pattern matches to acceptable preferences. If wildcards are included, an object will be printed for each pattern match, even if this results in the same object being printed multiple times.</p>"},{"location":"reference/cli/cmd_print/#examples","title":"Examples","text":"<p>Print the objects in working memory (and their timetags) which have wmes with identifier <code>s1</code> and value <code>v2</code> (note: this will print the entire <code>s1</code> object for each match found):</p> <pre><code>print --internal (s1 ^* v2)\n</code></pre> <p>Print the Soar stack which includes states and operators:</p> <pre><code>print --stack\n</code></pre> <p>Print the named production in its RETE form:</p> <pre><code>print -if named*production\n</code></pre> <p>Print the names of all user productions currently loaded:</p> <pre><code>print -u\n</code></pre> <p>Default print vs tree print:</p> <pre><code>print s1 --depth 2\n(S1 ^io I1 ^reward-link R1 ^superstate nil ^type state)\n  (I1 ^input-link I2 ^output-link I3)\n\nprint s1 --depth 2 --tree\n(S1 ^io I1)\n  (I1 ^input-link I2)\n  (I1 ^output-link I3)\n(S1 ^reward-link R1)\n(S1 ^superstate nil)\n(S1 ^type state)\n</code></pre>"},{"location":"reference/cli/cmd_print/#default-aliases","title":"Default Aliases","text":"<pre><code>p print\npc print --chunks\nps print --stack\nwmes print --depth 0 --internal\nvarprint print --varprint --depth 100\ngds_print print --gds\n</code></pre>"},{"location":"reference/cli/cmd_print/#see-also","title":"See Also","text":"<ul> <li>output</li> <li>trace</li> <li>wm</li> </ul>"},{"location":"reference/cli/cmd_production/","title":"production","text":"<p>Commands to manipulate Soar rules and analyze their usage.</p>"},{"location":"reference/cli/cmd_production/#synopsis","title":"Synopsis","text":"<pre><code>==================================================================\n-               Production Sub-Commands and Options              -\n==================================================================\nproduction                    [? | help]\n------------------------------------------------------------------\nproduction break              [--clear --print]\nproduction break              --set &lt;prod-name&gt;\n------------------------------------------------------------------\nproduction excise             &lt;production-name&gt;\nproduction excise             [--all --chunks --default ]\n                              [--never-fired --rl       ]\n                              [--task --templates --user]\n------------------------------------------------------------------\nproduction find               [--lhs --rhs         ] &lt;pattern&gt;\n                              [--show-bindings     ]\n                              [--chunks --nochunks ]\n------------------------------------------------------------------\nproduction firing-counts      [--all --chunks --default --rl]  [n]\n                              [--task --templates --user --fired]\nproduction firing-counts      &lt;prod-name&gt;\n------------------------------------------------------------------\nproduction matches            [--names --count  ]  &lt;prod-name&gt;\n                              [--timetags --wmes]\nproduction matches            [--names --count  ] [--assertions ]\n                              [--timetags --wmes] [--retractions]\n------------------------------------------------------------------\nproduction memory-usage       [options] [max]\nproduction memory-usage       &lt;production_name&gt;\n------------------------------------------------------------------\nproduction optimize-attribute [symbol [n]]\n------------------------------------------------------------------\nproduction watch              [--disable --enable] &lt;prod-name&gt;\n------------------------------------------------------------------\n\nFor a detailed explanation of sub-commands:    help production\n</code></pre>"},{"location":"reference/cli/cmd_production/#summary-screen","title":"Summary Screen","text":"<p>Using the <code>production</code> command without any arguments will display a summary of how many rules are loaded into memory:</p> <pre><code>=======================================================\n-                     Productions                     -\n=======================================================\nUser rules                                            0\nDefault rules                                         0\nChunks                                                0\nJustifications                                        0\n-------------------------------------------------------\nTotal                                                 0\n-------------------------------------------------------\nUse 'production ?' to learn more about the command\n</code></pre>"},{"location":"reference/cli/cmd_production/#production-break","title":"production break","text":"<p>Toggles the <code>:interrupt</code> flag on a rule at run-time, which stops the Soar decision cycle when the rule fires. The <code>break</code> command can be used to toggle the <code>:interrupt</code> flag on production rules which did not have it set in the original source file, which stops the Soar decision cycle when the rule fires. This is intended to be used for debugging purposes.</p>"},{"location":"reference/cli/cmd_production/#synopsis-break","title":"Synopsis Break","text":"<pre><code>production break -c|--clear &lt;production-name&gt;\nproduction break -p|--print\nproduction break -s|--set &lt;production-name&gt;\nproduction break &lt;production-name&gt;\n</code></pre>"},{"location":"reference/cli/cmd_production/#options","title":"Options","text":"Parameter Argument Description <code>-c, --clear</code> &lt;production-name&gt; Clear :interrupt flag from a production. <code>-p, --print</code> (none) Print which production rules have had their :interrupt flags set. (none) (none) Print which production rules have had their :interrupt flags set. <code>-s, --set</code> &lt;production-name&gt; Set :interrupt flag on a production rule. (none) &lt;production-name&gt; Set flag :interrupt on a production rule."},{"location":"reference/cli/cmd_production/#production-excise","title":"production excise","text":"<p>This command removes productions from Soar's memory. The command must be called with either a specific production name or with a flag that indicates a particular group of productions to be removed.</p> <p>Note: As of Soar 9.6, using the flag <code>-a</code> or <code>--all</code> no longer causes a <code>soar init</code>.</p>"},{"location":"reference/cli/cmd_production/#synopsis-excise","title":"Synopsis Excise","text":"<pre><code>production excise production_name\nproduction excise options\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_1","title":"Options","text":"Option Description <code>-a, --all</code> Remove all productions from memory and perform an init-soar command <code>-c, --chunks</code> Remove all chunks (learned productions) and justifications from memory <code>-d, --default</code> Remove all default productions (<code>:default</code>) from memory <code>-n, --never-fired</code> Excise rules that have a firing count of 0 <code>-r, --rl</code> Excise Soar-RL rules <code>-t, --task</code> Remove chunks, justifications, and user productions from memory <code>-T, --templates</code> Excise Soar-RL templates <code>-u, --user</code> Remove all user productions (but not chunks or default rules) from memory <code>production_name</code> Remove the specific production with this name."},{"location":"reference/cli/cmd_production/#examples","title":"Examples","text":"<p>This command removes the production <code>my*first*production</code> and all chunks:</p> <pre><code>production excise my*first*production --chunks\n</code></pre> <p>This removes all productions:</p> <pre><code>production excise --all\n</code></pre>"},{"location":"reference/cli/cmd_production/#production-find","title":"production find","text":"<p>Find productions by condition or action patterns.</p>"},{"location":"reference/cli/cmd_production/#synopsis_1","title":"Synopsis","text":"<pre><code>production find [-lrs[n|c]] pattern\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_2","title":"Options","text":"Option Description <code>-c, --chunks</code> Look only for chunks that match the pattern. <code>-l, --lhs</code> Match pattern only against the conditions (left-hand side) of productions (default). <code>-n, --nochunks</code> Disregard chunks when looking for the pattern. <code>-r, --rhs</code> Match pattern against the actions (right-hand side) of productions. <code>-s, --show-bindings</code> Show the bindings associated with a wildcard pattern. <code>pattern</code> Any pattern that can appear in productions."},{"location":"reference/cli/cmd_production/#description","title":"Description","text":"<p>The <code>production find</code> command is used to find productions in production memory that include conditions or actions that match a given <code>pattern</code>. The pattern given specifies one or more condition elements on the left hand side of productions (or negated conditions), or one or more actions on the right-hand side of productions. Any pattern that can appear in productions can be used in this command. In addition, the asterisk symbol, <code>*</code>, can be used as a wildcard for an attribute or value. It is important to note that the whole pattern, including the parenthesis, must be enclosed in curly braces for it to be parsed properly.</p> <p>The variable names used in a call to production find do not have to match the variable names used in the productions being retrieved.</p> <p>The <code>production find</code> command can also be restricted to apply to only certain types of productions, or to look only at the conditions or only at the actions of productions by using the flags.</p>"},{"location":"reference/cli/cmd_production/#production-find-examples","title":"Production Find Examples","text":"<p>Find productions that test that some object <code>gumby</code> has an attribute <code>alive</code> with value <code>t</code>. In addition, limit the rules to only those that test an operator named <code>foo</code>:</p> <pre><code>production find (&lt;state&gt; ^gumby &lt;gv&gt; ^operator.name foo)(&lt;gv&gt; ^alive t)\n</code></pre> <p>Note that in the above command, <code>&lt;state&gt;</code> does not have to match the exact variable name used in the production.</p> <p>Find productions that propose the operator <code>foo</code>:</p> <pre><code>production find --rhs (&lt;x&gt; ^operator &lt;op&gt; +)(&lt;op&gt; ^name foo)\n</code></pre> <p>Find chunks that test the attribute ^pokey:</p> <pre><code>production find --chunks (&lt;x&gt; ^pokey *)\n</code></pre> <p>Examples using the water-jugs demo:</p> <pre><code>source demos/water-jug/water-jug.soar\nproduction-find (&lt;s&gt; ^name *)(&lt;j&gt; ^volume *)\nproduction-find (&lt;s&gt; ^name *)(&lt;j&gt; ^volume 3)\nproduction-find --rhs (&lt;j&gt; ^* &lt;volume&gt;)\n</code></pre>"},{"location":"reference/cli/cmd_production/#production-firing-counts","title":"production firing-counts","text":"<p>Print the number of times productions have fired.</p>"},{"location":"reference/cli/cmd_production/#synopsis_2","title":"Synopsis","text":"<pre><code>production firing-counts [type] [n]\nproduction firing-counts production_name\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_3","title":"Options","text":"<p>If given, an option can take one of two forms -- an integer or a production name:</p> Option Description <code>n</code> List the top <code>n</code> productions. If <code>n</code> is 0, only the productions which haven't fired are listed <code>production_name</code> Print how many times a specific production has fired <code>-a, --all</code> Print how many times all productions have fired (the default) <code>-f, --fired</code> Prints only rules that have fired <code>-c, --chunks</code> Print how many times chunks (learned rules) fired <code>-j, --justifications</code> Print how many times justifications fired <code>-d, --default</code> Print how many times default productions (<code>:default</code>) fired <code>-r, --rl</code> Print how many times Soar-RL rules fired <code>-T, --templates</code> Print how many times Soar-RL templates fired <code>-u, --user</code> Print how many times user productions (but not chunks or default rules) fired"},{"location":"reference/cli/cmd_production/#description_1","title":"Description","text":"<p>The <code>production firing-counts</code> command prints the number of times each production has fired; production names are given from most frequently fired to least frequently fired. With no arguments, it lists all productions. If an integer argument, <code>n</code>, is given, only the top <code>n</code> productions are listed. If <code>n</code> is zero (0), only the productions that haven't fired at all are listed. If --fired is used, the opposite happens. Only rules that have fired are listed. If a production name is given as an argument, the firing count for that production is printed.</p> <p>Note that firing counts are reset by a call to soar init.</p>"},{"location":"reference/cli/cmd_production/#examples_1","title":"Examples","text":"<p>This example prints the 10 productions which have fired the most times along with their firing counts:</p> <pre><code>production firing-counts 10\n</code></pre> <p>This example prints the firing counts of production <code>my*first*production</code>:</p> <pre><code>production firing-counts my*first*production\n</code></pre> <p>This example prints all rules that have fired at least once:</p> <pre><code>production firing-counts -f\n</code></pre>"},{"location":"reference/cli/cmd_production/#production-matches","title":"production matches","text":"<p>The <code>production matches</code> command prints a list of productions that have instantiations in the match set, i.e., those productions that will retract or fire in the next propose or apply phase. It also will print partial match information for a single, named production.</p>"},{"location":"reference/cli/cmd_production/#synopsis_3","title":"Synopsis","text":"<pre><code>production matches [options] production_name\nproduction matches [options] -[a|r]\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_4","title":"Options","text":"Option Description <code>production_name</code> Print partial match information for the named production. <code>-n, --names, -c, --count</code> For the match set, print only the names of the productions that are about to fire or retract (the default). If printing partial matches for a production, just list the partial match counts. <code>-t, --timetags</code> Also print the timetags of the wmes at the first failing condition <code>-w, --wmes</code> Also print the full wmes, not just the timetags, at the first failing condition. <code>-a, --assertions</code> List only productions about to fire. <code>-r, --retractions</code> List only productions about to retract."},{"location":"reference/cli/cmd_production/#printing-the-match-set","title":"Printing the match set","text":"<p>When printing the match set (i.e., no production name is specified), the default action prints only the names of the productions which are about to fire or retract. If there are multiple instantiations of a production, the total number of instantiations of that production is printed after the production name, unless <code>--timetags</code> or <code>--wmes</code> are specified, in which case each instantiation is printed on a separate line.</p> <p>When printing the match set, the <code>--assertions</code> and <code>--retractions</code> arguments can be specified to restrict the output to print only the assertions or retractions.</p>"},{"location":"reference/cli/cmd_production/#printing-partial-matches-for-productions","title":"Printing partial matches for productions","text":"<p>In addition to printing the current match set, the <code>matches</code> command can be used to print information about partial matches for a named production. In this case, the conditions of the production are listed, each preceded by the number of currently active matches for that condition. If a condition is negated, it is preceded by a minus sign <code>-</code>. The pointer <code>&gt;&gt;&gt;&gt;</code> before a condition indicates that this is the first condition that failed to match.</p> <p>When printing partial matches, the default action is to print only the counts of the number of WME's that match, and is a handy tool for determining which condition failed to match for a production that you thought should have fired. At levels <code>--timetags</code> and <code>--wmes</code> the <code>matches</code> command displays the WME's immediately after the first condition that failed to match -- temporarily interrupting the printing of the production conditions themselves.</p>"},{"location":"reference/cli/cmd_production/#notes","title":"Notes","text":"<p>When printing partial match information, some of the matches displayed by this command may have already fired, depending on when in the execution cycle this command is called. To check for the matches that are about to fire, use the matches command without a named production.</p> <p>In Soar 8, the execution cycle (decision cycle) is input, propose, decide, apply output; it no longer stops for user input after the decision phase when running by decision cycles (<code>run -d 1</code>). If a user wishes to print the match set immediately after the decision phase and before the apply phase, then the user must run Soar by phases (<code>run -p 1</code>).</p>"},{"location":"reference/cli/cmd_production/#examples_2","title":"Examples","text":"<p>This example prints the productions which are about to fire and the WMEs that match the productions on their left-hand sides:</p> <pre><code>production matches --assertions --wmes\n</code></pre> <p>This example prints the WME timetags for a single production.</p> <pre><code>production matches -t my*first*production\n</code></pre>"},{"location":"reference/cli/cmd_production/#production-memory-usage","title":"production memory-usage","text":"<p>Print memory usage for partial matches.</p>"},{"location":"reference/cli/cmd_production/#synopsis_4","title":"Synopsis","text":"<pre><code>production memory-usage [options] [number]\nproduction memory-usage production_name\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_5","title":"Options","text":"Option Description <code>-c, --chunks</code> Print memory usage of chunks. <code>-d, --default</code> Print memory usage of default productions. <code>-j, --justifications</code> Print memory usage of justifications. <code>-u, --user</code> Print memory usage of user-defined productions. <code>production_name</code> Print memory usage for a specific production. <code>number</code> Number of productions to print, sorted by those that use the most memory. <code>-T, --template</code> Print memory usage of Soar-RL templates."},{"location":"reference/cli/cmd_production/#description_2","title":"Description","text":"<p>The <code>memory-usage</code> command prints out the internal memory usage for full and partial matches of production instantiations, with the productions using the most memory printed first. With no arguments, the <code>memory-usage</code> command prints memory usage for all productions. If a <code>production_name</code> is specified, memory usage will be printed only for that production. If a positive integer <code>number</code> is given, only <code>number</code> productions will be printed: the <code>number</code> productions that use the most memory. Output may be restricted to print memory usage for particular types of productions using the command options.</p> <p>Memory usage is recorded according to the tokens that are allocated in the Rete network for the given production(s). This number is a function of the number of elements in working memory that match each production. Therefore, this command will not provide useful information at the beginning of a Soar run (when working memory is empty) and should be called in the middle (or at the end) of a Soar run.</p> <p>The <code>memory-usage</code> command is used to find the productions that are using the most memory and, therefore, may be taking the longest time to match (this is only a heuristic). By identifying these productions, you may be able to rewrite your program so that it will run more quickly. Note that memory usage is just a heuristic measure of the match time: A production might not use much memory relative to others but may still be time-consuming to match, and excising a production that uses a large number of tokens may not speed up your program, because the Rete matcher shares common structure among different productions.</p> <p>As a rule of thumb, numbers less than 100 mean that the production is using a small amount of memory, numbers above 1000 mean that the production is using a large amount of memory, and numbers above 10,000 mean that the production is using a very large amount of memory.</p>"},{"location":"reference/cli/cmd_production/#production-optimize-attribute","title":"production optimize-attribute","text":"<p>Declare a symbol to be multi-attributed so that conditions in productions that test that attribute are re-ordered so that the rule can be matched more efficiently.</p>"},{"location":"reference/cli/cmd_production/#synopsis_5","title":"Synopsis","text":"<pre><code>production optimize-attribute [symbol [n]]\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_6","title":"Options","text":"Option Description <code>symbol</code> Any Soar attribute. <code>n</code> Integer greater than 1, estimate of degree of simultaneous values for attribute."},{"location":"reference/cli/cmd_production/#description_3","title":"Description","text":"<p>This command is used to improve efficiency of matching against attributes that can have multiple values at once.</p> <pre><code>(S1 ^foo bar1)\n(S1 ^foo bar2)\n(S1 ^foo bar3)\n</code></pre> <p>If you know that a certain attribute will take on multiple values, <code>optimize-attribute</code> can be used to provide hints to the production condition reorderer so that it can produce better orderings that allow the Rete network to match faster. This command has no effect on the actual contents of working memory and is only used to improve efficiency in problematic situations.</p> <p><code>optimize-attribute</code> declares a symbol to be an attribute which can take on multiple values. The optional <code>n</code> is an integer (greater than 1) indicating an upper limit on the number of expected values that will appear for an attribute. If <code>n</code> is not specified, the value 10 is used for each declared multi-attribute. More informed values will tend to result in greater efficiency.</p> <p>Note that <code>optimize-attribute</code> declarations must be made before productions are loaded into soar or this command will have no effect.</p>"},{"location":"reference/cli/cmd_production/#example","title":"Example","text":"<p>Declare the symbol \"thing\" to be an attribute likely to take more than 1 but no more than 4 values:</p> <pre><code>production optimize-attribute thing 4\n</code></pre>"},{"location":"reference/cli/cmd_production/#production-watch","title":"production watch","text":"<p>Trace firings and retractions of specific productions.</p>"},{"location":"reference/cli/cmd_production/#synopsis_6","title":"Synopsis","text":"<pre><code>production watch [-d|e] [production name]\n</code></pre>"},{"location":"reference/cli/cmd_production/#options_7","title":"Options","text":"Option Description <code>-d, --disable, --off</code> Turn production watching off for the specified production. If no production is specified, turn production watching off for all productions. <code>-e, --enable, --on</code> Turn production watching on for the specified production. The use of this flag is optional, so this is watch's default behavior. If no production is specified, all productions currently being watched are listed. <code>production name</code> The name of the production to watch."},{"location":"reference/cli/cmd_production/#description_4","title":"Description","text":"<p>The <code>production watch</code> command enables and disables the tracing of the firings and retractions of individual productions. This is a companion command to trace, which cannot specify individual productions by name.</p> <p>With no arguments, production watch lists the productions currently being traced. With one production-name argument, production watch enables tracing the production; <code>--enable</code> can be explicitly stated, but it is the default action.</p> <p>If <code>--disable</code> is specified followed by a production-name, tracing is turned off for the production. When no production-name is specified, <code>--enable</code> lists all productions currently being traced, and <code>--disable</code> disables tracing of all productions.</p> <p>Note that <code>production watch</code> now only takes one production per command. Use multiple times to watch multiple functions.</p>"},{"location":"reference/cli/cmd_production/#default-aliases","title":"Default Aliases","text":"<pre><code>ex                         production excise\nexcise                     production excise\nfc                         production firing-counts\nfiring-counts              production firing-counts\nmatches                    production matches\nmemories                   production memory-usage\nmulti-attributes           production optimize-attribute\npbreak                     production break\nproduction-find            production find\npw                         production watch\npwatch                     production watch\n</code></pre>"},{"location":"reference/cli/cmd_production/#see-also","title":"See Also","text":"<ul> <li>soar init</li> <li>sp</li> <li>trace</li> </ul>"},{"location":"reference/cli/cmd_rl/","title":"rl","text":"<p>Control how numeric indifferent preference values in RL rules are updated via reinforcement learning.</p>"},{"location":"reference/cli/cmd_rl/#synopsis","title":"Synopsis","text":"<pre><code>rl -g|--get &lt;parameter&gt;\nrl -s|--set &lt;parameter&gt; &lt;value&gt;\nrl -t|--trace &lt;parameter&gt; &lt;value&gt;\nrl -S|--stats &lt;statistic&gt;\n</code></pre>"},{"location":"reference/cli/cmd_rl/#options","title":"Options","text":"Option Description <code>-g, --get</code> Print current parameter setting <code>-s, --set</code> Set parameter value <code>-t, --trace</code> Print, clear, or init traces <code>-S, --stats</code> Print statistic summary or specific statistic"},{"location":"reference/cli/cmd_rl/#description","title":"Description","text":"<p>The <code>rl</code> command sets parameters and displays information related to reinforcement learning. The <code>print</code> and <code>trace</code> commands display additional RL related information not covered by this command.</p>"},{"location":"reference/cli/cmd_rl/#parameters","title":"Parameters","text":"<p>Due to the large number of parameters, the <code>rl</code> command uses the <code>--get|--set &lt;parameter&gt; &lt;value&gt;</code> convention rather than individual switches for each parameter. Running <code>rl</code> without any switches displays a summary of the parameter settings.</p> Parameter Description Possible values Default chunk-stop If enabled, chunking does not create duplicate RL rules that differ only in numeric-indifferent preference value <code>on</code>, <code>off</code> <code>on</code> decay-mode How the learning rate changes over time <code>normal</code>, <code>exponential</code>, <code>logarithmic</code>, <code>delta-bar-delta</code> <code>normal</code> discount-rate Temporal discount (gamma) <code>[</code>0, 1<code>]</code> 0.9 eligibility-trace-decay-rate Eligibility trace decay factor (lambda) <code>[</code>0, 1<code>]</code> 0 eligibility-trace-tolerance Smallest eligibility trace value not considered 0 (0, inf) 0.001 hrl-discount Discounting of RL updates over time in impassed states <code>on</code>, <code>off</code> <code>off</code> learning Reinforcement learning enabled <code>on</code>, <code>off</code> <code>off</code> learning-rate Learning rate (alpha) <code>[</code>0, 1<code>]</code> 0.3 step-size-parameter Secondary learning rate <code>[</code>0,1<code>]</code> 1 learning-policy Value update policy <code>sarsa</code>, <code>q-learning</code>, <code>off-policy-gq-lambda</code>, <code>on-policy-gq-lambda</code> <code>sarsa</code> meta Store rule metadata in header string <code>on</code>, <code>off</code> <code>off</code> meta-learning-rate Delta-Bar-Delta learning parameter <code>[</code>0, 1<code>]</code> 0.1 temporal-discount Discount RL updates over gaps <code>on</code>, <code>off</code> <code>on</code> temporal-extension Propagation of RL updates over gaps <code>on</code>, <code>off</code> <code>on</code> trace Update the trace <code>on</code>, <code>off</code> <code>off</code> update-log-path File to log information about RL rule updates <code>\"\"</code>, <code>&lt;filename&gt;</code> <code>\"\"</code>"},{"location":"reference/cli/cmd_rl/#apoptosis-parameters","title":"Apoptosis Parameters","text":"Parameter Description Possible values Default <code>apoptosis</code> Automatic excising of productions via base-level decay <code>none</code>, <code>chunks</code>, <code>rl-chunks</code> <code>none</code> <code>apoptosis-decay</code> Base-level decay parameter <code>[</code>0, 1<code>]</code> 0.5 <code>apoptosis-thresh</code> Base-level threshold parameter (negates supplied value) (0, inf) 2 <p>Apoptosis is a process to automatically excise chunks via the base-level decay model (where rule firings are the activation events). A value of <code>chunks</code> has this apply to any chunk, whereas <code>rl-chunks</code> means only chunks that are *also RL rules can be forgotten.</p>"},{"location":"reference/cli/cmd_rl/#rl-statistics","title":"RL Statistics","text":"<p>Soar tracks some RL statistics over the lifetime of the agent. These can be accessed using <code>rl --stats &lt;statistic&gt;</code>. Running <code>rl --stats</code> without a statistic will list the values of all statistics.</p> Option Description <code>update-error</code> Difference between target and current values in last RL update <code>total-reward</code> Total accumulated reward in the last update <code>global-reward</code> Total accumulated reward since agent initialization"},{"location":"reference/cli/cmd_rl/#rl-delta-bar-delta","title":"RL Delta-Bar-Delta","text":"<p>This is an experimental feature of Soar RL. It based on the work in Richard S. Sutton's paper \"Adapting Bias by Gradient Descent: An Incremental Version of Delta-Bar-Delta\", available online at http://incompleteideas.net/papers/sutton-92a.pdf. Delta Bar Delta (DBD) is implemented in Soar RL as a decay mode. It changes the way all the rules in the eligibility trace get their values updated. In order to implement this, the agent gets an additional learning parameter <code>meta-learning-rate</code> and each rule gets two additional decay parameters: beta and h. The meta learning rate is set manually; the per-rule features are handled automatically by the DBD algorithm. The key idea is that the meta parameters keep track of how much a rule's RL value has been updated recently, and if a rule gets updates in the same direction multiple times in a row then subsequent updates in the same direction will have more effect. So DBD acts sort of like momentum for the learning rate.</p> <p>To enable DBD, use <code>rl --set decay-mode delta-bar-delta</code>. To change the meta learning rate, use e.g. <code>rl --set meta-learning-rate 0.1</code>. When you execute <code>rl</code>, under the \"Experimental\" section of output you'll see the current settings for <code>decay-mode</code> and <code>meta-learning-rate</code>. Also, if a rule gets printed concisely (e.g. by executing <code>p</code>), and the rule is an RL rule, and the decay mode is set to delta-bar-delta, then instead of printing the rule name followed by the update count and the RL value, it will print the rule name, beta, h, update count, and RL value.</p> <p>Note that DBD is a different feature than <code>meta</code>. Meta determines whether metadata about a production is stored in its header string. If meta is on and DBD is on, then each rule's beta and h values will be stored in the header string in addition to the update count, so you can print out the rule, source it later and that metadata about the rule will still be in place.</p>"},{"location":"reference/cli/cmd_rl/#rl-gq","title":"RL GQ","text":"<p>Linear GQ(\\(\\lambda\\)) is a gradient-based off-policy temporal-difference learning algorithm, as developed by Hamid Maei and described by Adam White and Rich Sutton (https://arxiv.org/pdf/1705.03967.pdf). This reinforcement learning option provides off-policy learning quite effectively. This is a good approach in cases when agent training performance is less important than agent execution performance. GQ(\\(\\lambda\\)) converges despite irreversible actions and other difficulties approaching the training goal. Convergence should be guaranteed for stable environments.</p> <p>To change the secondary learning rate that only applies when learning with GQ(\\(\\lambda\\)), set the rl <code>step-size-parameter</code>. It controls how fast the secondary set of weights changes to allow GQ(\\(\\lambda\\)) to improve the rate of convergence to a stable policy. Small learning rates such as 0.01 or even lower seems to be good practice.</p> <p><code>rl --set learning-policy off-policy-gq-lambda</code> will set Soar to use linear GQ(\\(\\lambda\\)). It is preferable to use GQ(\\(\\lambda\\)) over sarsa or q-learning when multiple weights are active in parallel and sequences of actions required for agents to be successful are sufficiently complex that divergence is possible. To take full advantage of GQ(\\(\\lambda\\)), it is important to set <code>step-size-parameter</code> to a reasonable value for a secondary learning rate, such as 0.01.</p> <p><code>rl --set learning-policy on-policy-gq-lambda</code> will set Soar to use a simplification of GQ(\\(\\lambda\\)) to make it on-policy while otherwise functioning identically. It is still important to set <code>step-size-parameter</code> to a reasonable value for a secondary learning rate, such as 0.01.</p> <p>For more information, please see the relevant slides on http://www-personal.umich.edu/~bazald/b/publications/009-sw35-gql.pdf</p>"},{"location":"reference/cli/cmd_rl/#rl-update-logging","title":"RL Update Logging","text":"<p>Sets a path to a file that Soar RL will write to whenever a production's RL value gets updated. This can be useful for logging these updates without having to capture all of Soar's output and parse it for these updates. Enable with e.g. <code>rl --set update-log-path rl\\_log.txt</code>. Disable with <code>rl --set update-log-path \"\"</code> - that is, use the empty string \"\" as the log path. The current log path appears under the experimental section when you execute \"rl\".</p>"},{"location":"reference/cli/cmd_rl/#rl-trace","title":"RL Trace","text":"<p>If <code>rl --set trace on</code> has been called, then proposed operators will be recorded in the trace for all goal levels. Along with operator names and other attribute-value pairs, transition probabilities derived from their numeric preferences are recorded.</p> <p>Legal arguments following <code>rl -t</code> or <code>rl --trace</code> are as follows:</p> Option Description <code>print</code> Print the trace for the top state. <code>clear</code> Erase the traces for all goal levels. <code>init</code> Restart recording from the beginning of the traces for all goal levels. <p>These may be followed by an optional numeric argument specifying a specific goal level to print, clear, or init. <code>rl -t init</code> is called automatically whenever Soar is reinitialized. However, <code>rl -t clear</code> is never called automatically.</p> <p>The format in which the trace is printed is designed to be used by the program dot, as part of the Graphviz suite. The command <code>ctf rl.dot rl -t</code> will print the trace for the top state to the file \"rl.dot\". (The default behavior for <code>rl -t</code> is to print the trace for the top state.)</p> <p>Here are some sample dot invocations for the top state:</p> Option Description <code>dot -Tps rl.dot -o rl.ps</code> <code>ps2pdf rl.ps</code> Generate a .ps file and convert it to .pdf. <code>dot -Tsvg rl.dot -o rl.svg</code> <code>inkscape -f rl.svg -A rl.pdf</code> Generate a .svg file and convert it to .pdf. <p>The .svg format works better for large traces.</p>"},{"location":"reference/cli/cmd_rl/#see-also","title":"See Also","text":"<ul> <li>excise</li> <li>print</li> <li>trace</li> </ul>"},{"location":"reference/cli/cmd_run/","title":"run","text":"<p>Begin Soar's execution cycle.</p>"},{"location":"reference/cli/cmd_run/#synopsis","title":"Synopsis","text":"<pre><code>run -[d|e|o|p][g][u|n][s] [count] [-i e|p|d|o]\n</code></pre>"},{"location":"reference/cli/cmd_run/#options","title":"Options","text":"Option Description <code>-d, --decision</code> Run Soar for count decision cycles. <code>-e, --elaboration</code> Run Soar for count elaboration cycles. <code>-o, --output</code> Run Soar until the nth time output is generated by the agent. Limited by the value of max-nil-output-cycles. <code>-p, --phase</code> Run Soar by phases. A phase is either an input phase, proposal phase, decision phase, apply phase, or output phase. <code>-s, --self</code> If other agents exist within the kernel, do not run them at this time. <code>-u, --update</code> Sets a flag in the update event callback requesting that an environment updates. This is the default if <code>--self</code> is not specified. <code>-n, --noupdate</code> Sets a flag in the update event callback requesting that an environment does not update. This is the default if <code>--self</code> is specified. <code>count</code> A single integer which specifies the number of cycles to run Soar. <code>-i, --interleave</code> Support round robin execution across agents at a finer grain than the run-size parameter. <code>e</code> = elaboration, <code>p</code> = phase, <code>d</code> = decision, <code>o</code> = output <code>-g, --goal</code> Run agent until a goal retracts"},{"location":"reference/cli/cmd_run/#deprecated-run-options","title":"Deprecated Run Options","text":"<p>These may be reimplemented in the future.</p> Option Description <code>--operator</code> Run Soar until the nth time an operator is selected. <code>--state</code> Run Soar until the nth time a state is selected."},{"location":"reference/cli/cmd_run/#description","title":"Description","text":"<p>The <code>run</code> command starts the Soar execution cycle or continues any execution that was temporarily stopped. The default behavior of run, with no arguments, is to cause Soar to execute until it is halted or interrupted by an action of a production, or until an external interrupt is issued by the user. The <code>run</code> command can also specify that Soar should run only for a specific number of Soar cycles or phases (which may also be prematurely stopped by a production action or the stop-soar command). This is helpful for debugging sessions, where users may want to pay careful attention to the specific productions that are firing and retracting.</p> <p>The <code>run</code> command takes optional arguments: an integer, <code>count</code>, which specifies how many units to run; and a <code>units</code> flag indicating what steps or increments to use. If <code>count</code> is specified, but no <code>units</code> are specified, then Soar is run by decision cycles. If <code>units</code> are specified, but <code>count</code> is unpecified, then <code>count</code> defaults to '1'. If both are unspecified, Soar will run until either a <code>halt</code> is executed, an interrupt is received, or max stack depth is reached.</p> <p>If there are multiple Soar agents that exist in the same Soar process, then issuing a run command in any agent will cause all agents to run with the same set of parameters, unless the flag <code>--self</code> is specified, in which case only that agent will execute.</p> <p>If an environment is registered for the kernel's update event, then when the event it triggered, the environment will get information about how the run was executed. If a run was executed with the <code>--update</code> option, then then event sends a flag requesting that the environment actually update itself. If a run was executed with the --noupdate option, then the event sends a flag requesting that the environment not update itself. The <code>--update</code> option is the default when run is specified without the <code>--self</code> option is not specified. If the <code>--self</code> option is specified, then the <code>--noupdate</code> option is on by default. It is up to the environment to check for these flags and honor them.</p> <p>Some use cases include:</p> Option Description <code>run --self</code> runs one agent but not the environment <code>run --self --update</code> runs one agent and the environment <code>run</code> runs all agents and the environment <code>run --noupdate</code> runs all agents but not the environment"},{"location":"reference/cli/cmd_run/#setting-an-interleave-size","title":"Setting an interleave size","text":"<p>When there are multiple agents running within the same process, it may be useful to keep agents more closely aligned in their execution cycle than the run increment (<code>--elaboration, --phases, --decisions, --output</code>) specifies. For instance, it may be necessary to keep agents in \"lock step\" at the phase level, even though the run command issued is for 5 decisions. Some use cases include:</p> Option Description <code>run -d 5 -i p</code> run the agent one phase and then move to the next agent, looping over agents until they have run for 5 decision cycles <code>run -o 3 -i d</code> run the agent one decision cycle and then move to the next agent. When an agent generates output for the 3rd time, it no longer runs even if other agents continue. <p>The <code>interleave</code> parameter must always be equal to or smaller than the specified run parameter.</p>"},{"location":"reference/cli/cmd_run/#note","title":"Note","text":"<p>If Soar has been stopped due to a <code>halt</code> action, an init-soar command must be issued before Soar can be restarted with the run command.</p>"},{"location":"reference/cli/cmd_run/#default-aliases","title":"Default Aliases","text":"<pre><code>d             run -d 1\ne             run -e 1\nstep          run -d 1\n</code></pre>"},{"location":"reference/cli/cmd_save/","title":"save","text":"<p>Saves chunks, rete networks and percept streams.</p>"},{"location":"reference/cli/cmd_save/#synopsis","title":"Synopsis","text":"<pre><code>======================================================\n-            Save Sub-Commands and Options           -\n======================================================\nsave [? | help]\n------------------------------------------------------\nsave agent                           &lt;filename&gt;\nsave chunks                          &lt;filename&gt;\n------------------------------------------------------\nsave percepts                        --open &lt;filename&gt;\nsave percepts                        [--close --flush]\n------------------------------------------------------\nsave rete-network                    --save &lt;filename&gt;\n------------------------------------------------------\nFor a detailed explanation of sub-commands:  help save\n</code></pre>"},{"location":"reference/cli/cmd_save/#save-agent","title":"save agent","text":"<p>The <code>save agent</code> command will write all procedural and semantic memory to disk, as well as many commonly used settings. This command creates a standard <code>.soar</code> text file, with semantic memory stored as a series of <code>smem --add</code> commands.</p>"},{"location":"reference/cli/cmd_save/#save-chunks","title":"save chunks","text":"<p>The <code>save chunks</code> command will write all chunks in memory to disk. This command creates a standard <code>.soar</code> text file.</p>"},{"location":"reference/cli/cmd_save/#save-rete-network","title":"save rete-network","text":"<p>The <code>save rete-network</code> command saves the current Rete net to a file. The Rete net is Soar's internal representation of production memory; the conditions of productions are reordered and common substructures are shared across different productions. This command provides a fast method of saving and loading productions since a special format is used and no parsing is necessary. Rete-net files are portable across platforms that support Soar.</p> <p>Note that justifications cannot be present when saving the Rete net. Issuing a production excise -j before saving a Rete net will remove all justifications.</p> <p>If the filename contains a suffix of <code>.Z</code>, then the file is compressed automatically when it is saved and uncompressed when it is loaded. Compressed files may not be portable to another platform if that platform does not support the same uncompress utility.</p> <pre><code>save rete-network -s &lt;filename&gt;\n</code></pre>"},{"location":"reference/cli/cmd_save/#save-percepts","title":"save percepts","text":"<p>Store all incoming input wmes in a file for reloading later. Commands are recorded decision cycle by decision cycle. Use the command load percepts to replay the sequence.</p> <p>Note that this command seeds the random number generator and writes the seed to the capture file.</p> Option Description <code>filename</code> Open filename and begin recording input. <code>-o, --open</code> Writes captured input to file overwriting any existing data. <code>-f, --flush</code> Writes input to file as soon as it is encountered instead of storing it in RAM and writing when capturing is turned off. <code>-c, --close</code> Stop capturing input and close the file, writing captured input unless the flush option is given. <pre><code>save percepts -o &lt;filename&gt;\n...\nsave percepts -c\n</code></pre>"},{"location":"reference/cli/cmd_save/#default-aliases","title":"Default Aliases","text":"<pre><code>capture-input        save percepts\n</code></pre>"},{"location":"reference/cli/cmd_save/#see-also","title":"See Also","text":"<ul> <li>production</li> <li>soar</li> <li>load</li> </ul>"},{"location":"reference/cli/cmd_smem/","title":"smem","text":"<p>Controls the behavior of and displays information about semantic memory.</p>"},{"location":"reference/cli/cmd_smem/#synopsis","title":"Synopsis","text":"<pre><code>=======================================================\n-             Semantic Memory Sub-Commands            -\n=======================================================\nsmem [? | help]                                           Print help screen\nsmem [--enable | --disable ]                              Turn smem on/off\nsmem [--get | --set]                 &lt;option&gt; [&lt;value&gt;]   Print or set a parameter\nsmem --add                        { (id ^attr value)* }   Add memory to smem\nsmem --backup                                &lt;filename&gt;   Save copy of database\nsmem --clear                                              Delete contents of smem\nsmem --export                        &lt;filename&gt; [&lt;LTI&gt;]   Save database to file\nsmem --init                                               Reinit smem store\nsmem --query                           {(cue)* [&lt;num&gt;]}   Query smem via given cue\nsmem --remove                 { (id [^attr [value]])* }   Remove smem structures\n------------------------ Printing ---------------------\nprint                                                 @   Print all smem contents\nprint                                             &lt;LTI&gt;   Print specific smem memory\nsmem --history                                    &lt;LTI&gt;   Print memory activation history\n=======================================================\n-        Semantic Memory Parameters  (use --set)      -\n=======================================================\nenabled                                             off\ndatabase                              [ MEMORY | file ]   Store database in memory or file\nappend                                               on   Append or overwrite after init\npath                                                      Path to database on disk\n---------------------- Activation ---------------------\nactivation-mode    [ RECENCY | frequency | base-level ]\nactivate-on-query                          [ ON | off ]\nbase-decay                                          0.5   Decay amount for base-level activation\nbase-update-policy     [ STABLE | naive | incremental ]\nbase-incremental-threshes                            10   Integer &gt; 0\nthresh                                              100   Integer &gt;= 0\nbase-inhibition                            [ on | OFF ]\n---------- Experimental Spreading Activation ----------\nspreading                                  [ on | OFF ]\nspreading-limit                                     300   integer &gt; 0\nspreading-depth-limit                                10   integer &gt; 0\nspreading-baseline                               0.0001   1 &gt; decimal &gt; 0\nspreading-continue-probability                      0.9   1 &gt; decimal &gt; 0\nspreading-loop-avoidance                   [ on | OFF ]\nspreading-edge-updating                    [ on | OFF ]\nspreading-wma-source                       [ on | OFF ]\nspreading-edge-update-factor                       0.99   1 &gt; decimal &gt; 0\n------------- Database Optimization Settings ----------\nlazy-commit                                          on   Delay writing store until exit\noptimization                   [ safety | PERFORMANCE ]\ncache-size                                        10000   Number of memory pages for SQLite cache\npage-size                                            8k   Size of each memory page\n----------------- Timers and Statistics ---------------\ntimers                      [ OFF | one | two | three ]   How detailed timers should be\nsmem --timers                                 [&lt;timer&gt;]   Print summary or specifics\nsmem --stats                                   [&lt;stat&gt;]   Print summary or specifics\n                  ---------------------\nTimers: smem_api, smem_hash, smem_init, smem_query,\n        smem_ncb_retrieval, three_activation\n        smem_storage, _total\nStats:  act_updates, db-lib-version, edges, mem-usage,\n        mem-high, nodes, queries, retrieves, stores\n-------------------------------------------------------\nFor a detailed explanation of these settings:             help smem\n</code></pre>"},{"location":"reference/cli/cmd_smem/#summary-output","title":"Summary Output","text":"<p>With no arguments, <code>smem</code> will return a quick summary of key aspects of semantic memory.</p> <pre><code>====================================================\n              Semantic Memory Summary\n====================================================\nEnabled                                          off\nStorage                                       Memory   (append after init)\n----------------------------------------------------\nNodes                                              2\nEdges                                              1\nMemory Usage                                  406784   bytes\n----------------------------------------------------\nFor a full list of smem's sub-commands and settings:  smem ?\n</code></pre>"},{"location":"reference/cli/cmd_smem/#options","title":"Options","text":"Commands Description <code>-e, --enable, --on</code> Enable semantic memory. <code>-d, --disable, --off</code> Disable semantic memory. <code>-g, --get</code> Print current parameter setting <code>-s, --set</code> Set parameter value <code>-c, --clear</code> Deletes all memories <code>-x, --export</code> Creates an agent-sourceable copy of semantic memory on disk <code>-i, --init</code> Deletes all memories if append is off <code>-S, --stats</code> Print statistic summary or specific statistic <code>-t, --timers</code> Print timer summary or specific statistic <code>-a, --add</code> Add concepts to semantic memory <code>-r, --remove</code> Remove concepts from semantic memory <code>-q, --query</code> Print concepts in semantic store matching some cue <code>-h, --history</code> Print activation history for some LTI <code>-b, --backup</code> Creates a backup of the semantic database on disk"},{"location":"reference/cli/cmd_smem/#printing","title":"Printing","text":"<p>To print from semantic memory, the standard print command can be used, for example, to print a specific LTI:</p> <p><code>p @23</code></p> <p>To print the entire semantic store:</p> <p><code>p @</code></p> <p>Note that such print commands will honor the --depth parameter passed in.</p> <p>The command <code>trace --smem</code> displays additional trace information for semantic memory not controlled by this command.</p>"},{"location":"reference/cli/cmd_smem/#parameters","title":"Parameters","text":"<p>Due to the large number of parameters, the <code>smem</code> command uses the <code>--get|--set &lt;parameter&gt; &lt;value&gt;</code> convention rather than individual switches for each parameter. Running <code>smem</code> without any switches displays a summary of the parameter settings.</p> Parameter Description Possible values Default <code>append</code> Controls whether database is overwritten or appended when opening or re-initializing <code>on</code>, <code>off</code> <code>off</code> <code>database</code> Database storage method <code>file</code>, <code>memory</code> <code>memory</code> <code>learning</code> Semantic memory enabled <code>on</code>, <code>off</code> <code>off</code> <code>path</code> Location of database file empty, some path empty <p>The <code>learning</code> parameter turns the semantic memory module on or off. This is the same as using the enable and disable commands.</p> <p>The <code>path</code> parameter specifies the file system path the database is stored in. When <code>path</code> is set to a valid file system path and database mode is set to file, then the SQLite database is written to that path.</p> <p>The <code>append</code> parameter will determine whether all existing facts stored in a database on disk will be erased when semantic memory loads. Note that this affects semantic memory re-initialization also, i.e. if the append setting is off, all semantic facts stored to disk will be lost when a <code>soar init</code> is performed. For semantic memory, <code>append</code> mode is by default on.</p> <p>Note that changes to database, <code>path</code> and <code>append</code> will not have an effect until the database is used after an initialization. This happens either shortly after launch (on first use) or after a database initialization command is issued. To switch databases or database storage types while running, set your new parameters and then perform an <code>smem --init</code> command.</p>"},{"location":"reference/cli/cmd_smem/#activation-parameters","title":"Activation Parameters","text":"Parameter Description Possible values Default activation-mode Sets the ordering bias for retrievals that match more than one memory <code>recency</code>, <code>frequency</code>, <code>base-level</code> <code>recency</code> activate-on-query Determines if the results of queries should be activated <code>on</code>, <code>off</code> <code>on</code> base-decay Sets the decay parameter for base-level activation computation <code>&gt;</code> 0 0.5 base-update-policy Sets the policy for re-computing base-level activation <code>stable</code>, <code>naive</code>, <code>incremental</code> <code>stable</code> base-incremental-threshes Sets time deltas after which base-level activation is re-computed for old memories 1, 2, 3, ... 10 thresh Threshold for activation locality 0, 1, ... 100 base-inhibition Sets whether or not base-level activation has a short-term inhibition factor. <code>on</code>, <code>off</code> <code>off</code> <p>If <code>activation-mode</code> is <code>base-level</code>, three parameters control bias values. The <code>base-decay</code> parameter sets the free decay parameter in the base-level model. Note that we do implement the (Petrov, 2006) approximation, with a history size set as a compile-time parameter (default=10). The <code>base-update-policy</code> sets the frequency with which activation is recomputed. The default, <code>stable</code>, only recomputes activation when a memory is referenced (through storage or retrieval). The <code>naive</code> setting will update the entire candidate set of memories (defined as those that match the most constraining cue WME) during a retrieval, which has severe performance detriment and should be used for experimentation or those agents that require high-fidelity retrievals. The <code>incremental</code> policy updates a constant number of memories, those with last-access ages defined by the <code>base-incremental-threshes</code> set. The <code>base-inhibition</code> parameter switches an additional prohibition factor <code>on</code> or <code>off</code>.</p>"},{"location":"reference/cli/cmd_smem/#performance-parameters","title":"Performance Parameters","text":"Parameter Description Possible values Default cache-size Number of memory pages used in the SQLite cache 1, 2, ... 10000 lazy-commit Delay writing semantic store changes to file until agent exits <code>on</code>, <code>off</code> <code>on</code> optimization Policy for committing data to disk <code>safety</code>, <code>performance</code> <code>performance</code> page-size Size of each memory page used in the SQLite cache 1k, 2k, 4k, 8k, 16k, 32k, 64k 8k timers Timer granularity <code>off</code>, <code>one</code>, <code>two</code>, <code>three</code> <code>off</code> <p>When the database is stored to disk, the <code>lazy-commit</code> and <code>optimization</code> parameters control how often cached database changes are written to disk. These parameters trade off safety in the case of a program crash with database performance. When <code>optimization</code> is set to <code>performance</code>, the agent will have an exclusive lock on the database, meaning it cannot be opened concurrently by another SQLite process such as SQLiteMan. The lock can be relinquished by setting the database to memory or another database and issuing init-soar/<code>smem --init</code> or by shutting down the Soar kernel.</p>"},{"location":"reference/cli/cmd_smem/#statistics","title":"Statistics","text":"<p>Semantic memory tracks statistics over the lifetime of the agent. These can be accessed using <code>smem --stats &lt;statistic&gt;</code>. Running <code>smem --stats</code> without a statistic will list the values of all statistics. Unlike timers, statistics will always be updated.</p> <p>Available statistics are:</p> Name Label Description <code>act_updates</code> Activation Updates Number of times memory activation has been calculated <code>db-lib-version</code> SQLite Version SQLite library version <code>edges</code> Edges Number of edges in the semantic store <code>mem-usage</code> Memory Usage Current SQLite memory usage in bytes <code>mem-high</code> Memory Highwater High SQLite memory usage watermark in bytes <code>nodes</code> Nodes Number of nodes in the semantic store <code>queries</code> Queries Number of times the query command has been issued <code>retrieves</code> Retrieves Number of times the retrieve command has been issued <code>stores</code> Stores Number of times the store command has been issued"},{"location":"reference/cli/cmd_smem/#timers","title":"Timers","text":"<p>Semantic memory also has a set of internal timers that record the durations of certain operations. Because fine-grained timing can incur runtime costs, semantic memory timers are off by default. Timers of different levels of detail can be turned on by issuing <code>smem --set timers &lt;level&gt;</code>, where the levels can be <code>off</code>, <code>one</code>, <code>two</code>, or <code>three</code>, <code>three</code> being most detailed and resulting in all timers being turned on. Note that none of the semantic memory statistics nor timing information is reported by the <code>stats</code> command.</p> <p>All timer values are reported in seconds.</p> <p>Level one</p> Timer Description <code>_total</code> Total smem operations <p>Level two</p> Timer Description <code>smem_api</code> Agent command validation <code>smem_hash</code> Hashing symbols <code>smem_init</code> Semantic store initialization <code>smem_ncb_retrieval</code> Adding concepts (and children) to working memory <code>smem_query</code> Cue-based queries <code>smem_storage</code> Concept storage <p>Level three</p> Timer Description three_activation Recency information maintenance"},{"location":"reference/cli/cmd_smem/#smem-add","title":"smem --add","text":"<p>Concepts can be manually added to the semantic store using the <code>smem --add &lt;concept&gt;</code> command. The format for specifying the concept is similar to that of adding WMEs to working memory on the RHS of productions. For example:</p> <pre><code>smem --add {\n   (&lt;arithmetic&gt; ^add10-facts &lt;a01&gt; &lt;a02&gt; &lt;a03&gt;)\n   (&lt;a01&gt; ^digit1 1 ^digit-10 11)\n   (&lt;a02&gt; ^digit1 2 ^digit-10 12)\n   (&lt;a03&gt; ^digit1 3 ^digit-10 13)\n}\n</code></pre> <p>Although not shown here, the common \"dot-notation\" format used in writing productions can also be used for this command. Unlike agent storage, manual storage is automatically recursive. Thus, the above example will add a new concept (represented by the temporary \"arithmetic\" variable) with three children. Each child will be its own concept with two constant attribute/value pairs.</p>"},{"location":"reference/cli/cmd_smem/#smem-remove","title":"smem --remove","text":"<p>Part or all of the information in the semantic store of some LTI can be manually removed from the semantic store using the</p> <pre><code>smem --remove &lt;concept&gt;\n</code></pre> <p>command. The format for specifying what to remove is similar to that of adding WMEs to working memory on the RHS of productions. For example:</p> <pre><code>smem --remove {\n   (@34 ^good-attribute |gibberish value|)\n}\n</code></pre> <p>If <code>good-attribute</code> is multi-valued, then all values will remain in the store except <code>|gibberish value|</code>. If <code>|gibberish value|</code> is the only value, then <code>good-attribute</code> will also be removed. It is not possible to use the common \"dot-notation\" for this command. Manual removal is not recursive.</p> <p>Another example highlights the ability to remove all of the values for an attribute:</p> <pre><code>smem --remove {\n   (@34 ^bad-attribute)\n}\n</code></pre> <p>When a value is not given, all of the values for the given attribute are removed from the LTI in the semantic store.</p> <p>Also, it is possible to remove all augmentations of some LTI from the semantic store:</p> <pre><code>smem --remove {\n   (@34)\n}\n</code></pre> <p>This would remove all attributes and values of <code>@34</code> from the semantic store. The LTI will remain in the store, but will lack augmentations.</p> <p>(Use the following at your own risk.) Optionally, the user can force removal even in the event of an error:</p> <pre><code>smem -r {(@34 ^bad-attribute ^bad-attribute-2)} force\n</code></pre> <p>Suppose that LTI <code>@34</code> did not contain <code>bad-attribute</code>. The above example would remove <code>bad-attribute-2</code> even though it would indicate an error (having not found <code>bad-attribute</code>).</p>"},{"location":"reference/cli/cmd_smem/#smem-query","title":"smem --query","text":"<p>Queries for LTIs in the semantic store that match some cue can be initialized external to an agent using the <code>smem --query &lt;cue&gt; [&lt;num&gt;]</code> command. The format for specifying the cue is similar to that of adding a new identifier to working memory in the RHS of a rule:</p> <pre><code>smem --query {\n    (&lt;cue&gt; ^attribute &lt;wildcard&gt; ^attribute-2 |constant|)\n}\n</code></pre> <p>Note that the root of the cue structure must be a variable and should be unused in the rest of the cue structure. This command is for testing and the full range of queries accessible to the agent are not yet available for the command. For example, math queries are not supported.</p> <p>The additional option of <code>&lt;num&gt;</code> will trigger the display of the top <code>&lt;num&gt;</code> most activated LTIs that matched the cue.</p> <p>The result of a manual query is either to print that no LTIs could be found or to print the information associated with LTIs that were found in the <code>print &lt;lti&gt;</code> format.</p>"},{"location":"reference/cli/cmd_smem/#smem-history","title":"smem --history","text":"<p>When the activation-mode of a semantic store is set to base-level, some history of activation events is stored for each LTI. This history of when some LTI was activated can be displayed:</p> <pre><code>smem --history @34\n</code></pre> <p>In the event that semantic memory is not using base-level activation, <code>history</code> will mimic <code>print</code>.</p>"},{"location":"reference/cli/cmd_smem/#experimental-spreading-activation","title":"Experimental Spreading Activation","text":"Parameter Description Possible values Default spreading Controls whether spreading activation is on or off. <code>on</code>, <code>off</code> <code>off</code> spreading-limit Limits amount of spread from any LTI 0, 1, ... 300 spreading-depth-limit Limits depth of spread from any LTI 0, 1, ..., 10 10 spreading-baseline Gives minimum to spread values. 0, ..., 1 0.0001 spreading-continue-probability Gives 1 - (decay factor of spread with distance) 0, ..., 1 0.9 spreading-loop-avoidance Controls whether spread traversal avoids self-loops <code>on</code>, <code>off</code> <code>off</code> <p>Spreading activation has been added as an additional mechanism for ranking LTIs in response to a query. Spreading activation is only compatible with base-level activation. <code>activation-mode</code> must be set to <code>base-level</code> in order to also use spreading. They are additive. Spreading activation serves to rank LTIs that are connected to those currently instanced in Working Memory more highly than those which are unconnected. Note that spreading should be turned on before running an agent. Also, be warned that an agent which loads a database with spreading activation active at the time of back-up currently has undefined behavior and will likely crash as spreading activation currently maintains state in the database.</p> <p>Spreading activation introduces additional parameters. <code>spreading-limit</code> is an absolute cap on the number of LTIs that can receive spread from a given instanced LTI. <code>spreading-depth-limit</code> is an absolute cap on the depth to which a Working Memory instance of some LTI can spread into the SMem network. <code>spreading-baseline</code> provides a minimum amount of spread that an element can receive. <code>spreading-continue-probability</code> sets the amount of spread that is passed on with greater depth. (It can also be thought of as 1-decay where decay is the loss of spread magnitude with depth.) <code>spreading-loop-avoidance</code> is a boolean parameter which controls whether or not any given spread traversal can loop back onto itself.</p> <p>Note that the default settings here are not necessarily appropriate for your application. For many applications, simply changing the structure of the network can yield wildly different query results even with the same spreading parameters.</p>"},{"location":"reference/cli/cmd_smem/#see-also","title":"See Also","text":"<ul> <li>print</li> <li>trace</li> <li>visualize</li> </ul>"},{"location":"reference/cli/cmd_soar/","title":"soar","text":"<p>Commands and settings related to running Soar</p>"},{"location":"reference/cli/cmd_soar/#synopsis","title":"Synopsis","text":"<pre><code>======= Soar General Commands and Settings =======\nsoar ?                                                 Print this help listing\nsoar init                                              Re-initializes Soar\nsoar stop [--self]                                     Stop Soar execution\nsoar version                                           Print version number\n------------------- Settings ----------------------\nkeep-all-top-oprefs                    [ on | OFF ]    Keep prefs for o-supported WMEs in top-state\nmax-elaborations                                100    Max elaborations per decision cycle\nmax-goal-depth                                   23    Halt at this goal stack depth\nmax-nil-output-cycles                            15    Impasse after this many nil outputs\nmax-dc-time                                       0    Interrupt after this much time\nmax-memory-usage                          100000000    Threshold for memory warning\nmax-gp                                        20000    Max rules gp can generate\nstop-phase   [input|proposal|decision|APPLY|output]    Phase before which Soar will stop\ntcl                                    [ on | OFF ]    Allow Tcl code in commands\ntimers                                 [ ON | off ]    Profile Soar\nwait-snc                               [ on | OFF ]    Wait instead of impasse\n-----------------------------------------------\nTo change a setting:                                   soar &lt;setting&gt; [&lt;value&gt;]\nFor a detailed explanation of these settings:          help soar\n</code></pre>"},{"location":"reference/cli/cmd_soar/#summary-view","title":"Summary View","text":"<p>Using the <code>soar</code> command without any arguments will display a summary of Soar's current state of execution and which capabilities of Soar are enabled:</p> <pre><code>=======================================================\n                     Soar 9.6.0 Summary\n=======================================================\nEnabled:                                           Core\nDisabled:                EBC, SMem, EpMem, SVS, RL, WMA\n-------------------------------------------------------\nNumber of rules:                                     52\nDecisions                                            20\nElaborations                                         61\n-------------------------------------------------------\nState stack                        S1, S21 ... S29, S33\nCurrent number of states                              5\nNext phase                                        apply\n-------------------------------------------------------\n</code></pre> <p>To enable a particular capability of Soar, see the corresponding documentation for that component.</p>"},{"location":"reference/cli/cmd_soar/#soar-init","title":"soar init","text":"<p>The <code>init</code> command re-initializes Soar. It removes all elements from working memory, wiping out the goal stack, and resets all runtime statistics. The firing counts for all productions are reset to zero. The <code>soar init</code> command allows a Soar program that has been halted to be reset and start its execution from the beginning.</p> <p><code>soar init</code> does not remove any productions from production memory; to do this, use the production excise command. Note, however, that all justifications will be removed because they will no longer be supported.</p>"},{"location":"reference/cli/cmd_soar/#soar-stop","title":"soar stop","text":"<pre><code>soar stop [--self]\n</code></pre> <p>The <code>soar stop</code> command stops any running Soar agents. It sets a flag in the Soar kernel so that Soar will stop running at a \"safe\" point and return control to the user. The <code>--self</code> option will stop only the soar agent where the command is issued. All other agents continue running as previously specified.</p> <p>This command is usually not issued at the command line prompt - a more common use of this command would be, for instance, as a side-effect of pressing a button on a Graphical User Interface (GUI).</p> <p>Note that if a graphical interface doesn't periodically do an \"update\"/flush the pending I/O, then it may not be possible to interrupt a Soar agent from the command line.</p>"},{"location":"reference/cli/cmd_soar/#soar-version","title":"soar version","text":"<p>This command prints the version of Soar to the screen.</p>"},{"location":"reference/cli/cmd_soar/#settings","title":"Settings","text":"<p>Invoke a sub-command with no arguments to query the current setting. Partial commands are accepted.</p> Option Valid Values Default <code>keep-all-top-oprefs</code> on or off off <code>max-dc-time</code> &gt;= 0 0 <code>max-elaborations</code> &gt; 0 100 <code>max-goal-depth</code> &gt; 0 23 <code>max-gp</code> &gt; 0 20000 <code>max-memory-usage</code> &gt; 0 100000000 <code>max-nil-output-cycles</code> &gt; 0 15 <code>stop-phase</code> <code>&lt;phase&gt;</code> apply <code>tcl</code> on or off off <code>timers</code> on or off on <code>wait-snc</code> &gt;= 1 1"},{"location":"reference/cli/cmd_soar/#soar-keep-all-top-oprefs","title":"soar keep-all-top-oprefs","text":"<p>Enabling <code>keep-all-top-oprefs</code> turns off an optimization that reduces memory usage by discarding any internal preferences for WMEs that already have top-level o-support. Turning this setting off allows those preferences to be examined during debugging.</p>"},{"location":"reference/cli/cmd_soar/#soar-max-dc-time","title":"soar max-dc-time","text":"<p><code>max-dc-time</code> sets a maximum amount of time a decision cycle is permitted. After output phase, the elapsed decision cycle time is checked to see if it is greater than the old maximum, and the maximum dc time stat is updated (see stats). At this time, this threshold is also checked. If met or exceeded, Soar stops at the end of the current output phase with an interrupted state.</p>"},{"location":"reference/cli/cmd_soar/#soar-max-elaborations","title":"soar max-elaborations","text":"<p><code>max-elaborations</code> sets and prints the maximum number of elaboration cycles allowed in a single decision cycle.</p> <p>If <code>n</code> is given, it must be a positive integer and is used to reset the number of allowed elaboration cycles. The default value is 100. max-elaborations with no arguments prints the current value.</p> <p>The elaboration phase will end after <code>max-elaboration</code> cycles have completed, even if there are more productions eligible to fire or retract; and Soar will proceed to the next phase after a warning message is printed to notify the user. This limits the total number of cycles of parallel production firing but does not limit the total number of productions that can fire during elaboration.</p> <p>This limit is included in Soar to prevent getting stuck in infinite loops (such as a production that repeatedly fires in one elaboration cycle and retracts in the next); if you see the warning message, it may be a signal that you have a bug your code. However some Soar programs are designed to require a large number of elaboration cycles, so rather than a bug, you may need to increase the value of <code>max-elaborations</code>.</p> <p><code>max-elaborations</code> is checked during both the Propose Phase and the Apply Phase. If Soar runs more than the max-elaborations limit in either of these phases, Soar proceeds to the next phase (either Decision or Output) even if quiescence has not been reached.</p>"},{"location":"reference/cli/cmd_soar/#soar-max-goal-depth","title":"soar max-goal-depth","text":"<p>The <code>max-goal-depth</code> command is used to limit the maximum depth of sub-states that an agent can subgoal to. The initial value of this variable is 100; allowable settings are any integer greater than 0. This limit is also included in Soar to prevent getting stuck in an infinite recursive loop, which may come about due to deliberate actions or via an agent bug, such as dropping inadvertently to state-no-change impasses.</p>"},{"location":"reference/cli/cmd_soar/#soar-max-gp","title":"soar max-gp","text":"<p><code>max-gp</code> is used to limit the number of productions produced by a gp command. It is easy to write a gp rule that has a combinatorial explosion and hangs for a long time while those productions are added to memory. The <code>max-gp</code> setting bounds this.</p>"},{"location":"reference/cli/cmd_soar/#soar-max-memory-usage","title":"soar max-memory-usage","text":"<p>The <code>max-memory-usage</code> setting is used to trigger the memory usage exceeded event. The initial value of this is 100MB (100,000,000); allowable settings are any integer greater than 0.</p> <p>NOTE: The code supporting this event is not enabled by default because the test can be computationally expensive and is needed only for specific embedded applications. Users may enable the test and event generation by uncommenting code in <code>mem.cpp</code>.</p>"},{"location":"reference/cli/cmd_soar/#soar-max-nil-output-cycles","title":"soar max-nil-output-cycles","text":"<p><code>max-nil-output-cycles</code> sets and prints the maximum number of nil output cycles (output cycles that put nothing on the output link) allowed when running using run-til-output (<code>run --output</code>). If <code>n</code> is not given, this command prints the current number of nil-output-cycles allowed. If <code>n</code> is given, it must be a positive integer and is used to reset the maximum number of allowed nil output cycles.</p> <p><code>max-nil-output-cycles</code> controls the maximum number of output cycles that generate no output allowed when a <code>run --out</code> command is issued. After this limit has been reached, Soar stops. The default initial setting of <code>n</code> is 15.</p>"},{"location":"reference/cli/cmd_soar/#soar-stop-phase","title":"soar stop-phase","text":"<p><code>stop-phase</code> allows the user to control which phase Soar stops in. When running by decision cycle it can be helpful to have agents stop at a particular point in its execution cycle. The precise definition is that \"running for n decisions and stopping before phase ph means to run until the decision cycle counter has increased by n and then stop when the next phase is ph\". The phase sequence (as of this writing) is: input, proposal, decision, apply, output. Stopping after one phase is exactly equivalent to stopping before the next phase.</p>"},{"location":"reference/cli/cmd_soar/#soar-tcl","title":"soar tcl","text":"<p>Enabling the <code>tcl</code> setting augments Soar's prompt with Tcl scripting capabilities. In other words, it provides the ability to run Tcl code from any Soar command line by passing all Soar commands first through a Tcl interpreter for processing. (Each agent has its own Tcl interpreter.)</p> <p>This command provides Tcl capabilities to both local and remote clients, including the java-based debugger. It processes Tcl commands in both the Soar command line and any files sourced. Productions can make Tcl calls by writing <code>(exec tcl  | &lt;Tcl code&gt; |)</code> clauses on the RHS of rules. Soar symbols and variables can be included in RHS item.</p> <p>Important Notes:</p> <ul> <li> <p>If you source a file that turns tcl on, you cannot use any Tcl code until     the source command returns.</p> <p>If you'd like to have Tcl turned on automatically when Soar launches, add the <code>soar tcl on</code> command to your settings.soar file in the main Soar directory. This activates Tcl mode on initial launch, allowing you to immediately source files that use Tcl code.</p> </li> <li> <p><code>soar tcl off</code> is currently not supported due to memory issues.</p> </li> <li> <p>Only one RHS Tcl call will produce output.</p> <p>Soar rhs commands <code>write</code> (and even something like <code>echo</code>) will always work. But for Tcl commands that produce output, for example, a 'puts' command or a custom Tcl proc that produces output as a side effect, only the last one will display output. Note that all rhs Tcl calls do get executed, so they will do what they are supposed to do, including perhaps writing output to a file. The print output just doesn\u2019t get redirected to the right place, despite being produced. As a workaround, a user can make sure that there is only one Tcl call which needs to produce output and that it comes after any other Tcl RHS actions.</p> </li> <li> <p>Does not support Tk code. Tk is a widget toolkit that many Tcl programs use     to provide a GUI, for example, the old Soar TSI debugger.</p> </li> <li> <p>Tcl code that tries to do low-level Soar SML calls may or may not     work.Creating and deleting a kernel will certainly not work. But other things     like creating an agent may work fine. This caveat is inherent to the design of     Tcl as a plug-in without a main event loop.</p> </li> <li> <p>Third-party Tcl code that requires a Tcl event loop may or may not work, for     example, the Tcl <code>after</code> command.</p> </li> </ul>"},{"location":"reference/cli/cmd_soar/#soar-timers","title":"soar timers","text":"<p>This setting is used to control the timers that collect internal profiling information while Soar is running. With no arguments, this command prints out the current timer status. Timers are ENABLED by default. The default compilation flags for soar enable the basic timers and disable the detailed timers. The timers command can only enable or disable timers that have already been enabled with compiler directives. See the stats command for more info on the Soar timing system.</p>"},{"location":"reference/cli/cmd_soar/#soar-wait-snc","title":"soar wait-snc","text":"<p><code>wait-snc</code> controls an architectural wait state. On some systems, especially those that model expert knowledge, a state-no-change may represent a wait state rather than an impasse. The waitsnc command allows the user to switch to a mode where a state-no-change that would normally generate an impasse (and subgoaling), instead generates a wait state. At a wait state, the decision cycle will repeat (and the decision cycle count is incremented) but no state-no-change impasse (and therefore no substate) will be generated.</p>"},{"location":"reference/cli/cmd_soar/#examples","title":"Examples","text":"<pre><code>soar init\nsoar stop -s\nsoar timers off\nsoar stop-phase output                 // stop before output phase\nsoar max-goal-depth 100\nsoar max-elaborations\n</code></pre>"},{"location":"reference/cli/cmd_soar/#default-aliases","title":"Default Aliases","text":"<pre><code>init                             soar init\nis                               soar init\ninit-soar                        soar init\ninterrupt                        soar stop\nss                               soar stop\nstop                             soar stop\nstop-soar                        soar stop\ngp-max                           soar max-gp\nmax-dc-time                      soar max-dc-time\nmax-elaborations                 soar max-elaborations\nmax-goal-depth                   soar max-goal-depth\nmax-memory-usage                 soar max-memory-usage\nmax-nil-output-cycles            soar max-nil-output-cycles\nset-stop-phase                   soar stop-phase\ntimers                           soar timers\nversion                          soar version\nwaitsnc                          soar wait-snc\n</code></pre>"},{"location":"reference/cli/cmd_soar/#see-also","title":"See Also","text":"<ul> <li>production excise</li> <li>run</li> <li>stats</li> </ul>"},{"location":"reference/cli/cmd_sp/","title":"sp","text":"<p>Define a Soar production.</p>"},{"location":"reference/cli/cmd_sp/#synopsis","title":"Synopsis","text":"<pre><code>sp {production_body}\n</code></pre>"},{"location":"reference/cli/cmd_sp/#options","title":"Options","text":"Option Description <code>production_body</code> A Soar production."},{"location":"reference/cli/cmd_sp/#description","title":"Description","text":"<p>The <code>sp</code> command creates a new production and loads it into production memory. <code>production_body</code> is a single argument parsed by the Soar kernel, so it should be enclosed in curly braces to avoid being parsed by other scripting languages that might be in the same process. The overall syntax of a rule is as follows:</p> <pre><code>  name\n      [\"documentation-string\"]\n      [FLAG*]\n      LHS\n      --&gt;\n      RHS\n</code></pre> <p>The first element of a rule is its name. If given, the documentation-string must be enclosed in double quotes. Optional flags define the type of rule and the form of support its right-hand side assertions will receive. The specific flags are listed in a separate section below. The LHS defines the left-hand side of the production and specifies the conditions under which the rule can be fired. Its syntax is given in detail in a subsequent section. The --&gt; symbol serves to separate the LHS and RHS portions. The RHS defines the right-hand side of the production and specifies the assertions to be made and the actions to be performed when the rule fires. The syntax of the allowable right-hand side actions are given in a later section. (See the Syntax of Soar Programs chapter of the manual for naming conventions and discussion of the design and coding of productions.)</p> <p>If the name of the new production is the same as an existing one, the old production will be overwritten (excised).</p> <p>Rules matching the following requirement are flagged upon being created/sourced: a rule is a Soar-RL rule if and only if its right hand side (RHS) consists of a single numeric preference and it is not a template rule (see FLAGs below). This format exists to ease technical requirements of identifying/updating Soar-RL rules, as well as to make it easy for the agent programmer to add/maintain RL capabilities within an agent. (See the Reinforcement Learning chapter of the manual for further details.)</p>"},{"location":"reference/cli/cmd_sp/#rule-flags","title":"Rule Flags","text":"<p>The optional flags are given below. Note that these switches are preceded by a colon instead of a dash -- this is a Soar parser convention.</p> <pre><code>:o-support      specifies that all the RHS actions are to be given\n                o-support when the production fires\n\n:i-support     specifies that all the RHS actions are only to be given\n                i-support when the production fires\n\n:default        specifies that this production is a default production\n                (this matters for excise -task and trace task)\n\n:chunk          specifies that this production is a chunk\n                (this matters for learn trace)\n\n:interrupt      specifies that Soar should stop running when this\n                production matches but before it fires\n                (this is a useful debugging tool)\n\n:template       specifies that this production should be used to generate\n                new reinforcement learning rules by filling in those\n                variables that match constants in working memory\n</code></pre> <p>Multiple flags may be used, but not both of <code>o-support</code> and <code>no-support</code>.</p> <p>Although you could force your productions to provide o-support or i-support by using these commands --- regardless of the structure of the conditions and actions of the production --- this is not proper coding style. The <code>o-support</code> and <code>i-support</code> flags are included to help with debugging, but should not be used in a standard Soar program.</p>"},{"location":"reference/cli/cmd_sp/#examples","title":"Examples","text":"<pre><code>sp {blocks*create-problem-space\n     \"This creates the top-level space\"\n     (state &lt;s1&gt; ^superstate nil)\n     --&gt;\n     (&lt;s1&gt; ^name solve-blocks-world ^problem-space &lt;p1&gt;)\n     (&lt;p1&gt; ^name blocks-world)\n}\n</code></pre>"},{"location":"reference/cli/cmd_sp/#see-also","title":"See Also","text":"<ul> <li>production</li> <li>chunk</li> <li>trace</li> </ul>"},{"location":"reference/cli/cmd_stats/","title":"stats","text":"<p>Print information on Soar's runtime statistics.</p>"},{"location":"reference/cli/cmd_stats/#synopsis","title":"Synopsis","text":"<pre><code>stats [options]\n</code></pre>"},{"location":"reference/cli/cmd_stats/#options","title":"Options","text":"Option Description <code>-m, --memory</code> report usage for Soar's memory pools <code>-l, --learning</code> report statistics about rules learned via explanation-based chunking <code>-r, --rete</code> report statistics about the rete structure <code>-s, --system</code> report the system (agent) statistics (default) <code>-M, --max</code> report the per-cycle maximum statistics (decision cycle time, WM changes, production fires) <code>-R, --reset</code> zero out the per-cycle maximum statistics reported by <code>--max</code> command <code>-t, --track</code> begin tracking the per-cycle maximum statistics reported by <code>--max</code> for each cycle (instead of only the max value) <code>-T, --stop-track</code> stop and clear tracking of the per-cycle maximum statistics <code>-c, --cycle</code> print out collected per-cycle maximum statistics saved by <code>--track</code> in human-readable form <code>-C, --cycle-csv</code> print out collected per-cycle maximum statistics saved by <code>--track</code> in comma-separated form <code>-S, --sort N</code> sort the tracked cycle stats by column number <code>N</code>, see table below"},{"location":"reference/cli/cmd_stats/#-sort-parameters","title":"--sort parameters","text":"Option Description <code>0</code> Use default sort <code>1, -1</code> Sort by decision cycle (use negative for descending) <code>2, -2</code> Sort by DC time (use negative for descending) <code>3, -3</code> Sort by WM changes (use negative for descending) <code>4, -4</code> Sort by production firings (use negative for descending)"},{"location":"reference/cli/cmd_stats/#description","title":"Description","text":"<p>This command prints Soar internal statistics. The argument indicates the component of interest, <code>--system</code> is used by default.</p> <p>With the <code>--system</code> flag, the stats command lists a summary of run statistics, including the following:</p> <ul> <li>Version --- The Soar version number, hostname, and date of the run.</li> <li>Number of productions --- The total number of productions loaded in the     system, including all chunks built during problem solving and all default     productions.</li> <li>Timing Information --- Might be quite detailed depending on the flags     set at compile time. See note on timers below.</li> <li>Decision Cycles --- The total number of decision cycles in the run and     the average time-per-decision-cycle in milliseconds.</li> <li>Elaboration cycles --- The total number of elaboration cycles that were     executed during the run, the average number of elaboration cycles per decision     cycle, and the average time-per-elaboration-cycle in milliseconds. This is not     the total number of production firings, as productions can fire in parallel.</li> <li>Production Firings --- The total number of productions that were fired.</li> <li>Working Memory Changes --- This is the total number of changes to     working memory. This includes all additions and deletions from working memory.     Also prints the average match time.</li> <li>Working Memory Size --- This gives the current, mean and maximum number     of working memory elements.</li> </ul> <p>The stats argument <code>--memory</code> provides information about memory usage and Soar's memory pools, which are used to allocate space for the various data structures used in Soar.</p> <p>The stats argument <code>--learning</code> provides information about rules learned through Soar's explanation-based chunking mechanism. This is the same output that <code>chunk stats</code> provides. For statistics about a specific rule learned, see the <code>explain</code> command.</p> <p>The stats argument <code>--rete</code> provides information about node usage in the Rete net, the large data structure used for efficient matching in Soar.</p> <p>The <code>--max</code> argument reports per-cycle maximum statistics for decision cycle time, working memory changes, and production fires. For example, if Soar runs for three cycles and there were 23 working memory changes in the first cycle, 42 in the second, and 15 in the third, the <code>--max</code> argument would report the highest of these values (42) and what decision cycle that it occurred in (2nd). Statistics about the time spent executing the decision cycle and number of productions fired are also collected and reported by <code>--max</code> in this manner. <code>--reset</code> zeros out these statistics so that new maximums can be recorded for future runs. The numbers are also zeroed out with a call to init-soar.</p> <p>The <code>--track</code> argument starts tracking the same stats as the <code>--max</code> argument but records all data for each cycle instead of the maximum values. This data can be printed using the <code>--cycle</code> or <code>--cycle-csv</code> arguments. When printing the data with <code>--cycle</code>, it may be sorted using the <code>--sort</code> argument and a column integer. Use negative numbers for descending sort. Issue <code>--stop-track</code> to reset and clear this data.</p>"},{"location":"reference/cli/cmd_stats/#a-note-on-timers","title":"A Note on Timers","text":"<p>The current implementation of Soar uses a number of timers to provide time-based statistics for use in the stats command calculations. These timers are:</p> <ul> <li>total CPU time</li> <li>total kernel time</li> <li>phase kernel time (per phase)</li> <li>phase callbacks time (per phase)</li> <li>input function time</li> <li>output function time</li> </ul> <p>Total CPU time is calculated from the time a decision cycle (or number of decision cycles) is initiated until stopped. Kernel time is the time spent in core Soar functions. In this case, kernel time is defined as the all functions other than the execution of callbacks and the input and output functions. The total kernel timer is only stopped for these functions. The phase timers (for the kernel and callbacks) track the execution time for individual phases of the decision cycle (i.e., input phase, preference phase, working memory phase, output phase, and decision phase). Because there is overhead associated with turning these timers on and off, the actual kernel time will always be greater than the derived kernel time (i.e., the sum of all the phase kernel timers). Similarly, the total CPU time will always be greater than the derived total (the sum of the other timers) because the overhead of turning these timers on and off is included in the total CPU time. In general, the times reported by the single timers should always be greater than than the corresponding derived time. Additionally, as execution time increases, the difference between these two values will also increase. For those concerned about the performance cost of the timers, all the run time timing calculations can be compiled out of the code by defining <code>NO_TIMING_STUFF</code> (in <code>kernel.h</code>) before compilation.</p>"},{"location":"reference/cli/cmd_stats/#examples","title":"Examples","text":"<p>Track per-cycle stats then print them out using default sort:</p> <pre><code>stats --track\nrun\nstop\nstats --cycle\n</code></pre> <p>Print out per-cycle stats sorting by decision cycle time</p> <pre><code>stats --cycle --sort 2\n</code></pre> <p>Print out per-cycle stats sorting by firing counts, descending</p> <pre><code>stats --cycle --sort -4\n</code></pre> <p>Save per-cycle stats to file <code>stats.csv</code></p> <pre><code>ctf stats.csv stats --cycle-csv\n</code></pre>"},{"location":"reference/cli/cmd_stats/#default-aliases","title":"Default Aliases","text":"<pre><code>st       stats\n</code></pre>"},{"location":"reference/cli/cmd_stats/#see-also","title":"See Also","text":"<ul> <li>timers</li> <li>init-soar</li> </ul>"},{"location":"reference/cli/cmd_svs/","title":"svs","text":"<p>Control the behavior of the Spatial Visual System</p> <p>Syntax:</p> <pre><code>svs &lt;elements to inspect&gt;\nsvs [--enable | -e | --on | --disable | -d | --off]\n</code></pre>"},{"location":"reference/cli/cmd_svs/#synopsis","title":"Synopsis","text":"<pre><code>svs &lt;path&gt; dir\nsvs &lt;path&gt; help\nsvs connect_viewer &lt;port&gt;\nsvs disconnect_viewer\nsvs filters\nsvs filters.&lt;filter_name&gt;\nsvs commands\nsvs commands.&lt;command_name&gt;\nsvs &lt;state&gt;.scene.world\nsvs &lt;state&gt;.scene.world.&lt;path-to-node&gt;\nsvs &lt;state&gt;.scene.properties\nsvs &lt;state&gt;.scene.sgel &lt;sgel-command&gt;\nsvs &lt;state&gt;.scene.draw on|off\nsvs &lt;state&gt;.scene.clear\n</code></pre>"},{"location":"reference/cli/cmd_svs/#paths","title":"Paths","text":"<p>SVS can be navigated by specifying a path after the svs command. This path mimicks a directory structure and is specified by dot notation.</p> Path Argument Description connect_viewer &lt;port&gt; Connects to a svs_viewer listening on the given port disconnect_viewer Disconnects from an active svs_viewer filters Prints out a list of all the filters filters.&lt;filter_name&gt; Prints information about a specific filter commands Prints out a list of all the soar commands commands.&lt;command_name&gt; Prints information about a specific command &lt;state&gt;.scene.world Prints information about the world &lt;state&gt;.scene.&lt;node-path&gt; Prints information about a specific node &lt;state&gt;.scene.properties Prints pos/rot/scale/tag info about all nodes &lt;state&gt;.scene.sgel &lt;sgel&gt; Sends an sgel command to the scene &lt;state&gt;.scene.draw on Causes this scene to be the one drawn on the viewer &lt;state&gt;.scene.draw off Stops this scene from being drawn in the viewer &lt;state&gt;.scene.clear Removes all objects from the given scene"},{"location":"reference/cli/cmd_svs/#description","title":"Description","text":"<p>Each path can be followed by <code>help</code> to print some help info, or followed by <code>dir</code> to see the children of that path. The <code>&lt;state&gt;</code> variable is the identifier for the substate you want to examine. For example, to do things to the topstate scene you would use <code>svs S1.scene</code>.</p>"},{"location":"reference/cli/cmd_svs/#examples","title":"Examples","text":"<p>Print the full SVS directory structure</p> <pre><code>svs . dir\n</code></pre> <p>Print help information about connect_viewer</p> <pre><code>svs connect_viewer help\n</code></pre> <p>Print information about a distance filter</p> <pre><code>svs filters.distance\n</code></pre> <p>Print all the nodes in the scene for substate S17</p> <pre><code>svs S17.scene.world dir\n</code></pre> <p>Print information about the node wheel2 on car5</p> <pre><code>svs S1.scene.world.car5.wheel2\n</code></pre> <p>Add a new node to the scene using SGEL</p> <pre><code>svs S1.scene.sgel add ball3 world ball .5 position 1 1 1\n</code></pre>"},{"location":"reference/cli/cmd_trace/","title":"trace","text":"<p>Control the run-time tracing of Soar.</p>"},{"location":"reference/cli/cmd_trace/#synopsis","title":"Synopsis","text":"<pre><code>============================================================\n                    Soar Trace Messages\n============================================================\n------------------------- Level 1 --------------------------\nOperator decisions and states                             on     -d\n------------------------- Level 2 --------------------------\nPhases                                                   off     -p\nState removals caused by GDS violation                   off     -g\n------------------ Level 3: Rule firings -------------------\nDefault rules                                            off     -D\nUser rules                                               off     -u\nChunks                                                   off     -c\nJustifications                                           off     -j\nTemplates                                                off     -T\nFirings inhibited by higher-level firings                off     -W\n------------------------- Level 4 --------------------------\nWME additions and removals                               off     -w\n------------------------- Level 5 --------------------------\nPreferences                                              off     -r\n---------------- Additional Trace Messages -----------------\nChunking dependency analysis                             off     -b\nGoal dependency set changes                              off     -G\nEpisodic memory recording and queries                    off     -e\nNumeric preference calculations                          off     -i\nLearning Level                                           off     -L 0-2\nReinforcement learning value updates                     off     -R\nSemantic memory additions                                off     -s\nWorking memory activation and forgetting                 off     -a\n\nWME Detail Level                                        none     -n, -t, -f\n</code></pre>"},{"location":"reference/cli/cmd_trace/#trace-levels","title":"Trace Levels","text":"<pre><code>trace 0-5\n</code></pre> <p>Use of the <code>--level</code> (<code>-l</code>) flag is optional but recommended.</p> Option Description <code>0</code> trace nothing; equivalent to <code>-N</code> <code>1</code> trace decisions; equivalent to <code>-d</code> <code>2</code> trace phases, gds, and decisions; equivalent to <code>-dpg</code> <code>3</code> trace productions, phases, and decisions; equivalent to <code>-dpgP</code> <code>4</code> trace wmes, productions, phases, and decisions; equivalent to <code>-dpgPw</code> <code>5</code> trace preferences, wmes, productions, phases, and decisions; equivalent to <code>-dpgPwr</code> <p>It is important to note that trace level <code>0</code> turns off ALL trace options, including backtracing, indifferent selection and learning. However, the other trace levels do not change these settings. That is, if any of these settings is changed from its default, it will retain its new setting until it is either explicitly changed again or the trace level is set to <code>0</code>.</p>"},{"location":"reference/cli/cmd_trace/#options","title":"Options","text":"<pre><code>trace [options]\n</code></pre> Option Flag Argument to Option Description <code>-l, --level</code> <code>0</code> to <code>5</code> (see Trace Levels below) This flag is optional but recommended. Set a specific trace level using an integer <code>0</code> to <code>5</code>, this is an inclusive operation <code>-N, --none</code> No argument Turns off all printing about Soar's internals, equivalent to <code>--level 0</code> <code>-b, --backtracing</code> <code>remove</code> (optional) Print backtracing information when a chunk or justification is created <code>-d, --decisions</code> <code>remove</code> (optional) Controls whether state and operator decisions are printed as they are made <code>-e, --epmem</code> <code>remove</code> (optional) Print episodic retrieval traces and IDs of newly encoded episodes <code>-g, --gds</code> <code>remove</code> (optional) Controls printing of warnings when a state is removed due to the GDS <code>-G, --gds-wmes</code> <code>remove</code> (optional) Controls printing of warnings about wme changes to GDS <code>-i, --indifferent-selection</code> <code>remove</code> (optional) Print scores for tied operators in random indifferent selection mode <code>-p, --phases</code> <code>remove</code> (optional) Controls whether decisions cycle phase names are printed as Soar executes <code>-r, --preferences</code> <code>remove</code> (optional) Controls whether the preferences generated by the traced productions are printed when those productions fire or retract <code>-P, --productions</code> <code>remove</code> (optional) Controls whether the names of productions are printed as they fire and retract, equivalent to <code>-Dujc</code> <code>-R, --rl</code> <code>remove</code> (optional) Print RL debugging output <code>-s, --smem</code> <code>remove</code> (optional) Print log of semantic memory storage events <code>-w, --wmes</code> <code>remove</code> (optional) Controls the printing of working memory elements that are added and deleted as productions are fired and retracted. <code>-a, --wma</code> <code>remove</code> (optional) Print log of working memory activation events <code>-A, --assertions</code> <code>remove</code> (optional) Print assertions of rule instantiations and the preferences they generate. <p>When appropriate, a specific option may be turned off using the <code>remove</code> argument. This argument has a numeric alias; you can use <code>0</code> for <code>remove</code>. A mix of formats is acceptable, even in the same command line.</p>"},{"location":"reference/cli/cmd_trace/#tracing-productions","title":"Tracing Productions","text":"<p>By default, the names of the productions are printed as each production fires and retracts (at trace levels <code>3</code> and higher). However, it may be more helpful to trace only a specific type of production. The tracing of firings and retractions of productions can be limited to only certain types by the use of the following flags:</p> Option Flag Argument to Option Description <code>-D, --default</code> <code>remove</code> (optional) Control only default-productions as they fire and retract <code>-u, --user</code> <code>remove</code> (optional) Control only user-productions as they fire and retract <code>-c, --chunks</code> <code>remove</code> (optional) Control only chunks as they fire and retract <code>-j, --justifications</code> <code>remove</code> (optional) Control only justifications as they fire and retract <code>-T, --template</code> <code>remote</code> (optional) Soar-RL template firing trace <p>Note: The production watch command is used to trace individual productions specified by name rather than trace a type of productions, such as <code>--user</code>.</p> <p>Additionally, when tracing productions, users may set the level of detail to be displayed for WMEs that are added or retracted as productions fire and retract. Note that detailed information about WMEs will be printed only for productions that are being traced.</p> Option Flag Description <code>-n, --nowmes</code> When tracing productions, do not print any information about matching wmes <code>-t, --timetags</code> When tracing productions, print only the timetags for matching wmes <code>-f, --fullwmes</code> When tracing productions, print the full matching wmes"},{"location":"reference/cli/cmd_trace/#tracing-learning","title":"Tracing Learning","text":"Option Flag Argument to Option Description <code>-L, --learning</code> <code>noprint</code>, <code>print</code>, or <code>fullprint</code> (see table below) Controls the printing of chunks/justifications as they are created <p>As Soar is running, it may create justifications and chunks which are added to production memory. The trace command allows users to monitor when chunks and justifications are created by specifying one of the following arguments to the <code>--learning</code> command:</p> Argument Alias Effect <code>noprint</code> <code>0</code> Print nothing about new chunks or justifications (default) <code>print</code> <code>1</code> Print the names of new chunks and justifications when created <code>fullprint</code> <code>2</code> Print entire chunks and justifications when created"},{"location":"reference/cli/cmd_trace/#description","title":"Description","text":"<p>The <code>trace</code> command controls the amount of information that is printed out as Soar runs. The basic functionality of this command is to trace various levels of information about Soar's internal workings. The higher the level, the more information is printed as Soar runs. At the lowest setting, <code>0</code> (<code>--none</code>), nothing is printed. The levels are cumulative, so that each successive level prints the information from the previous level as well as some additional information. The default setting for the level is <code>1</code>, (<code>--decisions</code>).</p> <p>The numerical arguments inclusively turn on all levels up to the number specified. To use numerical arguments to turn off a level, specify a number which is less than the level to be turned off. For instance, to turn off tracing of productions, specify <code>--level 2</code> (or 1 or 0). Numerical arguments are provided for shorthand convenience. For more detailed control over the trace settings, the named arguments should be used.</p> <p>With no arguments, this command prints information about the current trace status, i.e., the values of each parameter.</p> <p>For the named arguments, including the named argument turns on only that setting. To turn off a specific setting, follow the named argument with <code>remove</code> or <code>0</code>.</p> <p>The named argument <code>--productions</code> is shorthand for the four arguments <code>--default</code>, <code>--user</code>, <code>--justifications</code>, and <code>--chunks</code>.</p>"},{"location":"reference/cli/cmd_trace/#examples","title":"Examples","text":"<p>The most common uses of trace are by using the numeric arguments which indicate trace levels. To turn off all printing of Soar internals, do any one of the following (not all possibilities listed):</p> <pre><code>trace --level 0\ntrace -l 0\ntrace -N\n</code></pre> <p>Note: You can turn off printing at an even lower level using the <code>output</code> command.</p> <p>Although the <code>--level</code> flag is optional, its use is recommended:</p> <pre><code>trace --level 5   ## OK\ntrace 5           ## OK, avoid\n</code></pre> <p>Be careful of where the level is on the command line, for example, if you want level 2 and preferences:</p> <pre><code>trace -r -l 2 ## Incorrect: -r flag ignored, level 2 parsed after it and overrides the setting\ntrace -r 2    ## Syntax error: 0 or remove expected as optional argument to -r\ntrace -r -l 2 ## Incorrect: -r flag ignored, level 2 parsed after it and overrides the setting\ntrace 2 -r    ## OK, avoid\ntrace -l 2 -r ## OK\n</code></pre> <p>To turn on printing of decisions, phases and productions, do any one of the following (not all possibilities listed):</p> <pre><code>trace --level 3\ntrace -l 3\ntrace --decisions --phases --productions\ntrace -d -p -P\n</code></pre> <p>Individual options can be changed as well. To turn on printing of decisions and WMEs, but not phases and productions, do any one of the following (not all possibilities listed):</p> <pre><code>trace --level 1 --wmes\ntrace -l 1 -w\ntrace --decisions --wmes\ntrace -d --wmes\ntrace -w --decisions\ntrace -w -d\n</code></pre> <p>To turn on printing of decisions, productions and WMEs, and turns phases off, do any one of the following (not all possibilities listed):</p> <pre><code>trace --level 4 --phases remove\ntrace -l 4 -p remove\ntrace -l 4 -p 0\ntrace -d -P -w -p remove\n</code></pre> <p>To trace the firing and retraction of decisions and only user productions, do any one of the following (not all possibilities listed):</p> <pre><code>trace -l 1 -u\ntrace -d -u\n</code></pre> <p>To trace decisions, phases and all productions except user productions and justifications, and to see full WMEs, do any one of the following (not all possibilities listed):</p> <pre><code>trace --decisions --phases --productions --user remove --justifications remove --fullwmes\ntrace -d -p -P -f -u remove -j 0\ntrace -f -l 3 -u 0 -j 0\n</code></pre>"},{"location":"reference/cli/cmd_trace/#default-aliases","title":"Default Aliases","text":"<pre><code>v           trace -A\nw           trace\nwatch       trace\n</code></pre>"},{"location":"reference/cli/cmd_trace/#see-also","title":"See Also","text":"<ul> <li>epmem</li> <li>production</li> <li>output</li> <li>print</li> <li>run</li> <li>wm</li> </ul>"},{"location":"reference/cli/cmd_visualize/","title":"visualize","text":"<p>Creates visualizations of Soar's memory systems or processing.</p>"},{"location":"reference/cli/cmd_visualize/#synopsis","title":"Synopsis","text":"<pre><code>======= Visualization Commands and Settings =======\nvisualize ?                                           Print this help listing\nvisualize [wm | smem | epmem] [id] [depth]            Visualize from memory system\nvisualize [ identity_graph | ebc_analysis]            Visualize EBC explainer analysis\n------------------ Presentation -------------------\nrule-format                          [ name | FULL]   Print all conditions and\n                                                      actions or just the rule name\nmemory-format                      [ node | RECORD]   Print memories as records\n                                                      or just simple nodes\nline-style                                 polyline   GraphViz line style that will\n                                                      be used\nseparate-states                        [ ON | off ]   Whether to create links\n                                                      between goal states\narchitectural-wmes                     [ on | OFF ]   Whether to include WMEs\n                                                      created by the Soar architecture\ncolor-identities                       [ on | OFF ]   Color identities in visualization\nuse-joined-identities                  [ ON | off ]   Color using final joined identities\n------------------ File Handling ------------------\nfile-name                                  soar_viz\nuse-same-file                          [ on | OFF ]   Whether to create new files each time\ngenerate-image                         [ ON | off ]   Whether an image should be created\nimage-type                                      svg   Image type that will be generated\n------------------ Post Actions -------------------\nviewer-launch                          [ ON | off ]   Launch image in viewer\neditor-launch                          [ on | OFF ]   Open data file in editor\nprint-debug                            [ on | OFF ]   Print data file to screen\n                                                      for debugging\n</code></pre>"},{"location":"reference/cli/cmd_visualize/#description","title":"Description","text":"<p>The <code>visualize</code> command will generate graphical representations of either Soar memory structure or the analysis that explanation-based chunking performed to learn a rule.</p> <p>This command can be instructed to automatically launch a viewer to see the visual representation. If you have an editor that can open graphviz files, you can have Soar launch that automatically as well. (Such editors allow you to move things around and lay out the components of the visualization exactly as you want them.)</p>"},{"location":"reference/cli/cmd_visualize/#visualizing-memory","title":"Visualizing Memory","text":"<pre><code>visualize [wm | smem | epmem] [id] [depth]\n</code></pre> <p>The first argument is the memory system that you want to visualize.</p> <p>The optional id argument allows you to specify either a root identifier from which to start working memory or semantic memory visualizations, or an episode ID for episodic memory visualization.</p> <p>The depth argument specifies how many levels of augmentation that will be printed.</p>"},{"location":"reference/cli/cmd_visualize/#visualizing-how-a-rule-was-learned","title":"Visualizing How a Rule was Learned","text":"<p><code>visualize [ identity_graph | ebc_analysis]</code></p> <p><code>visualize identity_graph</code> will create a visualization of how the final identities used in a learned rule were determined. This shows all identities involved and how the identity analysis joined them based on the problem-solving that occurred.</p> <p><code>visualize ebc_analysis</code> will create a visualization of the chunk that was learned and all rules that fired in a substate that contributed to a rule being learned. In addition to all of the dependencies between rules that fired, this visualization also shows which conditions in the instantiations tested knowledge in the superstate and hence contributed to a conditions in the final learned rule.</p>"},{"location":"reference/cli/cmd_visualize/#presentation-settings","title":"Presentation Settings","text":"<p><code>rule-format</code>: This setting only applies to visualizing EBC processing. The <code>full</code> format will print all conditions and actions of the rule. The <code>name</code> format will only print a simple object with the rule name.</p> <p><code>memory-format</code>: This setting only applies to visualizing memory systems. The <code>node</code> format will print a single graphical object for every symbol, using a circle for identifiers and a square for constants. The <code>record</code> format will print a database-style record for each identifier with all of its augmentations as fields. Links to other identifiers appear as arrows.</p> <p><code>line-style</code> is a parameter that is passed to Graphviz and affects how lines are drawn between objects. See the Graphviz documentation for legal values.</p> <p><code>separate-states</code> is a parameter that determines whether a link to a state symbol is drawn. When this setting is on, Soar will not connect states and instead will represent it as a constant. This setting only applies to visualizing memory systems.</p> <p><code>architectural-wmes</code> is a parameter that determines whether working memory elements created by the architecture, for example I/O and the various memory sub-system links, will be included in the visualization. This setting only applies to visualizing memory systems.</p>"},{"location":"reference/cli/cmd_visualize/#file-handling-settings","title":"File Handling Settings","text":"<p><code>file-name</code> specifies the base file name that Soar will use when creating both Graphviz data files and images. You can specify a path as well, for example \"visualization/soar_viz\", but make sure the directory exists first!</p> <p><code>use-same-file</code> tells the visualizer to always overwrite the same files for each visualization. When off, Soar will create a new visualization each time by using the base file name and adding a new number to it each time. Note that this command does not yet handle file creation as robustly as it could. If the file already exists, it will simply overwrite it rather than looking for a new file name.</p> <p><code>generate-image</code> specifies whether the visualizer should render the Graphviz file into an image. This setting is overridden if the viewer-launch setting is enabled.</p> <p><code>image-type</code> specifies what kind of image that visualizer should create. Graphviz is capable of rendering to a staggering number of different image types. The default that the visualizer uses is SVG, which is a vector-based format that can be scaled without loss of clarity. For other legal formats, see the Graphviz or DOT documentation.</p>"},{"location":"reference/cli/cmd_visualize/#post-action-settings","title":"Post Action Settings","text":"<p>After the data and image files are generated, the visualizer can automatically launch an external program to view or edit the output.</p> <p><code>viewer-launch</code> specifies whether to launch an image viewer. Most web browser can view SVG files.</p> <p><code>editor-launch</code> specifies whether to launch whatever program is associated with <code>.gv</code> files. For example, on OSX, the program OmniGraffle can be used to great effect.</p> <p><code>print-debug</code> specifies whether to print the raw Graphviz output to the screen. If you are having problems, you may want to use this setting to see what it is generating for your agent.</p> <p>Note that your operating system chooses which program to launch based on the file type. This feature has not been tested extensively on other platforms. Certain systems may not allow Soar to launch an external program.</p> Note <p>For the visualizer to work, you must have Graphviz and <code>dot</code> installed, which are free third-party tools, and both must be available on your path. To date, the visualizer has only been tested on Mac and Linux. It is possible that certain systems may not allow Soar to launch an external program.</p>"},{"location":"reference/cli/cmd_visualize/#see-also","title":"See Also","text":"<ul> <li>explain</li> <li>epmem</li> <li>smem</li> <li>chunk</li> </ul>"},{"location":"reference/cli/cmd_wm/","title":"wm","text":"<p>Commands and settings related to working memory and working memory activation. There are four sub-commands: <code>add</code>, <code>remove</code>, <code>activation</code>, and <code>watch</code>.</p>"},{"location":"reference/cli/cmd_wm/#synopsis","title":"Synopsis","text":"<pre><code>=========================================================\n-               WM Sub-Commands and Options             -\n=========================================================\nwm              [? | help]\n---------------------------------------------------------\nwm add          &lt;id&gt; [^]&lt;attribute&gt; &lt;value&gt; [+]\nwm remove       &lt;timetag&gt;\n---------------------------------------------------------\nwm activation   --get &lt;parameter&gt;\n                --set &lt;parameter&gt;                 &lt;value&gt;\n                      activation             [ on | OFF ]\n                      petrov-approx          [ on | OFF ]\n                      forgetting             [ on | OFF ]\n                      fake-forgetting        [ on | OFF ]\n                      forget-wme                      all  [all, lti]\n                      decay-rate                     -0.5  [0 to 1]\n                      decay-thresh                     -2  [0 to infinity]\n                      max-pow-cache                    10  MB\n                      timers                          off  [off, one]\n                --history &lt;timetag&gt;\n                --stats                                    Print forget stats\n                --timers [&lt;timer&gt;]                         Print timing results\n                  &lt;timer&gt; = wma_forgetting or wma_history\n---------------------------------------------------------\nwm watch        --add-filter    --type &lt;t&gt;  pattern\n                --remove-filter --type &lt;t&gt;  pattern\n                --list-filter  [--type &lt;t&gt;]\n                --reset-filter [--type &lt;t&gt;]\n                              &lt;t&gt; = adds, removes or both\n---------------------------------------------------------\n\nFor a detailed explanation of sub-commands:       help wm\n</code></pre>"},{"location":"reference/cli/cmd_wm/#wm-activation","title":"wm activation","text":"<p>The <code>wm activation</code> command changes the behavior of and displays information about working memory activation.</p> <p>To get the activation of individual WMEs, use <code>print -i</code>. To get the reference history of an individual WME, use <code>wm activation -h|--history &lt;timetag&gt;</code>. For example:</p> <pre><code>print --internal s1\n(4000016: S1 ^ct 1000000 [3.6])\n(4: S1 ^epmem E1 [1])\n(11: S1 ^io I1 [1])\n(20: S1 ^max 1000000 [3.4])\n(18: S1 ^name ct [3.4])\n(4000018: S1 ^operator O1000001 [1] +)\n(4000019: S1 ^operator O1000001 [1])\n(3: S1 ^reward-link R1 [1])\n(8: S1 ^smem S2 [1])\n(2: S1 ^superstate nil [1])\n(14: S1 ^top-state S1 [1])\n(1: S1 ^type state [1])\n</code></pre> <p>The bracketed values are activation. To get the history of an individual element:</p> <pre><code>wm activation --history 18\nhistory (60/5999999, first @ d1):\n 6 @ d1000000 (-1)\n 6 @ d999999 (-2)\n 6 @ d999998 (-3)\n 6 @ d999997 (-4)\n 6 @ d999996 (-5)\n 6 @ d999995 (-6)\n 6 @ d999994 (-7)\n 6 @ d999993 (-8)\n 6 @ d999992 (-9)\n 6 @ d999991 (-10)\n\nconsidering WME for decay @ d1019615\n</code></pre> <p>This shows the last 60 references (of 5999999 in total, where the first occurred at decision cycle 1). For each reference, it says how many references occurred in the cycle (such as 6 at decision 1000000, which was one cycle ago at the time of executing this command). Note that references during the current cycle will not be reflected in this command (or computed activation value) until the end of output phase. If <code>forgetting</code> is <code>on</code>, this command will also display the cycle during which the WME will be considered for decay. Even if the WME is not referenced until then, this is not necessarily the cycle at which the WME will be forgotten. However, it is guaranteed that the WME will not be forgotten before this cycle.</p>"},{"location":"reference/cli/cmd_wm/#options","title":"Options","text":"Option Description <code>-g, --get</code> Print current parameter setting <code>-s, --set</code> Set parameter value <code>-S, --stats</code> Print statistic summary or specific statistic <code>-t, --timers</code> Print timer summary or specific timer <code>-h, --history</code> Print reference history of a WME"},{"location":"reference/cli/cmd_wm/#parameters","title":"Parameters","text":"<p>The <code>activation</code> command uses the <code>--get|--set &lt;parameter&gt; &lt;value&gt;</code> convention rather than individual switches for each parameter. Running <code>wm activation</code> without any switches displays a summary of the parameter settings.</p> Parameter Description Possible values Default <code>activation</code> Enable working memory activation <code>on</code>, <code>off</code> <code>off</code> <code>decay-rate</code> WME decay factor <code>[</code>0, 1<code>]</code> 0.5 <code>decay-thresh</code> Forgetting threshold <code>(</code>0, inf<code>)</code> 2.0 <code>forgetting</code> Enable removal of WMEs with low activation values <code>on</code>, <code>off</code> <code>off</code> <code>forget-wme</code> If <code>lti</code> only remove WMEs with a long-term id <code>all</code>, <code>lti</code> <code>all</code> <code>max-pow-cache</code> Maximum size, in MB, for the internal <code>pow</code> cache 1, 2, ... 10 <code>petrov-approx</code> Enables the (Petrov 2006) long-tail approximation <code>on</code>, <code>off</code> <code>off</code> <code>timers</code> Timer granularity <code>off</code>, <code>one</code> <code>off</code> <p>The <code>decay-rate</code> and <code>decay-thresh</code> parameters are entered as positive decimals, but are internally converted to, and printed out as, negative.</p> <p>The <code>petrov-approx</code> may provide additional validity to the activation value, but comes at a significant computational cost, as the model includes unbounded positive exponential computations, which cannot be reasonably cached.</p> <p>When <code>activation</code> is enabled, the system produces a cache of results of calls to the <code>pow</code> function, as these can be expensive during runtime. The size of the cache is based upon three run-time parameters (<code>decay-rate</code>, <code>decay-thresh</code>, and <code>max-pow-cache</code>), and one compile time parameter, <code>WMA_REFERENCES_PER_DECISION</code> (default value of 50), which estimates the maximum number of times a WME will be referenced during a decision. The cache is composed of <code>double</code> variables (i.e. 64-bits, currently) and the number of cache items is computed as follows:</p> \\[ e^((decay_thresh - ln(max_refs)) / decay_rate) \\] <p>With the current default parameter values, this will incur about 1.04MB of memory. Holding the <code>decay-rate</code> constant, reasonable changes to <code>decay-thresh</code> (i.e. +/- 5) does not greatly change this value. However, small changes to <code>decay-rate</code> will dramatically change this profile. For instance, keeping everything else constant, a <code>decay-thresh</code> of 0.3 requires ~2.7GB and 0.2 requires ~50TB. Thus, the <code>max-pow-cache</code> parameter serves to allow you to control the space vs. time tradeoff by capping the maximum amount of memory used by this cache. If <code>max-pow-cache</code> is much smaller than the result of the equation above, you may experience somewhat degraded performance due to relatively frequent system calls to <code>pow</code>.</p> <p>If <code>forget-wme</code> is <code>lti</code> and <code>forgetting</code> is <code>on</code>, only those WMEs whose id is a long-term identifier at the decision of forgetting will be removed from working memory. If, for instance, the id is stored to semantic memory after the decision of forgetting, the WME will not be removed till some time after the next WME reference (such as testing/creation by a rule).</p>"},{"location":"reference/cli/cmd_wm/#statistics","title":"Statistics","text":"<p>Working memory activation tracks statistics over the lifetime of the agent. These can be accessed using <code>wm activation --stats &lt;statistic&gt;</code>. Running <code>wm activation --stats</code> without a statistic will list the values of all statistics. Unlike timers, statistics will always be updated.</p> <p>Available statistics are:</p> Name Label Description <code>forgotten-wmes</code> Forgotten WMEs Number of WMEs removed from working memory due to forgetting"},{"location":"reference/cli/cmd_wm/#timers","title":"Timers","text":"<p>Working memory activation also has a set of internal timers that record the durations of certain operations. Because fine-grained timing can incur runtime costs, working memory activation timers are off by default. Timers of different levels of detail can be turned on by issuing <code>wm activation --set timers &lt;level&gt;</code>, where the levels can be <code>off</code> or <code>one</code>, <code>one</code> being most detailed and resulting in all timers being turned on. Note that none of the working memory activation statistics nor timing information is reported by the <code>stats</code> command.</p> <p>All timer values are reported in seconds.</p> <p>Timer Levels:</p> Option Description <code>wma_forgetting</code> Time to process forgetting operations each cycle <code>wma_history</code> Time to consolidate reference histories each cycle"},{"location":"reference/cli/cmd_wm/#wm-add","title":"wm add","text":"<p>Manually add an element to working memory.</p> <pre><code>wm add id [^]attribute value [+]\n</code></pre>"},{"location":"reference/cli/cmd_wm/#options_1","title":"Options","text":"Option Description <code>id</code> Must be an existing identifier. <code>^</code> Leading <code>^</code> on attribute is optional. <code>attribute</code> Attribute can be any Soar symbol. Use <code>*</code> to have Soar create a new identifier. <code>value</code> Value can be any soar symbol. Use <code>*</code> to have Soar create a new identifier. <code>+</code> If the optional preference is specified, its value must be <code>+</code> (acceptable)."},{"location":"reference/cli/cmd_wm/#description","title":"Description","text":"<p>Manually add an element to working memory. <code>wm add</code> is often used by an input function to update Soar's information about the state of the external world.</p> <p><code>wm add</code> adds a new wme with the given id, attribute, value and optional preference. The given id must be an existing identifier. The attribute and value fields can be any Soar symbol. If <code>*</code> is given in the attribute or value field, Soar creates a new identifier (symbol) for that field. If the preference is given, it can only have the value <code>+</code> to indicate that an acceptable preference should be created for this WME.</p> <p>Note that because the id must already exist in working memory, the WME that you are adding will be attached (directly or indirectly) to the top-level state. As with other WME's, any WME added via a call to add-wme will automatically be removed from working memory once it is no longer attached to the top-level state.</p>"},{"location":"reference/cli/cmd_wm/#examples","title":"Examples","text":"<p>This example adds the attribute/value pair <code>^message-status received</code> to the identifier (symbol) S1:</p> <pre><code>wm add S1 ^message-status received\n</code></pre> <p>This example adds an attribute/value pair with an acceptable preference to the identifier (symbol) Z2. The attribute is <code>message</code> and the value is a unique identifier generated by Soar. Note that since the <code>^</code> is optional, it has been left off in this case.</p> <pre><code>wm add Z2 message * +\n</code></pre>"},{"location":"reference/cli/cmd_wm/#warnings","title":"Warnings","text":"<p>Be careful how you use this command. It may have weird side effects (possibly even including system crashes). For example, the chunking mechanism can't backtrace through WMEs created via <code>wm add</code> nor will such WMEs ever be removed through Soar's garbage collection. Manually removing context/impasse WMEs may have unexpected side effects.</p>"},{"location":"reference/cli/cmd_wm/#wm-remove","title":"wm remove","text":"<p>Manually remove an element from working memory.</p> <pre><code>wm remove timetag\n</code></pre>"},{"location":"reference/cli/cmd_wm/#options_2","title":"Options","text":"Option Description <code>timetag</code> A positive integer matching the timetag of an existing working memory element."},{"location":"reference/cli/cmd_wm/#description_1","title":"Description","text":"<p>The <code>wm remove</code> command removes the working memory element with the given timetag. This command is provided primarily for use in Soar input functions; although there is no programming enforcement, wm remove should only be called from registered input functions to delete working memory elements on Soar's input link.</p> <p>Beware of weird side effects, including system crashes.</p>"},{"location":"reference/cli/cmd_wm/#warnings_1","title":"Warnings","text":"<p><code>wm remove</code> should never be called from the RHS of a production: if you try to match a WME on the LHS of a production, and then remove the matched WME on the RHS, Soar will crash.</p> <p>If used other than by input and output functions interfaced with Soar, this command may have weird side effects (possibly even including system crashes). Removing input WMEs or context/impasse WMEs may have unexpected side effects. You've been warned.</p>"},{"location":"reference/cli/cmd_wm/#wm-watch","title":"wm watch","text":"<p>Print information about WMEs matching a certain pattern as they are added and removed.</p> <pre><code>wm watch -[a|r]  -t &lt;type&gt;  &gt;pattern&gt;\nwm watch -[l|R] [-t &lt;type&gt;]\n</code></pre>"},{"location":"reference/cli/cmd_wm/#options_3","title":"Options","text":"Option Description <code>-a, --add-filter</code> Add a filter to print wmes that meet the type and pattern criteria. <code>-r, --remove-filter</code> Delete filters for printing wmes that match the type and pattern criteria. <code>-l, --list-filter</code> List the filters of this type currently in use. Does not use the pattern argument. <code>-R, --reset-filter</code> Delete all filters of this type. Does not use pattern arg. <code>-t, --type</code> Follow with a type of wme filter, see below."},{"location":"reference/cli/cmd_wm/#watch-patterns","title":"Watch Patterns","text":"<p>The pattern is an id-attribute-value triplet:</p> <pre><code>id attribute value\n</code></pre> <p>Note that <code>*</code> can be used in place of the id, attribute or value as a wildcard that matches any string. Note that braces are not used anymore.</p>"},{"location":"reference/cli/cmd_wm/#watch-types","title":"Watch Types","text":"<p>When using the -t flag, it must be followed by one of the following:</p> Option Description <code>adds</code> Print info when a wme is <code>added</code>. <code>removes</code> Print info when a wme is <code>retracted</code>. <code>both</code> Print info when a wme is added <code>or</code> retracted. <p>When issuing a <code>-R</code> or <code>-l</code>, the <code>-t</code> flag is optional. Its absence is equivalent to <code>-t both</code>.</p>"},{"location":"reference/cli/cmd_wm/#description_2","title":"Description","text":"<p>This commands allows users to improve state tracing by issuing filter-options that are applied when watching WMEs. Users can selectively define which <code>object-attribute-value</code> triplets are monitored and whether they are monitored for addition, removal or both, as they go in and out of working memory.</p>"},{"location":"reference/cli/cmd_wm/#examples_1","title":"Examples","text":"<p>Users can watch an <code>attribute</code> of a particular object (as long as that object already exists):</p> <pre><code>soar&gt; wm watch --add-filter -t both D1 speed *\n</code></pre> <p>or print WMEs that retract in a specific state (provided the <code>state</code> already exists):</p> <pre><code>soar&gt; wm watch --add-filter -t removes S3 * *\n</code></pre> <p>or watch any relationship between objects:</p> <pre><code>soar&gt; wm watch --add-filter -t both * ontop *\n</code></pre>"},{"location":"reference/cli/cmd_wm/#default-aliases","title":"Default Aliases","text":"<pre><code>add-wme       wm add\naw            wm add\nremove-wme    wm remove\nrw            wm remove\nwatch-wmes    wm watch\nwma           wm activation\n</code></pre>"},{"location":"reference/cli/cmd_wm/#see-also","title":"See Also","text":"<ul> <li>print</li> <li>trace</li> </ul>"},{"location":"soar_manual/","title":"The Soar User\u2019s Manual","text":"<p>John E. Laird, Clare Bates Congdon, Mazin Assanie, Nate Derbinsky and Joseph Xu</p> <p>Additional contributions by:</p> <p>Mitchell Bloch, Karen J. Coulter, Steven Jones, Aaron Mininger, Preeti Ramaraj and Bryan Stearns</p> <p>Division of Computer Science and Engineering University of Michigan</p> <p>Errors may be reported to John E. Laird (laird@umich.edu)</p> <p>Copyright \u00a9 1998 - 2023, The Regents of the University of Michigan</p> <p>Development of earlier versions of this manual were supported under contract N00014-92- K-2015 from the Advanced Systems Technology Office of the Advanced Research Projects Agency and the Naval Research Laboratory, and contract N66001-95-C-6013 from the Advanced Systems Technology Office of the Advanced Research Projects Agency and the Naval Command and Ocean Surveillance Center, RDT&amp;E division.</p>"},{"location":"soar_manual/01_Introduction/","title":"Introduction","text":"<p>Soar has been developed to be an architecture for constructing general intelligent systems. It has been in use since 1983, and has evolved through many different versions. This manual documents the most current of these: version 9.6.4.</p> <p>Our goals for Soar include that it ultimately be an architecture that can:</p> <ul> <li>be used to build systems that work on the full range of tasks expected of an intelligent agent, from highly routine to extremely difficult, open-ended problems;</li> <li>represent and use appropriate forms of knowledge, such as procedural, declarative, episodic, and possibly iconic;</li> <li>employ the full range of possible problem solving methods;</li> <li>interact with the outside world; and</li> <li>learn about all aspects of the tasks and its performance on those tasks.</li> </ul> <p>In other words, our intention is for Soar to support all the capabilities required of a general intelligent agent. Below are the major principles that are the cornerstones of Soar\u2019s design:</p> <ol> <li>The number of distinct architectural mechanisms should be minimized. Classically    Soar had only a single representation of permanent knowledge (production rules), a    single representation of temporary knowledge (objects with attributes and values), a    single mechanism for generating goals (automatic subgoaling), and a single learning    mechanism (chunking). It was only as Soar was applied to diverse tasks in complex    environments that we found these mechanisms to be insufficient and added new long-    term memories (semantic and episodic) and learning mechanisms (semantic, episodic,    and reinforcement learning) to extend Soar agents with crucial new functionalities.</li> <li>All decisions are made through the combination of relevant knowledge at run-time.    In Soar, every decision is based on the current interpretation of sensory data and any    relevant knowledge retrieved from permanent memory. Decisions are never precompiled    into uninterruptible sequences.</li> </ol>"},{"location":"soar_manual/01_Introduction/#using-this-manual","title":"Using this Manual","text":"<p>We expect that novice Soar users will read the manual in the order it is presented. Not all users will makes use of the mechanisms described in chapters 4-8, but it is important to know that these capabilities exist.</p> <p>Chapter 2 and Chapter 3 describe Soar from different perspectives: Chapter 2 describes the Soar architecture, but avoids issues of syntax, while Chapter 3 describes the syntax of Soar, including the specific conditions and actions allowed in Soar productions.</p> <p>Chapter 4 describes chunking, Soar\u2019s mechanism to learn new procedural knowledge (productions).</p> <p>Chapter 5 describes reinforcement learning (RL), a mechanism by which Soar\u2019s procedural knowledge is tuned given task experience.</p> <p>Chapter 6 and Chapter 7 describe Soar\u2019s long-term declarative memory systems, semantic and episodic.</p> <p>Chapter 8 describes the Spatial Visual System (SVS), a mechanism by which Soar can convert complex perceptual input into practical semantic knowledge.</p> <p>Chapter 9 describes the Soar user interface \u2014 how the user interacts with Soar. The chapter is a catalog of user-interface commands, grouped by functionality. The most accurate and up-to-date information on the syntax of the Soar User Interface is found online, at the Soar web site, at https://soar.eecs.umich.edu/reference/.</p> <p>Advanced users will refer most often to Chapter 9, flipping back to Chapters 2 and 3 to answer specific questions.</p> <p>Chapters 2 and 3 make use of a Blocks World example agent. The Soar code for this agent can be downloaded from https://raw.githubusercontent.com/SoarGroup/website-downloads/refs/heads/main/files/blocksworld.soar or viewed in the manual here.</p>"},{"location":"soar_manual/01_Introduction/#additional-back-matter","title":"Additional Back Matter","text":"<p>After these chapters is an index; the last pages of this manual contain a summary and index of the user-interface functions for quick reference.</p>"},{"location":"soar_manual/01_Introduction/#not-described-in-this-manual","title":"Not Described in This Manual","text":"<p>Some of the more advanced features of Soar are not described in this manual, such as how to interface with a simulator, or how to create Soar applications using multiple interacting agents. The Soar project website (see link below) has additional help documents and resources.</p> <p>For novice Soar users, try The Soar 9 Tutorial, which guides the reader through several example tasks and exercises.</p>"},{"location":"soar_manual/01_Introduction/#contacting-the-soar-group","title":"Contacting the Soar Group","text":"<p>The primary website for Soar is:</p> <p>http://soar.eecs.umich.edu/</p> <p>Look here for the latest Soar-related downloads, documentation, FAQs, and announcements, as well as links to information about specific Soar research projects and researchers.</p> <p>Soar kernel development is hosted on GitHub at</p> <p>https://github.com/SoarGroup</p> <p>This site contains the public GitHub repository, a wiki describing the command-line interface, and an issue tracker where users can report bugs or suggests features.</p> <p>To contact the Soar group or get help, or to receive notifications of significant developments in Soar, we recommend that you register with one or both of our email lists:</p> <p>For questions about using Soar, you can use the soar-help list. For other discussion or to receive announcements, use the soar-group list.</p> <p>Also, please do not hesitate to file bugs on our issue tracker:</p> <p>https://github.com/SoarGroup/Soar/issues</p> <p>To avoid redundant entries, please search for duplicate issues first.</p>"},{"location":"soar_manual/01_Introduction/#for-those-without-internet-access","title":"For Those Without Internet Access","text":"<p>Mailing Address:</p> <pre><code>The Soar Group\nArtificial Intelligence Laboratory\nUniversity of Michigan\n2260 Hayward Street\nAnn Arbor, MI 48109-2121\nUSA\n</code></pre>"},{"location":"soar_manual/01_Introduction/#different-platforms-and-operating-systems","title":"Different Platforms and Operating Systems","text":"<p>Soar runs on a wide variety of platforms, including Linux, Unix (although not heavily tested), Mac OS X, and Windows 10, 7, possibly 8 and Vista, XP, 2000 and NT). We currently test Soar on both 32-bit and 64-bit versions of Ubuntu Linux, OS X 10, and Windows 10.</p> <p>This manual documents Soar generally, although all references to files and directories use Unix format conventions rather than Windows-style folders.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/","title":"The Soar Architecture","text":"<p>This chapter describes the Soar architecture. It covers all aspects of Soar except for the specific syntax of Soar\u2019s memories and descriptions of the Soar user-interface commands.</p> <p>This chapter gives an abstract description of Soar. It starts by giving an overview of Soar and then goes into more detail for each of Soar\u2019s main memories (working memory, production memory, and preference memory) and processes (the decision procedure, learning, and input and output).</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#an-overview-of-soar","title":"An Overview of Soar","text":"<p>The design of Soar is based on the hypothesis that all deliberate goal-oriented behavior can be cast as the selection and application of operators to a state. A state is a representation of the current problem-solving situation; an operator transforms a state (makes changes to the representation); and a goal is a desired outcome of the problem-solving activity.</p> <p>As Soar runs, it is continually trying to apply the current operator and select the next operator (a state can have only one operator at a time), until the goal has been achieved. The selection and application of operators is illustrated in Figure 2.1.</p> Soar is continually trying to select and apply operators. <p>Soar has separate memories (and different representations) for descriptions of its current situation and its long-term procedural knowledge. In Soar, the current situation, including data from sensors, results of intermediate inferences, active goals, and active operators is held in working memory. Working memory is organized as objects. Objects are described in terms of their attributes; the values of the attributes may correspond to sub-objects, so the description of the state can have a hierarchical organization. (This need not be a strict hierarchy; for example, there\u2019s nothing to prevent two objects from being \"substructure\" of each other.)</p> <p>Long-term procedural knowledge is held in production memory. Procedural knowledge specifies how to respond to different situations in working memory, can be thought of as the program for Soar. The Soar architecture cannot solve any problems without the addition of long-term procedural knowledge. (Note the distinction between the \"Soar architecture\" and the \"Soar program\": The former refers to the system described in this manual, common to all users, and the latter refers to knowledge added to the architecture.)</p> <p>A Soar program contains the knowledge to be used for solving a specific task (or set of tasks), including information about how to select and apply operators to transform the states of the problem, and a means of recognizing that the goal has been achieved.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#types-of-procedural-knowledge-in-soar","title":"Types of Procedural Knowledge in Soar","text":"<p>Soar\u2019s procedural knowledge can be categorized into four distinct types of knowledge:</p> <ol> <li>Inference Rules    In Soar, we call these state elaborations. This knowledge provides monotonic inferences    that can be made about the state in a given situation. The knowledge created by such    rules are not persistent and exist only as long as the conditions of the rules are met.</li> <li>Operator Proposal Knowledge    Knowledge about when a particular operator is appropriate for a situation. Note    that multiple operators may be appropriate in a given context. So, Soar also needs    knowledge to determine which of the candidates to choose:</li> <li>Operator Selection Knowledge    Knowledge about the desirability of an operator in a particular situation.    Such knowledge can be either in terms of a single operator (e.g. never choose    this operator in this    situation) or relational (e.g. prefer this operator over another in this situation).</li> <li>Operator Application Rules    Knowledge of how a specific selected operator modifies the state. This knowledge    creates persistent changes to the state that remain even after the rule no longer matches    or the operator is no longer selected.</li> </ol> <p>Note that state elaborations can indirectly affect operator selection and application by creating knowledge that the proposal and application rules match on.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#problem-solving-functions-in-soar","title":"Problem-Solving Functions in Soar","text":"<p>These problem-solving functions are the primitives for generating behavior that is relevant to the current situation: elaborating the state, proposing candidate operators, comparing the candidates, and applying the operator by modifying the state. These functions are driven by the knowledge encoded in a Soar program.</p> <p>Soar represents that knowledge as production rules. Production rules are similar to \"if- then\" statements in conventional programming languages. (For example, a production might say something like \"if there are two blocks on the table, then suggest an operator to move one block on top of the other block\"). The \"if\" part of the production is called its conditions and the \"then\" part of the production is called its actions. When the conditions are met in the current situation as defined by working memory, the production is matched and it will fire, which means that its actions are executed, making changes to working memory.</p> <p>Selecting the current operator, involves making a decision once sufficient knowledge has been retrieved. This is performed by Soar\u2019s decision procedure, which is a fixed procedure that interprets preferences that have been created by the knowledge retrieval functions. The knowledge-retrieval and decision-making functions combine to form Soar\u2019s decision cycle.</p> <p>When the knowledge to perform the problem-solving functions is not directly available in productions, Soar is unable to make progress and reaches an impasse. There are three types of possible impasses in Soar:</p> <ol> <li>An operator cannot be selected because no new operators are proposed.</li> <li>An operator cannot be selected because multiple operators are proposed and    the comparisons are insufficient to determine which one should be selected.</li> <li>An operator has been selected, but there is insufficient knowledge to apply it.</li> </ol> <p>In response to an impasse, the Soar architecture creates a substate in which operators can be selected and applied to generate or deliberately retrieve the knowledge that was not directly available; the goal in the substate is to resolve the impasse. For example, in a substate, a Soar program may do a lookahead search to compare candidate operators if comparison knowledge is not directly available. Impasses and substates are described in more detail in Impasses and Substates.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#an-example-task-the-blocks-world","title":"An Example Task: The Blocks-World","text":"<p>We will use a task called the blocks-world as an example throughout this manual. In the blocks-world task, the initial state has three blocks named A, B, and C on a table; the operators move one block at a time to another location (on top of another block or onto the table); and the goal is to build a tower with A on top, B in the middle, and C on the bottom. The initial state and the goal are illustrated in Figure 2.2.</p> <p>The Soar code for this task is available for download here https://raw.githubusercontent.com/SoarGroup/website-downloads/refs/heads/main/files/blocksworld.soar and can be viewed in the manual here. You do not need to look at the code at this point.</p> A B C Initial State A B C Goal The initial state and goal of the \"blocks-world\" task. <p>The operators in this task move a single block from its current location to a new location; each operator is represented with the following information:</p> <ul> <li>the name of the block being moved</li> <li>the current location of the block (the \"thing\" it is on top of)</li> <li>the destination of the block (the \"thing\" it will be on top of)</li> </ul> <p>The goal in this task is to stack the blocks so that C is on the table, with block B on top of block C, and block A on top of block B.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#representation-of-states-operators-and-goals","title":"Representation of States, Operators, and Goals","text":"<p>The initial state in our blocks-world task - before any operators have been proposed or selected - is illustrated in Figure 2.3.</p> <p>A state can have only one selected operator at a time but it may also have a number of potential operators that are in consideration. These proposed operators should not be confused with the active, selected operator.</p> <p>Figure 2.4 illustrates working memory after the first operator has been selected. There are six operators proposed, and only one of these is actually selected.</p> <p>Goals are either represented explicitly as substructures of the working memory state with general rules that recognize when the goal is achieved, or are implicitly represented in the Soar program by goal-specific rules that test the state for specific features and recognize when the goal is achieved. The point is that sometimes a description of the goal will be available in the state for focusing the problem solving, whereas other times it may not.  Although representing a goal explicitly has many advantages, some goals are difficult to explicitly represent on the state.</p> <p>For example, the goal in our blocks-world task is represented implicitly in the provided Soar program. This is because a single production rule monitors the state for completion of the goal and halts Soar when the goal is achieved. (Syntax of Soar programs will be explained in Chapter 3.) If the goal was an explicit working memory structure, a rule could compare the configuration of blocks to that structure instead of having the goal embedded within the rule\u2019s programming.</p> An abstract illustration of the initial state of the blocks world as working memory objects. At this stage of problem solving, no operators have been proposed or selected. An abstract illustration of working memory in the blocks world after the first operator has been selected."},{"location":"soar_manual/02_TheSoarArchitecture/#proposing-candidate-operators","title":"Proposing candidate operators","text":"<p>As a first step in selecting an operator, one or more candidate operators are proposed.  Operators are proposed by rules that test features of the current state. When the blocks- world task is run, the Soar program will propose six distinct (but similar) operators for the initial state as illustrated in Figure 2.5. These operators correspond to the six different actions that are possible given the initial state.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#comparing-candidate-operators-preferences","title":"Comparing candidate operators: Preferences","text":"<p>The second step Soar takes in selecting an operator is to evaluate or compare the candidate operators. In Soar, this is done via rules that test the proposed operators and the current state, and then create preferences(stored in preference memory). Preferences assert the relative or absolute merits of the candidate operators. For example, a preference may say that operator A is a \"better\" choice than operator B at this particular time, or a preference may say that operator A is the \"best\" thing to do at this particular time. Preferences are discussed in detail in how preferences are evaluated to decide an operator.</p> The six operators proposed for the initial state of the blocks world each move one block to a new location."},{"location":"soar_manual/02_TheSoarArchitecture/#selecting-a-single-operator-decision","title":"Selecting a single operator: Decision","text":"<p>Soar attempts to select a single operator as a decision, based on the preferences available for the candidate operators. There are four different situations that may arise:</p> <ol> <li>The available preferences unambiguously prefer a single operator.</li> <li>The available preferences suggest multiple operators, and prefer a subset that can be    selected from randomly.</li> <li>The available preferences suggest multiple operators,but neither case 1 or 2 above hold.</li> <li>The available preferences do not suggest any operators.</li> </ol> <p>In the first case, the preferred operator is selected. In the second case, one of the subset is selected randomly. In the third and fourth cases, Soar has reached an impasse in problem solving, and a new substate is created. Impasses are discussed in Impasses and Substates.</p> <p>In our blocks-world example, the second case holds, and Soar can select one of the operators randomly</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#applying-the-operator","title":"Applying the operator","text":"<p>An operator applies by making changes to the state; the specific changes that are appropriate depend on the operator and the current state.</p> <p>There are two primary approaches to modifying the state: indirect and direct. Indirect changes are used in Soar programs that interact with an external environment: The Soar program sends motor commands to the external environment and monitors the external environment for changes. The changes are reflected in an updated state description, garnered from sensors. Soar may also make direct changes to the state; these correspond to Soar doing problem solving \"in its head\". Soar programs that do not interact with an external environment can make only direct changes to the state.</p> <p>Internal and external problem solving should not be viewed as mutually exclusive activities in Soar. Soar programs that interact with an external environment will generally have operators that make direct and indirect changes to the state: The motor command is represented as substructure of the state and it is a command to the environment. Also, a Soar program may maintain an internal model of how it expects an external operator will modify the world; if so, the operator must update the internal model (which is substructure of the state).</p> <p>When Soar is doing internal problem solving, it must know how to modify the state descriptions appropriately when an operator is being applied. If it is solving the problem in an external environment, it must know what possible motor commands it can issue in order to affect its environment.</p> <p>The example blocks-world task described here does not interact with an external environment. Therefore, the Soar program directly makes changes to the state when operators are applied. There are four changes that may need to be made when a block is moved in our task:</p> <ol> <li>The block that is being moved is no longer where it was (it is no longer \"on top\" of    the same thing).</li> <li>The block that is being moved is in a new location (it is \"on top\" of a new thing).</li> <li>The place that the block used to be in is now clear.</li> <li>The place that the block is moving to is no longer clear \u2014 unless it is the table, which    is always considered \"clear\".<sup>1</sup></li> </ol> <p>The blocks-world task could also be implemented using an external simulator. In this case, the Soar program does not update all the \"on top\" and \"clear\" relations; the updated state description comes from the simulator.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#making-inferences-about-the-state","title":"Making inferences about the state","text":"<p>Making monotonic inferences about the state is the other role that Soar long-term procedural knowledge may fulfill. Such elaboration knowledge can simplify the encoding of operators because entailments of a set of core features of a state do not have to be explicitly included in application of the operator. In Soar, these inferences will be automatically retracted when the situation changes such that the inference no longer holds.</p> <p>For instance, our example blocks-world task uses an elaboration to keep track of whether or not a block is \"clear\". The elaboration tests for the absence of a block that is \"on top\" of a particular block; if there is no such \"on top\", the block is \"clear\". When an operator application creates a new \"on top\", the corresponding elaboration retracts, and the block is no longer \"clear\".</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#problem-spaces","title":"Problem Spaces","text":"<p>If we were to construct a Soar system that worked on a large number of different types of problems, we would need to include large numbers of operators in our Soar program. For a specific problem and a particular stage in problem solving, only a subset of all possible operators are actually relevant. For example, if our goal is to count the blocks on the table, operators having to do with moving blocks are probably not important, although they may still be \"legal\". The operators that are relevant to current problem-solving activity define the space of possible states that might be considered in solving a problem, that is, they define the problem space.</p> <p>Soar programs are implicitly organized in terms of problem spaces because the conditions for proposing operators will restrict an operator to be considered only when it is relevant. The complete problem space for the blocks world is shown in Figure 2.6. Typically, when</p> The problem space in the blocks-world includes all operators that move blocks from one location to another and all possible configurations of the three blocks. <p>Soar solves a problem in this problem space, it does not explicitly generate all of the states, examine them, and then create a path. Instead, Soar isin a specific state at a given time (represented in working memory), attempting to select an operator that will move it to a new state. It uses whatever knowledge it has about selecting operators given the current situation, and if its knowledge is sufficient, it will move toward its goal.</p> <p>The same problem could be recast in Soar as a planning problem, where the goal is to develop a plan to solve the problem, instead of just solving the problem. In that case, a state in Soar would consist of a plan, which in turn would have representations of blocks-world states and operators from the original space. The operators would perform editing operations on the plan, such as adding new blocks-world operators, simulating those operators, etc. In both formulations of the problem, Soar is still applying operators to generate new states, it is just that the states and operators have different content.</p> <p>The remaining sections in this chapter describe the memories and processes of Soar: work- ing memory, production memory, preference memory, Soar\u2019s execution cycle (the decision procedure), learning, and how input and output fit in.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#working-memory-the-current-situation","title":"Working memory: The Current Situation","text":"<p>Soar represents the current problem-solving situation in its working memory. Thus, working memory holds the current state and operator and is Soar\u2019s \"short-term\" knowledge, reflecting the current knowledge of the world and the status in problem solving.</p> <p>Working memory contains elements called working memory elements, or WMEs for short. Each WME contains a very specific piece of information; for example, a WME might say that \"B1 is a block\". Several WMEs collectively may provide more information about the same object, for example, \"B1 is a block\", \"B1 is named A\", \"B1 is on the table\", etc. These WMEs are related because they are all contributing to the description of something that is internally known to Soar as \"B1\". B1 is called an identifier; the group of WMEs that share this identifier are referred to as an object in working memory. Each WME describes a different attribute of the object, for example, its name or type or location; each attribute has a value associated with it, for example, the name is A, the type is block, and the position is on the table. Therefore, each WME is an identifier-attribute-value triple, and all WMEs with the same identifier are part of the same object.</p> <p>Objects in working memory are linked to other objects: The value of one WME may be an identifier of another object. For example, a WME might say that \"B1 is on top of T1\", and another collection of WMEs might describe the object T1: \"T1 is a table\", \"T1 is brown\", and \"T1 is on top of F1\". And still another collection of WMEs might describe the object F1: \"F1 is a floor\", etc. All objects in working memory must be linked to a state, either directly or indirectly (through other objects). Objects that are not linked to a state will be automatically removed from working memory by the Soar architecture.</p> <p>WMEs are also often called augmentations because they \"augment\" the object, providing more detail about it. While these two terms are somewhat redundant, WME is a term that is used more often to refer to the contents of working memory (as a single identifier-attribute-value triple), while augmentation is a term that is used more often to refer to the description of an object. Working memory is illustrated at an abstract level in Figure 2.3.</p> <p>The attribute of an augmentation is usually a constant, such as <code>name</code> or <code>type</code>, because in a sense, the attribute is just a label used to distinguish one link in working memory from another.<sup>2</sup></p> <p>The value of an augmentation may be either a constant, such as <code>red</code>, or an identifier, such as 06. When the value is an identifier, it refers to an object in working memory that may have additional substructure. In semantic net terms, if a value is a constant, then it is a terminal node with no links; if it is an identifier it is a non terminal node.</p> <p>One key concept of Soar is that working memory is a set, which means that there can never be two elements in working memory at the same time that have the same identifier-attribute- value triple (this is prevented by the architecture). However, it is possible to have multiple working memory elements that have the same identifier and attribute, but that each have different values. When this happens, we say the attribute is a multi-valued attribute, which is often shortened to be multi-attribute.</p> <p>An object is defined by its augmentations and not by its identifier. An identifier is simply a label or pointer to the object. On subsequent runs of the same Soar program, there may be an object with exactly the same augmentations, but a different identifier, and the program will still reason about the object appropriately. Identifiers are internal markers for Soar; they can appear in working memory, but they never appear in a production.</p> <p>There is no predefined relationship between objects in working memory and \"real objects\" in the outside world. Objects in working memory may refer to real objects, such as block A; features of an object, such as the color red or shape cube; a relation between objects, such as on top; classes of objects, such as blocks; etc. The actual names of attributes and values have no meaning to the Soar architecture (aside from a few WMEs created by the architecture itself). For example, Soar doesn\u2019t care whether the things in the blocks world are called \"blocks\" or \"cubes\" or \"chandeliers\". It is up to the Soar programmer to pick suitable labels and to use them consistently.</p> <p>The elements in working memory arise from one of four sources:</p> <ol> <li>Productions: The actions on the RHS of productions create most working memory    elements.</li> <li>Architecture:<ul> <li>(a) State augmentations: The decision procedure automatically creates some special   state augmentations (type, superstate, impasse, ...) whenever a state is created.   States are created during initialization (the first state) or because of an impasse   (a substate).</li> <li>(b) Operator augmentations: The decision procedure creates the operator   augmentation of the state based on preferences. This records the selection of   the current operator.</li> </ul> </li> <li>Memory Systems </li> <li>SVS</li> <li>The Environment: External I/O systems create working memory elements on the    input-link for sensory data.</li> </ol> <p>The elements in working memory are removed in six different ways:</p> <ol> <li>The decision procedure automatically removes all state augmentations it creates when    the impasse that led to their creation is resolved.</li> <li>The decision procedure removes the operator augmentation of the state when that    operator is no longer selected as the current operator.</li> <li>Production actions that user <code>reject</code> preferences remove working memory elements that    were created by other productions.</li> <li>The architecture automatically removes i-supported WMEs when the productions that    created them no longer match.</li> <li>The I/O system removes sensory data from the input-link when it is no longer valid.</li> <li>The architecture automatically removes WMEs that are no longer linked to a state    (because some other WME has been removed).</li> </ol> <p>For the most part, the user is free to use any attributes and values that are appropriate for the task. However, states have special augmentations that cannot be directly created, removed, or modified by rules. These include the augmentations created when a state is created, and the state\u2019s operator augmentation that signifies the current operator (and is created based on preferences). The specific attributes that the Soar architecture automatically creates are listed in Impasses in Working Memory and in Production. Productions may create any other attributes for states.</p> <p>Preferences are held in a separate preference memory where they cannot be tested by productions. There is one notable exception. Since a soar program may need to reason about candidate operators,acceptable preferences are made available in working memory as well.  The <code>acceptable</code> preferences can then be tested by productions, which allows a Soar program to reason about candidates operators to determine which one should be selected. Preference memory and the different types of preferences will be discussed in Section Preference Memory: Selection Knowledge.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#production-memory-long-term-procedural-knowledge","title":"Production Memory: Long-term Procedural Knowledge","text":"<p>Soar represents long-term procedural knowledge as productions that are stored in production memory, illustrated in Figure 2.7. Each production has a set of conditions and a set of actions. If the conditions of a production match working memory, the production fires, and the actions are performed.</p> An abstract view of production memory. The productions are not related to one another."},{"location":"soar_manual/02_TheSoarArchitecture/#the-structure-of-a-production","title":"The structure of a production","text":"<p>In the simplest form of a production, conditions and actions refer directly to the presence (or absence) of objects in working memory. For example, a production might say:</p> <pre><code>CONDITIONS: block A is clear\n            block B is clear\nACTIONS:    suggest an operator to move block A ontop of block B\n</code></pre> <p>This is not the literal syntax of productions, but a simplification. The actual syntax is presented in Chapter 3.</p> <p>The conditions of a production may also specify the absence of patterns in working memory. For example, the conditions could also specify that \"block A is not red\" or \"there are no red blocks on the table\". But since these are not needed for our example production, there are no examples of negated conditions for now.</p> <p>The order of the conditions of a production do not matter to Soar except that the first condition must directly test the state. Internally, Soar will reorder the conditions so that the matching process can be more efficient. This is a mechanical detail that need not concern most users. However, you may print your productions to the screen or save them in a file; if they are not in the order that you expected them to be, it is likely that the conditions have been reordered by Soar.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#variables-in-productions-and-multiple-instantiations","title":"Variables in productions and multiple instantiations","text":"<p>In the example production above, the names of the blocks are \"hardcoded\", that is, they are named specifically. In Soar productions, variables are used so that a production can apply to a wider range of situations.</p> <p>When variables are bound to specific symbols in working memory elements by Soar\u2019s match- ing process, Soar creates an instantiation of the production. This instantiation consists of the matched production along with a specific and consistent set of symbols that matched the variables. A production instantiation is consistent only if every occurrence of a variable is bound to the same value. Multiple instantiations of the same production can be created since the same production may match multiple times, each with different variable bindings. If blocks A and B are clear, the first production (without variables) will suggest one operator. However, consider a new proposal production that used variables to test the names of the block. Such a production will be instantiated twice and therefore suggest two operators: one operator to move block A on top of block B and a second operator to move block B on top of block A.</p> <p>Because the identifiers of objects are determined at runtime, literal identifiers cannot appear in productions. Since identifiers occur in every working memory element, variables must be used to test for identifiers, and using the same variables across multiple occurrences is what links conditions together.</p> <p>Just as the elements of working memory must be linked to a state in working memory, so must the objects referred to in a production\u2019s conditions. That is, one condition must test a state object and all other conditions must test that same state or objects that are linked to that state.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#architectural-roles-of-productions","title":"Architectural roles of productions","text":"<p>Soar productions can fulfill the following four roles, by retrieving  different types of procedural knowledge:</p> <ol> <li>Operator proposal</li> <li>Operator comparison</li> <li>Operator application</li> <li>State elaboration</li> </ol> <p>A single production should not fulfill more than one of these roles (except for proposing an operator and creating an absolute preference for it). Although productions are not declared to be of one type or the other, Soar examines the structure of each production and classifies the rules automatically based on whether they propose and compare operators, apply operators, or elaborate the state.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#production-actions-and-persistence","title":"Production Actions and Persistence","text":"<p>Generally, actions of a production either create preferences for operator selection, or cre- ate/remove working memory elements. For operator proposal and comparison, a production creates preferences for operator selection. These preferences should persist only as long as the production instantiation that created them continues to match. When the production instantiation no longer matches, the situation has changed, making the preference no longer relevant. Soar automatically removes the preferences in such cases. These preferences are said to have i-support (for \"instantiation support\"). Similarly, state elaborations are simple inferences that are valid only so long as the production matches. Working memory elements created as state elaborations also have i-support and remain in working memory only as long as the production instantiation that created them continues to match working memory. For example, the set of relevant operators changes as the state changes, thus the proposal of operators is done with i-supported preferences. This way, the operator proposals will be retracted when they no longer apply to the current situation.</p> <p>However, the actions of productions that apply an operator, either by adding or removing elements from working memory, persist regardless of whether the operator is still selected or the operator application production instantiation still matches. For example, in placing a block on another block, a condition is that the second block be clear. However, the action of placing the first block removes the fact that the second block is clear, so the condition will no longer be satisfied.</p> <p>Thus, operator application productions do not retract their actions, even if they no longer match working memory. This is called o-support (for \"operator support\"). Working memory elements that participate in the application of operators are maintained throughout the existence of the state in which the operator is applied, unless explicitly removed (or if they become unlinked). Working memory elements are removed by a reject action of a operator- application rule.</p> <p>Whether a working memory element receives o-support or i-support is determined by the structure of the production instantiation that creates the working memory element. O-support is given only to working memory elements created by operator-application productions in the state where the operator was selected.</p> <p>An operator-application production tests the current operator of a state and modifies the state. Thus, a working memory element receives o-support if it is for an augmentation of the current state or substructure of the state, and the conditions of the instantiation that created it test augmentations of the current operator.</p> <p>During productions matching, all productions that have their conditions met fire, creating preferences which may add or remove working memory elements. Also, working memory elements and preferences that lose i-support are removed from working memory. Thus, several new working memory elements and preferences may be created, and several existing working memory elements and preferences may be removed at the same time. (Of course, all this doesn\u2019t happen literally at the same time, but the order of firings and retractions is unimportant, and happens in parallel from a functional perspective.)</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#preference-memory-selection-knowledge","title":"Preference Memory: Selection Knowledge","text":"<p>The selection of the current operator is determined by the preferences in preference memory. Preferences are suggestions or imperatives about the current operator, or information about how suggested operators compare to other operators. Preferences refer to operators by using the identifier of a working memory element that stands for the operator. After preferences have been created for a state, the decision procedure evaluates them to select the current operator for that state.</p> <p>For an operator to be selected, there will be at least one preference for it, specifically, a preference to say that the value is a candidate for the operator attribute of a state (this is done with either an  <code>\"acceptable</code> or <code>\"require\"</code> preference). There may also be others, for example to say that the value is \"best\".</p> <p>Preferences remain in preference memory until removed for one of the reasons previously discussed in Production Actions and Persistence.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#preference-semantics","title":"Preference Semantics","text":"<p>This section describes the semantics of each type of preference. More details on the preference resolution process are provided in How preferences are evaluated to decide an operator.</p> <p>Only a single value can be selected as the current operator, that is, all values are mutually exclusive. In addition, there is no implicit transitivity in the semantics of preferences. If A is indifferent to B, and B is indifferent to C, A and C will not be indifferent to one another unless there is a preference that A is indifferent to C (or C and A are both indifferent to all competing values).</p> <ul> <li> <p>Acceptable (+) An <code>acceptable</code> preference states that a value is a candidate for selection. All values, except those with require preferences, must have an <code>acceptable</code> preference in order to be selected. If there is only one value with an <code>acceptable</code> preference (and none with a require preference), that value will be selected as long as it does not also have a reject or a prohibit preference.</p> </li> <li> <p>Reject (-) A <code>reject</code> preference states that the value is not a candidate for selection.</p> </li> <li> <p>Better (<code>&gt;value</code>), Worse (<code>&lt;value</code>) A <code>better</code> or <code>worse</code> preference states, for the two values involved, that one value should not be selected if the other value is a candidate. <code>Better</code> and <code>worse</code> allow for the creation of a partial ordering between candidate values. <code>Better</code> and <code>worse</code> are simple inverses of each other, so that A better than B is equivalent to be worse than A.</p> </li> <li> <p>Best (&gt;) A <code>best</code> preference states that the value may be better than any competing value (unless there are other competing values that are also \"best\"). If a value is <code>best</code> (and not <code>rejected</code>, <code>prohibited</code>, or worse than another), it will be selected over any other value that is not also <code>best</code> (or required). If two such values are <code>best</code>, then any remaining preferences for those candidates (worst,indifferent) will be examined to determine the selection. Note that if a value (that is not <code>rejected</code> or <code>prohibited</code>) is better than a <code>best</code> value, the better value will be selected. (This result is counter- intuitive, but allows explicit knowledge about the relative worth of two values to dominate knowledge of only a single value. A require preference should be used when a value must be selected for the goal to be achieved.)</p> </li> <li> <p>Worst (&lt;) A <code>worst</code> preference states that the value should be selected only if there are no alternatives. It allows for a simple type of default specification. The semantics of the worst preference are similar to those for the <code>best</code> preference.</p> </li> <li> <p>Unary Indifferent (=) A <code>unary indifferent</code> preference states that there is positive knowledge that a single value is as good or as bad a choice as other expected alternatives.  When two or more competing values both have indifferent preferences, by default, Soar chooses randomly from among the alternatives. (The <code>decide indifferent-selection</code> function can be used to change this behavior).</p> </li> <li> <p>Binary Indifferent (=value) A <code>binary indifferent</code> preference states that two values are mutually indifferent and it does not matter which of these values are selected. It behaves like a unary in different preference, except that the operator value given this preference is only made indifferent to the operator value given as the argument.</p> </li> <li> <p>Numeric-Indifferent (=number) A <code>numeric-indifferent</code> preference is used to bias the random selection from mutually indifferent values. This preference includes a unary indifferent preference, and behaves in that manner when competing with another value having a unary indifferent preference. But when a set of competing operator values have <code>numeric-indifferent</code> preferences, the decision mechanism will choose an operator based on their numeric-indifferent values and the exploration policy. The available exploration policies and how they calculate selection probability are detailed in the documentation for the indifferent-selection command. When a single operator is given multiple <code>numeric-indifferent</code> preferences, they are either averaged or summed into a single value based on the setting of the <code>numeric-indifferent-mode</code> command. Numeric-indifferent preferences that are created by RL rules can be adjusted by the reinforcement learning mechanism. In this way, it\u2019s possible for an agent to begin a task with only arbitrarily initialized numeric indifferent preferences and with experience learn to make the optimal decisions.  See chapter 5 for more information.</p> </li> <li> <p>Require (!) A <code>require</code> preference states that the value must be selected if the goal is to be achieved. A <code>required</code> value is preferred over all others. Only a single operator value should be given a <code>require</code> preference at a time.</p> </li> <li> <p>Prohibit (~) A <code>prohibit</code> preference states that the value cannot be selected if the goal is to be achieved. If a value has a prohibit preference, it will not be selected for a value of an augmentation, independent of the other preferences.</p> </li> </ul> <p>If there is an <code>acceptable</code> preference for a value of an operator, and there are no other competing values, that operator will be selected. If there are multiple <code>acceptable</code> preferences for the same state but with different values, the preferences must be evaluated to determine which candidate is selected.</p> <p>If the preferences can be evaluated without conflict, the appropriate operator augmentation of the state will be added to working memory. This can happen when they all suggest the same operator or when one operator is preferable to the others that have been suggested. When the preferences conflict, Soar reaches an impasse, as described in Impasses and Substates.</p> <p>Preferences can be confusing; for example, there can be two suggested values that are both \"best\" (which again will lead to an impasse unless additional preferences resolve this conflict); or there may be one preference to say that value A is better than valueB and a second preference to say that value B is better than valueA.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#how-preferences-are-evaluated-to-decide-an-operator","title":"How preferences are evaluated to decide an operator","text":"<p>During the decision phase, operator preferences are evaluated in a sequence of eight steps, in an effort to select a single operator. Each step handles a specific type of preference, as illustrated in Figure 2.8. (The figure should be read starting at the top where all the operator preferences are collected and passed into the procedure. At each step, the procedure either exits through a arrow to the right, or passes to the next step through an arrow to the left.)</p> <p>Input to the procedure is the set of current operator preferences, and the output consists of:</p> <ol> <li>A subset of the candidate operators, which is either the empty set, a single, winning    candidate, or a larger set of candidates that may be conflicting, tied, or indifferent.</li> <li>An impasse-type.</li> </ol> <p>The procedure has several potential exit points. Some occur when the procedure has detected a particular type of impasse. The others occur when the number of candidates has been reduced to one (necessarily the winner) or zero (a no-change impasse).</p> image/svg+xml RequireTest AcceptableCollect ProhibitFilter RejectFilter BetterWorseFilter BestFilter WorstFilter IndifferentTest All operatorpreferences else all acceptablecandidates arepassed on all nonprohibitedcandidates arepassed on all nonrejectedcandidates arepassed on pass along onlycandidates thatare not worse pass along onlycandidates that arebest; if none, passon all candidates all nonworstcandidates arepassed on one required operator multiple required operators require is also prohibited one candidate remaining no candidates remaining all candidates areworse than another remining candidates areALL mutually indifferent remaining candidates are NOT mutually indifferent one candidate remaining no candidates remaining Outcome ofpreferenceresolution winner returned constraintfailureimpasse winner returned none selected(no-change impasse) conflict impasse winner returned winner will bechosen based onuserselect setting tie impasse none selected(no-change impasse) } Preference resolution: -all operator preferences are input to the resolution procedure -each step may add or remove some operator candidates -only some steps may exit An illustration of the preference resolution process. There are eight steps; only five of these provide exits from the resolution process. <p>Each step in Figure 2.8 is described below:</p> <ul> <li> <p>RequireTest (!) This test checks for required candidates in preference memory and also constraint-failure impasses involving require preferences, cf. Impasses and Substates.</p> <ul> <li>If there is exactly one candidate operator with a require preference and that   candidate does not have a prohibit preference, then that candidate is the winner   and preference semantics terminates.</li> <li>Otherwise \u2014 If there is more than one required candidate, then a constraint-   failure impasse is recognized and preference semantics terminates by returning   the set of required candidates.</li> <li>Otherwise \u2014 If there is a required candidate that is also prohibited, a constraint-   failure impasse with the required/prohibited value is recognized and preference   semantics terminates.</li> <li>Otherwise \u2014 There is no required candidate; candidates are passed to AcceptableCollect.</li> </ul> </li> <li> <p>AcceptableCollect (+) This operation builds a list of operators for which there is an acceptable preference in preference memory. This list of candidate operators is passed to the ProhibitFilter.</p> </li> <li> <p>ProhibitFilter (~) This filter removes the candidates that have prohibit preferences in memory. The rest of the candidates are passed to the RejectFilter.</p> </li> <li> <p>RejectFilter (-) This filter removes the candidates that have reject preferences in mem- ory.</p> </li> <li> <p>Exit Point 1:</p> <ul> <li>At this point, if the set of remaining candidates is empty, a no-change impasse is   created with no operators being selected.</li> <li>If the set has one member, preference semantics terminates and this set is re-   turned.</li> <li>Otherwise, the remaining candidates are passed to the BetterWorseFilter.</li> </ul> </li> <li> <p>BetterWorseFilter (&gt;), (&lt;) This filter removes any candidates that are worse than an- other candidate.</p> </li> <li> <p>Exit point 2:  </p> <ul> <li>If the set of remaining candidates is empty, a conflict impasse is created returning   the set of all candidates passed into this filter, i.e. all of the conflicted operators.</li> <li>If the set of remaining candidates has one member, preference semantics terminates and this set is returned.</li> <li>Otherwise, the remaining candidates are passed to the BestFilter.</li> </ul> </li> <li> <p>BestFilter (&gt;) If some remaining candidate has a best preference, this filter removes any candidates that do not have a best preference. If there are no best preferences for any of the current candidates, the filter has no effect. The remaining candidates are passed to the WorstFilter.</p> </li> <li> <p>Exit Point 3:</p> <ul> <li>At this point, if the set of remaining candidates is empty, a no-change impasse is   created with no operators being selected.</li> <li>If the set has one member, preference semantics terminates and this set is re-   turned.</li> <li>Otherwise, the remaining candidates are passed to the WorstFilter.</li> </ul> </li> <li> <p>WorstFilter (&lt;) This filter removes any candidates that have a <code>worst</code> preference. If all    remaining candidates have <code>worst</code> preferences or there are no <code>worst</code> preferences, this    filter has no effect.</p> </li> <li> <p>Exit Point 4:</p> <ul> <li>At this point, if the set of remaining candidates is empty, a no-change impasse is   created with no operators being selected.</li> <li>If the set has one member, preference semantics terminates and this set is re-   turned.</li> <li>Otherwise, the remaining candidates are passed to the IndifferentFilter.</li> </ul> </li> <li> <p>IndifferentFilter (=) This operation traverses the remaining candidates and marks each    candidate for which one of the following is true:</p> <ul> <li>the candidate has a unary indifferent preference</li> <li>the candidate has a numeric indifferent preference</li> </ul> </li> </ul> <p>This filter then checks every candidate that is not one of the above two types to see if it has a binary indifferent preference with every other candidate. If one of the candidates fails this test, then the procedure signals a tie impasse and returns the complete set of candidates that were passed into the IndifferentFilter. Otherwise, the candidates are mutually indifferent, in which case an operator is chosen according to the method set by the <code>decide indifferent-selection</code> command.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#soars-execution-cycle-without-substates","title":"Soar\u2019s Execution Cycle: Without Substates","text":"<p>The execution of a Soar program proceeds through a number of decision cycles. Each cycle has five phases:</p> <ol> <li>Input: New sensory data comes into working memory.</li> <li>Proposal: Productions fire (and retract) to interpret new data (state    elaboration), propose operators for the current situation (operator proposal),    and compare proposed operators (operator comparison). All of the actions of    these productions are i-supported. All matched productions fire in parallel (and    all retractions occur in parallel), and matching and firing continues until    there are no more additional complete matches or retractions of productions    (quiescence).</li> <li>Decision: A new operator is selected, or an impasse is detected and a new state is    created.</li> <li>Application: Productions fire to apply the operator (operator application).    The actions of these productions will be o-supported. Because of changes from    operator application productions, other productions with i-supported actions may    also match or retract. Just as during proposal, productions fire and retract in    parallel until quiescence.</li> <li>Output: Output commands are sent to the external environment.</li> </ol> <p>The cycles continue until the halt action is issued from the Soar program (as the action of a production) or until Soar is interrupted by the user.</p> <p>An important aspect of productions in Soar to keep in mind is that all productions will always fire whenever their conditions are met, and retract whenever their conditions are no longer met. The exact details of this process are shown in Figure 2.9. The Proposal and Application phases described above are both composed of as many elaboration cycles as are necessary to reach quiescence. In each elaboration cycle, all matching productions fire and the working memory changes or operator preferences described through their actions are made. After each elaboration cycle, if the working memory changes just made change the set of matching productions, another cycle ensues. This repeats until the set of matching rules remains unchanged, a situation called quiescence.</p> A detailed illustration of Soar\u2019s decision cycle. <p>After quiescence is reached in the Proposal phase, the Decision phase ensues, which is the architectural selection of a single operator, if possible. Once an operator is selected, the Apply phase ensues, which is practically the same as the Proposal phase, except that any productions that apply the chosen operator (they test for the selection of that operator in their conditions) will now match and fire.</p> <p>During the processing of these phases, it is possible that the preferences that resulted in the selection of the current operator could change. Whenever operator preferences change, the preferences are re-evaluated and if a different operator selection would be made, then the current operator augmentation of the state is immediately removed. However, a new operator is not selected until the next decision phase, when all knowledge has had a chance to be retrieved. In other words, if, during the Apply phase, the production(s) that proposed the selected operator retract, that Apply phase will immediately end.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#input-and-output","title":"Input and Output","text":"<p>Many Soar users will want their programs to interact with a real or simulated environment. For example, Soar programs may control a robot, receiving sensory inputs and sending command outputs. Soar programs may also interact with simulated environments, such as a flight simulator. Input is viewed as Soar\u2019s perception and output is viewed as Soar\u2019s motor abilities.</p> <p>When Soar interacts with an external environment, it must make use of mechanisms that allow it to receive input from that environment and to effect changes in that environment; the mechanisms provided in Soar are called input functions and output functions.</p> <ul> <li>Input functions add and delete elements from working memory in response to changes in the external environment.</li> <li>Output functions attempt to effect changes in the external environment.</li> </ul> <p>Input is processed at the beginning of each execution cycle and output occurs at the end of each execution cycle. See Soar I/O: Input and Output in Soar for more information.</p> <p>A simplified version of the Soar algorithm:  <pre><code>Soar\n   while (HALT not true) Cycle;\n\nCycle\n   InputPhase;\n   ProposalPhase;\n   DecisionPhase;\n   ApplicationPhase;\n   OutputPhase;\n\nProposalPhase\n   while (some i-supported productions are waiting to fire or retract)\n   FireNewlyMatchedProductions;\n   RetractNewlyUnmatchedProductions;\n\nDecisionPhase\n   for (each state in the stack,\n      starting with the top-level state)\n   until (a new decision is reached)\n      EvaluateOperatorPreferences; /_ for the state being considered _/\n      if (one operator preferred after preference evaluation)\n         SelectNewOperator;\n      else /_ could be no operator available or _/\n         CreateNewSubstate; /_ unable to decide between more than one _/\n\nApplicationPhase\n   while (some productions are waiting to fire or retract)\n      FireNewlyMatchedProductions;\n      RetractNewlyUnmatchedProductions;\n</code></pre></p>"},{"location":"soar_manual/02_TheSoarArchitecture/#impasses-and-substates","title":"Impasses and Substates","text":"<p>When the decision procedure is applied to evaluate preferences and determine the operator augmentation of the state, it is possible that the preferences are either incomplete or inconsistent. The preferences can be incomplete in that no acceptable operators are suggested, or that there are insufficient preferences to distinguish among <code>acceptable</code> operators. The preferences can be inconsistent if, for instance, operator A is preferred to operator B, and operator B is preferred to operator A. Since preferences are generated independently across different production instantiations, there is no guarantee that they will be consistent.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#impasse-types","title":"Impasse Types","text":"<p>There are four types of impasses that can arise from the preference scheme.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#tie-impasse","title":"Tie impasse","text":"<p>A tie impasse arises if the preferences do not distinguish between two or more operators that have <code>acceptable</code> preferences. If two operators both have best or worst preferences, they will tie unless additional preferences distinguish between them.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#conflict-impasse","title":"Conflict impasse","text":"<p>A conflict impasse arises if at least two values have conflicting better or worse preferences (such as A is better than B and B is better than A) for an operator, and neither one is rejected, prohibited, or required.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#constraint-failure-impasse","title":"Constraint-failure impasse","text":"<p>A constraint-failure impasse arises if there is more than one <code>required</code> value for an operator, or if a value has both a <code>require</code> and a <code>prohibit</code> preference. These preferences represent constraints on the legal selections that can be made for a decision and if they conflict, no progress can be made from the current situation and the impasse cannot be resolved by additional preferences.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#no-change-impasse","title":"No-change impasse","text":"<p>A no-change impasse arises if a new operator is not selected during the decision procedure. There are two types of no-change impasses: </p> <ul> <li> <p>A State no-change impasse occurs when there are no <code>acceptable</code> (or <code>require</code>) preferences to suggest operators for the current state (or all the <code>acceptable</code> values have also been rejected). The decision procedure cannot select a new operator.</p> </li> <li> <p>A Operator no-change impasse occurs when either a new operator is selected for the current state but no additional productions match during the application phase, or a new operator is not selected during the next decision phase.</p> </li> </ul> <p>There can be only one type of impasse at a given level of subgoaling at a time. Given the semantics of the preferences, it is possible to have a tie or conflict impasse and a constraint- failure impasse at the same time. In these cases, Soar detects only the constraint-failure impasse.</p> <p>The impasse is detected during the selection of the operator, but happens because one of the four problem-solving functions (described in  Problem-Solving function in Soar)  was incomplete.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#creating-new-states","title":"Creating New States","text":"<p>Soar handles these inconsistencies by creating a new state, called a substate in which the goal of the problem solving is to resolve the impasse. Thus, in the substate, operators will be selected and applied in an attempt either to discover which of the tied operators should be selected, or to apply the selected operator piece by piece. The substate is often called a subgoal because it exists to resolve the impasse, but is sometimes called a substate because the representation of the subgoal in Soar is as a state.</p> <p>The initial state in the subgoal contains a complete description of the cause of the impasse, such as the operators that could not be decided among (or that there were no operators proposed) and the state that the impasse arose in. From the perspective of the new state, the latter is called the <code>superstate</code>. Thus, the <code>superstate</code> is part of the substructure of each state, represented by the Soar architecture using the <code>superstate</code> attribute. (The initial state, created in the 0th decision cycle, contains a <code>superstate</code> attribute with the value of <code>nil</code> - the top-level state has no superstate.)</p> <p>The knowledge to resolve the impasse may be retrieved by any type of problem solving, from searching to discover the implications of different decisions, to asking an outside agent for advice. There is no a priori restriction on the processing, except that it involves applying operators to states.</p> <p>In the substate, operators can be selected and applied as Soar attempts to solve the sub- goal. (The operators proposed for solving the subgoal may be similar to the operators in the superstate, or they may be entirely different.) While problem solving in the subgoal, additional impasses may be encountered, leading to new subgoals. Thus, it is possible for Soar to have a stack of subgoals, represented as states: Each state has a single superstate (except the initial state) and each state may have at most one substate. Newly created subgoals are considered to be added to the bottom of the stack; the first state is therefore called the top-level state.<sup>3</sup> See Figure 2.11 for a simplified illustrations of a subgoal stack.</p> A simplified illustration of a subgoal stack. <p>Soar continually attempts to retrieve knowledge relevant to all goals in the subgoal stack, although problem-solving activity will tend to focus on the most recently created state. However, problem solving is active at all levels, and productions that match at any level will fire.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#results","title":"Results","text":"<p>In order to resolve impasses, subgoals must generate results that allow the problem solving at higher levels to proceed. The results of a subgoal are the working memory elements and preferences that were created in the substate, and that are also linked directly or indirectly to a superstate (any superstate in the stack). A preference or working memory element is said to be created in a state if the production that created it tested that state and this is the most recent state that the production tested. Thus, if a production tests multiple states, the preferences and working memory elements in its actions are considered to be created in the most recent of those states (the lowest-level state) and is not considered to have been created in the other states. The architecture automatically detects if a preference or working memory element created in a substate is also linked to a superstate.</p> <p>These working memory elements and preferences will not be removed when the impasse is resolved because they are still linked to a superstate, and therefore, they are called the results of the subgoal. A result has either i-support or o-support; the determination of support is described below.</p> <p>A working memory element or preference will be a result if its identifier is already linked to a superstate. A working memory element or preference can also become a result indirectly if, after it is created and it is still in working memory or preference memory, its identifier becomes linked to a superstate through the creation of another result. For example, if the problem solving in a state constructs an operator for a superstate, it may wait until the operator structure is complete before creating an <code>acceptable</code> preference for the operator in the superstate. The <code>acceptable</code> preference is a result because it was created in the state and is linked to the superstate (and, through the superstate, is linked to the top-level state). The substructures of the operator then become results because the operator\u2019s identifier is now linked to the superstate.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#justifications-support-for-results","title":"Justifications: Support for results","text":"<p>Recall from section Production Actions and Persistance that WMEs with i-support disappear as soon as the production that created them retract,<sup>4</sup> whereas WMEs with o-support (created through applying an operator) persist in working memory until deliberately removed.</p> <p>Some results receive i-support, while others receive o-support. The type of support received by a result is determined by the function it plays in the superstate, and not the function it played in the state in which it was created. For example, a result might be created through operator application in the state that created it; however, it might only be a state elaboration in the superstate. The first function would lead to o-support, but the second would lead to i-support.</p> <p>In order for the architecture to determine whether a result receives i-support or o-support, Soar must first determine the function that the working memory element or preference plays (that is, whether the result should be considered an operator application or not). To do this, Soar creates a temporary production, called a justification. The justification summarizes the processing in the substate that led to the result:</p> <ul> <li> <p>The conditions of a justification are those working memory elements that exist in the superstate (and above) that were necessary for producing the result. This is determined by collecting all of the working memory elements tested by the productions that fired in the subgoal that led to the creation of the result, and then removing those conditions that test working memory elements created in the subgoal.</p> </li> <li> <p>The action of the justification is the result of the subgoal.</p> </li> </ul> <p>Thus, when the substate disappears, the generated justification serves as the production that supports any subgoal results.</p> <p>Soar determines i-support or o-support for the justification and its actions just as it would for any other production, as described in section Production Actions and Persistence.  If the justification is an operator application, the result will receive o-support. Otherwise, the result gets i-support from the justification. If such a result loses i-support from the justification, it will be retracted if there is no other support.</p> <p>Justifications include any negated conditions that were in the original productions that participated in producing the results, and that test for the absence of superstate working memory elements. Negated conditions that test for the absence of working memory elements that are local to the substate are not included, which can lead to overgeneralization in the justification (see Sections Operational Analysis and Collapsed Negative Reasoning for details).</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#chunking-learning-procedural-knowledge","title":"Chunking: Learning Procedural Knowledge","text":"<p>When an operator impasse is resolved, it means that Soar has, through problem solving, gained access to knowledge that was not readily available before. Therefore, when an impasse is resolved, Soar has an opportunity to learn, by summarizing and generalizing the processing in the substate.</p> <p>One of Soar\u2019s learning mechanisms is called chunking (See chapter 4 for more information); it attempts to create a new production, called a chunk. The conditions of the chunk are the elements of the state that (through some chain of production firings) allowed the impasse to be resolved; the action of the production is the working memory element or preference that resolved the impasse (the result of the impasse). The conditions and action are variablized so that this new production may match in a similar situation in the future and prevent an impasse from arising.</p> <p>Chunks and justifications are very similar in that they both summarize substate results. They are, in fact, generated by the architecture using the same result dependency trace mechanisms. However, there are some important distinctions:</p> <ol> <li>Justifications disappear as soon as its conditions no longer match.</li> <li>Chunks contain variables so that they may match working memory in other situations;    justifications are similar to an instantiated chunk.</li> </ol> <p>In other words, a chunk might be thought of as a permanent and potentially more generalized form of a justification. Since the result that solves the impasse problem is learned in a chunk, whenever the agent encounters the same situation again as that which resulted in the original impasse, it can simply fire the chunk to generate the same result previously derived, preempting the need for a substate and repeated deliberate problem solving.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#the-calculation-of-o-support","title":"The calculation of o-support","text":"<p>This section provides a more detailed description of when an action is given o-support by an instantiation.<sup>5</sup> The content here is somewhat more advanced, and the reader unfamiliar with rule syntax (explained in Chapter 3) may wish to skip this section and return at a later point.</p> <p>Support is given by the production; that is, all working memory changes generated by the actions of a single instantiated production will have the same support (an action that is not given o-support will have i-support). The conditions and actions of a production rule will here be referred to using the shorthand of LHS and RHS (for Left-Hand Side and Right-Hand Side), respectively.</p> <p>A production must meet the following two requirements to have o-supported actions:</p> <ol> <li> <p>The RHS has no operator proposals, i.e. nothing of the form    <pre><code>(&lt;s&gt; ^operator &lt;o&gt; +)\n</code></pre></p> </li> <li> <p>The LHS has a condition that tests the current operator, i.e. something of the form    <pre><code>(&lt;s&gt; ^operator &lt;o&gt;)\n</code></pre></p> </li> </ol> <p>In condition 1, the variable <code>&lt;s&gt;</code> must be bound to a state identifier. In condition 2, the variable <code>&lt;s&gt;</code> must be bound to the lowest state identifier. That is to say, each (positive) condition on the LHS takes the form <code>(id ^attr value)</code>, some of these id\u2019s match state identifiers, and the system looks for the deepest matched state identifier. The tested current operator must be on this state. For example, in this production,</p> <pre><code>sp {elaborate*state*operator\\*name\n   (state &lt;s&gt; ^superstate &lt;s1&gt;)\n   (&lt;s1&gt; ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name &lt;name&gt;)\n   --&gt;\n   (&lt;s&gt; ^name something)}\n</code></pre> <p>the RHS action gets i-support. Of course, the state bound to <code>&lt;s&gt;</code> is destroyed when  <code>(&lt;s1&gt; ^operator &lt;o&gt;)</code> retracts, so o-support would make little difference. On the other hand, this production,</p> <pre><code>   sp {operator*superstate*application\n   (state &lt;s&gt; ^superstate &lt;s1&gt;)\n              ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name &lt;name&gt;)\n   --&gt;\n   (&lt;s1&gt; ^sub-operator-name &lt;name&gt;)}\n</code></pre> <p>gives o-support to its RHS action, which remains after the substate bound to <code>&lt;s&gt;</code> is destroyed.</p> <p>An extension of condition 1 is that operator augmentations should always receive i-support (augmentations define the proposed operator). Soar has been written to recognize augmentations directly off the operator (ie, <code>(&lt;o&gt; ^augmentation value)</code>), and to attempt to give them i-support. However, what should be done about a production that simultaneously tests an operator, doesn\u2019t propose an operator, adds an operator augmentation, and adds a non-operator augmentation?</p> <p>For example:</p> <pre><code>sp {operator*augmentation*application\n   (state &lt;s&gt; ^task test-support\n              ^operator &lt;o&gt;)\n   --&gt;\n   (&lt;o&gt; ^new augmentation)\n   (&lt;s&gt; ^new augmentation)}\n</code></pre> <p>In such cases, both receive i-support. Soar will print a warning on firing this production, because this is considered bad coding style.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#removal-of-substates-impasse-resolution","title":"Removal of Substates: Impasse Resolution","text":"<p>Problem solving in substates is an important part of what Soar does, and an operator impasse does not necessarily indicate a problem in the Soar program. They are a way to decompose a complex problem into smaller parts and they provide a context for a program to deliberate about which operator to select. Operator impasses are necessary, for example, for Soar to do any learning about problem solving (as will be discussed in Chapter 4). This section describes how impasses may be resolved during the execution of a Soar program, how they may be eliminated during execution without being resolved, and some tips on how to modify a Soar program to prevent a specific impasse from occurring in the first place.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#resolving-impasses","title":"Resolving Impasses","text":"<p>An impasse is resolved when processing in a subgoal creates results that lead to the selection of a new operator for the state where the impasse arose. When an operator impasse is resolved, Soar has an opportunity to learn, and the substate (and all its substructure) is removed from working memory.</p> <p>Here are possible approaches for resolving specific types of impasses are listed below:</p> <ul> <li> <p>Tie impasse \u2014 A tie impasse can be resolved by productions that create preferences that prefer one option (<code>better</code>, <code>best</code>, <code>require</code>), eliminate alternatives (<code>worse</code>, <code>worst</code>, <code>reject</code>,<code>prohibit</code>), or make all of the objects indifferent (<code>indifferent</code>).</p> </li> <li> <p>Conflict impasse \u2014 A conflict impasse can be resolved by productions that create preferences to require one option (<code>require</code>), or eliminate the alternatives (<code>reject</code>, <code>prohibit</code>).</p> </li> <li> <p>Constraint-failure impasse \u2014 A constraint-failure impasse cannot be resolved by additional preferences, but may be prevented by changing productions so that they create fewer <code>require</code> or <code>prohibit</code> preferences. A substate can resolve a constraint-failure impasse through actions that cause all but one of the conflicting preferences to retract.</p> </li> <li> <p>State no-change impasse \u2014 A state no-change impasse can be resolved by productions that create <code>acceptable</code> or <code>require</code> preferences for operators.</p> </li> <li> <p>Operator no-change impasse \u2014 An operator no-change impasse can be resolved by productions that apply the operator, change the state so the operator proposal no longer matches, or cause other operators to be proposed and preferred.</p> </li> </ul>"},{"location":"soar_manual/02_TheSoarArchitecture/#eliminating-impasses","title":"Eliminating Impasses","text":"<p>An impasse is resolved when results are created that allow progress to be made in the state where the impasse arose. In Soar, an impasse can be eliminated (but not resolved) when a higher level impasse is resolved, eliminated, or regenerated. In these cases, the impasse becomes irrelevant because higher-level processing can proceed. An impasse can also become irrelevant if input from the outside world changes working memory which in turn causes productions to fire that make it possible to select an operator. In these cases, the impasse is eliminated, but not \"resolved\", and Soar does not learn in this situation.</p> <p>For example, in the blocks-world domain, an agent might deliberate in a substate to deter- mine whether it should move block A onto block C or block B onto block C in its current situation. If a child suddenly throws block A out a window, this problem solving becomes irrelevant, and the impasse is eliminated.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#regenerating-impasses","title":"Regenerating Impasses","text":"<p>An impasse is regenerated when the problem solving in the subgoal becomes inconsistent with the current situation. During problem solving in a subgoal, Soar monitors which aspect of the surrounding situation (the working memory elements that exist in superstates) the problem solving in the subgoal has depended upon. If those aspects of the surrounding situation change, either because of changes in input or because of results, the problem solving in the subgoal is inconsistent, and the state created in response to the original impasse is removed and a new state is created. Problem solving will now continue from this new state. The impasse is not \"resolved\", and Soar does not learn in this situation.</p> <p>The reason for regeneration is to guarantee that the working memory elements and preferences created in a substate are consistent with higher level states. As stated above, inconsistency can arise when a higher level state changes either as a result of changes in what is sensed in the external environment, or from results produced in the subgoal. The problem with inconsistency is that once inconsistency arises, the problem being solved in the subgoal may no longer be the problem that actually needs to be solved. Luckily, not all changes to a superstate lead to inconsistency.</p> <p>In order to detect inconsistencies, Soar maintains a Goal Dependency Set (GDS) for every subgoal/substate. The dependency set consists of all working memory elements that were tested in the conditions of productions that created o-supported working memory elements that are directly or indirectly linked to the substate (in other words, any superstate knowledge used to derive persistent substate knowledge). Whenever such an o-supported WME is created, Soar records which superstate WMEs were tested, directly or indirectly, to create it. Whenever any of the WMEs in the dependency set of a substate change, the substate is regenerated. (See Sections print  and trace for how to examine GDS information through the user-interface.)</p> <p>Note that the creation of i-supported structures in a subgoal does not increase the dependency set, nor do o-supported results. Thus, only subgoals that involve the creation of internal o-support working memory elements risk regeneration, and then only when the basis for the creation of those elements changes.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#substate-removal","title":"Substate Removal","text":"<p>Whenever a substate is removed, all working memory elements and preferences that were created in the substate that are not results are removed from working memory. In Figure 2.11, state <code>S3</code> will be removed from working memory when the impasse that created it is resolved, that is, when sufficient preferences have been generated so that one of the operators for state <code>S2</code> can be selected. When state <code>S3</code> is removed, operator <code>O9</code> will also be removed, as will the <code>acceptable</code> preferences for <code>O7</code>, <code>O8</code>, and <code>O9</code>, and the <code>impasse</code>, <code>attribute</code>, and <code>choices</code> augmentations of state <code>S3</code>. These working memory elements are removed because they are no longer linked to the subgoal stack. The <code>acceptable</code> preferences for operators <code>O4</code>, <code>O5</code>, and <code>O6</code> remain in working memory. They were linked to state <code>S3</code>, but since they are also linked to state <code>S2</code>, they will stay in working memory until <code>S2</code> is removed (or until they are retracted or rejected).</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#soars-cycle-with-substates","title":"Soar\u2019s Cycle: With Substates","text":"<p>When there are multiple substates, Soar\u2019s cycle remains basically the same but has a few minor changes.</p> <p>The main change when there are multiple substates is that at each phase of the decision cycle, Soar goes through the substates, from oldest (highest) to newest (lowest), completing any necessary processing at that level for that phase before doing any processing in the next substate. When firing productions for the proposal or application phases, Soar processes the firing (and retraction) of rules, starting from those matching the oldest substate to the newest. Whenever a production fires or retracts, changes are made to working memory and preference memory, possibly changing which productions will match at the lower levels (productions firing within a given level are fired in parallel \u2013 simulated). Productions firings at higher levels can resolve impasses and thus eliminate lower states before the productions at the lower level ever fire. Thus, whenever a level in the state stack is reached, all production activity is guaranteed to be consistent with any processing that has occurred at higher levels.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#removal-of-substates-the-goal-dependency-set","title":"Removal of Substates: The Goal Dependency Set","text":"<p>This subsection describes the Goal Dependency Set (GDS) with discussions on the motivation for the GDS and behavioral consequences of the GDS from a developer/modeler\u2019s point of view. It goes into greater detail than might be beneficial for someone becoming familiar with the general operation of Soar for the first time. Readers may skip this section and return later if desired.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#why-the-gds-was-needed","title":"Why the GDS was needed","text":"<p>As a symbol system, Soar attempts to approximate a true knowledge level but will necessarily always fall short. We can informally think of the way in which Soar falls short as its peculiar \"psychology.\" Those interested in using Soar to model human cognition would like Soar\u2019s psychology to approximate human psychology. Those using Soar to create agent systems would like to make Soar\u2019s processing approximate the knowledge level as closely as possible. Soar 7 had a number of symbol-level quirks that appeared inconsistent with human psychology and that made building large-scale, knowledge-based systems in Soar more difficult than necessary. Bob Wray\u2019s thesis <sup>6</sup> addressed many of these symbol-level problems in Soar, among them logical inconsistency in symbol manipulations, non-contemporaneous constraints in chunks , race conditions in rule firings and in the decision process, and contention between original task knowledge and learned knowledge.</p> <p>The Goal Dependency Set implements a solution to logical inconsistencies between persis- tent (o-supported) WMEs in a substate and its \"context\". The context consists of all the WMEs in any superstates above the local goal/state.<sup>7</sup> In Soar, any action (application) of an operator receives an o-support preference. This preference makes the resulting WME persistent: it will remain in memory until explicitly removed or until its local state is removed, regardless of whether it continues to be justified.</p> <p>Persistent WMEs are pervasive in Soar, because operators are the main unit of problem solving. Persistence is necessary for taking any non-monotonic step in a problem space. However, persistent WMEs also are dependent on WMEs in the superstate context. The problem in Soar prior to GDS, especially when trying to create a large-scale system, is that the knowledge developer must always think about which dependencies can be \"ignored\" and which may affect the persistent WME. For example, imagine an exploration robot that makes a persistent decision to travel to some distant destination based, in part, on its power reserves. Now suppose that the agent notices that its power reserves have failed. If this change is not communicated to the state where the travel decision was made, the agent will continue to act as if its full power reserves were still available.</p> <p>Of course, for this specific example, the knowledge designer can encode some knowledge to react to this inconsistency. The fundamental problem is that the knowledge designer has to consider all possible interactions between all o-supported WMEs and all contexts. Soar systems often use the architecture\u2019s impasse mechanism to realize a form of decomposition.  These potential interactions mean that the knowledge developer cannot focus on individual problem spaces in isolation when creating knowledge, which makes knowledge development more difficult. Further, in all but the simplest systems, the knowledge designer will miss some potential interactions. The result is that agents were unnecessarily brittle, failing in difficult-to-understand, difficult-to-duplicate ways.</p> <p>The GDS also solves the the problem of non-contemporaneous constraints in chunks. A non-contemporaneous constraint refers to two or more conditions that never co-occur simultaneously. An example might be a driving robot that learned a rule that attempted to match \"red light\" and \"green light\" simultaneously. Obviously, for functioning traffic lights, this rule would never fire. By ensuring that local persistent elements are always consistent with the higher-level context, non-contemporaneous constraints in chunks are guaranteed not to happen.</p> <p>The GDS captures context dependencies during processing, meaning the architecture will identify and respond to inconsistencies automatically. The knowledge designer then does not have to consider potential inconsistencies between local, o-supported WMEs and the context.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#behavior-level-view-of-the-goal-dependency-set","title":"Behavior-level view of the Goal Dependency Set","text":"<p>The following discussion covers what the GDS does, and how that impacts production knowledge design and implementation.</p> <p>Operation of the Goal Dependency Set: Consider i-support. The persistence of an i-supported (\"instantiation supported\") WME depends upon the creating production instantiation (and, more specifically, the features the instantiation tests). When one of the conditions in the production instantiation no longer matches, the instantiation is retracted, resulting in the loss of that support for the WME. I-support is illustrated in Figure 2.12. A copy of A in the subgoal,As, is retracted automatically when A changes to A\u2019. The substate WME persists only as long as it remains justified by A.</p> <p>In the broadest sense, we can say that some feature <code>&lt;b&gt;</code> is \"dependent\" upon another element <code>&lt;a&gt;</code> if <code>&lt;a&gt;</code> was used in the creation of <code>&lt;b&gt;</code>, i.e., if <code>&lt;a&gt;</code> was tested in the production instantiation that created <code>&lt;b&gt;</code>. Further, a dependent change with respect to feature <code>&lt;b&gt;</code> is a change to any of its instantiating features. This applies to both i-supported and o- supported WMEs. In Figure 2.12, the change from A to A\u2019 is a dependent change for feature 1 because A was used to create 1.</p> <p>When A changes, the persistent WME 1 may be no longer consistent with its context (e.g., A\u2019). The specific solution to this problem through GDS is inspired by the dependency analysis portion of the justification/chunking algorithm (see Chapter 4). Whenever an o- supported WME is created in the local state, the superstate dependencies of that new feature are determined and added to the goal dependency set (GDS) of that state. Conceptually speaking, whenever a working memory change occurs, the dependency sets for every state in the context hierarchy are compared to working memory changes. If a removed element is found in a GDS, the state is removed from memory (along with all existing substructure). The dependency set includes only dependencies for o-supported features. For example, in Figure 2.13, at time \\(t_0\\) , because only i-supported features have been created in the subgoal, the dependency set is empty.</p> Simplified Representation of the context dependencies (above the line), local o-supported WMEs (below the line), and the generation of a result. Prior to GDS, this situation led to non-contemporaneous constraints in the chunk that generates 3. The Dependency Set in Soar. <p>Three types of features can be tested in the creation of an o-supported feature. Each requires a slightly different type of update to the dependency set.</p> <ol> <li>Elements in the superstate: WMEs in the superstate are added directly to the    goal\u2019s dependency set. In Figure 2.13, the persistent subgoal item 3 is dependent upon    A and D. These superstate WMEs are added to the subgoal\u2019s dependency set when 3    is added to working memory at time \\(t_1\\). It does not matter that A is i-supported and    Do-supported.</li> <li>Local i-supported features: Local i-supported features are not added to the goal    dependency set. Instead, the superstate WMEs that led to the creation of the i-    supported feature are determined and added to the GDS. In the example, when 4    is created,A, B and C must be added to the dependency set because they are the    superstate features that led to 1 , which in turn led to 2 and finally 4. However, because    item A was previously added to the dependency set at \\(t_1\\) , it is unnecessary to add it    again.</li> <li>Local o-supported features: The dependencies of a local o-supported feature have    already been added to the state\u2019s GDS. Thus, tests of local o-supported WMEs do not    require additions to the dependency set. In Figure 2.13, the creation of element 5 does    not change the dependency set because it is dependent only upon persistent items 3    and 4 , whose features had been previously added to the GDS.</li> </ol> <p>At any time after t 1 , either the D to D\u2019 or A to A\u2019 transition would cause the removal of the entire subgoal. TheEtoE\u2019transition causes no retraction becauseEis not in the goal\u2019s dependency set.</p> <p>The role of the GDS in agent design: The GDS places some design time constraints on operator implementation. These constraints are:</p> <ul> <li>Operator actions that are used to remember a previous state/situation should be asserted in the top state.</li> <li>All operator elaborations should be i-supported.</li> <li>Any operator with local actions should be designed to be re-entrant.</li> </ul> <p>Because any dependencies for o-supported subgoal WMEs will be added to the GDS, the developer must decide if an o-supported element should be represented in a substate or the top state. This decision is straightforward if the functional role of the persistent element is considered. Four important capabilities that require persistence are:</p> <ol> <li>Reasoning hypothetically: Some structures may need to reflect hypothetical states.    These are \"assumptions\" because a hypothetical inference cannot always be grounded    in the current context. In problem solvers with truth maintenance, only assumptions    are persistent.</li> <li>Reasoning non-monotonically: Sometimes the result of an inference changes one    of the structures on which the inference is dependent. As an example, consider the    task of counting. Each newly counted item replaces the old value of the count.</li> <li>Remembering: Agents oftentimes need to remember an external situation or    stimulus, even when that perception is no longer available.</li> <li>Avoiding Expensive Computations: In some situations, an agent may have the    information needed to derive some belief in a new world state but the expense of    performing the necessary computation makes this derivation undesirable. For example,    in dynamic, complex domains, determining when to make an expensive calculation is    often formulated as an explicit agent task.</li> </ol> <p>When remembering or avoiding an expensive computation, the agent/designer is making a commitment to retain something even though it might not be supported in the current context. These WMEs should be asserted in the top state. For many Soar systems, especially those focused on execution in a dynamic environment, most o-supported elements will need to be stored on the top state.</p> <p>For any kind of local, non-monotonic reasoning about the context (counting, projection planning), features should be stored locally. When a dependent context change occurs, the GDS interrupts the processing by removing the state. While this may seem like a severe over-reaction, formal and empirical analysis have suggested that this solution is less computationally expensive than attempting to identify the specific dependent assumption.</p>"},{"location":"soar_manual/02_TheSoarArchitecture/#footnotes","title":"Footnotes","text":"<ul> <li>[1]: In this blocks-world task, the table always has    room for another block, so it is represented as always being \"clear\".</li> <li>[2]: In order to allow these links to have some    substructure, the attribute name may be an identifier, which means that the    attribute may itself have attributes and values, as specified by additional    working memory elements.</li> <li>[3]:  The original state is the \"top\" of the stack    because as Soar runs, this state (created first), will be at the top of the    computer screen, and substates will appear on the screen below the top-level    state.</li> <li>[4]: Technically, an i-supported WME is only retracted    when it loses instantiation support, not when the creating production is    retracting. For example, a WME could receive i-support from several different    instantiated productions and the retraction of only one would not lead to the    retraction of the WME.  justification. If such a result loses i-support from the    justification, it will be retracted if there is no other support.</li> <li>[5]: In the past, Soar had various experimental    support mode settings. Since version 9.6, the support mode used is what was    previously called mode 4.  with rule syntax (explained in Chapter    3) may wish to skip this section and return at a    later point.</li> <li>[6]: Robert E. Wray. Ensuring Reasoning Consistency in    Hierarchical Architectures. PhD thesis, University of Michigan, 1998.</li> <li>[7]: This subsection will primarily use \"state,\" not    \"goal.\" While these terms are often used nearly-interchangeably in the context    of Soar, states refer to the set of WMEs comprising knowledge related to a    peculiar level of goal. TheGoalDependency Set is the set of state elements upon    which a goal depends.  </li> </ul>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/","title":"Syntax of Soar Programs","text":""},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#the-syntax-of-soar-programs","title":"The Syntax of Soar Programs","text":"<p>This chapter describes in detail the syntax of elements in working memory, preference memory, and production memory, and how impasses and I/O are represented in working memory and in productions. Working memory elements and preferences are created as Soar runs, while productions are created by the user or through chunking. The bulk of this chapter explains the syntax for writing productions.</p> <p>The first section of this chapter describes the structure of working memory elements in Soar; the second section describes the structure of preferences; and the third section describes the structure of productions. The fourth section describes the structure of impasses. An overview of how input and output appear in working memory is presented in the fifth section. Further discussion of Soar I/O can be found on the Soar website.</p> <p>This chapter assumes that you understand the operating principles of Soar, as presented in the Soar architecture.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#working-memory","title":"Working Memory","text":"<p>Working memory contains working memory elements (WME\u2019s). As described in Chapter 2, WME\u2019s can be created by the actions of productions, the evaluation of preferences, the Soar architecture, and via the input/output system.</p> <p>A WME is a tuple consisting of three symbols: an identifier, an attribute, and a value, where the entire WME is enclosed in parentheses and the attribute is preceded by an up-arrow (<code>^</code>). A template for a working memory element is:</p> <pre><code>(identifier ^attribute value)\n</code></pre> <p>The first position always holds an internal identifier symbol, generated by the Soar architecture as it runs. The attribute and value positions can hold either identifiers or constants. The term identifier is used to refer both to the first position of a WME, as well as to the symbols that occupy that position. If a WME\u2019s attribute or value is an identifier, there is at least one WME that has that identifier symbol in its first position.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#symbols","title":"Symbols","text":"<p>Soar distinguishes between two types of working memory symbols: identifiers and constants.</p> <ul> <li>Identifiers: An identifier is a unique symbol, created at runtime when a     new object is added to working memory. The names of identifiers are created     by Soar, and consist of a single uppercase letter followed by a string of     digits, such as <code>G37</code> or <code>O22</code>.</li> </ul> <p>(The Soar user interface will also allow users to specify identifiers using lowercase letters in a case-insensitive manner, for example, when using the <code>print</code> command. But internally, they are actually uppercase letters.)</p> <ul> <li>Constants: There are three types of constants: integers, floating-point,     and symbolic constants: - Integer constants (numbers). The range of values     depends on the machine and implementation you\u2019re using, but it is at least     [-2 billion...+2 billion].<ul> <li>Floating-point constants (numbers). The range depends on the machine and     implementation you\u2019re using.</li> <li>Symbolic constants. These are symbols with arbitrary names. A constant     can use any combination of letters, digits, or <code>$%&amp;*+-/:&lt;=&gt;?_</code>. Other     characters (such as blank spaces) can be included by surrounding the     complete constant name with vertical bars: <code>|This is a constant|</code>. (The     vertical bars aren\u2019t part of the name; they\u2019re just notation.) A     vertical bar can be included by prefacing it with a backslash inside     surrounding vertical bars: <code>|Odd-symbol\\|name|</code></li> </ul> </li> </ul> <p>Identifiers should not be confused with constants, although they may \"look the same\"; identifiers are generated (by the Soar architecture) at runtime and will not necessarily be the same for repeated runs of the same program. Constants are specified in the Soar program and will be the same for repeated runs.</p> <p>Even when a constant \"looks like\" an identifier, it will not act like an identifier in terms of matching. A constant is printed surrounded by vertical bars whenever there is a possibility of confusing it with an identifier: <code>|G37|</code> is a constant while <code>G37</code> is an identifier. To avoid possible confusion, you should not use letter-number combinations as constants or for production names.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#objects","title":"Objects","text":"<p>Recall from Section Working Memory: The current situation that all WME\u2019s that share an identifier are collectively called an object in working memory. The individual working memory elements that make up an object are often called augmentations, because they augment the object. A template for an object in working memory is:</p> <pre><code>(identifier ^attribute-1 value-1 ^attribute-2 value-2\n            ^attribute-3 value-3... ^attribute-n value-n)\n</code></pre> <p>For example, if you run Soar with the supplementary blocks-world program provided online, after one elaboration cycle, you can look at the top-level state object by using the print command:</p> <pre><code>soar&gt; print s1\n(S1 ^io I1 ^ontop O2 ^ontop O3 ^ontop O1 ^problem-space blocks\n    ^superstate nil ^thing B3 ^thing T1 ^thing B1 ^thing B2\n    ^type state)\n</code></pre> <p>The attributes of an object are printed in alphabetical order to make it easier to find a specific attribute.</p> <p>Working memory is a set, so that at any time, there are never duplicate versions of working memory elements. However, it is possible for several working memory elements to share the same identifier and attribute but have different values. Such attributes are called multi-valued attributes or multi-attributes. For example, state <code>S1</code>, above, has two attributes that are multi-valued: <code>thing</code> and <code>ontop</code>.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#timetags","title":"Timetags","text":"<p>When a working memory element is created, Soar assigns it a unique integer timetag. The timetag is a part of the working memory element, and therefore, WME\u2019s are actually quadruples, rather than triples. However, the timetags are not represented in working memory and cannot be matched by productions. The timetags are used to distinguish between multiple occurrences of the same WME. As preferences change and elements are added and deleted from working memory, it is possible for a WME to be created, removed, and created again. The second creation of the WME \u2014 which bears the same identifier, attribute, and value as the first WME \u2014 is different, and therefore is assigned a different timetag. This is important because a production will fire only once for a given instantiation, and the instantiation is determined by the timetags that match the production and not by the identifier-attribute-value triples.</p> <p>To look at the timetags of WMEs, the <code>print --internal</code> command can be used:</p> <pre><code>soar&gt; print --internal S1\n(3: S1 ^io I1)\n(10: S1 ^ontop O2)\n(9: S1 ^ontop O3)\n(11: S1 ^ontop O1)\n(4: S1 ^problem-space blocks)\n(2: S1 ^superstate nil)\n(6: S1 ^thing B3)\n(5: S1 ^thing T1)\n(8: S1 ^thing B1)\n(7: S1 ^thing B2)\n(1: S1 ^type state)\n</code></pre> <p>This shows all the individual augmentations ofS1, each is preceded by an integer timetag.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#acceptable-preferences-in-working-memory","title":"Acceptable preferences in working memory","text":"<p>The <code>acceptable</code> preferences for operators appear in working memory as identifier-attribute-value-preference quadruples. No other preferences appear in working memory. A template for an <code>acceptable</code> preference in working memory is:</p> <pre><code>(identifier ^operator value +)\n</code></pre> <p>For example, if you run Soar with the example blocks-world program linked above, after the first operator has been selected, you can again look at the top-level state using the <code>print --internal</code> command:</p> <pre><code>soar&gt; print --internal s1\n(3: S1 ^io I1)\n(9: S1 ^ontop O3)\n(10: S1 ^ontop O2)\n(11: S1 ^ontop O1)\n(48: S1 ^operator O4 +)\n(49: S1 ^operator O5 +)\n(50: S1 ^operator O6 +)\n(51: S1 ^operator O7 +)\n(54: S1 ^operator O7)\n(52: S1 ^operator O8 +)\n(53: S1 ^operator O9 +)\n(4: S1 ^problem-space blocks)\n(2: S1 ^superstate nil)\n(5: S1 ^thing T1)\n(8: S1 ^thing B1)\n(6: S1 ^thing B3)\n(7: S1 ^thing B2)\n(1: S1 ^type state)\n</code></pre> <p>The state S1 has six augmentations of <code>acceptable</code> preferences for different operators (O4 throughO9). These have plus signs following the value to denote that they are acceptable preferences. The state has exactly one operator,O7. This state corresponds to the illustration of working memory in Figure 2.4.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#working-memory-as-a-graph","title":"Working Memory as a Graph","text":"<p>Not only is working memory a set, it is also a graph structure where the identifiers are nodes, attributes are links, and constants are terminal nodes. Working memory is not an arbitrary graph, but a graph rooted in the states (e.g. S1). Therefore, all WMEs are linked either directly or indirectly to a state. The impact of this constraint is that all WMEs created by actions are linked to WMEs tested in the conditions. The link is one-way, from the identifier to the value. Less commonly, the attribute of a WME may be an identifier.</p> A semantic net illustration of four objects in working memory. <p>This figure illustrates four objects in working memory; the object with identifier <code>X44</code> has been linked to the object with identifier <code>O43</code>, using the attribute as the link, rather than the value. The objects in working memory illustrated by this figure are:</p> <pre><code>(O43 ^isa apple ^color red ^inside O53 ^size small ^X44 200)\n(O87 ^isa ball ^color red ^inside O53 ^size big)\n(O53 ^isa box ^size large ^color orange ^contains O43 O87)\n(X44 ^unit grams ^property mass)\n</code></pre> <p>In this example, object <code>O43</code> and object <code>O87</code> are both linked to object <code>O53</code> through <code>(O53 ^contains O43)</code> and <code>(O53 ^contains O87)</code>, respectively (the contains attribute is a multi-valued attribute). Likewise, object <code>O53</code> is linked to object <code>O43</code> through <code>(O43 ^inside O53)</code> and linked to object <code>O87</code> through <code>(O87 ^inside O53)</code>. Object <code>X44</code> is linked to object <code>O43</code> through <code>(O43 ^X44 200)</code>.</p> <p>Links are transitive so that <code>O53</code>is linked to <code>X44</code>(because <code>O53</code> is linked to<code>O43</code> and <code>O43</code> is linked to <code>X44</code>). However, since links are not symmetric, <code>X44</code>is not linked to <code>O53</code>.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#working-memory-activation","title":"Working Memory Activation","text":"<p>WMEs have a form of base level activation associated with them that is not accessible to the agent, but that is used by the architecture. Working Memory Activation (WMA) is sub-symbolic metadata associated with a given element and represents its usage. A WME has been used if it has been matched in a rule that fired. WMA is not recorded or maintained when disabled, which is the default. See wm command for working memory settings and options for enabling WMA.</p> <p>Simply enabling WMA has no impact on any agent\u2019s behavior outside of a small additional computational cost. However, working memory activation is used for other features. Primarily, it is necessary for allowing the forgetting of memory elements from working memory. When working memory forgetting is turned on, those working memory elements with activation below a given threshold are removed from working memory. This allows agents to maintain a bounded working memory size without explicit memory size management. It also has a role in determining spreading activation values, discussed in section activation.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#preference-memory","title":"Preference Memory","text":"<p>Preferences are created by production firings and express the relative or absolute merits for selecting an operator for a state. When preferences express an absolute rating, they are identifier-attribute-value-preference quadruples; when preferences express relative ratings, they are identifier-attribute-value-preference-value quintuples</p> <p>For example,</p> <pre><code>(S1 ^operator O3 +)\n</code></pre> <p>is a preference that asserts that operator O3 is an <code>acceptable</code> operator for state S1, while</p> <pre><code>(S1 ^operator O3 &gt; O4)\n</code></pre> <p>is a preference that asserts that operator O3 is a better choice for the operator of state S1 than operator O4.</p> <p>The semantics of preferences and how they are processed were described in Section Preference Memory: Selection Knowledge, which also described each of the eleven different types of preferences. Multiple production instantiations may create identical preferences. Unlike working memory, preference memory is not a set: Duplicate preferences are allowed in preference memory.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#production-memory","title":"Production Memory","text":"<p>Production memory contains productions, which can be entered in by a user (typed in while Soar is running or loaded from a file) or generated by chunking while Soar is running. Productions (both user-defined productions and chunks) may be examined using the <code>print</code> command, described in the print command.</p> <pre><code>sp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n      ^thing &lt;thing1&gt; {&lt;&gt; &lt;thing1&gt; &lt;thing2&gt;}\n      ^ontop &lt;ontop&gt;)\n   (&lt;thing1&gt; ^type block ^clear yes)\n   (&lt;thing2&gt; ^clear yes)\n   (&lt;ontop&gt; ^top-block &lt;thing1&gt;\n   ^bottom-block &lt;&gt; &lt;thing2&gt;)\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block\n   ^moving-block &lt;thing1&gt;\n   ^destination &lt;thing2&gt;)\n}\n</code></pre> <p>Each production has three required components: a name, a set of conditions (also called the left-hand side, or LHS), and a set of actions (also called the right-hand side, or RHS). There are also two optional components: a documentation string and a type.</p> <p>Syntactically, each production consists of the symbol <code>sp</code>, followed by: an opening curly brace, <code>{</code>; the production\u2019s name; the documentation string (optional); the production type (optional); comments (optional); the production\u2019s conditions; the symbol<code>--&gt;</code>(literally: <code>dash-dash-greater than</code>); the production\u2019s actions; and a closing curly brace,<code>}</code>. Each element of a production is separated by white space. Indentation and line feeds are used by convention, but are not necessary.</p> <p>An example production, named <code>blocks-world*propose*move-block</code>, is shown in the following code block. This production proposes operators named move-block that move blocks from one location to another. The details of this production will be described in the following sections.</p> <pre><code>sp {production-name\n   \"Documentation string\"\n   :type\n   CONDITIONS\n   --&gt;\n   ACTIONS\n   }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#conventions-for-indenting-productions","title":"Conventions for indenting productions","text":"<p>Productions in this manual are formatted using conventions designed to improve their readability. These conventions are not part of the required syntax. First, the name of the production immediately follows the first curly bracket after the <code>sp</code>. All conditions are aligned with the first letter after the first curly brace, and attributes of an object are all aligned The arrow is indented to align with the conditions and actions and the closing curly brace follows the last action.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#production-names","title":"Production Names","text":"<p>The name of the production is an almost arbitrary constant. (See Section Symbols for a description of constants.) By convention, the name describes the role of the production, but functionally, the name is just a label primarily for the use of the programmer.</p> <p>A production name should never be a single letter followed by numbers, which is the format of identifiers.</p> <p>The convention for naming productions is to separate important elements with asterisks; the important elements that tend to appear in the name are:</p> <ol> <li>The name of the task or goal (e.g.,blocks-world).</li> <li>The name of the architectural function (e.g.,propose).</li> <li>The name of the operator (or other object) at issue. (e.g.,move-block)</li> <li>Any other relevant details.</li> </ol> <p>This name convention enables one to have a good idea of the function of a production just by examining its name. This can help, for example, when you are watching Soar run and looking at the specific productions that are firing and retracting. Since Soar uses white space to delimit components of a production, if whitespace inadvertently occurs in the production name, Soar will complain that an open parenthesis was expected to start the first condition.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#documentation-string-optional","title":"Documentation string (optional)","text":"<p>A production may contain an optional documentation string. The syntax for a documentation string is that it is enclosed in double quotes and appears after the name of the production and before the first condition (and may carry over to multiple lines). The documentation string allows the inclusion of internal documentation about the production; it will be printed out when the production is printed using the <code>print</code> command.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#production-type-optional","title":"Production type (optional)","text":"<p>A production may also include an optional production type, which may specify that the production should be considered a default production (<code>`:default</code>) or a chunk (<code>:chunk</code>), or may specify that a production should be given o-support (<code>:o-support</code>) or i-support (<code>:i-support</code>). Users are discouraged from using these types.</p> <p>Another flag (<code>:template</code>) can be used to specify that a production should be used to generate new reinforcement learning rules. See Section Rule Templates for details. There is one additional flag (<code>:interrupt</code>) which can be placed at this location in a production. However this flag does not specify a production type, but is a signal that the production should be marked for special debugging capabilities. For more information, see <code>sp</code> command.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#comments-optional","title":"Comments (optional)","text":"<p>Productions may contain comments, which are not stored in Soar when the production is loaded, and are therefore not printed out by the print command. A comment is begun with a pound sign character <code>#</code> and ends at the end of the line. Thus, everything following the <code>#</code> is not considered part of the production, and comments that run across multiple lines must each begin with a <code>#</code>.</p> <p>For example:</p> <pre><code>sp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n      ^thing &lt;thing1&gt; {&lt;&gt; &lt;thing1&gt; &lt;thing2&gt;}\n      ^ontop &lt;ontop&gt;)\n   (&lt;thing1&gt; ^type block ^clear yes)\n   (&lt;thing2&gt; ^clear yes)\n#     (&lt;ontop&gt; ^top-block &lt;thing1&gt;\n#        ^bottom-block &lt;&gt; &lt;thing2&gt;)\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block # you can also use in-line comments\n      ^moving-block &lt;thing1&gt;\n      ^destination &lt;thing2&gt;)}\n</code></pre> <p>When commenting out conditions or actions, be sure that all parentheses remain balanced outside the comment.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#external-comments","title":"External comments","text":"<p>Comments may also appear in a file with Soar productions, outside the curly braces of the sp command. Comments must either start a new line with a <code>#</code> or start with <code>;#</code>. In both cases, the comment runs to the end of the line.</p> <pre><code># imagine that this is part of a \"Soar program\" that contains\n# Soar productions as well as some other code.\n\nload file blocks.soar   ;# this is also a comment\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#the-condition-side-of-productions-or-lhs","title":"The condition side of productions (or LHS)","text":"<p>The condition side of a production, also called the left-hand side (or LHS) of the production, is a pattern for matching one or more WMEs. When all of the conditions of a production match elements in working memory, the production is said to be instantiated, and is ready to perform its action. (Each instance binds the rule to specific WMEs.)</p> <p>The following subsections describe the condition side of a production, including predicates, disjunctions, conjunctions, negations, <code>acceptable</code> preferences for operators, and a few advanced topics.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#conditions","title":"Conditions","text":"<p>The condition side of a production consists of a set of conditions. Each condition tests for the existence or absence (explained later in Section Negated Conditions) of working memory elements. Each condition consists of a open parenthesis, followed by a test for the identifier, and the tests for augmentations of that identifier, in terms of attributes and values. The condition is terminated with a close parenthesis. A single condition might test properties of a single working memory element, or properties of multiple working memory elements that constitute an object.</p> <pre><code>(identifier-test ^attribute1-test value1-test\n   ^attribute2-test value2-test\n   ^attribute3-test value3-test\n   ...)\n</code></pre> <p>The first condition in a production must match against a state in working memory. Thus, the first condition must begin with the additional symbol \"state\". All other conditions and actions must be linked directly or indirectly to this condition. This linkage may be direct to the state, or it may be indirect, through objects specified in the conditions. If the identifiers of the actions are not linked to the state, a warning is printed when the production is parsed, and the production is not stored in production memory. In the actions of the example production shown in Figure 3.2, the operator preference is directly linked to the state and the remaining actions are linked indirectly via the operator preference.</p> <p>Although all of the attribute tests in the example condition above are followed by value tests, it is possible to test for only the existence of an attribute and not test any specific value by just including the attribute and no value. Another exception to the above template is operator preferences, which have the following structure where a plus sign follows the value test.</p> <pre><code>(state-identifier-test ^operator value1-test +\n   ...)\n</code></pre> <p>In the remainder of this section, we describe the different tests that can be used for identifiers, attributes, and values. The simplest of these is a constant, where the constant specified in the attribute or value must match the same constant in a working memory element.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#variables-in-productions","title":"Variables in productions","text":"<p>Variables match against symbols in WMEs in the identifier, attribute, or value positions. Variables can be further constrained by additional tests (described in later sections) or by multiple occurrences in conditions. If a variable occurs more than once in the condition of a production, the production will match only if the variables match the same identifier or constant. However, there is no restriction that prevents different variables from binding to the same identifier or constant.</p> <p>Because identifiers are generated by Soar at run time, it impossible to include tests for specific identifiers in conditions. Therefore, variables are used in conditions whenever an identifier is to be matched.</p> <p>Variables also provide a mechanism for passing identifiers and constants which match in conditions to the action side of a rule.</p> <p>Syntactically, a variable is a symbol that begins with a left angle-bracket (i.e.,&lt;), ends with a right angle-bracket (i.e.,&gt;), and contains at least one non-pipe (|) character in between.</p> <p>In the example production in Figure 3.2, there are seven variables: <code>&lt;s&gt;</code>, <code>&lt;clear1&gt;</code>, <code>&lt;clear2&gt;</code>, <code>&lt;ontop&gt;,&lt;block1&gt;,&lt;block2&gt;</code>, and <code>&lt;o&gt;</code>.</p> <p>The following table gives examples of legal and illegal variable names.</p> Legal variables Illegal variables <code>&lt;s&gt;</code> &lt;&gt; &lt;1&gt; &lt;1 <code>&lt;variable1&gt;</code> variable&gt; <code>&lt;abc1&gt;</code> <code>&lt;a b&gt;</code>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#predicates-for-values","title":"Predicates for values","text":"<p>A test for an identifier, attribute, or value in a condition (whether constant or variable) can be modified by a preceding predicate. There are six general predicates that can be used: <code>&lt;&gt;</code>, <code>&lt;=&gt;</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code>.</p> Predicate Semantics of Predicate &lt;&gt; Not equal. Matches anything except the value immediately following it. &lt;=&gt; Same type. Matches any symbol that is the same type (identifier, integer, floating-point, non-numeric constant) as the value immediately following it. &lt; Numerically less than the value immediately following it. &lt;= Numerically less than or equal to the value immediately following it. &gt;= Numerically greater than or equal to the value immediately following it. &gt; Numerically greater than the value immediately following it. <p>The following table shows examples of legal and illegal predicates:</p> Legal predicates Illegal predicates <code>&gt; &lt;valuex&gt;</code> <code>&gt; &gt; &lt;valuey&gt;</code> <code>&lt; 1</code> <code>1 &gt;</code> <code>&lt;=&gt; &lt;y&gt;</code> <code>= 10</code> <p>There are also four special predicates that can be used to test Long-Term Identifier (LTI) links held by working memory identifiers: <code>@</code>, <code>!@</code>, <code>@+</code>, <code>@-</code></p> Predicate Semantics of Predicate <code>@</code> Same LTI. Matches when the two values are working memory identifiers linked to the same LTI. <code>!@</code> Different LTI. Matches when the values are not both identifiers linked to the same LTI. <code>@+</code> Matches if the value is an identifier linked to some LTI. <code>@-</code> Matches if the value is not an identifier linked to some LTI. <p>See Knowledge Representation for more information on long-term semantic memory and LTIs.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#example-productions","title":"Example Productions","text":"<pre><code>sp {propose-operator*to-show-example-predicate\n   (state &lt;s&gt; ^car &lt;c&gt;)\n   (&lt;c&gt; ^style convertible ^color &lt;&gt; rust)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name drive-car ^car &lt;c&gt;) }\n</code></pre> <p>In this production, there must be a \"color\" attribute for the working memory object that matches <code>&lt;c&gt;</code>, and the value of that attribute must not be \"rust\".</p> <pre><code>sp {example*lti*predicates\n   (state &lt;s&gt; ^existing-item { @+ &lt;orig-sti&gt; }\n      ^smem.result.retrieved { @ &lt;orig-sti&gt; &lt;result-sti&gt; })\n   --&gt;\n... }\n</code></pre> <p>In this production,<code>&lt;orig-sti&gt;</code>, is tested for whether it is linked to some LTI. It is also compared against <code>&lt;result-sti&gt;</code>(a working memory element retrieved from long-term memory and known to be linked to an LTI) to see if the two elements point to the same long-term memory. Note the the <code>@+</code> in this example is actually unnecessary, since the <code>{ @ &lt;orig-sti&gt; &lt;result-sti&gt; }</code> test will fail to match if either value tested is not linked to an LTI.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#disjunctions-of-values","title":"Disjunctions of values","text":"<p>A test for an identifier, attribute, or value may also be for a disjunction of constants. With a disjunction, there will be a match if any one of the constants is found in a working memory element (and the other parts of the working memory element matches). Variables and predicates may not be used within disjunctive tests.</p> <p>Syntactically, a disjunctive test is specified with double angle brackets (i.e., <code>&lt;&lt; and &gt;&gt;</code>). There must be spaces separating the brackets from the constants.</p> <p>The following table provides examples of legal and illegal disjunctions:</p> Legal disjunctions Illegal disjunctions <code>&lt;&lt; A B C 45 I17 &gt;&gt;</code> <code>&lt;&lt; &lt;var&gt; A &gt;&gt;</code> <code>&lt;&lt; 5 10 &gt;&gt;</code> <code>&lt;&lt; &lt; 5 &gt; 10 &gt;&gt;</code> <code>&lt;&lt; good-morning good-evening &gt;&gt;</code> <code>&lt;&lt;A B C &gt;&gt;</code>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#example-production","title":"Example Production","text":"<p>For example, the third condition of the following production contains a disjunction that restricts the color of the table to red or blue:</p> <pre><code>sp {blocks*example-production-conditions\n   (state ^operator &lt;o&gt; + ^table &lt;t&gt;)\n   (&lt;o&gt; ^name move-block)\n   (&lt;t&gt; ^type table ^color &lt;&lt; red blue &gt;&gt; )\n   --&gt;\n   ... }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#note","title":"Note","text":"<p>Disjunctions of complete conditions are not allowed in Soar. Multiple (similar) productions fulfill this role.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#conjunctions-of-values","title":"Conjunctions of values","text":"<p>A test for an identifier, attribute, or value in a condition may include a conjunction of tests, all of which must hold for there to be a match.</p> <p>Syntactically, conjuncts are contained within curly braces (i.e., <code>{ and }</code>). The following table shows some examples of legal and illegal conjunctive tests:</p> Legal conjunctions Illegal conjunctions { <code>&lt;= &lt;a&gt; &gt;= &lt;b&gt;</code> } { <code>&lt;x&gt; &lt; &lt;a&gt; + &lt;b&gt;</code> } { <code>&lt;x&gt; &gt; &lt;y&gt;</code> } { <code>&gt; &gt; &lt;b&gt;</code>} { <code>&lt;&gt; &lt;x&gt; &lt;y&gt;</code>} { <code>&lt;a&gt; &lt;b&gt;</code> } { <code>&lt;y&gt; &lt;&gt; &lt;x&gt;</code>} { <code>&lt;&lt; A B C &gt;&gt; &lt;x&gt;</code> } { <code>&lt;=&gt; &lt;x&gt; &gt; &lt;y&gt; &lt;&lt; 1 2 3 4 &gt;&gt; &lt;z&gt;</code>} <p>Because those examples are a bit difficult to interpret, let\u2019s go over the legal examples one by one to understand what each is doing.</p> <p>In the first example, the value must be less than or equal to the value bound to variable <code>&lt;a&gt;</code> and greater than or equal to the value bound to variable <code>&lt;b&gt;</code>.</p> <p>In the second example, the value is bound to the variable <code>&lt;x&gt;</code>, which must also be greater than the value bound to variable <code>&lt;y&gt;</code>.</p> <p>The third and fourth examples are equivalent. They state that the value must not be equal to the value bound to variable <code>&lt;x&gt;</code> and should be bound to variable <code>&lt;y&gt;</code>. Note the importance of order when using conjunctions with predicates: in the second example, the predicate modifies <code>&lt;y&gt;</code>, but in the third example, the predicate modifies <code>&lt;x&gt;</code>.</p> <p>In the fifth example, the value must be one of A, B, or C, and the second conjunctive test binds the value to variable <code>&lt;x&gt;</code>.</p> <p>In the sixth example, there are four conjunctive tests. First, the value must be the same type as the value bound to variable <code>&lt;x&gt;</code>. Second, the value must be greater than the value bound to variable <code>&lt;y&gt;</code>. Third, the value must be equal to 1 , 2 , 3 , or 4. Finally, the value should be bound to variable <code>&lt;z&gt;</code>.</p> <p>In Figure 3.2, a conjunctive test is used for the thing attribute in the first condition.</p> <p>Note that it is illegal syntax for a condition to test the equality of two variables, as demonstrated in the last illegal conjunction above. Any such test can instead be coded in simpler terms by only using one variable in the places where either would be referenced throughout the rule.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#negated-conditions","title":"Negated conditions","text":"<p>In addition to the positive tests for elements in working memory, conditions can also test for the absence of patterns. A negated condition will be matched only if there does not exist a working memory element consistent with its tests and variable bindings. Thus, it is a test for the absence of a working memory element.</p> <p>Syntactically, a negated condition is specified by preceding a condition with a dash (i.e., \"-\").</p> <p>For example, the following condition tests the absence of a working memory element of the object bound to <code>&lt;p1&gt; ^type father</code>.</p> <pre><code>-(&lt;p1&gt; ^type father)\n</code></pre> <p>A negation can be used within an object with many attribute-value pairs by having it precede a specific attribute:</p> <pre><code>(&lt;p1&gt; ^name john -^type father ^spouse &lt;p2&gt;)\n</code></pre> <p>In that example, the condition would match if there is a working memory element that matches <code>(&lt;p1&gt; ^name john)</code> and another that matches <code>(&lt;p1&gt; ^spouse &lt;p2&gt;)</code>, but is no working memory element that matches <code>(&lt;p1&gt; ^type father)</code> (when <code>p1</code> is bound to the same identifier).</p> <p>On the other hand, the condition:</p> <pre><code>-(&lt;p1&gt; ^name john ^type father ^spouse &lt;p2&gt;)\n</code></pre> <p>would match only if there is no object in working memory that matches all three attribute-value tests.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#example-production_1","title":"Example Production","text":"<pre><code>sp {default*evaluate-object\n   (state &lt;ss&gt; ^operator &lt;so&gt;)\n   (&lt;so&gt; ^type evaluation\n      ^superproblem-space &lt;p&gt;)\n   -(&lt;p&gt; ^default-state-copy no)\n   --&gt;\n   (&lt;so&gt; ^default-state-copy yes) }\n</code></pre> <p>For negated conditions in combination with attribute-path notation consult the section negated multi-valued attributes and attribute-path notation.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#notes","title":"Notes","text":"<p>One use of negated conditions to avoid is testing for the absence of the working memory element that a production creates with i-support; this would lead to an \"infinite loop\" in your Soar program, as Soar would repeatedly fire and retract the production. For example, the following rule\u2019s actions will cause it to no longer match, which will cause the action to retract, which will cause the rule to match, and so on:</p> <pre><code>sp {example*infinite-loop\n   (state &lt;s&gt; ^car &lt;c&gt;\n      -^road )\n   --&gt;\n   (&lt;s&gt; ^road |route-66|) }\n</code></pre> <p>Also note that syntactically it is invalid for the first condition of a rule to be a negated condition. For example, the following production would fail to load:</p> <pre><code>sp {example*invalid-negated-first-condition\n   (state &lt;s&gt; -^road &lt;r&gt;\n      ^car &lt;c&gt;)\n   --&gt;\n... }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#negated-conjunctions-of-conditions","title":"Negated conjunctions of conditions","text":"<p>Conditions can be grouped into conjunctive sets by surrounding the set of conditions with <code>{ and }</code>. The production compiler groups the test in these conditions together. This grouping allows for negated tests of more than one working memory element at a time. In the example below, the state is tested to ensure that it does not have an object on the table.</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state)\n  -{(&lt;s&gt; ^ontop &lt;on&gt;)\n    (&lt;on&gt; ^bottom-object &lt;bo&gt;)\n    (&lt;bo&gt; ^type table)}\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-table true)}\n</code></pre> <p>When using negated conjunctions of conditions, the production has nested curly braces. One set of curly braces delimits the production, while the other set delimits the conditions to be conjunctively negated.</p> <p>If only the last condition, <code>(&lt;bo&gt; ^type table)</code> were negated, the production would match only if the state had an ontop relation, and the ontop relation had a bottom-object, but the bottom object wasn\u2019t a table. Using the negated conjunction, the production will also match when the state has no ontop augmentation or when it has an ontop augmentation that doesn\u2019t have a bottom-object augmentation.</p> <p>The semantics of negated conjunctions can be thought of in terms of mathematical logic, where the negation of \\((A \\wedge B \\wedge C)\\):</p> \\[\\neg (A \\wedge B \\wedge C)\\] <p>can be rewritten as:</p> \\[(\\neg A) \\vee (\\neg B) \\vee (\\neg C)\\] <p>That is, \"not (A and B and C)\" becomes \"(not A) or (not B) or (not C)\".</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#multi-valued-attributes","title":"Multi-valued attributes","text":"<p>An object in working memory may have multiple augmentations that specify the same attribute with different values; these are called multi-valued attributes, or multi-attributes for short. To shorten the specification of a condition, tests for multi-valued attributes can be shortened so that the value tests are together.</p> <p>For example, the condition:</p> <pre><code>(&lt;p1&gt; ^type father ^child sally ^child sue)\n</code></pre> <p>could also be written as:</p> <pre><code>(&lt;p1&gt; ^type father ^child sally sue)\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#multi-valued-attributes-and-variables","title":"Multi-valued attributes and variables","text":"<p>When variables are used with multi-valued attributes, remember that variable bindings are not unique unless explicitly forced to be so. For example, to test that an object has two values for attribute child, the variables in the following condition can match to the same value.</p> <pre><code>(&lt;p1&gt; ^type father ^child &lt;c1&gt; &lt;c2&gt;)\n</code></pre> <p>To do tests for multi-valued attributes with variables correctly, conjunctive tests must be used, as in:</p> <pre><code>(&lt;p1&gt; ^type father ^child &lt;c1&gt; {&lt;&gt; &lt;c1&gt; &lt;c2&gt;})\n</code></pre> <p>The conjunctive test <code>{&lt;&gt; &lt;c1&gt; &lt;c2&gt;}</code> ensures that <code>&lt;c2&gt;</code> will bind to a different value than <code>&lt;c1&gt;</code> binds to.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#negated-conditions-and-multi-valued-attributes","title":"Negated conditions and multi-valued attributes","text":"<p>A negation can also precede an attribute with multiple values. In this case it tests for the absence of the conjunction of the values. For example</p> <pre><code>(&lt;p1&gt; ^name john -^child oprah uma)\n</code></pre> <p>is the same as</p> <pre><code>(&lt;p1&gt; ^name john)\n-{(&lt;p1&gt; ^child oprah)\n(&lt;p1&gt; ^child uma)}\n</code></pre> <p>and the match is possible if either <code>(&lt;p1&gt; ^child oprah)</code> or <code>(&lt;p1&gt; ^child uma)</code> cannot be found in working memory with the binding for <code>&lt;p1&gt;</code> (but not if both are present).</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#acceptable-preferences-for-operators","title":"Acceptable preferences for operators","text":"<p>The only preferences that can appear in working memory are acceptable preferences for operators, and therefore, the only preferences that may appear in the conditions of a production are <code>acceptable</code> preferences for operators.</p> <p>Acceptable preferences for operators can be matched in a condition by testing for a \"+\" following the value. This allows a production to test the existence of a candidate operator and its properties, and possibly create a preference for it, before it is selected.</p> <p>In the example below, <code>^operator &lt;o&gt; +</code> matches the <code>acceptable</code> preference for the operator augmentation of the state. This does not test that operator <code>&lt;o&gt;</code> has been selected as the current operator.</p> <pre><code>sp {blocks*example-production-conditions\n   (state ^operator &lt;o&gt; + ^table &lt;t&gt;)\n   (&lt;o&gt; ^name move-block)\n   --&gt;\n   ... }\n</code></pre> <p>In the example below, the production tests the state for <code>acceptable</code> preferences for two different operators (and also tests that these operators move different blocks):</p> <pre><code>sp {blocks*example-production-conditions\n   (state ^operator &lt;o1&gt; + &lt;o2&gt; + ^table &lt;t&gt;)\n   (&lt;o1&gt; ^name move-block ^moving-block &lt;m1&gt; ^destination &lt;d1&gt;)\n   (&lt;o2&gt; ^name move-block ^moving-block {&lt;m2&gt; &lt;&gt; &lt;m1&gt;}\n      ^destination &lt;d2&gt;)\n   --&gt;\n   ... }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#attribute-tests","title":"Attribute tests","text":"<p>The previous examples applied all of the different tests to the values of working memory elements. All of the tests that can be used for values can also be used for attributes and identifiers (except those including constants).</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#variables-in-attributes","title":"Variables in attributes","text":"<p>Variables may be used with attributes, as in:</p> <pre><code>sp {blocks*example-production-conditions\n   (state &lt;s&gt; ^operator &lt;o&gt; +\n      ^thing &lt;t&gt; {&lt;&gt; &lt;t&gt; &lt;t2&gt;} )\n   (operator &lt;o&gt; ^name group\n      ^by-attribute &lt;a&gt;\n      ^moving-block &lt;t&gt;\n      ^destination &lt;t2&gt;)\n   (&lt;t&gt; ^type block ^&lt;a&gt; &lt;x&gt;)\n   (&lt;t2&gt; ^type block ^&lt;a&gt; &lt;x&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; &gt;) }\n</code></pre> <p>This production tests that there is <code>acceptable</code> operator that is trying to group blocks according to some attribute, <code>&lt;a&gt;</code>, and that block <code>&lt;t&gt;</code> and <code>&lt;t2&gt;</code> both have this attribute (whatever it is), and have the same value for the attribute.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#predicates-in-attributes","title":"Predicates in attributes","text":"<p>Predicates may be used with attributes, as in:</p> <pre><code>sp {blocks*example-production-conditions\n   (state ^operator &lt;o&gt; + ^table &lt;t&gt;)\n   (&lt;t&gt; ^&lt;&gt; type table)\n   --&gt;\n... }\n</code></pre> <p>which tests that the object with its identifier bound to <code>&lt;t&gt;</code> must have an attribute whose value is <code>table</code>, but the name of this attribute is not <code>type</code>.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#disjunctions-of-attributes","title":"Disjunctions of attributes","text":"<p>Disjunctions may also be used with attributes, as in:</p> <pre><code>sp {blocks*example-production-conditions\n   (state ^operator &lt;o&gt; + ^table &lt;t&gt;)\n   (&lt;t&gt; ^&lt;&lt; type name&gt;&gt; table)\n   --&gt;\n... }\n</code></pre> <p>which tests that the object with its identifier bound to <code>&lt;t&gt;</code> must have either an attribute <code>type</code> whose value is <code>table</code> or an attribute <code>name</code> whose value is <code>table</code>.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#conjunctive-tests-for-attributes","title":"Conjunctive tests for attributes","text":"<p>Section Conjunction of Values illustrated the use of conjunctions for the values in conditions. Conjunctive tests may also be used with attributes, as in:</p> <pre><code>sp {blocks*example-production-conditions\n   (state ^operator &lt;o&gt; + ^table &lt;t&gt;)\n   (&lt;t&gt; ^{&lt;ta&gt; &lt;&gt; name} table)\n   --&gt;\n   ... }\n</code></pre> <p>which tests that the object with its identifier bound to <code>&lt;t&gt;</code> must have an attribute whose value is <code>table</code>, and the name of this attribute is not <code>name</code>, and the name of this attribute (whatever it is) is bound to the variable <code>&lt;ta&gt;</code>.</p> <p>When attribute predicates or attribute disjunctions are used with multi-valued attributes, the production is rewritten internally to use a conjunctive test for the attribute; the conjunctive test includes a variable used to bind to the attribute name. Thus,</p> <pre><code>(&lt;p1&gt; ^type father ^ &lt;&gt; name sue sally)\n</code></pre> <p>is interpreted to mean:</p> <pre><code>(&lt;p1&gt; ^type father\n   ^{&lt;&gt; name &lt;a*1&gt;} sue\n   ^&lt;a*1&gt; sally)\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#attribute-path-notation","title":"Attribute-path notation","text":"<p>Often, variables appear in the conditions of productions only to link the value of one attribute with the identifier of another attribute. Attribute-path notation provides a shorthand so that these intermediate variables do not need to be included.</p> <p>Syntactically, path notation lists a sequence of attributes separated by dots (.), after the <code>^</code> in a condition.</p> <p>For example, using attribute path notation, the production:</p> <pre><code>sp {blocks-world*monitor*move-block\n   (state &lt;s&gt; ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name move-block\n      ^moving-block &lt;block1&gt;\n      ^destination &lt;block2&gt;)\n   (&lt;block1&gt; ^name &lt;block1-name&gt;)\n   (&lt;block2&gt; ^name &lt;block2-name&gt;)\n   --&gt;\n   (write (crlf) |Moving Block: | &lt;block1-name&gt;\n      | to: | &lt;block2-name&gt; ) }\n</code></pre> <p>could be written as:</p> <pre><code>sp {blocks-world*monitor*move-block\n   (state &lt;s&gt; ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name move-block\n      ^moving-block.name &lt;block1-name&gt;\n      ^destination.name &lt;block2-name&gt;)\n   --&gt;\n   (write (crlf) |Moving Block: | &lt;block1-name&gt;\n      | to: | &lt;block2-name&gt; ) }\n</code></pre> <p>Attribute-path notation yields shorter productions that are easier to write, less prone to errors, and easier to understand.</p> <p>When attribute-path notation is used, Soar internally expands the conditions into the multiple Soar objects, creating its own variables as needed. Therefore, when you print a production (using the <code>print</code> command), the production will not be represented using attribute-path notation.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#negations-and-attribute-path-notation","title":"Negations and attribute path notation","text":"<p>A negation may be used with attribute path notation, in which case it amounts to a negated conjunction. For example, the production:</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state)\n   -{(&lt;s&gt; ^ontop &lt;on&gt;)\n   (&lt;on&gt; ^bottom-object &lt;bo&gt;)\n   (&lt;bo&gt; ^type table)}\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-table true) }\n</code></pre> <p>could be rewritten as:</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state -^ontop.bottom-object.type table)\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-table true) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#multi-valued-attributes-and-attribute-path-notation","title":"Multi-valued attributes and attribute path notation","text":"<p>Attribute path notation may also be used with multi-valued attributes, such as:</p> <pre><code>sp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n      ^clear.block &lt;block1&gt; { &lt;&gt; &lt;block1&gt; &lt;block2&gt; }\n      ^ontop &lt;ontop&gt;)\n   (&lt;block1&gt; ^type block)\n   (&lt;ontop&gt; ^top-block &lt;block1&gt;\n      ^bottom-block &lt;&gt; &lt;block2&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block +\n      ^moving-block &lt;block1&gt; +\n      ^destination &lt;block2&gt; +) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#multi-attributes-and-attribute-path-notation","title":"Multi-attributes and attribute-path notation","text":"<p>Note: It would not be advisable to write the production in Figure 3.2 using attribute-path notation as follows:</p> <pre><code>sp {blocks-world*propose*move-block*dont-do-this\n   (state &lt;s&gt; ^problem-space blocks\n      ^clear.block &lt;block1&gt;\n      ^clear.block { &lt;&gt; &lt;block1&gt; &lt;block2&gt; }\n      ^ontop.top-block &lt;block1&gt;\n      ^ontop.bottom-block &lt;&gt; &lt;block2&gt;)\n   (&lt;block1&gt; ^type block)\n   --&gt;\n   ...}\n</code></pre> <p>This is not advisable because it corresponds to a different set of conditions than those in the original production (the <code>top-block</code> and <code>bottom-block</code> need not correspond to the same <code>ontop</code> relation). To check this, we could print the original production at the Soar prompt:</p> <pre><code>soar&gt; print blocks-world*propose*move-block*dont-do-this\nsp {blocks-world*propose*move-block*dont-do-this\n   (state &lt;s&gt; ^problem-space blocks ^thing &lt;thing2&gt;\n      ^thing { &lt;&gt; &lt;thing2&gt; &lt;thing1&gt; } ^ontop &lt;o*1&gt; ^ontop &lt;o*2&gt;)\n   (&lt;thing2&gt; ^clear yes)\n   (&lt;thing1&gt; ^clear yes ^type block)\n   (&lt;o*1&gt; ^top-block &lt;thing1&gt;)\n   (&lt;o*2&gt; ^bottom-block { &lt;&gt; &lt;thing2&gt; &lt;b*1&gt; })\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block\n      ^moving-block &lt;thing1&gt;\n      ^destination &lt;thing2&gt;) }\n</code></pre> <p>Soar has expanded the production into the longer form, and created two distinctive variables, <code>&lt;o*1&gt;</code> and <code>&lt;o*2&gt;</code> to represent the on top attribute. These two variables will not necessarily bind to the same identifiers in working memory.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#negated-multi-valued-attributes-and-attribute-path-notation","title":"Negated multi-valued attributes and attribute-path notation","text":"<p>Negations of multi-valued attributes can be combined with attribute-path notation. However; it is very easy to make mistakes when using negated multi-valued attributes with attribute-path notation. Although it is possible to do it correctly, we strongly discourage its use.</p> <p>For example,</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state -^ontop.bottom-object.name table A)\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-A-or-table true) }\n</code></pre> <p>gets expanded to:</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state)\n   -{(&lt;s&gt; ^ontop &lt;o*1&gt;)\n   (&lt;o*1&gt; ^bottom-object &lt;b*1&gt;)\n   (&lt;b*1&gt; ^name A)\n   (&lt;b*1&gt; ^name table)}\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-A-or-table true) }\n</code></pre> <p>This example does not refer to two different blocks with different names. It tests that there is not a non top relation with a <code>bottom-block</code> that is named <code>A</code> and named <code>table</code>. Thus, this production probably should have been written as:</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state\n   -^ontop.bottom-object.name table\n   -^ontop.bottom-object.name A)\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-A-or-table true) }\n</code></pre> <p>which expands to:</p> <pre><code>sp {blocks*negated-conjunction-example\n   (state &lt;s&gt; ^name top-state)\n   -{(&lt;s&gt; ^ontop &lt;o*2&gt;)\n     (&lt;o*2&gt; ^bottom-object &lt;b*2&gt;)\n     (&lt;b*2&gt; ^name a)}\n   -{(&lt;s&gt; ^ontop &lt;o*1&gt;)\n     (&lt;o*1&gt; ^bottom-object &lt;b*1&gt;)\n     (&lt;b*1&gt; ^name table)}\n   --&gt;\n   (&lt;s&gt; ^nothing-ontop-a-or-table true +) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#notes-on-attribute-path-notation","title":"Notes on attribute-path notation","text":"<ul> <li>Attributes specified in attribute-path notation may not start with a digit.     For example, if you type <code>^foo.3.bar</code>, Soar thinks the <code>.3</code> is a     floating-point number. (Attributes that don\u2019t appear in path notation can     begin with a number.)</li> <li>Attribute-path notation may be used to any depth.</li> <li>Attribute-path notation may be combined with structured values, described in     Section Structured Value Notation.</li> </ul>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#structured-value-notation","title":"Structured-value notation","text":"<p>Another convenience that eliminates the use of intermediate variables is structured-value notation. Syntactically, the attributes and values of a condition may be written where a variable would normally be written. The attribute-value structure is delimited by parentheses.</p> <p>Using structured-value notation, the production in Figure 3.2 may also be written as:</p> <pre><code>sp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n      ^thing &lt;thing1&gt;\n      ^thing {&lt;&gt; &lt;thing1&gt; &lt;thing2&gt;}\n      ^ontop (^top-block &lt;thing1&gt;\n      ^bottom-block &lt;&gt; &lt;thing2&gt;))\n   (&lt;thing1&gt; ^type block ^clear yes)\n   (&lt;thing2&gt; ^clear yes)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block\n      ^moving-block &lt;thing1&gt;\n      ^destination &lt;thing2&gt;) }\n</code></pre> <p>Thus, several conditions may be \"collapsed\" into a single condition.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#using-variables-within-structured-value-notation","title":"Using variables within structured-value notation","text":"<p>Variables are allowed within the parentheses of structured-value notation to specify an identifier to be matched elsewhere in the production. For example, the variable <code>&lt;ontop&gt;</code> could be added to the conditions (although it is not referenced again, so this is not helpful in this instance):</p> <pre><code>sp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n      ^thing &lt;thing1&gt;\n      ^thing {&lt;&gt; &lt;thing1&gt; &lt;thing2&gt;}\n      ^ontop (&lt;ontop&gt;\n      ^top-block &lt;thing1&gt;\n      ^bottom-block &lt;&gt; &lt;thing2&gt;))\n   (&lt;thing1&gt; ^type block ^clear yes)\n   (&lt;thing2&gt; ^clear yes)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block\n      ^moving-block &lt;thing1&gt;\n      ^destination &lt;thing2&gt;) }\n</code></pre> <p>Structured values may be nested to any depth. Thus, it is possible to write our example production using a single condition with multiple structured values:</p> <pre><code>sp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n      ^thing &lt;thing1&gt;\n   ({&lt;&gt; &lt;thing1&gt; &lt;thing2&gt;}\n      ^clear yes)\n      ^ontop (^top-block\n   (&lt;thing1&gt;\n      ^type block\n      ^clear yes)\n      ^bottom-block &lt;&gt; &lt;thing2&gt;) )\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block\n      ^moving-block &lt;thing1&gt;\n      ^destination &lt;thing2&gt;) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#notes-on-structured-value-notation","title":"Notes on structured-value notation","text":"<ul> <li>Attribute-path notation and structured-value notation are orthogonal and can     be combined in any way. A structured value can contain an attribute path, or     a structure can be given as the value for an attribute path.</li> <li>Structured-value notation can be combined with negations and with     multi-attributes.</li> <li>Structured-value notation can not be used in the actions of productions.</li> </ul>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#the-action-side-of-productions-or-rhs","title":"The action side of productions (or RHS)","text":"<p>The action side of a production, also called the right-hand side (or RHS) of the production, consists of individual actions that can:</p> <ul> <li>Add new elements to working memory.</li> <li>Remove elements from working memory.</li> <li>Create preferences.</li> <li>Perform other actions</li> </ul> <p>When the conditions of a production match working memory, the production is said to be instantiated, and the production will fire during the next elaboration cycle. Firing the production involves performing the actions using the same variable bindings that formed the instantiation.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#variables-in-actions","title":"Variables in Actions","text":"<p>Variables can be used in actions. A variable that appeared in the condition side will be replaced with the value that is was bound to in the condition. A variable that appears only in the action side will be bound to a new identifier that begins with the first letter of that variable (e.g., <code>&lt;o&gt;</code> might be bound to <code>o234</code>). This symbol is guaranteed to be unique and it will be used for all occurrences of the variable in the action side, appearing in all working memory elements and preferences that are created by the production action.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#creating-working-memory-elements","title":"Creating Working Memory Elements","text":"<p>An element is created in working memory by specifying it as an action. Multiple augmentations of an object can be combined into a single action, using the same syntax as in conditions, including path notation and multi-valued attributes.</p> <pre><code>--&gt;\n(&lt;s&gt; ^block.color red\n   ^thing &lt;t1&gt; &lt;t2&gt;) }\n</code></pre> <p>The action above is expanded to be:</p> <pre><code>--&gt;\n(&lt;s&gt; ^block &lt;*b&gt;)\n(&lt;*b&gt; ^color red)\n(&lt;s&gt; ^thing &lt;t1&gt;)\n(&lt;s&gt; ^thing &lt;t2&gt;) }\n</code></pre> <p>This will add four elements to working memory with the variables replaced with whatever values they were bound to on the condition side.</p> <p>Since Soar is case sensitive, different combinations of upper- and lowercase letters represent different constants. For example, <code>\"red\"</code>, <code>\"Red\"</code>, and <code>\"RED\"</code> are all distinct symbols in Soar. In many cases, it is prudent to choose one of uppercase or lowercase and write all constants in that case to avoid confusion (and bugs).</p> <p>The constants that are used for attributes and values have a few restrictions on them:</p> <ol> <li>There are a number of architecturally created augmentations for state and     impasse objects; see Section     Impass in Working Memory and in Productions     for a listing of these special augmentations. User-defined productions can     not create or remove augmentations of states that use these attribute names.</li> <li>Attribute names should not begin with a number if these attributes will be     used in attribute-path notation.</li> </ol>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#removing-working-memory-elements","title":"Removing Working Memory Elements","text":"<p>A element is explicitly removed from working memory by following the value with a dash: <code>-</code> , also called a reject.</p> <pre><code>--&gt;\n(&lt;s&gt; ^block &lt;b&gt; -)}\n</code></pre> <p>If the removal of a working memory element removes the only link between the state and working memory elements that had the value of the removed element as an identifier, those working memory elements will be removed. This is applied recursively, so that all item that become unlinked are removed.</p> <p>The removal should be used with an action that will be o-supported. If removal is attempted with i-support, the working memory element will reappear if the removal loses i-support and the element still has support.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#the-syntax-of-preferences","title":"The syntax of preferences","text":"<p>Below are the eleven types of preferences as they can appear in the actions of a production for the selection of operators:</p> RHS preferences Semantics (id ^operator value) acceptable (id ^operator value +) acceptable (id ^operator value !) require (id ^operator value ~) prohibit (id ^operator value -) reject (id ^operator value &gt; value2) better (id ^operator value &lt; value2) worse (id ^operator value &gt;) best (id ^operator value &lt;) worst (id ^operator value =) unary indifferent (id ^operator value = value2) binary indifferent (id ^operator value = number) numeric indifferent <p>The identifier and value will always be variables, such as <code>(&lt;s1&gt; ^operator &lt;o1&gt; &gt; &lt;o2&gt;)</code>.</p> <p>The preference notation appears similar to the predicate tests that appear on the left-hand side of productions, but has very different meaning. Predicates cannot be used on the right-hand side of a production and you cannot restrict the bindings of variables on the right-hand side of a production. (Such restrictions can happen only in the conditions.)</p> <p>Also notice that the + symbol is optional when specifying <code>acceptable</code> preferences in the actions of a production, although using this symbol will make the semantics of your productions clearer in many instances. The <code>+</code> symbol will always appear when you inspect preference memory (with the <code>preferences</code> command).</p> <p>Productions are never needed to delete preferences because preferences will be retracted when the production no longer matches. Preferences should never be created by operator application rules, and they should always be created by rules that will give only i-support to their actions.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#shorthand-notations-for-preference-creation","title":"Shorthand notations for preference creation","text":"<p>There are a few shorthand notations allowed for the creation of operator preferences on the right-hand side of productions.</p> <p>Acceptable preferences do not need to be specified with a+symbol.<code>(&lt;s&gt; ^operator &lt;op1&gt;)</code> is assumed to mean <code>(&lt;s&gt; ^operator &lt;op1&gt; +)</code>.</p> <p>Note however that the+is only implicit if no other preferences are specified for that operator. Specifying a preference that is not the <code>acceptable</code> preference does not also imply an acceptable preference. For example, <code>(&lt;s&gt; ^operator &lt;op1&gt; &gt; )</code> by itself cannot lead to <code>&lt;op1&gt;</code> being selected, since it does not have an <code>acceptable</code> preference.</p> <p>Ambiguity can easily arise when using a preference that can be either binary or unary: <code>&gt; &lt; =</code>. The default assumption is that if a value follows the preference, then the preference is binary. It will be unary if a caret (up-arrow), a closing parenthesis, another preference, or a comma follows it.</p> <p>Below are four examples of legal, although unrealistic, actions that have the same effect.</p> <pre><code>(&lt;s&gt; ^operator &lt;o1&gt; &lt;o2&gt; + &lt;o2&gt; &lt; &lt;o1&gt; &lt;o3&gt; =, &lt;o4&gt;)\n(&lt;s&gt; ^operator &lt;o1&gt; + &lt;o2&gt; +\n   &lt;o2&gt; &lt; &lt;o1&gt; &lt;o3&gt; =, &lt;o4&gt; +)\n(&lt;s&gt; ^operator &lt;o1&gt; &lt;o2&gt; &lt;o2&gt; &lt; &lt;o1&gt; &lt;o4&gt; &lt;o3&gt; =)\n(&lt;s&gt; ^operator &lt;o1&gt; ^operator &lt;o2&gt;\n   ^operator &lt;o2&gt; &lt; &lt;o1&gt; ^operator &lt;o4&gt; &lt;o3&gt; =)\n</code></pre> <p>Any one of those actions could be expanded to the following list of preferences:</p> <pre><code>(&lt;s&gt; ^operator &lt;o1&gt; +)\n(&lt;s&gt; ^operator &lt;o2&gt; +)\n(&lt;s&gt; ^operator &lt;o2&gt; &lt; &lt;o1&gt;)\n(&lt;s&gt; ^operator &lt;o3&gt; =)\n(&lt;s&gt; ^operator &lt;o4&gt; +)\n</code></pre> <p>Note that structured-value notation may not be used in the actions of productions.</p> <p>Commas are only allowed in rule syntax for this sort of use, in the RHS. They can be used to separate actions, and if used when no disambiguation is needed will have no effect other than syntactic sugar.</p> <p>As another example, <code>(&lt;s&gt; ^operator &lt;o1&gt; &lt;o2&gt; &gt; &lt;o3&gt;)</code> would be interpreted as</p> <pre><code>(&lt;s&gt; ^operator &lt;o1&gt; +\n^operator &lt;o2&gt; &gt; &lt;o3&gt;)\n</code></pre> <p>But <code>(&lt;s&gt; ^operator &lt;o1&gt; &lt;o2&gt; &gt;, &lt;o3&gt;)</code> would be interpreted as</p> <pre><code>(&lt;s&gt; ^operator &lt;o1&gt; +\n   ^operator &lt;o2&gt; &gt;\n   ^operator &lt;o3&gt; +)\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#right-hand-side-functions","title":"Right-hand side Functions","text":"<p>The fourth type of action that can occur in productions is called a right-hand side function. Right-hand side functions allow productions to create side effects other than changing working memory. The RHS functions are described below, organized by the type of side effect they have.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#stopping-and-pausing-soar","title":"Stopping and pausing Soar","text":"<p>halt \u2014 Terminates Soar\u2019s execution and returns to the user prompt. A <code>halt</code> action irreversibly terminates the running of a Soar program. It should not be used if the agent is to be restarted (see the <code>interrupt</code> RHS action below.)</p> <pre><code>sp {\n   ...\n   --&gt;\n   (halt) }\n</code></pre> <p>interrupt \u2014 Executing this function causes Soar to stop at the end of the current phase, and return to the user prompt. This is similar to halt, but does not terminate the run. The run may be continued by issuing a run command from the user interface. The interrupt RHS function has the same effect as typing stop-soar at the prompt, except that there is more control because it takes effect exactly at the end of the phase that fires the production.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (interrupt) }\n</code></pre> <p>Soar execution may also be stopped immediately before a production fires, using the <code>:interrupt</code> directive. This functionality is called a matchtime interrupt and is very useful for debugging. See 'sp' command for more information.</p> <pre><code>sp {production*name\n   :interrupt\n   ...\n   --&gt;\n   ...}\n</code></pre> <p>wait \u2014 Executing this function causes the current Soar thread to sleep for the given integer number of milliseconds.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (wait 1000) }\n</code></pre> <p>Note that use of this function is discouraged.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#text-input-and-output","title":"Text input and output","text":"<p>These functions are provided as production actions to do simple output of text in Soar. Soar applications that do extensive input and output of text should use Soar Markup Language (SML). To learn about SML, read the \"SML Quick Start Guide\" which should be located in the \"Documentation\" folder of your Soar install.</p> <p>write \u2014 This function writes its arguments to the standard output. It does not automatically insert blanks, line feeds, or carriage returns. For example, if <code>&lt;o&gt;</code> is bound to 4, then</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write &lt;o&gt; &lt;o&gt; &lt;o&gt; | x| &lt;o&gt; | | &lt;o&gt;) }\n</code></pre> <p>prints</p> <pre><code>444 x4 4\n</code></pre> <p>crlf \u2014 Short for \"carriage return, line feed\", this function can be called only within <code>write</code>. It forces a new line at its position in the write action.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write &lt;x&gt; (crlf) &lt;y&gt;) }\n</code></pre> <p>log \u2014 This function is equivalent to the <code>write</code> function, except that it specifies a \"log channel\" for output. The output will only show if that channel is active. The function takes two arguments. First is an integer corresponding to the channel level for output, second is the message to print. See the 'output` command for information about agent log channels.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (log 3 |This only prints when agent-logs channel 3 is enabled.|) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#mathematical-functions","title":"Mathematical functions","text":"<p>The expressions described in this section can be nested to any depth. For all of the functions in this section, missing or non-numeric arguments result in an error.</p> <p>+, -, *, / \u2014 These symbols provide prefix notation mathematical functions. These symbols work similarly to C functions. They will take either integer or real-number arguments. The first three functions return an integer when all arguments are integers and otherwise return a real number, and the last two functions always return a real number. These functions can each take any number of arguments, and will return the result of sequentially operating on each argument. The <code>-</code> symbol is also a unary function which, given a single argument, returns the product of the argument and -1. The <code>/</code> symbol is also a unary function which, given a single argument, returns the reciprocal of the argument <code>(1/x)</code>.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^sum (+ &lt;x&gt; &lt;y&gt;)\n      ^product-sum (* (+ &lt;v&gt; &lt;w&gt;) (+ &lt;x&gt; &lt;y&gt;))\n      ^big-sum (+ &lt;x&gt; &lt;y&gt; &lt;z&gt; 402)\n      ^negative-x (- &lt;x&gt;))}\n</code></pre> <p>div, mod \u2014 These symbols provide prefix notation binary mathematical functions (they each take two arguments). These symbols work similarly to C functions: They will take only integer arguments (using reals results in an error) and return an integer: div takes two integers and returns their integer quotient; mod returns their remainder.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^quotient (div &lt;x&gt; &lt;y&gt;)\n   ^remainder (mod &lt;x&gt; &lt;y&gt;)) }\n</code></pre> <p>abs, atan2, sqrt, sin, cos \u2014 These provide prefix notation unary mathematical functions (they each take one argument). These symbols work similarly to C functions:</p> <p>They will take either integer or real-number arguments. The first function (<code>abs</code>) returns an integer when its argument is an integer and otherwise returns a real number, and the last four functions always return a real number. <code>atan2</code> returns as a float in radians, the arctangent of (first_arg / second_arg).sin and cos take as arguments the angle in radians.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^abs-value (abs &lt;x&gt;)\n      ^sqrt (sqrt &lt;x&gt;)) }\n</code></pre> <p>min, max \u2014 These symbols provide n-ary mathematical functions (they each take a list of symbols as arguments). These symbols work similarly to C functions. They take either integer or real-number arguments, and return a real-number value if any of their arguments are real-numbers. Otherwise they return integers.</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^max (max &lt;x&gt; 3.14 &lt;z&gt;)\n      ^min (min &lt;a&gt; &lt;b&gt; 42 &lt;c&gt;)) }\n</code></pre> <p>set-[count, sum, multiply, min, max, range, mean, stdev]</p> <p>These provide mathematical functions of sets stored as multi-valued attributes. Each takes two arguments: the first is the WME ID containing the set attribute, and the second is the name of the WME's multi-valued attribute containing the set.</p> <p><code>set-count</code> returns the number of elements in the set, and the elements of the set do not necessarily need to be numeric.</p> <p>In contrast, the rest of the functions operate only on numeric values. They ignore all non-numeric (int, float) set members, and return <code>|NaN|</code> if the set is empty or contains no numeric members. If there is an issue with the parameters, all of the functions (including <code>set-count</code>) return a string containing an error message.</p> <p><code>set-range</code> returns the maximum value minus the minimum value.</p> <p><code>set-stdev</code> returns the standard deviation of the set.</p> <pre><code>sp { propose*math\n    (state &lt;s&gt; ^superstate nil)\n    (&lt;s&gt; -^results &lt;any&gt;)\n    --&gt;\n    (&lt;s&gt; ^operator &lt;o&gt; +\n        ^operator &lt;o&gt; =)\n    (&lt;o&gt; ^name do-math ^vals 100 ^vals 200 ^vals 40 ^vals -59)\n}\nsp { apply*math\n    (state &lt;s&gt; ^operator &lt;o&gt;)\n    (&lt;o&gt; ^name do-math)\n    --&gt;\n    (&lt;s&gt; ^results done)\n    (write |count: |(set-count &lt;o&gt; vals)\n        |, sum: | (set-sum &lt;o&gt; vals)\n        |, multiply: | (set-multiply &lt;o&gt; vals)\n        |, min: | (set-min &lt;o&gt; vals)\n        |, max: | (set-max &lt;o&gt; vals)\n        |, range: | (set-range &lt;o&gt; vals)\n        |, mean: | (set-mean &lt;o&gt; vals)\n        |, stdev: | (set-stdev &lt;o&gt; vals))\n    }\nstep 2\n</code></pre> <p>The above prints the following to the console:</p> <pre><code>1:    O: O1 (do-math)count: 4, sum: 281.000000,\nmultiply: -47200000.000000, min: -59.000000,\nmax: 200.000000, range: 259.000000,\nmean: 70.250000, stdev: 93.995678\n</code></pre> <p>int \u2014 Converts a single symbol to an integer constant. This function expects either an integer constant, symbolic constant, or floating point constant. The symbolic constant must be a string which can be interpreted as a single integer. The floating point constant is truncated to only the integer portion. This function essentially operates as a type casting function. For example, the expression \\(2 + \\sqrt(6)\\) could be printed as an integer using the following:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write (+ 2 (int sqrt(6))) ) }\n</code></pre> <p>float \u2014 Converts a single symbol to a floating point constant. This function expects either an integer constant, symbolic constant, or floating point constant. The symbolic constant must be a string which can be interpreted as a single floating point number. This function essentially operates as a type casting function. For example, if you wanted to print out an integer expression as a floating-point number, you could do the following:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write (float (+ 2 3))) }\n</code></pre> <p>ifeq \u2014 Conditionally return a symbol. This function takes four arguments. It returns the third argument if the first two are equal and the fourth argument otherwise. Note that symbols of different types will always be considered unequal. For example, 1.0 and 1 will be unequal because the first is a float and the second is an integer.</p> <pre><code>sp {example-rule\n   (state &lt;s&gt; ^a &lt;a&gt; ^b &lt;b&gt;)\n   ...\n   --&gt;\n   (write (ifeq &lt;a&gt; &lt;b&gt; equal not-equal)) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#generating-and-manipulating-symbols","title":"Generating and manipulating symbols","text":"<p>A new symbol (an identifier) is generated on the right-hand side of a production whenever a previously unbound variable is used. This section describes other ways of generating and manipulating symbols on the right-hand side.</p> <p>capitalize-symbol \u2014 Given a symbol, this function returns a new symbol with the first character capitalized. This function is provided primarily for text output, for example, to allow the first word in a sentence to be capitalized.</p> <pre><code>(capitalize-symbol foo)\n</code></pre> <p>compute-heading \u2014 This function takes four real-valued arguments of the form \\((x_1, y_1, x_2, y_2)\\), and returns the direction (in degrees) from \\((x_1, y_1)\\) to \\((x_2, y_2)\\), rounded to the nearest integer.</p> <p>For example:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^heading (compute-heading 0 0.5 32.5 28)) }\n</code></pre> <p>After this rule fires, working memory would look like:</p> <pre><code>(S1 ^heading 48).\n</code></pre> <p>compute-range \u2014 This function takes four real-valued arguments of the form \\((x_1, y_1, x_2, y_2)\\), and returns the distance from \\((x_1, y_1)\\) to \\((x_2, y_2)\\), rounded to the nearest integer.</p> <p>For example:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^distance (compute-range 0 0.5 32.5 28)) }\n</code></pre> <p>After this rule fires, working memory would look like:</p> <pre><code>(S1 ^distance 42).\n</code></pre> <p>concat \u2014 Given an arbitrary number of symbols, this function concatenates them together into a single constant symbol. For example:</p> <pre><code>sp {example\n   (state &lt;s&gt; ^type state)\n   --&gt;\n   (&lt;s&gt; ^name (concat foo bar (+ 2 4))) }\n</code></pre> <p>After this rule fires, the WME <code>(S1 ^name foobar6)</code> will be added.</p> <p>deep-copy \u2014 This function returns a copy of the given symbol along with linked copies of all descendant symbols. In other terms, a full copy is made of the working memory subgraph that can be reached when starting from the given symbol. All copied identifiers are created as new IDs, and all copied values remain the same. For example:</p> <pre><code>sp {\n   (state &lt;s&gt; ^tree &lt;t&gt;)\n   (&lt;t&gt; ^branch1 foo ^branch2 &lt;b&gt;)\n   (&lt;b&gt; ^branch3 &lt;t&gt;)\n   --&gt;\n   (&lt;s&gt; ^tree-copy (deep-copy &lt;t&gt;)) }\n</code></pre> <p>After this rule fires, the following structure would exist:</p> <pre><code>(S1 ^tree T1 ^tree-copy D1)\n   (T1 ^branch1 foo ^branch2 B1)\n      (B1 ^branch3 T1)\n(D1 ^branch1 foo ^branch2 B2)\n   (B2 ^branch3 D1)\n</code></pre> <p>dc \u2014 This function takes no arguments, and returns the integer number of the current decision cycle. For example:</p> <pre><code>sp {example\n   (state &lt;s&gt; ^type state)\n   --&gt;\n   (&lt;s&gt; ^dc-count (dc) }\n</code></pre> <p>@ (get) \u2014 This function returns the LTI number of the given ID. If the given ID is not linked to an LTI, it does nothing. For example:</p> <pre><code>sp {example\n   (state &lt;s&gt; ^stm &lt;l1&gt;)\n   --&gt;\n   (&lt;s&gt; ^lti-num (@ &lt;l1&gt;) }\n</code></pre> <p>After this rule fires, the <code>(S1 ^lti-num)</code> WME will have an integer value such as 42.</p> <p>link-stm-to-ltm \u2014 This function takes two arguments. It links the first given symbol to the LTI indicated by the second integer value.</p> <p>For example:</p> <pre><code>sp {example\n   (state &lt;s&gt; ^stm &lt;l1&gt;)\n   --&gt;\n   (link-stm-to-ltm &lt;l1&gt; 42) }\n</code></pre> <p>After this rule fires, the WME <code>(S1 ^stm &lt;l1&gt;)</code> will be linked to <code>@42</code>.</p> <p>make-constant-symbol \u2014 This function returns a new constant symbol guaranteed to be different from all symbols currently present in the system. With no arguments, it returns a symbol whose name starts with <code>\"constant\"</code>. With one or more arguments, it takes those argument symbols, concatenates them, and uses that as the prefix for the new symbol. (It may also append a number to the resulting symbol, if a symbol with that prefix as its name already exists.)</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^new-symbol (make-constant-symbol)) }\n</code></pre> <p>When this production fires, it will create an augmentation in working memory such as:</p> <pre><code>(S1 ^new-symbol constant5)\n</code></pre> <p>The production:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^new-symbol (make-constant-symbol &lt;s&gt; )) }\n</code></pre> <p>will create an augmentation in working memory such as:</p> <pre><code>(S1 ^new-symbol |S14|)\n</code></pre> <p>when it fires. The vertical bars denote that the symbol is a constant, rather than an identifier; in this example, the number 4 has been appended to the symbol S1. This can be particularly useful when used in conjunction with the <code>timestamp</code> function; by using <code>timestamp</code> as an argument to <code>make-constant-symbol</code>, you can get a new symbol that is guaranteed to be unique. For example:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^new-symbol (make-constant-symbol (timestamp))) }\n</code></pre> <p>When this production fires, it will create an augmentation in working memory such as:</p> <pre><code>(S1 ^new-symbol 8/1/96-15:22:49)\n</code></pre> <p>rand-float \u2014 This function takes an optional positive real-valued argument. If no argument (or a negative argument) is given, it returns a random real-valued number in the range \\([0. 0 , 1 .0]\\). Otherwise, given a value n, it returns a number in the range \\([0. 0 ,n]\\).</p> <p>For example:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^fate (rand-float 1000)) }\n</code></pre> <p>After this rule fires, working memory might look like: <code>(S1 ^fate 275.481802)</code>.</p> <p>rand-int \u2014 This function takes an optional positive integer argument. If no argument (or a negative argument) is given, it returns a random integer number in the range \\([-2^{31} , 2^{31}]\\). Otherwise, given a value n, it returns a number in the range \\([0,n]\\). For example:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (&lt;s&gt; ^fate (rand-int 1000)) }\n</code></pre> <p>After this rule fires, working memory might look like: <code>(S1 ^fate 13)</code>.</p> <p>round-off \u2014 This function returns the first given value rounded to the nearest multiple of the second given value. Values must be integers or real-numbers.</p> <p>For example:</p> <pre><code>sp {\n   (state &lt;s&gt; ^pi &lt;pi&gt;\n   --&gt;\n   (&lt;s&gt; ^pie (round-off &lt;pi&gt; 0.1)) }\n</code></pre> <p>After this rule fires, working memory might look like: <code>(S1 ^pi 3.14159 ^pie 3.1)</code>.</p> <p>round-off-heading \u2014 This function is the same as round-off, but additionally shifts the returned value by multiples of 360 such that \\(-360 \\le value \\le 360\\). For example:</p> <pre><code>sp {\n   (state &lt;s&gt; ^heading &lt;dir&gt;\n   --&gt;\n   (&lt;s&gt; ^true-heading (round-off-heading &lt;dir&gt; 0.5)) }\n</code></pre> <p>After this rule fires, working memory might look like: <code>(S1 ^heading 526.432 ^true-heading 166.5)</code>.</p> <p>size \u2014 This function returns an integer symbol whose value is the count of WME augmentations on a given ID argument. Providing a non-ID argument results in an error. For example:</p> <pre><code>sp {\n   (state &lt;s&gt; ^numbers &lt;n&gt;)\n   (&lt;n&gt; ^1 1 ^10 10 ^100 100)\n   --&gt;\n   (&lt;s&gt; ^augs (size &lt;n&gt;)) }\n</code></pre> <p>After this rule fires, the value of <code>S1 ^augs</code> would be 3. Note that some architecturally-maintained IDs such as <code>(&lt;s&gt; ^epmem)</code> and <code>(&lt;s&gt; ^io)</code> are not counted by the <code>size</code> function.</p> <p>strlen \u2014 This function returns an integer symbol whose value is the size of the given string symbol. For example:</p> <pre><code>sp {\n   (state &lt;s&gt; ^io.input-link.message &lt;m&gt;)\n   ...\n   --&gt;\n   (&lt;s&gt; ^message-len (strlen &lt;m&gt;)) }\n</code></pre> <p>timestamp \u2014 This function returns a symbol whose print name is a representation of the current date and time. For example:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write (timestamp)) }\n</code></pre> <p>When this production fires, it will print out a representation of the current date and time, such as:</p> <pre><code>soar&gt; run 1 e\n2018-09-26 14:36:39.375\n</code></pre> <p>trim \u2014 This function takes a single string symbol argument and returns the same string with leading and trailing whitespace removed. For example:</p> <pre><code>sp {\n   (state &lt;s&gt; ^message &lt;m&gt;)\n   --&gt;\n   (&lt;s&gt; ^trimmed (trim &lt;m&gt;)) }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#user-defined-functions-and-interface-commands-as-rhs-actions","title":"User-defined functions and interface commands as RHS actions","text":"<p>Any function with a certain signature may be registered with the Kernel (e.g. using SML) and called as an RHS function. RHS functions receive a single string argument and return a single string which is assigned to a symbol in Soar.</p> <p>RHS functions are most complex in C/C++ due to the requirements of memory management. An RHS function must adhere to the signature of <code>RHSEventHandler</code>:</p> <pre><code>char const _(smlRhsEventId id, void_ pUserData, Agent* pAgent,\nchar const* pFunctionName, char const* pArgument,\nint *buffSize, char *buff)\n</code></pre> <p>The function must fill <code>*buff</code> with the string to be returned and then return <code>*buff</code>, but only if <code>*buffSize</code> indicates there is enough room to hold the string. If <code>*buffSize</code> is not large enough, the function must return <code>NULL</code> and set <code>*buffSize</code> to the required size. Soar will then allocate a buffer of the required size and call the function again. If calling the function twice would have an undesirable effect, the following code can be used to cache the result in between calls by Soar:</p> <pre><code>// at beginning of function:\nstatic std::string prevResult;\nif ( !prevResult.empty() )\n{\n   strncpy( buf, prevResult.c_str(), *bufSize );\n   prevResult = \"\";\n   return buf;\n}\n\n// ...\n\n// at end of function:\nif ( resultString.length() + 1 &gt; *bufSize )\n{\n   *bufSize = resultString.length() + 1;\n   prevResult = resultString;\n   return NULL;\n}\nstrcpy( buf, resultString.c_str() );\nreturn buf;\n</code></pre> <p>RHS function interfaces in other languages are much simpler. For example, in Java the signature is:</p> <pre><code>String rhsFunctionHandler(int eventID, Object data, String agentName,\n   String functionName, String argument)\n</code></pre> <p>Any arguments passed to the function on the RHS of a production are concatenated (without spaces) and passed to the function in the pArgument argument.</p> <p>Such a function can be registered with the kernel via the client interface by calling:</p> <pre><code>Kernel::AddRhsFunction(char const* pRhsFunctionName, RhsEventHandler handler, void* pUserData);\n</code></pre> <pre><code>Kernel.AddRhsFunction(String functionName, RhsFunctionInterface handlerObject, Object callbackData);\n</code></pre> <p>The <code>exec</code> and <code>cmd</code> functions are used to call user-defined functions and interface commands on the RHS of a production.</p> <p>exec \u2014 Used to call user-defined registered functions. Any arguments are concatenated without spaces. For example, if <code>&lt;o&gt;</code> is bound to <code>x</code>, then</p> <pre><code>sp {\n   ...\n   --&gt;\n   (exec MakeANote &lt;o&gt; 1) }\n</code></pre> <p>will call the user-defined <code>MakeANote</code> function with the argument \"x1\". The return value of the function, if any, may be placed in working memory or passed to another RHS function. For example, the log of a number <code>&lt;x&gt;</code> could be printed this way:</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write |The log of | &lt;x&gt; | is: | (exec log(&lt;x&gt;))|) }\n</code></pre> <p>where \"log\" is a registered user-defined function.</p> <p>cmd \u2014 Used to call built-in Soar commands. Spaces are inserted between concatenated arguments. For example, the production</p> <pre><code>sp {\n   ...\n   --&gt;\n   (write (cmd print --depth 2 &lt;s&gt;)) }\n</code></pre> <p>will have the effect of printing the object bound to <code>&lt;s&gt;</code> to depth 2.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#controlling-chunking","title":"Controlling chunking","text":"<p>Chunking is described in Chapter 4.</p> <p>The following two functions are provided as RHS actions to assist in development of Soar programs; they are not intended to correspond to any theory of learning in Soar. This functionality is provided as a development tool, so that learning may be turned off in specific problem spaces, preventing otherwise buggy behavior.</p> <p>The <code>dont-learn</code> and <code>force-learn</code> RHS actions are to be used with specific settings for the <code>chunk</code> command. Using the <code>chunk</code> command, learning may be set to one of <code>always</code>, <code>never</code>, <code>flagged</code>, or <code>unflagged</code>; chunking must be set to <code>flagged</code> for the <code>force-learn</code> RHS action to have any effect and chunking must be set to <code>unflagged</code> for the <code>dont-learn</code> RHS action to have any effect.</p> <p>dont-learn \u2014 When chunking is set to <code>unflagged</code>, by default chunks can be formed in all states; the <code>dont-learn</code> RHS action will cause chunking to be turned off for the specified state.</p> <pre><code>sp {turn-learning-off\n   (state &lt;s&gt; ^feature 1 ^feature 2 -^feature 3)\n   --&gt;\n   (dont-learn &lt;s&gt;) }\n</code></pre> <p>The <code>dont-learn</code> RHS action applies when <code>chunk</code> is set to <code>unflagged</code>, and has no effect when other settings for <code>chunk</code> are used.</p> <p>force-learn \u2014 When learning is set to <code>flagged</code>, by default chunks are not formed in any state; the <code>force-learn</code> RHS action will cause chunking to be turned on for the specified state.</p> <pre><code>sp {turn-learning-on\n   (state &lt;s&gt; ^feature 1 ^feature 2 -^feature 3)\n   --&gt;\n   (force-learn &lt;s&gt;) }\n</code></pre> <p>The <code>force-learn</code> RHS action applies when <code>chunk</code> is set to flagged, and has no effect when other settings for <code>chunk</code> are used.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#grammars-for-production-syntax","title":"Grammars for production syntax","text":"<p>This subsection contains the BNF grammars for the conditions and actions of productions. (BNF stands for Backus-Naur form or Backus normal form; consult a computer science book on theory, programming languages, or compilers for more information. However, if you don\u2019t already know what a BNF grammar is, it\u2019s unlikely that you have any need for this subsection.)</p> <p>This information is provided for advanced Soar users, for example, those who need to write their own parsers. Note that some terms (e.g.<code>&lt;symconstant&gt;</code>) are undefined; as such, this grammar should only be used as a starting point.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#grammar-of-soar-productions","title":"Grammar of Soar productions","text":"<p>A grammar for Soar productions is:</p> <pre><code>&lt;soar-production&gt;  ::= sp \"{\" &lt;production-name&gt; [&lt;documentation&gt;] [&lt;flags&gt;]\n&lt;condition-side&gt; --&gt; &lt;action-side&gt; \"}\"\n&lt;documentation&gt;    ::= \"\"\" [&lt;string&gt;] \"\"\"\n&lt;flags&gt;            ::= \":\" (o-support | i-support | chunk | default)\n</code></pre> <p>Grammar for Condition Side: Below is a grammar for the condition sides of productions:</p> <pre><code>&lt;condition-side&gt;   ::= &lt;state-imp-cond&gt; &lt;cond&gt;*\n&lt;state-imp-cond&gt;   ::= \"(\" (state | impasse) [&lt;id_test&gt;]\n&lt;attr_value_tests&gt;+ \")\"\n&lt;cond&gt;             ::= &lt;positive_cond&gt; | \"-\" &lt;positive_cond&gt;\n&lt;positive_cond&gt;    ::= &lt;conds_for_one_id&gt; | \"{\" &lt;cond&gt;+ \"}\"\n&lt;conds_for_one_id&gt; ::= \"(\" [(state|impasse)] &lt;id_test&gt;\n&lt;attr_value_tests&gt;+ \")\"\n&lt;id_test&gt;          ::= &lt;test&gt;\n&lt;attr_value_tests&gt; ::= [\"-\"] \"^\" &lt;attr_test&gt; (\".\" &lt;attr_test&gt;)*\n&lt;value_test&gt;*\n&lt;attr_test&gt;        ::= &lt;test&gt;\n&lt;value_test&gt;       ::= &lt;test&gt; [\"+\"] | &lt;conds_for_one_id&gt; [\"+\"]\n\n&lt;test&gt;             ::= &lt;conjunctive_test&gt; | &lt;simple_test&gt;\n&lt;conjunctive_test&gt; ::= \"{\" &lt;simple_test&gt;+ \"}\"\n&lt;simple_test&gt;      ::= &lt;disjunction_test&gt; | &lt;relational_test&gt;\n&lt;disjunction_test&gt; ::= \"&lt;&lt;\" &lt;constant&gt;+ \"&gt;&gt;\"\n&lt;relational_test&gt;  ::= [&lt;relation&gt;] &lt;single_test&gt;\n&lt;relation&gt;         ::= \"&lt;&gt;\" | \"&lt;\" | \"&gt;\" | \"&lt;=\" | \"&gt;=\" | \"=\" | \"&lt;=&gt;\"\n&lt;single_test&gt;      ::= &lt;variable&gt; | &lt;constant&gt;\n&lt;variable&gt;         ::= \"&lt;\" &lt;sym_constant&gt; \"&gt;\"\n&lt;constant&gt;         ::= &lt;sym_constant&gt; | &lt;int_constant&gt; | &lt;float_constant&gt;\n</code></pre> <p>Notes on the Condition Side</p> <ul> <li>In an <code>&lt;idtest&gt;</code>, only a <code>&lt;variable&gt;</code> may be used in a <code>&lt;singletest&gt;</code>.</li> </ul> <p>Grammar for Action Side: Below is a grammar for the action sides of productions:</p> <pre><code>&lt;rhs&gt;                      ::= &lt;rhs_action&gt;*\n&lt;rhs_action&gt;               ::= \"(\" &lt;variable&gt; &lt;attr_value_make&gt;+ \")\"\n| &lt;func_call&gt;\n&lt;func_call&gt;                ::= \"(\" &lt;func_name&gt; &lt;rhs_value&gt;* \")\"\n&lt;func_name&gt;                ::= &lt;sym_constant&gt; | \"+\" | \"-\" | \"*\" | \"/\"\n&lt;rhs_value&gt;                ::= &lt;constant&gt; | &lt;func_call&gt; | &lt;variable&gt;\n&lt;attr_value_make&gt;          ::= \"^\" &lt;variable_or_sym_constant&gt;\n(\".\" &lt;variable_or_sym_constant&gt;)* &lt;value_make&gt;+\n&lt;variable_or_sym_constant&gt; ::= &lt;variable&gt; | &lt;sym_constant&gt;\n&lt;value_make&gt;               ::= &lt;rhs_value&gt; &lt;preference_specifier&gt;*\n\n&lt;preference-specifier&gt;     ::= &lt;unary-preference&gt; [\",\"]\n| &lt;unary-or-binary-preference&gt; [\",\"]\n| &lt;unary-or-binary-preference&gt; &lt;rhs_value&gt; [\",\"]\n&lt;unary-pref&gt;               ::= \"+\" | \"-\" | \"!\" | \"~\"\n&lt;unary-or-binary-pref&gt;     ::= \"&gt;\" | \"=\" | \"&lt;\"\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#impasses-in-working-memory-and-in-productions","title":"Impasses in Working Memory and in Productions","text":"<p>When the preferences in preference memory cannot be resolved unambiguously, Soar reaches an impasse, as described in Section the Soar architecture:</p> <ul> <li>When Soar is unable to select a new operator (in the decision cycle), it is     said to reach an operator impasse.</li> </ul> <p>All impasses lead to the creation of a new substate in working memory, and appear as objects within that substate. These objects can be tested by productions. This section describes the structure of state objects in working memory.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#impasses-in-working-memory","title":"Impasses in working memory","text":"<p>There are four types of impasses.</p> <p>Below is a short description of the four types of impasses. (This was described in more detail in Section impasses and substates)</p> <ol> <li>tie: when there is a collection of equally eligible operators competing for     the value of a particular attribute;</li> <li>conflict: when two or more objects are better than each other, and they are     not dominated by a third operator;</li> <li>constraint-failure: when there are conflicting necessity preferences;</li> <li>no-change: when the proposal phase runs to quiescence without suggesting a     new operator.</li> </ol> <p>The list below gives the seven augmentations that the architecture creates on the substate generated when an impasse is reached, and the values that each augmentation can contain:</p> <ul> <li><code>^type state</code></li> <li> <p><code>^impasse</code> Contains the impasse type: <code>tie</code>, <code>conflict</code>,     <code>constraint-failure</code>, or <code>no-change</code>.</p> </li> <li> <p><code>^choices</code> Either <code>multiple</code> (for tie and conflict impasses),     <code>constraint-failure</code> (for constraint-failure impasses), or <code>none</code> (for     constraint-failure or no-change impasses).</p> </li> <li> <p><code>^superstate</code> Contains the identifier of the state in which the impasse     arose.</p> </li> <li> <p><code>^attribute</code> For multi-choice and constraint-failure impasses, this contains     <code>operator</code>. For no-change impasses, this contains the attribute of the last     decision with a value (<code>state</code> or <code>operator</code>).</p> </li> <li> <p><code>^item</code> For multi-choice and constraint-failure impasses, this contains all     values involved in the tie, conflict, or constraint-failure. If the set of     items that tie or conflict changes during the impasse, the architecture     removes or adds the appropriate item augmentations without terminating the     existing impasse.</p> </li> <li> <p><code>^item-count</code> For multi-choice and constraint-failure impasses, this     contains the number of values listed under the item augmentation above.</p> </li> <li> <p><code>^non-numeric</code> For tie impasses, this contains all operators that do not     have numeric indifferent preferences associated with them. If the set of     items that tie changes during the impasse, the architecture removes or adds     the appropriate non-numeric augmentations without terminating the existing     impasse.</p> </li> <li> <p><code>^non-numeric-count</code> For tie impasses, this contains the number of operators     listed under the non-numeric augmentation above.</p> </li> <li> <p><code>^quiescence</code> States are the only objects with <code>quiescence t</code>, which is an     explicit statement that quiescence (exhaustion of the elaboration cycle) was     reached in the superstate. If problem solving in the subgoal is contingent     on quiescence having been reached, the substate should test this flag. The     side-effect is that no chunk will be built if it depended on that test. See     Problem Solving that does not test Superstate     for details. This attribute can be ignored when learning is turned off.</p> </li> </ul> <p>Knowing the names of these architecturally defined attributes and their possible values will help you to write productions that test for the presence of specific types of impasses so that you can attempt to resolve the impasse in a manner appropriate to your program. Many of the default productions in the demos/defaults directory of the Soar distribution provide means for resolving certain types of impasses. You may wish to make use of some of all of these productions or merely use them as guides for writing your own set of productions to respond to impasses.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#examples","title":"Examples","text":"<p>The following is an example of a substate that is created for a tie among three operators:</p> <pre><code>(S12 ^type state ^impasse tie ^choices multiple ^attribute operator\n   ^superstate S3 ^item O9 O10 O11 ^quiescence t)\n</code></pre> <p>The following is an example of a substate that is created for a no-change impasse to apply an operator:</p> <pre><code>(S12 ^type state ^impasse no-change ^choices none ^attribute operator\n   ^superstate S3 ^quiescence t)\n(S3 ^operator O2)\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#testing-for-impasses-in-productions","title":"Testing for impasses in productions","text":"<p>Since states appear in working memory, they may also be tested for in the conditions of productions.</p> <p>For example, the following production tests for a constraint-failure impasse on the top-level state.</p> <pre><code>sp {default*top-goal*halt*operator*failure\n   \"Halt if no operator can be selected for the top goal.\"\n   :default\n   (state &lt;ss&gt; ^impasse constraint-failure ^superstate &lt;s&gt;)\n   (&lt;s&gt; ^superstate nil)\n   --&gt;\n   (write (crlf) |No operator can be selected for top goal.| )\n   (write (crlf) |Soar will halt now. Goodnight.| )\n   (halt)\n   }\n</code></pre>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#soar-io-input-and-output-in-soar","title":"Soar I/O: Input and Output in Soar","text":"<p>Many Soar users will want their programs to interact with a real or simulated environment. For example, Soar programs could control a robot, receiving sensory inputs and sending command outputs. Soar programs might also interact with simulated environments, such as a flight simulator. The mechanisms by which Soar receives inputs and sends outputs to an external process is called Soar I/O.</p> <p>This section describes how input and output are represented in working memory and in productions. Interfacing with a Soar agent through input and output can be done using the SML. The details of designing an external process that uses SML to create the input and respond to output from Soar are beyond the scope of this manual, but they are described in the SML quick start guide. This section is provided for the sake of Soar users who will be making use of a program that has already been implemented, or for those who would simply like to understand how I/O works in Soar.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#overview-of-soar-io","title":"Overview of Soar I/O","text":"<p>When Soar interacts with an external environment, it must make use of mechanisms that allow it to receive input from that environment and to effect changes in that environment. An external environment may be the real world or a simulation; input is usually viewed as Soar\u2019s perception and output is viewed as Soar\u2019s motor abilities.</p> <p>Soar I/O is accomplished via input functions and output functions. Input functions are called at the start of every execution cycle, and add elements directly to specific input structures in working memory. These changes to working memory may change the set of productions that will fire or retract. Output functions are called at the end of every execution cycle and are processed in response to changes to specific output structures in working memory. An output function is called only if changes have been made to the output-link structures in working memory.</p> <p>The structures for manipulating input and output in Soar are linked to a predefined attribute of the top-level state, called the io attribute. The io attribute has substructure to represent sensor inputs from the environment called input links; because these are represented in working memory, Soar productions can match against input links to respond to an external situation. Likewise, the io attribute has substructure to represent motor commands, called output links. Functions that execute motor commands in the environment use the values on the output links to determine when and how they should execute an action. Generally, input functions create and remove elements on the input link to update Soar\u2019s perception of the environment. Output functions respond to values of working memory elements that appear on Soar\u2019s output link structure.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#input-and-output-in-working-memory","title":"Input and output in working memory","text":"<p>All input and output is represented in working memory as substructure of the io attribute of the top-level state. By default, the architecture creates an <code>input-link</code> attribute of the io object and an <code>output-link</code> attribute of the io object. The values of the <code>input-link</code> and <code>output-link</code> attributes are identifiers whose augmentations are the complete set of input and output working memory elements, respectively. Some Soar systems may benefit from having multiple input and output links, or that use names which are more descriptive of the input or output function, such as <code>vision-input-link</code>, <code>text-input-link</code>, or <code>motor-output-link</code>. In addition to providing the default io substructure, the architecture allows users to create multiple input and output links via productions and I/O functions. Any identifiers for io substructure created by the user will be assigned at run time and are not guaranteed to be the same from run to run. Therefore users should always employ variables when referring to input and output links in productions.</p> <p>Suppose a blocks-world task is implemented using a robot to move actual blocks around, with a camera creating input to Soar and a robotic arm executing command outputs.</p> <p>The camera image might be analyzed by a separate vision program; this program could have as its output the locations of blocks on an xy plane. The Soar input function could take the output from the vision program and create the following working memory elements on the input link (all identifiers are assigned at runtime; this is just an example of possible bindings):</p> <pre><code>(S1 ^io I1)          [A]\n(I1 ^input-link I2)  [A]\n(I2 ^block B1)\n(I2 ^block B2)\n(I2 ^block B3)\n(B1 ^x-location 1)\n(B1 ^y-location 0)\n(B1 ^color red)\n(B2 ^x-location 2)\n(B2 ^y-location 0)\n(B2 ^color blue)\n(B3 ^x-location 3)\n(B3 ^y-location 0)\n(B3 ^color yellow)\n</code></pre> An example portion of the input link for the blocks-world task. <p>The \u2019[A]\u2019 notation in the example is used to indicate the working memory elements that are created by the architecture and not by the input function. This configuration of blocks corresponds to all blocks on the table, as illustrated in the initial state in Figure 2.2.</p> <p>Then, during the Apply Phase of the execution cycle, Soar productions could respond to an operator, such as \"move the red block ontop of the blue block\" by creating a structure on the output link, such as:</p> <pre><code>(S1 ^io I1)          [A]\n(I1 ^output-link I3) [A]\n(I3 ^name move-block)\n(I3 ^moving-block B1)\n(I3 ^x-destination 2)\n(I3 ^y-destination 1)\n(B1 ^x-location 1)\n(B1 ^y-location 0)\n(B1 ^color red)\n</code></pre> An example portion of the output link for the blocks-world task. <p>An output function would look for specific structure in this output link and translate this into the format required by the external program that controls the robotic arm. Movement by the robotic arm would lead to changes in the vision system, which would later be reported on the input-link.</p> <p>Input and output are viewed from Soar\u2019s perspective. An input function adds or deletes augmentations of the <code>input-link</code> providing Soar with information about some occurrence external to Soar. An output function responds to substructure of the <code>output-link</code> produced by production firings, and causes some occurrence external to Soar. Input and output occur through the io attribute of the top-level state exclusively.</p> <p>Structures placed on the input-link by an input function remain there until removed by an input function. During this time, the structure continues to provide support for any production that has matched against it. The structure does not cause the production to rematch and fire again on each cycle as long as it remains in working memory; to get the production to refire, the structure must be removed and added again.</p>"},{"location":"soar_manual/03_SyntaxOfSoarPrograms/#input-and-output-in-production-memory","title":"Input and output in production memory","text":"<p>Productions involved in input will test for specific attributes and values on the input-link, while productions involved in output will create preferences for specific attributes and values on the output link. For example, a simplified production that responds to the vision input for the blocks task might look like this:</p> <pre><code>sp {blocks-world*elaborate*input\n   (state &lt;s&gt; ^io.input-link &lt;in&gt;)\n   (&lt;in&gt; ^block &lt;ib1&gt;)\n   (&lt;ib1&gt; ^x-location &lt;x1&gt; ^y-location &lt;y1&gt;)\n   (&lt;in&gt; ^block {&lt;ib2&gt; &lt;&gt; &lt;ib1&gt;})\n   (&lt;ib2&gt; ^x-location &lt;x1&gt; ^y-location {&lt;y2&gt; &gt; &lt;y1&gt;})\n   --&gt;\n   (&lt;s&gt; ^block &lt;b1&gt;)\n   (&lt;s&gt; ^block &lt;b2&gt;)\n   (&lt;b1&gt; ^x-location &lt;x1&gt; ^y-location &lt;y1&gt; ^clear no)\n   (&lt;b2&gt; ^x-location &lt;x1&gt; ^y-location &lt;y2&gt; ^above &lt;b1&gt;)\n}\n</code></pre> <p>This production \"copies\" two blocks and their locations directly to the top-level state. It also adds information about the relationship between the two blocks. The variables used for the blocks on the RHS of the production are deliberately different from the variable name used for the block on the input-link in the LHS of the production. If the variable were the same, the production would create a link into the structure of the input-link, rather than copy the information. The attributes <code>x-location</code> and <code>y-location</code> are assumed to be values and not identifiers, so the same variable names may be used to do the copying.</p> <p>A production that creates WMEs on the output-link for the blocks task might look like this:</p> <pre><code>sp {blocks-world*apply*move-block*send-output-command\n   (state &lt;s&gt; ^operator &lt;o&gt; ^io.output-link &lt;out&gt;)\n   (&lt;o&gt; ^name move-block ^moving-block &lt;b1&gt; ^destination &lt;b2&gt;)\n   (&lt;b1&gt; ^x-location &lt;x1&gt; ^y-location &lt;y1&gt;)\n   (&lt;b2&gt; ^x-location &lt;x2&gt; ^y-location &lt;y2&gt;)\n   --&gt;\n   (&lt;out&gt; ^move-block &lt;b1&gt;\n      ^x-destination &lt;x2&gt; ^y-destination (+ &lt;y2&gt; 1))\n   }\n</code></pre> <p>This production would create substructure on the output-link that the output function could interpret as being a command to move the block to a new location.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/","title":"Procedural Knowledge Learning","text":""},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#procedural-knowledge-learning","title":"Procedural Knowledge Learning","text":""},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#chunking","title":"Chunking","text":"<p>Chunking is Soar\u2019s experience-based mechanism for learning new procedural knowledge. Chunking utilizes Soar\u2019s impasse-driven model of problem decomposition into sub-goals to create new productions dynamically during task execution. These new productions, called chunks, summarize the substate problem-solving that occurred which led to new knowledge in a superstate. Whenever a rule fires and creates such new superstate knowledge, which are called results, Soar learns a new rule and immediately adds it to production memory. In future similar situations, the new chunk will fire and create the appropriate results in a single step, which eliminates the need to spawn another subgoal to perform similar problem-solving. In other words, rather than contemplating and figuring out what to do, the agent immediately knows what to do.</p> <p>Chunking can effect both speed-up and transfer learning. A chunk can effect speed-up learning because it compresses all of the problem-solving needed to produce a result into a single step. For some real-world agents, hundreds of rule firings can be compressed into a single rule firing. A chunk can effect transfer learning because it generalizes the problem-solving in such a way that it can apply to other situations that are similar but have not yet been experienced by the agent.</p> <p>Chunks are created whenever one subgoal creates a result in a superstate; since most Soar programs are continuously sub-goaling and returning results to higher-level states, chunks are typically created continuously as Soar runs. Note that Soar builds the chunk as soon as the result is created, rather than waiting until the impasse is resolved.</p> <p>While chunking is a core capability of Soar, procedural learning is disabled by default. Refer to the following CLI commands for more information about enabling and using chunking:</p> <ol> <li>chunk</li> <li>trace</li> <li>explain</li> <li>visualize</li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#explanation-based-behavior-summarization","title":"Explanation-based Behavior Summarization","text":"<p>Explanation-based behavior summarization (EBBS) improves on generality and correctness issues in previous versions of chunking. EBBS learns general rules with the full expressive power of hand-written rules.</p> <p>The following side-by-side code comparison shows an example of an explanation-based chunk and how it differs from a chunk learned from the original algorithm. It is interesting to note that in Soar 9.4, the arithmetic agent learns 1263 rules like the one on the left-side of the figure. In Soar 9.6, the same agent only learns 8 rules like the one on the right because they are so much more general.</p> Soar 9.4.0 chunk<pre><code>sp {chunk-94*process-column*apply\n   (state &lt;s1&gt; ^operator &lt;o1&gt;\n           ^arithmetic-problem &lt;a1&gt;\n           ^one-fact 1\n\n           ^top-state &lt;s1&gt;\n           ^arithmetic &lt;a2&gt;\n           ^arithmetic &lt;a3&gt;)\n   (&lt;o1&gt; ^name process-column)\n   (&lt;a1&gt; ^operation subtraction\n          ^current-column &lt;c1&gt;)\n   (&lt;c1&gt; -^new-digit1 &lt;n1&gt;\n           ^digit1 0\n           ^digit2 7\n           ^next-column &lt;n2&gt;)\n   (&lt;n2&gt; ^digit1 0\n           ^new-digit1 9\n           ^next-column &lt;n3&gt;)\n   (&lt;n3&gt; ^digit1 5\n           ^new-digit1 4)\n   (&lt;a2&gt; ^subtraction-facts &lt;s2&gt;\n           ^subtraction-facts &lt;s3&gt;\n           ^subtraction-facts &lt;s4&gt;)\n   (&lt;a3&gt; ^add10-facts &lt;a4&gt;)\n\n   (&lt;a4&gt; ^digit1 0\n           ^digit-10 10)\n\n\n   (&lt;s2&gt; ^digit1 10 ^digit2 1\n           ^result 9)\n   (&lt;s3&gt; ^digit1 5 ^digit2 1\n           ^result 4)\n   (&lt;s4&gt; ^digit1 10 ^digit2 7\n           ^result 3)\n   --&gt;\n   (&lt;c1&gt; ^result 3)}\n</code></pre> Soar 9.6.0 explanation-based chunk<pre><code>sp {chunk-96*process-column*apply\n   (state &lt;s1&gt; ^operator &lt;o1&gt;\n           ^arithmetic-problem &lt;a1&gt;\n           ^one-fact &lt;o2&gt;\n           ^one-fact &lt;o3&gt;\n           ^top-state &lt;t1&gt;\n           ^arithmetic &lt;a2&gt;\n           ^arithmetic &lt;a3&gt;)\n   (&lt;o1&gt; ^name process-column)\n   (&lt;a1&gt; ^operation subtraction\n          ^current-column &lt;c1&gt;)\n   (&lt;c1&gt; -^new-digit1 &lt;n1&gt;\n           ^digit1 { &lt;d2&gt; &lt; &lt;d1&gt; }\n           ^digit2 &lt;d1&gt;\n           ^next-column &lt;n2&gt;)\n   (&lt;n2&gt; ^digit1 { &lt;d3&gt; &lt; &lt;o3&gt; }\n           ^new-digit1 &lt;n3&gt;\n           ^next-column &lt;n4&gt;)\n   (&lt;n4&gt; ^digit1 { &lt;d4&gt; &gt;= &lt;o2&gt; }\n           ^new-digit1 &lt;n5&gt;)\n   (&lt;a2&gt; ^subtraction-facts &lt;s2&gt;\n           ^subtraction-facts &lt;s3&gt;\n           ^subtraction-facts &lt;s4&gt;)\n   (&lt;a3&gt; ^add10-facts &lt;a4&gt;\n           ^add10-facts &lt;a5&gt;)\n   (&lt;a4&gt; ^digit1 &lt;d2&gt;\n           ^digit-10 { &lt;d5&gt; &gt;= &lt;d1&gt; })\n   (&lt;a5&gt; ^digit1 &lt;d3&gt;\n           ^digit-10 { &lt;d6&gt; &gt;= &lt;o3&gt; })\n   (&lt;s2&gt; ^digit1 &lt;d6&gt; ^digit2 &lt;o3&gt;\n           ^result &lt;n3&gt;)\n   (&lt;s3&gt; ^digit1 &lt;d4&gt; ^digit2 &lt;o2&gt;\n           ^result &lt;n5&gt;)\n   (&lt;s4&gt; ^digit1 &lt;d5&gt; ^digit2 &lt;d1&gt;\n           ^result &lt;r1&gt;)\n   --&gt;\n   (&lt;c1&gt; ^result &lt;r1&gt;)}\n</code></pre> <p>To achieve this generality, chunking needs information about how rules matched in a substate and how those rules interacted. This allows it to determine what is generalizable and what limits there are on those generalizations. Unfortunately, the information necessary to determine this information was not readily available in prior versions of Soar which only recorded a trace of all WMEs that were tested in the substate. This trace, which we call the working memory trace possesses limited explanatory information, which limited chunking to learning very specific rules in which only Soar identifiers were variablized and all other elements tested the exact values found in the working memory trace.</p> <p>To remedy this limitation and produce more general chunks, EBBS creates and analyzes a behavior trace. Figure below shows an example behavior trace.</p> A close-up of a trace showing differences between a working memory trace (left) and a behavior trace (right). The working memory trace only contains the literal values of the WMEs that matched. The behavior trace, on the other hand, contains variables and various constraints on the values those variables can hold. <p>Note that this trace is generated dynamically as rules match. Whenever a rule matches during agent execution, Soar creates an internal record of the rule that fired, which is called a rule instantiation. (Each box in the behavior traces of this chapter represents an instantiation that was created during task execution within a particular substate.) The instantiation contains both instance information about what matched (the working memory elements) and explanatory information about why they matched (the rules and actions in the original rules that contains variables, constraint tests, RHS actions, etc.).</p> <p>Note that WMEs that were automatically created by the architecture have special instantiations that explain why they were created. For example, an architectural instantiation is created for each <code>^item</code> attribute automatically created in operator tie impasse substates; the explanation causes the <code>^item</code> augmentation to be dependent on the operator in the super-state that led to it, which means that chunks learned which tested that <code>^item</code> augmentation will cause the chunk to also be dependent on the operator in the superstate.</p> <p>Similarly, architectural instantiations are created for structures recalled by semantic and episodic memory in the substate.</p> <p>All of the instantiations that were created in a substate form the instantiation graph of that substate. As chunking backtraces through the instantiation graph, it determines the subset of instantiations that contributed to a result. This set of instantiations and the connections between them is the basis for the behavior trace used for a learning episode. (At this point, the behavior trace is a subgraph of the instantiation graph.)</p> A visualization of the behavior trace of a chunk learned by the arithmetic agent. Each box represents a rule that fired in the substate. Arrows show dependencies between rules that create working memory elements and conditions that test those working memory elements. <p>EBBS also creates an identity graph as it incrementally builds the instantiation graph. Production memory has knowledge about the actual matched value for each element in each condition of a rule in the instantiation graph. Some elements are variables, some are literal constants, some variables are the same as other variables, constraints are placed on some variables. Distributed Identity Graph Unification (DIGU) annotates each element with a pointer that maps it to either a new or existing identity in the identity graph. This annotation is used to determine whether elements in different instantiations refer to the same underlying object and supports identity-based variabilization.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#overview-of-the-ebbs-algorithm","title":"Overview of the EBBS Algorithm","text":"<p>Basic concepts:</p> <ul> <li>Every condition and action in the instantiation graph has three elements:<ul> <li>For conditions, the three elements refer to the symbol in the positive     equality test for the identifier, attribute and value of the condition.     For example, the last condition of rule 2 in the     explanation trace figure has <code>&lt;s&gt;</code> as     the identifier element, number as the attribute element, and <code>&lt;y&gt;</code> as     the value element.</li> <li>For actions, the three elements refer to the identifier, attribute and     value of the WME being created.</li> </ul> </li> <li>An element is either a variable, like <code>&lt;s&gt;</code> or a literal constant, like <code>23</code>,     <code>3.3</code>, or <code>someString</code></li> </ul>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#identity","title":"Identity","text":"<p>Before we can discuss the algorithm, we must first define one of its central concepts: identity.</p> <ul> <li>An identity is the set of all variables in a trace that refer to the same     underlying object. - So we can say that two variables are said to share     an identity if they both refer to the same underlying object.</li> <li>The NULL identity is a special identity that indicates an element which     cannot be generalized and must contain a specific value. - All elements in     the original rule that reference specific constant values are trivially     assigned the NULL identity. - A variable\u2019s identity can also be mapped to the     NULL identity. When this happens, we say the identity has been     literalized.</li> </ul> <p>EBBS traverses a behavior trace of the problem-solving that occurred in the substate to determine which variables in different rule instances refer to the same underlying object. Identities can be shared in the following situations.</p> <ol> <li>Variables that have the same name and are in the same rule firing will share     an identity This is the trivial case. The basic semantics of rules implies that     the same variable in a rule references the same underlying object.</li> <li>If a RHS action of one rule creates a WME and a LHS condition of another     rules tests that same WME, then all variables in the condition and actions will     possess the same identity as their counterpart\u2019s corresponding element. The     interaction between the two rules indicates a shared identity between their     corresponding variables.</li> </ol> <p></p> A behavior trace of two simple rules that matched in a substate. <p>To get a better picture of what a shared identity is, consider the two simple rules and the behavior trace of how they matched in a substate as shown in the explanation trace figure. The connection between rule 2 and rule 1 will unify the identities of <code>&lt;s&gt;</code> ,<code>&lt;x&gt;</code> an <code>&lt;y&gt;</code> in rule 1 with the identities of <code>&lt;s&gt;</code> ,<code>&lt;x&gt;</code> an <code>&lt;y2&gt;</code> in rule 2. So, the <code>&lt;x&gt;</code> in rule 2 shares the same identity as the <code>&lt;x&gt;</code> in rule 1. Similarly, the <code>&lt;y2&gt;</code> in rule 2 shares the same identity as <code>&lt;y&gt;</code> in rule 1. In contrast, the <code>&lt;y&gt;</code> in rule 2 does NOT share the same identity as the <code>&lt;y&gt;</code> in rule 1.</p> <p>It doesn\u2019t matter that the <code>&lt;y&gt;</code> in rule 1 uses the same variable name as the<code>&lt;y&gt;</code> in rule 2. It also doesn\u2019t matter that both conditions with <code>&lt;y&gt;</code> happen to match the same working memory element, <code>(S1 ^number 3)</code>. In terms of sharing an identity, the only thing that matters is how the rules interact, namely whether there\u2019s a connection between elements in the condition of one rule and elements in the actions of another rule.</p> <p>Variable identities can also be mapped to the NULL identity, which means that any elements in the final rule that share that identity will not be variablized. When this happens, we say that the identity has been literalized. There are two ways that a rule interaction can effect an identity literalization:</p> <ol> <li>If a RHS action of one rule creates a WME element using a constant, literal     value in an element and a LHS condition tests that element, then the     identity of the condition\u2019s variables is literalized and mapped to the NULL     identity.  Because the variable in the condition matched a rule that will     always create the same constant, literal value, the condition\u2019s variable     must have that same value. Otherwise, it would not have matched.</li> <li>If a RHS action of one rule creates a WME element using a variable and a LHS     condition tests that that element is a specific value, then the identity of the     action\u2019s variables is literalized and mapped to the NULL identity. Because the     condition requires that the rule that created the matched WME to have a specific     constant, literal value, the action\u2019s variable must have that same value.     Otherwise, it would not have created something that matched the condition.</li> </ol> <p>Identities are the basis of nearly every mechanism in EBBS. DIGU, which is a fairly complicated process, determines all identities in a behavior trace. The following figure shows a trace after identity analysis has been performed. Elements that share an identity in the figure are colored the same.</p> <p></p> A behavior trace incorporating identity analysis. <p>While it\u2019s not readable in this figure, note that each identity is assigned a numeric ID. Both the explainer and the visualizer annotate elements of an explanation with the identity ID in square brackets. These numbers are simply syntactic sugar to ease debugging and make traces easier to understand. Underneath the hood, every test in a condition has a pointer to more complicated identity data structure that will be discussed in more detail in Section Identity Assignment and Propagation on the identity graph.</p> Note that the two rows on the bottom indicate when each component occurs during Soar\u2019s processing."},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#the-nine-components-of-explanation-based-behavior-summarization","title":"The Nine Components of Explanation-Based Behavior Summarization","text":"<ol> <li> <p>Operator Selection Knowledge Analysis     This component also occurs before the learning episode. Whenever an operator     is selected, it analyzes what rule firings contributed necessary operator     selection preferences and caches them in all rule instances that tests that     operator.</p> </li> <li> <p>Instantiation Creation     As a rule is fired, copies of the exact knowledge structures that matched     each condition are made.</p> </li> <li> <p>Identity Assignment and Propagation     When a rule matches, identities are created and assigned for each element.     The identity graph built during these rules firings is manipulated later for     further generalization and identity sharing.</p> </li> <li> <p>Constraint Tracking     This component stores every value or relational constraint (e.g. <code>&lt;&gt; &lt;x&gt;</code>,     <code>&gt;= 3.14</code>, <code>&lt;&lt; disjunction of constants &gt;&gt;</code>) placed on variables.</p> </li> <li> <p>Collect Full Set of Inferences     When a rule creates a result with an identifier, children of that identifier     also become results. This step determines which working memory elements     become supergoal results.</p> </li> <li> <p>Dependency Analysis     The first part of a learning episode, this step backtraces through the     behavior trace to determine which rule conditions test working memory     elements in a supergoal. This works similarly in classical chunking.</p> </li> <li> <p>Identity Graph Manipulation     As backtracing occurs, the identity graph is also manipulated to build rules     at the right level of generality and to prevent correctness issues in     previous versions of chunking.</p> </li> <li> <p>Constraint Collection     Constraints recorded during constraint tracking that are encountered during     backtracing are copied to the relevant identities in the identity graph.     Later, during rule formation, these constraints are enforced on identities     included in the learned rule.</p> </li> <li> <p>Rule Formation     The above eight components performed the analysis that EBBS needs to form a     general but correct rule. This final component uses the results of that     analysis to actually build the new rule. This is a complex component that     has eight different stages. If a valid rule is created, Soar immediately     adds the rule to production memory.</p> </li> </ol> <p>The following sections will describe each component in more detail.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#what-ebbs-does-prior-to-the-learning-episode","title":"What EBBS Does Prior to the Learning Episode","text":"<p>While most of the work that EBBS performs occurs during the learning episode, i.e. after a rule in a substate fires and Soar detects that a result will be created, some critical aspects of the analysis it performs also occur prior to the learning episode, during problem-solving in the substate. The two points when that happens is when a rule fires in a substate and when an operator is selected in a substate.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#operator-selection-knowledge-analysis","title":"Operator Selection Knowledge Analysis","text":"<p>As described in the beginning of this chapter, chunking summarizes the processing required to produce the results of subgoals. Traditionally, the philosophy behind how an agent should be designed was that the path of operator selections and applications from an initial state in a substate to a result would always have all necessary tests in the operator proposal conditions and any goal test, so only those items would need to be summarized. The idea was that in a properly designed agent, a substate's operator evaluation preferences lead to a more efficient search of the space but do not influence the correctness of the result. As a result, the knowledge used by rules that produce such evaluation preferences should not be included in any chunks produced from that substate.</p> <p>In practice, however, it may make sense to design an agent so that search control does affect the correctness of search. Here are just two examples:</p> <ol> <li> <p>Some of the tests for correctness of a result are included in productions     that prefer operators that will produce correct results. The system will work     correctly only when those productions are loaded.</p> </li> <li> <p>An operator is given a worst preference, indicating that it should be used     only when all other options have been exhausted. Because of the semantics of     worst, this operator will be selected after all other operators; however, if     this operator then produces a result that is dependent on the operator     occurring after all others, this fact will not be captured in the conditions     of the chunk.</p> </li> </ol> <p>In both of these cases, part of the test for producing a result is implicit in search control productions. This move allows the explicit state test to be simpler because any state to which the test is applied is guaranteed to satisfy some of the requirements for success. However, chunks created in such a problem space will not be correct because important parts of the superstate that were tested by operator evaluation rules do not appear as conditions. The chunks would not accurately summarize the processing in that problem state. The tracking of Relevant Operator Selection Knowledge (ROSK) is a way to address this issue.</p> <p>Relevant operator selection knowledge is the set of necessary operator evaluation preferences that led to the selection of an operator in a subgoal. As previously described, whenever Soar learns a rule, it recursively backtraces through rule instances to determine which conditions to include in the final chunk or justification. With the ROSK, not only does Soar backtrace through each rule instance that created a matched working memory element, but it also backtraces through every rule instance that created preferences in the ROSK for any operator that gave those matched WMEs o-support. By backtracing through that additional set of preferences at each step of the backtrace, an agent will create more specific chunks that incorporate the goal-attainment knowledge encoded in the operator evaluation rules.</p> <p>Specifically, this component does two things:</p> <ol> <li> <p>When an operator is selected, it analyzes the operator preferences that led     to the decision, and caches any operator selection knowledge that played a     necessary role in the selection.</p> <p>All necessity preferences, i.e. prohibit and require preferences, are always included in the ROSK since they inherently encode the correctness of whether an operator is applicable in a problem space. In contrast, some desirability preferences (rejects, betters, worses, bests, worsts and indifferents) are included in the ROSK depending on the role they play in the selection of the operator.</p> <p>How Soar determines which of those preferences to include in the ROSK is determined by the preference semantics it uses to choose an operator. During the decision phase, operator preferences are evaluated in a sequence of seven steps or filters, in an effort to select a single operator, as described in how preferences are evaluated to decide an operator. Each step, or filter, handles a specific type of preference. As the preference semantics are applied at each step to incrementally filter the candidate operators to a potential selected operator, EBBS incrementally adds operator preferences to the ROSK based on the preferences that were instrumental in applying each filter. A more detailed explanation of the logic used at each step can be found in determining which OSK preferences are relevant.</p> </li> <li> <p>When an o-supported rule matches, EBBS caches the operator's ROSK in the     instantiation of that rule. Since that selection knowledge was necessary to     select the operator needed for the rule to match, EBBS must backtrace     through that knowledge. Cached ROSK is used to do this and incorporate the     necessary operator selection reasoning knowledge into the learned rule. For     some types of agent designs, including operator selection knowledge is needed     to ensure correctness.</p> </li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#instantiation-creation","title":"Instantiation Creation","text":"<p>Whenever a rule matches, EBBS creates a record called an instantiation that contains information about what specific working memory elements matched, what elements were created, and extends the instantiation graph by creating links from other instantiations to this instantiation for those instantiations that correspond to rule firings that created the elements tested in the rule.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#identity-assignment-and-propagation","title":"Identity Assignment and Propagation","text":"<p>Each instantiation describes the working memory elements that matched each condition and the working memory elements and preferences that are created by each action. With the introduction of EBBS, all instantiations now also store the underlying explanation behind each condition and action as defined by the original rule: which elements in conditions are variables and which ones are literal constants, which variables are the same variables, what constraints must be met on the values of each variable and any relationships between variables.</p> <p>EBBS uses this underlying logic to determine the identities of objects used during the problem-solving. Identities are not simply IDs. Each identity is a declarative object that describes a set of variables across multiple rule firings and the various properties they hold.</p> <p>When an instantiation is created, EBBS assigns all elements of every condition and action to an identity, creating new identities as necessary. Identities are created and propagated using the following rules:</p> <ol> <li>If the same variable appears in multiple places in the same rule, it must be     assigned the same identity.</li> <li>The NULL Identity is assigned to any element with a literal value in the     original rule.</li> <li>A new identity is created and assigned for:<ul> <li>All right-hand side action elements that produce a new Soar identifier in     the substate These are also known as unbound RHS variables.</li> <li>All variable elements of conditions that matched superstate WMEs It is     important to note that if two conditions both match the same superstate     WME, each condition is considered independent. This means that each     condition is assigned new identities for each of its elements and will     produce its own condition in the final learned rule. This is a key way     that EBBS differs from previous versions of chunking.</li> </ul> </li> <li>An existing identity is propagated for:<ol> <li>Any condition element that matched a substate WME with existing identities     Each element is assigned the identity found in the corresponding element     of the action of the rule that created that WME. This propagates     identities forward through the behavior trace, which allows us to     represent that the variable in the condition refers to the same object     as the variable in the action of the other rule.</li> <li>Any element that matches special working memory elements called singletons     are assigned the same identity. Singletons are working memory elements     that are guaranteed to only have a single possible value in a state. The     most important singleton is the local <code>^superstate</code> singleton, which is     an architecturally created WME that links the substate to the     superstate, for example <code>(S2 ^superstate S1)</code>. Since we know that it\u2019s     impossible for there to be two superstate features in a state, all     conditions that test that singleton WME will be assigned the same     identities. While there are a variety of built-in singletons for     architecturally-created WMEs, users can also specify their own     domain-specific singletons to eliminate unnecessary generality when     learning. The full list of architecturally-created singletons can be     found in the <code>chunk</code> command\u2019s help     entry.</li> </ol> </li> </ol> <p>Note that rule 1 may conflict with other rules. For example, if a variable appears in two different conditions, then two different identities may propagate into each one of them. In such cases, rule 1 is always enforced and propagation is ignored. During the second phase of identity analysis, which occurs during the actual learning episode, EBBS will re-examine all of the condition-action pairs as it performs a backward traversal of the behavior trace and fix the missing propagations. It does this by creating and manipulating an identity graph that can correctly incorporate all identity relationships.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#constraint-tracking","title":"Constraint Tracking","text":"<p>Rules underlying a behavior trace can include conditions that impose constraints on the values that a variable can hold. These can include equality tests, disjunctions, relative comparisons, literal tests, and conjunctions of constraints. These constraints must be included in later analysis of the behavior trace so that overgeneral rules are not created that fire when those constraints are not met. Thus, as instantiations are created, EBBS stores with each instantiation the constraints required for that rule to match.</p> <p>Constraints are stored relative to identities used in an instantiation. If a rule tests that <code>&lt;x&gt; &lt; 7</code>, EBBS would record on identity node 1 associated with <code>&lt;x&gt;</code> that identity node 1 must have a value less than 7. Similarly, if another condition imposed the constraint <code>&lt;&gt; &lt;y&gt;</code> on <code>&lt;x&gt;</code> and <code>&lt;y&gt;</code> was mapped to identity node 2, then EBBS would record on identity node 1 that it cannot have the same value as identity node 2.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#what-ebbs-does-during-the-learning-episode","title":"What EBBS Does During the Learning Episode","text":"<p>All of the previously discussed steps occurred during problem-solving in the substate as rules matched and operators were selected. It is worth noting that the analysis performed prior to the learning episode (such as identity propagation) is persistent and can be shared across learning episodes. In other words, EBBS can repeatedly re-use that analysis if it learns multiple chunks in the same substate.</p> <p>Every time a rule fires in a substate, Soar checks to see if any of the working memory elements created by the rule qualify as results. This is when the actual learning episode begins.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#collect-full-set-of-inferences","title":"Collect Full Set of Inferences","text":"<p>A chunk\u2019s actions are built from the results of a subgoal. Aresultis any working memory element created in the substate that is linked to a superstate. A working memory element is linked if its identifier is either the value of a superstate WME, or the value of an augmentation for an object that is linked to a superstate.</p> <p>The results produced by a single production firing are the basis for creating the actions of a chunk. A new result can lead to other results by linking a superstate to a WME in the substate. This WME may in turn link other WMEs in the substate to the superstate, making them results. Therefore, the creation of a single WME that is linked to a superstate can lead to the creation of a large number of results. All of the newly created results become the basis of the chunk\u2019s actions.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#backtracing","title":"Backtracing","text":"<p>When learning a new rule, EBBS performs a dependency analysis of the productions that fired in a substate \u2013 a process called backtracing. Backtracing works as follows. For each instantiated production that creates a subgoal result, backtracing examines the behavior trace to determine which working memory elements matched each condition. If the working memory element is local to the substate, then backtracing recursively examines the instantiation that created that condition\u2019s matched working memory element. Thus, backtracing traces backwards through all rules that fired and created working memory elements that were used to produce a result.</p> <p>If an instantiation being backtraced through tested a selected operator, EBBS will backtrace through each instantiation that created a preference in that operator\u2019s relevant operator selection knowledge set. This behavior is off by default and can be enabled with <code>chunk add-osk on</code>.</p> <p>Multiple components of EBBS perform their work during backtracing: dependency analysis, identity graph manipulation and constraint collection. The following sections will discuss what aspects of the agent\u2019s problem-solving are analyzed during backtracing.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#dependency-analysis","title":"Dependency Analysis","text":"<p>The traditional core function of chunking\u2019s backtracing is to determine which conditions in the working memory trace tested working memory elements accessible to the superstate. These conditions will form the left-hand side of the rule.</p> <p>Note: Soar 9.6.0\u2019s explanation-based approach has led to one key change to Soar\u2019s operationality analysis. In previous versions of chunking, chunking would never add two conditions to a chunk that matched the same superstate working memory element. This made sense because chunking was based on a generalization of the working memory trace. More than one condition that tested the same WME would be redundant. Explanation-based behavior summarization, though, learns based on the reasoning within the original hand-written rules. Since the reasoning behind each of the two conditions may be different even if they matched the same WME, EBBS must always add both conditions. (Note that there are some exceptions. See chunk singletons on superstate singletons and user singletons.)</p> <p>Negated conditions are included in a trace in the following way: when a production fires, its negated conditions are fully instantiated with its variables\u2019 appropriate values. This instantiation is based on the working memory elements that matched the production\u2019s positive conditions. If the variable is not used in any positive conditions, such as in a conjunctive negation, a dummy variable is used that will later become a variable in a chunk. If the identifier used to instantiate a negated condition\u2019s identifier field is linked to the super-state, then the instantiated negated condition is added to the trace as a negated condition. In all other cases, the negated condition is ignored because the system cannot determine why a working memory element was not produced in the subgoal and thus allowed the production to fire.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#identity-graph-manipulation","title":"Identity Graph Manipulation","text":"<p>The first phase of identity analysis, forward identity propagation, occurred as rules fired and instantiations were recorded. Unfortunately, forward propagation alone will not produce correct identities. We previously gave one reason why this is the case \u2013 conditions may have conflicting identities propagated forward \u2013 but there are other, more complicated reasons as well that are beyond the scope of this document. What is important to know is that a second phase of identity analysis will be performed during backtracing that will refine and correct the limitations of the initial forward propagation of identity. This second phase achieves these corrections by building an identity graph, which represent the identities involved during problem-solving, and manipulating it as it backtraces through the behavior trace.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#the-identity-graph","title":"The Identity Graph","text":"<p>The identity graph initially contains a node for each identity used in the instantiation graph. Each node can have multiple edges that point to children identities and a single directed join edge that initially points back to itself. As the agent backtraces through the instantiation graph, EBBS will manipulate the identity graph based on the condition-action pairs it encounters.</p> <ol> <li>Joining identities     If a condition matches an action with a conflicting identity, EBBS performs a     join operation between the two identities. This chooses one identity as     the joined identity and points the join edges of the other identity and any     previously joined identities to the new joined identity. Note that any time     EBBS uses an element\u2019s identity, it is actually using the joined identity.</li> <li>Literalizing identities     If a condition/action with a variable element matches an action/condition     with a literal element, EBBS marks the identity as literalized. This means     that any conditions in the final chunk that have elements with that identity     will be considered to have the NULL identity, just like constants, and will     not be variablized. Instead, the matched value will be used for that     element.</li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#constraint-collection","title":"Constraint Collection","text":"<p>Some constraints in the behavior trace may not test working memory elements in the superstate, but could transitively place constraints on the values of variables in conditions that \\textit{will} appear in a chunk. To handle this, once backtracing is complete, EBBS:</p> <ul> <li>stores constraints on the value a single identity, for example <code>&gt;=0</code>, <code>&lt;23</code>.</li> <li>stores relational constraints between two identities, for example <code>&gt; &lt;min&gt;</code>,     <code>&lt; &lt;max&gt;</code> or <code>&lt;&gt; &lt;other&gt;</code>.</li> <li>stores all of these constraints based on the underlying identities, not     the variables used. For example, if a variable <code>&lt;foo&gt;</code> had the constraint     <code>&lt;&gt; &lt;other&gt;</code>, EBBS would record that the variables that share the identity of     <code>&lt;foo&gt;</code> cannot have the same value as variables that share the identity of     <code>&lt;other&gt;</code>.</li> </ul>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#rule-formation","title":"Rule Formation","text":"<p>There are eight distinct, sequential stages to rule formation:</p> <ol> <li>Conditions and Action Generation</li> <li>Constraint Enforcement</li> <li>Identity-based Generalization</li> <li>Condition Merging</li> <li>Condition Simplification</li> <li>Rule Repair and Validation</li> <li>Condition Re-Ordering</li> <li>Add and Recursively Learn Additional Rules</li> </ol> <p>The following sections will give a brief overview of each stage.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#condition-and-action-creation","title":"Condition and Action Creation","text":"<p>This stage creates the basis for the left-hand and right-hand side of the rule. To create the initial conditions of the chunk, it copies all conditions in the behavior trace that were flagged as operational during backtracing. These initial conditions contain literal values for each element. To form the actions of the chunk, it creates copies of the actions that produced each of the result and all children of those results that came along for the ride.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#identity-based-constraint-enforcement","title":"Identity-based Constraint Enforcement","text":"<p>This stage adds all constraints on conditions that were collected during backtracing. As previously described, each constraint is indexed in terms of the identity it constrains. So,if the identity being constrained exists in one of the conditions of the learned rule, EBBS will enforce the constraint by adding a new test to that condition.</p> <p>One situation in which attaching a constraint can be tricky occurs when the constrained identity has been literalized but the constraint itself refers to an identity that has not been literalized, for example <code>{ &gt; &lt;x&gt; 3 }</code>. While that constraint references a condition element that can only match a value of 3 , the relationship between 3 and the identity o <code>&lt;x&gt;</code> must still hold (assuming <code>&lt;x&gt;</code> appears in a different element somewhere else in the rule.) Since these constraints still need to be enforced to ensure a correct rule, EBBS will invert the constraint and attach it to a variable in another condition. In this example, it would add <code>a &lt; 3</code> to some other condition with an element that had <code>&lt;x&gt;</code>\u2019s identity.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#identity-based-generalization","title":"Identity-Based Generalization","text":"<p>To achieve any useful generality in chunks, identifiers of actual objects must be replaced by variables when the chunk is created; otherwise chunks will only ever fire when the exact same objects are matched. At this point in the algorithm, all of the real work needed to determine the most general but correct variablization has already been performed by the identity analysis component.</p> <p>So, this step simply needs to replace all elements with non-NULL identities with variables, making sure that elements with the same joined identity are assigned the same variable. This step also makes sure to skip and elements with identities that have been flagged as literalized.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#conditionn-merging","title":"Conditionn Merging","text":"<p>Any two conditions in the learned rule that share the same identities in all three elements can be combined. In such cases, it is logically impossible for those two conditions to match two different WMEs and cause the same rules to match in the substate. (If the two conditions were to match two different WMEs, at least one of the other rules in the behavior trace that had unified the two conditions would not have matched.) As a result, EBBS can safely merge those two conditions without losing generality.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#condition-simplification","title":"Condition Simplification","text":"<p>EBBS polishes the conditions of the learned rule by pruning unnecessary constraints on literalized elements and replacing multiple disjunction constraints with a single simplified disjunction.</p> <ol> <li>Merging disjunctions: If an element in a condition has two disjunction     tests, the constraints will be merged into a single disjunction that     contains only the shared values. <code>{ &lt;&lt; a b c &gt;&gt; &lt;&lt; b c d &gt;&gt; &lt;x&gt;}</code> becomes <code>{ &lt;&lt;b c &gt;&gt; &lt;x&gt; }</code>, because it is impossible fo <code>&lt;x&gt;</code> to be either a or b. This     will also eliminate any duplicate disjunctions.</li> <li>Throwing out unnecessary constraints: If an element in a condition has been     literalized but also has a literal constraint on its value, then the     constraint is unnecessary and will be thrown out. For example, <code>&lt;s&gt; ^value{ &lt; 33 23 }</code> becomes <code>&lt;s&gt; ^value 23</code>.</li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#rule-validation-and-repair","title":"Rule Validation and Repair","text":"<p>At this point, the rule is essentially formed. Chunking must now make sure that the learned rule can be legally added to production memory.  Specifically, the rule cannot have any conditions or actions that are not linked to a goal state specified in the rule.</p> <p>If an unconnected action or condition is found, EBBS will attempt to repair the rule by adding new conditions that provide a link from a state that is already tested somewhere else in the rule to the unconnected condition or action.</p> <p>To repair the rule, EBBS performs a search through working memory to find the shortest path of working memory elements that lead from a state identifier in the rule to a WME with the identifier in the unconnected condition or action. A new condition is then added for every WME in that found path, which is then variablized.</p> <p>Note that there may be multiple paths from a state to the unconnected identifier. EBBS does a breadth-first search, so it will find one with the shortest distance.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#conditions-re-ordering","title":"Conditions Re-ordering","text":"<p>Since the efficiency of the Rete matcher depends heavily upon the order of a production\u2019s conditions, the chunking mechanism attempts to sort the chunk\u2019s conditions into the most favorable order. At each stage, the condition-ordering algorithm tries to determine which eligible condition, if placed next, will lead to the fewest number of partial instantiations when the chunk is matched. A condition that matches an object with a multi-valued attribute will lead to multiple partial instantiations, so it is generally more efficient to place these conditions later in the ordering. This is the same process that internally reorders the conditions in user-defined productions, as mentioned briefly in the structure of a production.</p> <p>If the constructed rule is not a duplicate of an existing rule, it is added to production memory.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#add-and-recursively-learn-additional-rules","title":"Add and Recursively Learn Additional Rules","text":"<p>When a rule is added, it may generate another learned rule. Once the learned rule is added to production memory, it is guaranteed to immediately match in the supergoal. When it does, the chunk makes new data structures and EBBS creates an instantiation for the chunk that includes new identities relative to the existing identity graph. In the case when a problem has been decomposed into at least two subgoals and the newly created chunk makes results for an even higher level goal, EBBS then backtraces and creates a second chunk based on the reasoning in the subgoal that the chunk matched it. This process stops when a chunk only generates working memory elements in the same state it matched in.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#subtleties-of-ebbs","title":"Subtleties of EBBS","text":""},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#relationship-between-chunks-and-justifications","title":"Relationship Between Chunks and Justifications","text":"<p>Chunks are closely related to another type of rule called a justification. Justifications are also created when a substate creates a result for a superstate, the difference being that justifications are only built when learning is off. These justifications are needed to decide whether the working memory elements in the result should get i-support or o-support in the superstate. To do that, Soar needs to determine whether any rules involved in the creation of the result tested the selected operator in the superstate, which is exactly the same type of analysis that chunking does.</p> <p>As a result, Soar uses a limited version of the chunking algorithm to do that. It analyzes the substate problem-solving and learns a new, temporary rule, a \"justification\", which is added to production memory. If this temporary rule tests an operator in the superstate, it gives the result o-support. (Note that when learning is on, a justification is not needed since the chunk will provide the correct support.)</p> <p>Justifications use all the components described in the previous sections and are even affected by the current chunk settings. You can even print justifications out like other rules. The only differences between chunks and justifications are:</p> Info <p>Even though justifications don\u2019t contain variables, justifications can be over-general because they don\u2019t incorporate enough knowledge, for example, operator selection knowledge.</p> <ol> <li> <p>Every condition and action in a justification contain the literal values     that matched. Justifications contain no variables.</p> Info <p>Justifications can have variables in the negated conditions and negated conjunctions of conditions. They just don\u2019t have any variables in its positive conditions.</p> </li> <li> <p>Justifications don\u2019t contain any of the value constraints that a chunk would     have.</p> </li> <li>Justifications get removed from production memory as soon as their     conditions no longer match.</li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#chunk-inhibition","title":"Chunk Inhibition","text":"<p>If a newly learned chunk was immediately added to production memory, it would immediately match with the same working memory elements that participated in its creation. This can be problematic if the production\u2019s actions create new working memory elements. Consider the case where a substate proposes a new operator, which causes a chunk to be learned that also proposes a new operator. The chunk would immediately fire and create a preference for another new operator, which duplicates the operator preference that was the original result of the subgoal.</p> <p>To prevent this, Soar uses inhibition. This means that each production that is built during chunking is considered to have already fired with an instantiation based on the exact set of working memory elements used to create it.</p> <p>Note that inhibition does not prevent a newly learned chunk from immediately matching other working memory elements that are present and creating a new instantiation.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#chunks-based-on-chunks","title":"Chunks Based on Chunks","text":"<p>When a problem has been decomposed into more than one substate, a single result can produce multiple chunks. This process is called bottom-up chunking. The first chunk is produced in the substate where the problem-solving that produced the result occurred. The next chunk is based on the implicit match of the first chunk in one of the higher level problem-spaces. If that match is lower than the state that the result is being returned to, Soar will backtrace through the chunk match and learn a second chunk (relative to the substate that the chunk matched in). This process continues until it learns a chunk that only creates working memory elements in the same state that it matched in.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#mixing-chunks-and-justifications","title":"Mixing Chunks and Justifications","text":"<p>If an agent is using the only or except setting, then justifications will be built in states where learning is disabled and chunks will be built in states where learning is enabled. In these situations, justifications also serve another purpose: they provide an explanation of the results for future learning episodes in states that do have learning on. EBBS does this by retaining all of the extra information that chunks have but justifications do not, namely those extra tests and how things would have been variablized. This allows EBBS to learn chunks from justifications as readily as it can from hand-written rules and other chunks.</p> <p>When mixing justifications and chunks, users may want to set the explainer to record the learning episodes behind justifications. This allows one to examine the reasoning behind a justification just like you would a chunk, which may be important if that justification later participates in the formation a chunk. See the explainer\u2019s settings for more information.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#generality-and-correctness-of-learned-rules","title":"Generality and Correctness of Learned Rules","text":"<p>Chunking is intended to produce the most general rule that is also correct.</p> <p>Generality is a measure of the space of similar situations that a rule can apply to. A more general rule can be applied to a larger space of similar situations. A rule is considered over-general if it can apply to situations in which the original problem-solving would have never occurred.</p> <p>Correctness is a requirement that the learned rule produces the exact same results that the original problem-solving would have produced. In other words, if we inhibited a correct chunk so that it did not fire, the agent should subgoal, execute the same substate reasoning that it previously performed when learning the chunk, and produce the same results that the learned chunk produces.</p> <p>Note that an over-general rule is an incorrect rule, but not all incorrect rules are over-general.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#over-specialization-and-over-generalization","title":"Over-specialization and Over-generalization","text":"<p>Explanation-based behavior summarization was pursued to address the main limitation of traditional chunking: over-specialized rules that were very specific and could not be applied to many other situations. Specifically, EBBS\u2019s identity-based variablization and constraint tracking/enforcement has eliminated the core source of this issue.</p> <p>The nature of EBBS\u2019s algorithm does add two new situations in which rules may become over-specialized. Generalizing knowledge retrieved discusses how variables used in certain RHS functions need to be literalized to maintain correctness, which can cause overspecialization. Previous results and rule repair discusses how testing or augmenting a previous result creates rules that require repair, a process which may sometimes over-specialize a rule. Note that this situation can easily be avoided and, even when it does occur, may not add much unnecessary specificity to learned rules.</p> <p>While over-specialization may no longer be a common problem, it is still possible to get over-general rules. Several of the sources of correctness issues listed in the next section can produce over-general rules in certain situations.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#previous-results-and-rule-repair","title":"Previous Results and Rule Repair","text":"<p>An agent may learn a slightly over-specialized rule when EBBS repairs a rule that has unconnected conditions, which are conditions that have an identifier that is not linked to one of the states referenced in the rule. Such rules are illegal and cannot be added to Soar\u2019s production memory.</p> <p>Rules that require repair are caused by substate problem-solving that tests or augments a previous result. A previous result is a working memory element that was originally created locally in the substate but then later became a result when a rule fired and connected it to the superstate. (At which point a chunk must have been learned.). If another substate rules later matches or augments such a previous result WMEusing a path relative to the local substate, then EBBS will have problems. It won\u2019t know where in the superstate that working memory is located is and how it should be referenced in the learned rule, because the problem solving referenced the result relative to the local substate.</p> <p>As described in validating rule and repairing unconnected conditions, EBBS repairs the rule by adding new grounding conditions that provide a link from a state, which is tested somewhere else in the rule, to the unconnected condition or action. It does this by searching through working memory to find the shortest path from a state to the identifier behind the unconnected element. It then variablizes those conditions appropriately.</p> <p>Since the conditions are based purely on what happened to be in working memory at that point and nothing in the explanation dictated that particular path found during the search, the learned rule may be over-specialized. The chunk will only match future situations where the previous result can be found on that same path. Fortunately, new chunks can be learned to ameliorate this. If a similar situation is encountered in the future, but with a different path to the unconnected element, the chunk won\u2019t fire, because the added grounding conditions won\u2019t match, which should cause the agent to subgoal and learn a similar chunk with a different set of grounding conditions.</p> <p>Note that if an agent designer expects that the path to the previous result found by the search will always exist, a repaired rule should match just as generally as an unrepaired rule.</p> <p>But if this is not the case, an agent designer can avoid this situation by modifying the rules that test or augment the substructure of a previous result. If those rules are modified so that they match the previous results by referencing them relative to the superstate than the the local substate, EBBS will be able create a valid rule without any repair.</p> <p>To detect when this is happening, use the 'chunk' stats command. It will tell you if any of an agent\u2019s learned rules that required repair. If you instruct the explainer to record the chunk, you can also see whether a specific chunk was repaired by looking at the chunk\u2019s individual stats</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#missing-operator-selection-knowledge","title":"Missing Operator Selection Knowledge","text":"<p>If an agent uses rules that create operator preferences to choose amongst multiple operators in the substate, it is possible that the reasoning behind those rules needs to be incorporated in any rule learned. This topic is discussed in greater detail in ROSK tracking.</p> <p>EBBS will incorporate relevant operator selection knowledge if you enable the chunk setting add-osk, which is off by default.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#generalizing-over-operators-selected-probabilistically","title":"Generalizing Over Operators Selected Probabilistically","text":"<p>If the problem-solving in a substate involves operators that were selected probabilistically, chunking will not be able to summarize the agent\u2019s reasoning into a correct rule. For a rule to be correct, it must always produce the same result that the substate would have produced if the learned rule was not in production memory. Since a different operator could have been selected which could have resulted in different problem-solving, the substate could easily produce different results than any chunk learned in that substate.</p> <p>EBBS detects these cases while it is analyzing operator selection preferences. EBBS adds a flag to inndicate whether an operator was selected in an unreliable way (using random selection, numeric preferences, or reinforcement learning). EBBS checks for this flag during backtracing and if it is encountered, EBBS will not add the rule to production memory.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#collapsed-negative-reasoning","title":"Collapsed Negative Reasoning","text":"<p>Over-general chunks can be created when conditions in the behavior trace test for the absence of a working memory elements in the substate. Since there is no clear way for chunking to generate a set of conditions that describe when a given working memory element would not exist in a substate, chunking can\u2019t represent that aspect of the problem-solving.</p> <p>Chunking can include negated tests if they test for the absence of working memory elements in the superstate, though. So, the agent engineer can avoid using negated conditions for local substate data by either (1) designing the problem-solving so that the data that is being tested in the negation is already in the superstate or (2) making the data a result by attaching it to the superstate. This increases the number of chunks learned, but a negated condition of knowledge in the superstate can be incorporated correctly into learned rules.</p> <p>Note that there are agent design patterns where local negations are perfectly safe to ignore, so Soar allows local negations by default. In some agents, they are common enough that turning the filter on prevents any rules from being learned.</p> <p>If you suspect that a rule may be over-general because of locally negated condition, you can verify whether such a condition was encountered during backtracing by using the chunk stats command and explain stats command. See Debugging Explanation-Based Chunking and explain stats for more information.</p> <p>If such chunks are problematic, turning off chunking\u2019s correctness filter allow-local-negations will force Soar to reject chunks whose problem-solving involved a local negation.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#problem-solving-that-doesnt-test-the-superstate","title":"Problem-Solving That Doesn\u2019t Test The Superstate","text":"<p>Over-general chunks can be created if a result of a subgoal is dependent on the creation of an impasse within the substate. For example, processing in a subgoal may consist of exhaustively applying all the operators in the problem space. If so, then a convenient way to recognize that all operators have applied and processing is complete is to wait for a state no-change impasse to occur. When the impasse occurs, a production can test for the resulting substate and create a result for the original subgoal. This form of state test builds over-general chunks because no pre-existing structure is relevant to the result that terminates the subgoal. The result is dependent only on the existence of the substate within a substate.</p> <p>In these cases, EBBS will learn a chunk with no conditions, which it will reject. But the superstate result is still created by the substate rule that matched. If a new rule is learned that uses that result, it will be over-general since the rule does not summarize the reasoning that led to the result, namely that all operators were exhaustively applied.</p> <p>The current solution to this problem is a bit of a hack. Soar allows an agent to signal to the architecture that a test for a substate is being made by testing for the^quiescence t augmentation of the subgoal. If this special test is found in the behavior trace, EBBS will not build a chunk. The history of this test is maintained, so that if the result of the substate is then used to produce further results for a superstate, no higher chunks will be built.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#disjunctive-context-conflation","title":"Disjunctive Context Conflation","text":"<p>An incorrect rule can be learned when multiple rules fire in a substate that test different structures in the superstate but create the same WME in the substate. For example, there may be a rule that can match the superstate in several different ways, each time elaborating the local state with a WME indicating that at least one of these qualifying superstate WMEs existed. In such a situation, the rule would fire multiple times, but the result of the rule firings will be collapsed into creating a single WME in the substate.</p> <p>If this WME is then tested to create a result on the superstate, the chunk that is subsequently created can produce different behavior than the substate would have. In the original subgoal processing, multiple matches produced one substate WME, but that one substate WME only created a single result in the superstate. The chunk on the other hand will match multiple times for each of the items that previously created the substate WME. And then, each one of those matches will create its own distinct result in the superstate. Since this is different behavior than the original substate, this rule would be considered incorrect.</p> <p>If it were possible, EBBS should learn a disjunctive conjunctive condition, with each disjunction being the superstate conditions tested by each substate rule that had previously created the substate WME that was repeatedly asserted. This is why this potential source of incorrect rules is called disjunctive context conflation.</p> <p>If this type of reasoning is needed, agents can move the conflating WME to the superstate. The rule learned would then produce only one result regardless of the number of rules that repeatedly created that WME.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#generalizing-knowledge-retrieved-from-semantic-or-episodic-memory","title":"Generalizing knowledge retrieved from semantic or episodic memory","text":"<p>Generalizing problem-solving based on knowledge recalled from an external memory system can be problematic for three main reasons.</p> <ol> <li>Knowledge can change after the learning episode     Semantic knowledge can be modified by the agent. Different semantic     knowledge can effect different problem-solving, in which case a rule based on     the original problem-solving would be incorrect.</li> <li>Justification for a memory recall is opaque to agent     EBBS does not have access     to the reasoning behind why a piece of knowledge was recalled from a memory     system. For example, consider the case of a semantic memory that is recalled     because it has the highest level of activation at a particular time. In a future     situation, the same semantic memory may not be the most active, in which case     something else would be recalled and different problem-solving could occur.     Because of that possibility, the original rule is not guaranteed to produce the     same result and hence has the potential to be incorrect. (Note that this can     also occur with episodic memory queries.)</li> <li>Knowledge from semantic or episodic memory recalled directly into the     substate is considered local     To understand why this is a problem, remember that a chunk\u2019s conditions are     based on the conditions in the behavior trace that tested knowledge linked     to a superstate. (See operational analysis     for more information.) If semantic or     episodic memory is recalled directly into the substate, then any conditions     that test that recalled knowledge is considered local to the substate and     will not be included as a condition in the chunk. So, even though the     substate reasoning required some piece of semantic knowledge to exist, the     chunk will not require it. And, since the learned rule is not incorporating     some of the reasoning and constraints that involved the recalled knowledge,     the rule may be over-general. To avoid this situation, an agent can retrieve     the knowledge in a higher-level state rather than the substate in which the     rule is learned.</li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#learning-from-instruction","title":"Learning from Instruction","text":"<p>Note that some agent designs, for example an agent that learns by instruction, can take advantage of the fact that knowledge recalled from semantic or episodic memory directly into the substate is considered local. For such agents, a rule that is directly dependent on the instructions being in working memory would be useless. The agent would need to get the instruction every time it wanted to perform the task again, defeating the purpose of learning by instruction.</p> <p>One technique that can be used to produce a more general rule which is not directly dependent on the instruction being in working memory is to first store the instructions in semantic or episodic memory. When the agent is in a substate that it wants to learn a rule based on the instructions, it recalls the instructions from semantic or episodic memory directly into the substate. Because that knowledge is not linked to the superstate, any rules learned in that substate will not be directly dependent on the existence of the instructions.</p> <p>Since conditions that test the recalled knowledge are not incorporated into the learned rule, it is very easy to learn over-general chunks. To avoid this, any substate rules which test recalled knowledge must also test superstate structures that correspond to the recalled knowledge. Doing so removes the need for the instructions to exist while avoiding over-generality by ensuring that structures in the superstate corresponding to those instructions are still being tested. Those conditions that test superstate WMEs will be generalized and included in the chunk, but the undesired portion of the reason that they matched will not be, namely the fact that the superstate knowledge corresponded to recalled instructions.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#determining-which-osk-preferences-are-relevant","title":"Determining Which OSK Preferences are Relevant","text":"<p>The following outline describes the logic that happens at each step. For a more detailed description of the various filters (but not the ROSK).  Note that depending on the set of preferences being processed, impasses may occur at some of these stages, in which case, no operator is selected and the ROSK is emptied. Moreover, if the candidate set is reduced to zero or one, the decision process will exit with a finalized ROSK. For simplicity\u2019s sake, this explanation assumes that there are no impasses and the decision process continues.</p> <ul> <li> <p>Require Filter If an operator is selected based on a require preference,     that preference is added to the ROSK. The logic behind this step is     straightforward, the require preference directly resulted in the selection of     the operator.</p> </li> <li> <p>Prohibit/Reject Filters If there exists at least one prohibit or reject     preference, all prohibit and reject preferences for the eliminated candidates     are added to the ROSK. The logic behind this stage is that the conditions that     led to the exclusion of the prohibited and rejected candidates is what allowed     the final operator to be selected from among that particular set of surviving     candidates.</p> </li> <li> <p>Better/Worse Filter For every candidate that is not worse than some     other candidate, add all better/worse preferences involving the candidate.</p> </li> <li> <p>Best Filter Add any best preferences for remaining candidates to the ROSK.</p> </li> <li> <p>Worst Filter If any remaining candidate has a worst preference which     leads to that candidate being removed from consideration, that worst preference     is added to the ROSK. Again, the logic is that the conditions that led to that     candidate not being selected allowed the final operator to be chosen.</p> </li> <li> <p>Indifferent/Numeric Filter This is the final stage, so the operator is now selected     based on the agent\u2019s exploration policy. How indifferent preferences are added     to the ROSK depends on whether any numeric indifferent preferences exist.</p> <ol> <li>If there exists at least one numeric indifferent preference, then every     numeric preference for the winning candidate is added to the ROSK. There     can be multiple such preferences. Moreover, all binary indifferent     preferences between that winning candidate and candidates without a     numeric preference are added.</li> <li>If all indifferent preferences are non-numeric, then any unary indifferent     preferences for the winning candidate are added to the ROSK. Moreover, all     binary indifferent preferences between that winning candidate and other     candidates are added.</li> </ol> <p>The logic behind adding binary indifferent preferences between the selected operator and the other final candidates is that those binary indifferent preferences prevented a tie impasse and allowed the final candidate to be chosen by the exploration policy from among those mutually indifferent preferences.</p> </li> </ul> <p>Note that there may be cases where two or more rules create the same type of preference for a particular candidate. In those cases, only the first preference encountered is added to the ROSK. Adding all of them can produce over-specific chunks. It may still be possible to learn similar chunks with those other preferences if the agent subgoals again in a similar context.</p> <p>Note also that operator selection knowledge is not tracked and incorporated into chunks by default. The setting must be turned on via the chunk command\u2019s add-osk setting..</p> <p>The ROSK also affects the conditions of justifications, so the <code>add-desirability-prefs</code> setting does have an effect on the agent even if learning is turned off.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#generalizing-knowledge-from-math","title":"Generalizing Knowledge From Math","text":"<p>EBBS introduces the ability to learn more expressive rules whose actions perform arbitrary right-hand side functions with variablized arguments.</p> <p>It is important to note that this ability is limited. EBBS can only learn rules with generalized RHS functions in its actions when the rule that created the result contained a RHS function. In many cases, RHS functions will be used in the intermediate rule firings in the behavior trace. Not only will these intermediate RHS function not appear in the chunk, but any chunk learned based on their output will become more specific. This is one of the sources of over-specialization referenced in over-specialization and over-generalization on over-specialization.</p> <p>RHS function calls in intermediate rule firings are a challenge for EBBS to deal with because the problem-solving may have placed constraints on the intermediate results that cannot be represented in a single Soar rule.</p> <p>For example, consider the case of one rule that used a RHS function to add two numbers. Now consider another rule that matched the output of the RHS function, but only if it was less than 5. If the second rule matched, it would return the total as a result. How could we encode the reasoning of those two rules into one rule? Since Soar\u2019s production syntax does not allow using RHS function as constraints in conditions, there is no way to insure that the two numbers add up to something less than 5 in a single rule. This is why RHS functions in intermediate rule firings can cause over-specialization.</p> <p>Because the chunk\u2019s conditions can\u2019t represent constraints on the output of intermediate RHS functions, EBBS must literalize both the identities of the variables that appear as arguments to the intermediate RHS function, as well as the identities in any conditions that test the output of the RHS function. That fixes the value of the RHS function and guarantees that any constraints in conditions that test the output of that RHS function will be met. While this will make the learned rule more specific, it will also ensure that the rule is correct.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#situations-in-which-a-chunk-is-not-learned","title":"Situations in which a Chunk is Not Learned","text":"<p>Soar learns a chunk every time a subgoal produces a result, unless one of the following conditions is true:</p> <ol> <li>Chunking is off     This corresponds to the command chunk never.</li> <li>Chunking was only enabled for some states, and the subgoal in question is not     one of them When chunking is enabled via the only or except command, the agent     must specify which states learning either occurs in or doesn\u2019t occur in,     respectively. For the except setting, Soar will learn rules in all states in     which a <code>dont-learn</code> RHS production action was not executed. Similarly, for the     only setting, Soar will learn rules in all states where a <code>force-learn</code> RHS     production action was executed, cf. Controlling chunking     for more information. This capability is provided for debugging and     practical system development, but it is not part of the theory of Soar.</li> <li>The chunk learned is a duplicate of another production or chunk already in     production memory In some rare cases, a duplicate production will not be     detected because the order of the conditions or actions is not the same as an     existing production.</li> <li>The problem-solving in the substate violated one of the enabled correctness     guarantee filters During the development of explanation-based behavior summarization, we have     developed a list of possible causes of incorrect chunks. EBBS\u2019s correctness     guarantee filters detect when those situations occur and prevents a chunk from     being learned. For example, the allow-local-negations filter will prevent a rule     from being formed if the problem-solving that led to the result was     dependent on a condition that tested whether a subgoal WME doesn\u2019t exist.     Since there is no practical way to determine why a piece of knowledge     doesn\u2019t exist, testing a local negation can result in an over-general and     incorrect chunk, cf. prohibiting known sources for correctness issues     for more information. Note that correctness filters have not yet been     implemented for all the identified potential sources of correctness issues.</li> <li>The chunking option bottom-only is on and a chunk was already built in the     bottom subgoal that generated the results With bottom-only chunking, chunks are     learned only in states in which no subgoal has yet generated a chunk. In this     mode, chunks are learned only for the \"bottom\" of the subgoal hierarchy and not     the intermediate levels. With experience, the subgoals at the bottom will be     replaced by the chunks, allowing higher level subgoals to be chunked. See     chunk reference for details of chunk used     with the bottom-only setting.</li> <li>The problem-solving that led to the result contained a condition that tested     the architecturally-created <code>&lt;state&gt; ^quiescence t</code> augmentation This mechanism     is motivated by the chunking from exhaustion problem, where the results of a     subgoal are dependent on the exhaustion of alternatives     (see Problem-Solving that does not test the superstate).     If this substate augmentation is encountered when determining the     conditions of a chunk, then no chunk will be built for the currently considered     action. This is recursive, so that if an un-chunked result is relevant to a     second result, no chunk will be built for the second result. This does not     prevent the creation of a chunk that would include^quiescence tas a condition.</li> <li>The problem-solving in the substate did not test any knowledge in the     superstate In these cases, the chunk learned does not have any conditions     and is not a legal production. Note that this creates an unusual persistence     issue for any results that came out of the substate. Since a justification     or chunk was not learned, there is no rule in the superstate that can     provide either i-support or o-support for the result that came out of the     substate. Consequently, those result WMEs will be completely dependent on     the rules that fired within the substate. So, when the substate is removed,     those results will also be removed.</li> </ol>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#usage","title":"Usage","text":"<p>More details on the <code>chunk</code> command and its settings can be found in the chunk command reference.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#enabling-procedural-learning","title":"Enabling Procedural Learning","text":"<p>By default, chunking is off.</p> <ul> <li>To turn on chunking: <code>chunk always</code></li> <li>To turn off chunking: <code>chunk never</code></li> </ul> <p>In real world agents, there may be certain problem spaces in which you don't want your agent to learn rules. Chunking has a mechanism to allow agents to dynamically specify the states in which rules are learned.</p> <ul> <li>To turn off chunking in all states except ones manually flagged on:<ul> <li>Use <code>chunk only</code> setting.</li> <li>Design an agent rule that executes the RHS action <code>force-learn</code>,     which only matches in states in which you want to learn rules.</li> </ul> </li> <li>To turn on chunking in all states except ones manually flagged off:<ul> <li>Use <code>chunk except</code> setting.</li> <li>Design an agent rule that executes the RHS action <code>dont-learn</code>,     which only matches in states in which you don't want to learn     rules.</li> </ul> </li> </ul> <p>Depending on your agent design, you may want to consider enabling the <code>add-osk</code> option. As of Soar 9.6.0, EBBS does not incorporate operator selection knowledge into learned rules by default, since there is a performance cost and not all agents designs require its inclusion. You may want to enable this option if your agent has rules that test knowledge in the superstate to create operator preferences in the substate. See the section on learning and operator selection knowledge for more information.</p> <p>See the chunk command reference for more information about using the chunk command to enable and disable procedural learning.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#fine-tuning-what-your-agent-learns","title":"Fine-tuning What Your Agent Learns","text":""},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#prohibiting-known-sources-of-correctness-issues","title":"Prohibiting known sources of correctness issues","text":"<p>It is theoretically possible to detect nearly all of the sources of correctness issues and prevent rules from forming when those situations are detected. In Soar 9.6.0, though, only one filter is available, <code>allow-local-negations</code>. Future versions of Soar will include more correctness filters.</p> <p>Note that it is still possible to detect that your agent may have encountered a known source of a correctness issue by looking at the output of the <code>chunk stats</code> command. It has specific statistics for some of the sources, while others can be gleaned indirectly. For example, if the stats show that some rules required repair, you know that your agent testing or augmenting a previous result in a substate.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#using-singletons-to-simplify-a-rules-conditions","title":"Using singletons to simplify a rule's conditions","text":"<p>Unlike previous versions of chunking, EBBS adds all conditions that tested superstate knowledge to a chunk, regardless of whether another condition already tested that working memory element. This means that EBBS can sometimes produce learned rules with seemingly duplicate conditions. While these conditions are logically correct, they may be redundant because the nature of the domain may make it impossible for the two conditions to match different working memory elements. For example, in the blocks-world domain, the fact that there can be only one gripper in the world means that having multiple conditions testing for a gripper would be redundant.</p> <p>Soar allows agents to specify such known domain characteristics, which EBBS will then use to create better rules that don't have such unnecessary conditions. We call any working memory element that is guaranteed to only have a single possible value at any given time, a singleton. If EBBS encounters two different conditions in the backtrace that both test the same superstate WME that matches a user singleton pattern, it will merge the two conditions. There are several architectural singletons that EBBS already knows about. To specify patterns for domain-specific singletons, the <code>chunk singleton</code> command can be used.</p> <p>See the chunk command reference for more information about the chunk singleton command.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#examining-what-was-learned","title":"Examining What Was Learned","text":""},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#printing-and-traces","title":"Printing and Traces","text":"<p>Printing Rules:</p> <ul> <li>To print all chunks learned: <code>print --chunks</code> or <code>print -c</code></li> <li>To print all justifications learned (and still matching): <code>print --justifications</code> or <code>print -j</code></li> <li>To print a rule or justification: <code>print &lt;rule-name&gt;</code></li> </ul> <p>For more information on print, see the print command reference.</p> <p>Trace Messages:</p> <ul> <li>To print when new rules are learned (just the name): <code>trace --learning 1</code> or <code>trace -l 1</code></li> <li>To print when new rules are learned (the full rule): <code>trace --learning 2</code> or <code>trace -l 2</code></li> <li>To print a trace of the conditions as they are collected during     backtracing: <code>trace --backtracing</code> or <code>trace -b</code></li> <li>To print warnings about chunking issues detected while learning: <code>trace --chunk-warnings</code> or <code>trace -C</code></li> <li>To print when learned chunks match and fire: <code>trace --backtracing</code> or <code>trace -b</code></li> </ul> <p>For more information on trace, see the trace command reference.</p> <p>Note that the most detailed information about why a particular rule was learned can be acquired using the explain mechanism as described in the explain command reference. That is highly recommended over printing the backtracing trace messages.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#chunking-statistics","title":"Chunking Statistics","text":"<p>Chunking automatically compiles various statistics about the procedural rule learning that an agent performs. To access these stats, use the command <code>chunk stats</code> or <code>stats -l</code></p> <pre><code>===========================================================================\n                  Explanation-Based Chunking Statistics\n===========================================================================\nRules learned                                                          0\nJustifications learned                                                 0\n\n---------------------------------------------------------------------------\n                               Work Performed\n---------------------------------------------------------------------------\nSub-states analyzed                                                    0\nNumber of rules fired in substates analyzed                            0\nNumber of rule firings analyzed during backtracing                     0\n\nConditions merged                                                      0\nDisjunction tests merged                                               0\nOperational constraints                                                0\nNon-operational constraints detected                                   0\nNon-operational constraints enforced                                   0\n\n---------------------------------------------------------------------------\n                     Problem-Solving Characteristics\n---------------------------------------------------------------------------\nRules repaired that had unconnected conditions or actions              0\nChunk used negated reasoning about sub-state                           0\nChunk tested knowledge retrieved from long-term memory                 0\nJustification used negated reasoning about sub-state                   0\nJustification tested knowledge retrieved from long-term memory         0\n\n---------------------------------------------------------------------------\n                           Identity Analysis\n---------------------------------------------------------------------------\nIdentities created                                                     0\nDistinct identities in learned rules                                   0\nIdentity propagations                                                  0\nIdentity propagations blocked                                          0\nIdentities joined                                                      0\nIdentities literalized                                                 0\n\n---------------------------------------------------------------------------\n                      Learning Skipped or Unsuccessful\n---------------------------------------------------------------------------\nIgnored duplicate of existing rule                                     0\nSkipped because problem-solving tested ^quiescence true                0\nSkipped because no super-state knowledge tested                        0\nSkipped because MAX-CHUNKS exceeded in a decision cycle                0\nSkipped because MAX-DUPES exceeded for rule this decision cycle        0\n</code></pre> <p>Note that similar statistics for a specific learned rule can be acquired using the explain mechanism as described in the explain command reference.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#interrupting-execution-to-examine-learning","title":"Interrupting Execution To Examine Learning","text":"<ul> <li>To stop Soar after each successful learning episode: <code>chunk interrupt on</code></li> <li>To stop Soar after detecting any learning issue: <code>chunk warning-interrupt on</code></li> <li>To stop Soar after learning a rule that the explainer recorded: <code>chunk explain-interrupt on</code></li> </ul> <p>For more information about how to record when a specific rule is learned, see the explain command reference that describes the explain mechanism.</p>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#explaining-learned-procedural-knowledge","title":"Explaining Learned Procedural Knowledge","text":"<p>While explanation-based behavior summarization makes it easier for people to now incorporate learning into their agents, the complexity of the analysis it performs makes it far more difficult to understand how the learned rules were formed. The explainer is a new module that has been developed to help ameliorate this problem. The explainer allows you to interactively explore how rules were learned.</p> <p>When requested, the explainer will make a very detailed record of everything that happened during a learning episode. Once a user specifies a recorded chunk to \"discuss\", they can browse all of the rule firings that contributed to the learned rule, one at a time. The explainer will present each of these rules with detailed information about the identity of the variables, whether it tested knowledge relevant to the the superstate, and how it is connected to other rule firings in the substate. Rule firings are assigned IDs so that user can quickly choose a new rule to examine.</p> <p>The explainer can also present several different screens that show more verbose analyses of how the chunk was created. Specifically, the user can ask for a description of (1) the chunk's initial formation, (2) the identities of variables and how they map to identity sets, (3) the constraints that the problem-solving placed on values that a particular identity can have, and (4) specific statistics about that chunk, such as whether correctness issues were detected or whether it required repair to make it fully operational.</p> <p>Finally, the explainer will also create the data necessary to visualize all of the processing described in an image using the new 'visualize' command. These visualization are the easiest way to quickly understand how a rule was formed.</p> <p>Note that, despite recording so much information, a lot of effort has been put into minimizing the cost of the explainer. When debugging, we often let it record all chunks and justifications formed because it is efficient enough to do so.</p> <p>Use the <code>explain</code> command without any arguments to display a summary of which rule firings the explainer is watching. It also shows which chunk or justification the user has specified is the current focus of its output, i.e. the chunk being discussed.</p> <p>Tip: This is a good way to get a chunk id so that you don't have to type or paste in a chunk name.</p> <pre><code>=======================================================\n                   Explainer Summary\n=======================================================\nWatch all chunk formations                            Yes\nExplain justifications                                Nof\nNumber of specific rules watched                      0\n\nChunks available for discussion:                      chunkx2*apply2 (c 14)\n                                                      chunk*apply*o (c 13)\n                                                      chunkx2*apply2 (c 12)\n                                                      chunk*apply*d (c 11)\n                                                      chunkx2*apply2 (c 6)\n                                                      chunk*apply* (c 15)\n                                                      chunkx2*apply (c 8)\n                                                      chunk*apply*c (c 5)\n                                                      chunkx2*apply (c 10)\n                                                      chunk*apply (c 1)\n\n* Note:  Printed the first 10 chunks. 'explain list' to see other 6 chunks.\n\nCurrent chunk being discussed:                        chunk*apply*down-gripper(c 3)\n</code></pre> <p><code>explain chunk [ &lt;chunk id&gt; | &lt;chunk name&gt; ]</code></p> <p>This command starts the explanation process by specifying which chunk's explanation trace you want to explore.</p> <p>Tip: Use the alias <code>c</code> to quickly start discussing a chunk, for example:</p> <pre><code>soar % c 3\nNow explaining chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1.\n- Note that future explain commands are now relative\n  to the problem-solving that led to that chunk.\n\nExplanation Trace                                     Using variable identity IDs                  Shortest Path to Result Instantiation\n\nsp {chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1\n1:    (&lt;s1&gt; ^top-state &lt;s2&gt;)                          ([140] ^top-state [162])\n     -{\n2:    (&lt;s1&gt; ^operator &lt;o*1&gt;)                          ([140] ^operator [141])\n3:    (&lt;o*1&gt; ^name evaluate-operator)                 ([141] ^name evaluate-operator)\n     }\n4:    (&lt;s2&gt; ^gripper &lt;g1&gt;)                            ([162] ^gripper [156])                       i 30 -&gt; i 31\n5:    (&lt;g1&gt; ^position up)                             ([156] ^position up)                         i 30 -&gt; i 31\n6:    (&lt;g1&gt; ^holding nothing)                         ([156] ^holding nothing)                     i 30 -&gt; i 31\n7:    (&lt;g1&gt; ^above &lt;t1&gt;)                              ([156] ^above [157])                         i 30 -&gt; i 31\n8:    (&lt;s2&gt; ^io &lt;i2&gt;)                                 ([162] ^io [163])                            i 31\n9:    (&lt;i2&gt; ^output-link &lt;i1&gt;)                        ([163] ^output-link [164])                   i 31\n10:   (&lt;i1&gt; ^gripper &lt;g2&gt;)                            ([164] ^gripper [165])                       i 31\n11:   (&lt;s2&gt; ^clear { &lt;&gt; &lt;t1&gt; &lt;b1&gt; })                  ([162] ^clear { &lt;&gt;[161]  [161] })            i 30 -&gt; i 31\n12:   (&lt;s1&gt; ^operator &lt;o1&gt;)                           ([140] ^operator [149])\n13:   (&lt;o1&gt; ^moving-block &lt;b1&gt;)                       ([149] ^moving-block [161])\n14:   (&lt;o1&gt; ^name pick-up)                            ([149] ^name pick-up)\n      --&gt;\n1:    (&lt;g2&gt; ^command move-gripper-above +)            ([165] ^command move-gripper-above +)\n2:    (&lt;g2&gt; ^destination &lt;c1&gt; +)                      ([165] ^destination [161] +)\n</code></pre> <p><code>explain formation</code></p> <p>Once you specify a rule to explain, this will be one of the first commands you issue.  <code>explain formation</code> provides an explanation of the initial rule that fired which created a result. This is what is called the `base instantiation' and is what led to the chunk being learned. Other rules may also be base instantiations if they previously created children of the base instantiation's results. They also will be listed in the initial formation output.</p> <pre><code>soar % explain formation\n------------------------------------------------------------------------------------\nThe formation of chunk 'chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1' (c 1)\n------------------------------------------------------------------------------------\n\nInitial base instantiation (i 31) that fired when apply*move-gripper-above*pass*top-state matched at level 3 at time 6:\n\nExplanation trace of instantiation # 31            (match of rule apply*move-gripper-above*pass*top-state at level 3)\n (produced chunk result)\n                                                   Identities instead of variables       Operational    Creator\n\n1:    (&lt;s&gt; ^operator &lt;op&gt;)                         ([159] ^operator [160])                   No         i 30 (pick-up*propose*move-gripper-above)\n2:    (&lt;op&gt; ^name move-gripper-above)              ([160] ^name move-gripper-above)          No         i 30 (pick-up*propose*move-gripper-above)\n3:    (&lt;op&gt; ^destination &lt;des&gt;)                    ([160] ^destination [161])                No         i 30 (pick-up*propose*move-gripper-above)\n4:    (&lt;s&gt; ^top-state &lt;t*1&gt;)                       ([159] ^top-state [162])                  No         i 27 (elaborate*state*top-state)\n5:    (&lt;t*1&gt; ^io &lt;i*1&gt;)                            ([162] ^io [163])                         Yes        Higher-level Problem Space\n6:    (&lt;i*1&gt; ^output-link &lt;o*1&gt;)                   ([163] ^output-link [164])                Yes        Higher-level Problem Space\n7:    (&lt;o*1&gt; ^gripper &lt;gripper&gt;)                   ([164] ^gripper [165])                    Yes        Higher-level Problem Space\n   --&gt;\n1:    (&lt;gripper&gt; ^command move-gripper-above +)    ([165] ^command move-gripper-above +)\n2:    (&lt;gripper&gt; ^destination &lt;des&gt; +)             ([165] ^destination [161] +)\n------\n\nThis chunk summarizes the problem-solving involved in the following 5\nrule firings:\n\n   i 27 (elaborate*state*top-state)\n   i 28 (elaborate*state*operator*name)\n   i 29 (pick-up*elaborate*desired)\n   i 30 (pick-up*propose*move-gripper-above)\n   i 31 (apply*move-gripper-above*pass*top-state)\n</code></pre> <p><code>explain instantiation &lt;instantiation id&gt;</code></p> <p>This command prints a specific instantiation in the behavior trace. This lets you browse the instantiation graph one rule at a time. This is probably one of the most common things you will do while using the explainer.</p> <p>Tip: Use the alias <code>i &lt;instantiation id&gt;</code> to quickly view an instantiation, for example:</p> <pre><code>soar % i 30\nExplanation trace of instantiation # 30            (match of rule pick-up*propose*move-gripper-above at level 3)\n- Shortest path to a result: i 30 -&gt; i 31\n                                                   Identities instead of variables       Operational    Creator\n\n1:    (&lt;s&gt; ^name pick-up)                          ([152] ^name pick-up)                     No         i 28 (elaborate*state*operator*name)\n2:    (&lt;s&gt; ^desired &lt;d*1&gt;)                         ([152] ^desired [153])                    No         i 29 (pick-up*elaborate*desired)\n3:    (&lt;d*1&gt; ^moving-block &lt;mblock&gt;)               ([153] ^moving-block [154])               No         i 29 (pick-up*elaborate*desired)\n4:    (&lt;s&gt; ^top-state &lt;ts&gt;)                        ([152] ^top-state [155])                  No         i 27 (elaborate*state*top-state)\n5:    (&lt;ts&gt; ^clear &lt;mblock&gt;)                       ([155] ^clear [154])                      Yes        Higher-level Problem Space\n6:    (&lt;ts&gt; ^gripper &lt;g&gt;)                          ([155] ^gripper [156])                    Yes        Higher-level Problem Space\n7:    (&lt;g&gt; ^position up)                           ([156] ^position up)                      Yes        Higher-level Problem Space\n8:    (&lt;g&gt; ^holding nothing)                       ([156] ^holding nothing)                  Yes        Higher-level Problem Space\n9:    (&lt;g&gt; ^above { &lt;&gt; &lt;mblock&gt; &lt;a*1&gt; })           ([156] ^above { &lt;&gt;[154]  [157] })         Yes        Higher-level Problem Space\n   --&gt;\n1:    (&lt;s&gt; ^operator &lt;op1&gt; +)                      ([152] ^operator [158] +)\n2:    (&lt;op1&gt; ^name move-gripper-above +)           ([158] ^name move-gripper-above +)\n3:    (&lt;op1&gt; ^destination &lt;mblock&gt; +)              ([158] ^destination [154] +)\n</code></pre> <p><code>explain [explanation-trace | wm-trace]</code></p> <p>In most cases, users spend most of their time browsing the explanation trace. This is where chunking learns most of the subtle relationships that you are likely to be debugging. But users will also need to examine the working memory trace to see the specific values matched.</p> <p>To switch between traces, you can use the <code>explain e</code> and the <code>explain w</code> commands.</p> <p>Tip: Use the aliases <code>et</code> and <code>wt</code> to quickly switch between traces.</p> <pre><code>soar % explain w\nWorking memory trace of instantiation # 30     (match of rule pick-up*propose*move-gripper-above at level 3)\n1:    (S9 ^name pick-up)                               No         i 28 (elaborate*state*operator*name)\n2:    (S9 ^desired D6)                                 No         i 29 (pick-up*elaborate*desired)\n3:    (D6 ^moving-block B3)                            No         i 29 (pick-up*elaborate*desired)\n4:    (S9 ^top-state S1)                               No         i 27 (elaborate*state*top-state)\n5:    (S1 ^clear B3)                                   Yes        Higher-level Problem Space\n6:    (S1 ^gripper G2)                                 Yes        Higher-level Problem Space\n7:    (G2 ^position up)                                Yes        Higher-level Problem Space\n8:    (G2 ^holding nothing)                            Yes        Higher-level Problem Space\n9:    (G2 ^above { &lt;&gt; B3 T1 })                         Yes        Higher-level Problem Space\n   --&gt;\n1:    (S9 ^operator O9) +\n2:    (O9 ^name move-gripper-above) +\n3:    (O9 ^destination B3) +\n</code></pre> <p><code>explain constraints</code></p> <p>This feature lists all constraints found in non-operational constraints of the explanation trace. If these constraints were not met, the problem-solving would not have occurred.</p> <p>This feature is not yet implemented. You can use <code>explain stats</code> to see if any transitive constraints were added to a particular chunk.</p> <p><code>explain identity</code></p> <p><code>explain identity</code> will show the mappings from variable identities to identity sets. If available, the variable in a chunk that an identity set maps to will also be displayed. an identity set maps to will also be displayed.</p> <p>By default, only identity sets that appear in the chunk will be displayed in the identity analysis. To see the identity set mappings for other sets, change the <code>only-chunk-identities</code> setting to <code>off</code>.</p> <pre><code>soar % explain identity\n=========================================================================\n-             Variablization Identity to Identity Set Mappings          -\n=========================================================================\n\n-== NULL Identity Set ==-\n\nThe following variable identities map to the null identity set and will\nnot be generalized: 282 301 138 291 355 336 227 309 328 318 128 218 345\n\n-== How variable identities map to identity sets ==-\n\nVariablization IDs      Identity     CVar    Mapping Type\n\nInstantiation 36:\n  125 -&gt; 482          | IdSet 12  | &lt;s&gt;       | New identity set\n  126 -&gt; 493          | IdSet 11  | &lt;o&gt;       | New identity set\nInstantiation 38:\nInstantiation 41:\n  146 -&gt; 482          | IdSet 12  | &lt;s&gt;       | New identity set\n  147 -&gt; 493          | IdSet 11  | &lt;o&gt;       | New identity set\nInstantiation 42:\n  151 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | New identity set\n  149 -&gt; 482          | IdSet 12  | &lt;s&gt;       | New identity set\n  150 -&gt; 493          | IdSet 11  | &lt;o&gt;       | New identity set\n  307 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  187 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  334 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  173 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\n  280 -&gt; 180          | IdSet 1   | &lt;ss&gt;      | Added to identity set\nInstantiation 53:\n  219 -&gt; 489          | IdSet 15  | &lt;b&gt;       | New identity set\nInstantiation 61:\nInstantiation 65:\n  319 -&gt; 492          | IdSet 20  | &lt;t&gt;       | New identity set\n</code></pre> <p><code>explain stats</code></p> <p>Explain's <code>stat</code> command prints statistics about the specific chunk being discussed. This is a good way to see whether any generality or correctness issues were detected while learning that rule.</p> <pre><code>===========================================================\nStatistics for 'chunk*apply*move-gripper-above*pass*top-state*OpNoChange*t6-1' (c 1):\n===========================================================\nNumber of conditions                                       14\nNumber of actions                                          2\nBase instantiation                                         i 31 (apply*move-gripper-above*pass*top-state)\n\n===========================================================\n                 Generality and Correctness\n===========================================================\n\nTested negation in local substate                          No\nLHS required repair                                        No\nRHS required repair                                        No\nWas unrepairable chunk                                     No\n\n===========================================================\n                      Work Performed\n===========================================================\nInstantiations backtraced through                          5\nInstantiations skipped                                     6\nConstraints collected                                      1\nConstraints attached                                       0\nDuplicates chunks later created                            0\nConditions merged                                          2\n</code></pre>"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#after-action-reports","title":"After-Action Reports","text":"<p>The explainer has an option to create text files that contain statistics about the rules learned by an agent during a particular run. When enabled, the explainer will write out a file with the statistics when either Soar exits or a <code>soar init</code> is executed. This option is still considered experimental and in beta.</p> A colored visualization of a behavior trace"},{"location":"soar_manual/04_ProceduralKnowledgeLearning/#visualizing-the-explanation","title":"Visualizing the Explanation","text":"<p>The <code>visualize</code> command can generate two graphical representations of the analysis that chunking performed to learn a rule. While the explainer provides more data, these images are the easiest and most effective ways to quickly understand how a chunk was formed, especially for particularly complex chunks. The visualizer can create two types of chunking-related images:</p> <ol> <li> <p>An image that shows the entire instantiation graph at once and how     it contributed to the learned rule.</p> <p>Use the command <code>visualize ebc analysis</code> to create a very informative graph that shows all rules that fired in a substate with arrows that indicate dependencies between actions in one rule and conditions in others. In addition to all of the dependencies between the rules that fired, this visualization also shows which conditions in the instantiations tested knowledge in the superstate and hence became the basis for a condition in the final learned rule. Finally, the individual elements in the explanation are color-coded to show which variables share the same identity.</p> </li> <li> <p>An image that shows the graph of how variable identities were     combined.</p> <p>Use the <code>visualize identity graph</code> to create a graph that shows how identities were used to determine the variablization of a learned rule. This shows all identities found in the chunk and how the identity analysis joined them based on the problem-solving that occurred. This can be useful in determining why two elements were assigned the same variable.</p> </li> </ol> <p>Note that Soar will automatically attempt to launch a viewer to see the image generated. If you have an editor that can open graphviz files, you can have Soar launch that automatically as well. (Such editors allow you to move things around and lay out the components of the image exactly as you want them.) Your operating system chooses which program to launch based on the file type.</p> <p>For the visualizer to work, you must have Graphviz and DOT installed, which are free third-party tools, and both must be available on your path. To date, the visualizer has only been tested on Mac and Linux. It is possible that certain systems may not allow Soar to launch an external program.</p>"},{"location":"soar_manual/05_ReinforcementLearning/","title":"Reinforcement Learning","text":""},{"location":"soar_manual/05_ReinforcementLearning/#reinforcement-learning","title":"Reinforcement Learning","text":"<p>Soar has a reinforcement learning (RL) mechanism that tunes operator selection knowledge based on a given reward function. This chapter describes the RL mechanism and how it is integrated with production memory, the decision cycle, and the state stack. We assume that the reader is familiar with basic reinforcement learning concepts and notation. If not, we recommend first reading Reinforcement Learning: An Introduction (1998) by Richard S. Sutton and Andrew G. Barto. The detailed behavior of the RL mechanism is determined by numerous parameters that can be controlled and configured via the <code>rl</code> command.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#rl-rules","title":"RL Rules","text":"Info <p>In this context, the term \"state\" refers to the state of the task or environment, not a state identifier. For the rest of this chapter, bold capital letter names such as <code>S1</code> will refer to identifiers and italic lowercase names such as \\(s_1\\) will refer to task states.</p> <p>Soar\u2019s RL mechanism learns \\(Q\\)-values for state-operator pairs. \\(Q\\)-values are stored as numeric-indifferent preferences created by specially formulated productions called RL rules. RL rules are identified by syntax. A production is a RL rule if and only if its left hand side tests for a proposed operator, its right hand side creates a single numeric-indifferent preference, and it is not a template rule (see rule templates). These constraints ease the technical requirements of identifying/ updating RL rules and makes it easy for the agent programmer to add/ maintain RL capabilities within an agent. We define an RL operator as an operator with numeric-indifferent preferences created by RL rules.</p> <p>The following is an RL rule:</p> <pre><code>sp {rl*3*12*left\n   (state &lt;s&gt; ^name task-name\n      ^x 3\n      ^y 12\n      ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move\n      ^direction left)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = 1.5)\n}\n</code></pre> <p>Note that the LHS of the rule can test for anything as long as it contains a test for a proposed operator. The RHS is constrained to exactly one action: creating a numeric-indifferent preference for the proposed operator.</p> <p>The following are not RL rules:</p> <pre><code>sp {multiple*preferences\n   (state &lt;s&gt; ^operator &lt;o&gt; +)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = 5, &gt;) # (1)\n}\n</code></pre> <ol> <li>Proposes multiple preferences for the proposed operator and thus does not     comply with the rule format</li> </ol> <pre><code>sp {variable*binding\n   (state &lt;s&gt; ^operator &lt;o&gt; +\n      ^value &lt;v&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = &lt;v&gt;) # (1)\n}\n</code></pre> <ol> <li>Does not provide a constant for the numeric-indifferent preference value</li> </ol> <pre><code>sp {invalid*actions\n   (state &lt;s&gt; ^operator &lt;o&gt; +)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = 5)\n   (write (crlf) |This is not an RL rule.|) # (1)\n}\n</code></pre> <ol> <li>Includes a RHS function action in addition to the numeric-indifferent     preference action.</li> </ol> <p>In the typical RL use case, the user intends for the agent to learn the best operator in each possible state of the environment. The most straightforward way to achieve this is to give the agent a set of RL rules, each matching exactly one possible state-operator pair. This approach is equivalent to a table-based RL algorithm, where the \\(Q\\)-value of each state-operator pair corresponds to the numeric-indifferent preference created by exactly one RL rule.</p> <p>In the more general case, multiple RL rules can match a single state-operator pair, and a single RL rule can match multiple state-operator pairs. That is, in Soar, a state-operator pair corresponds to an operator in a specific working memory context, and multiple rules can modify the preferences for a single operator, and a single rule can be instantiated multiple ways to modify preferences for multiple operators. For RL in Soar, all numeric-indifferent preferences for an operator are summed when calculating the operator\u2019s \\(Q\\)-value.</p> Info <p>This is assuming the value of numeric-indifferent-mode is set to sum. In general, the RL mechanism only works correctly when this is the case, and we assume this case in the rest of the chapter.</p> <p>In this context, RL rules can be interpreted more generally as binary features in a linear approximator of each state-operator pair\u2019s \\(Q\\)-value, and their numeric-indifferent preference values their weights. In other words,</p> \\[Q(s, a) = w_1 \\phi_1 (s, a) + w_2 \\phi_2 (s, a) + \\ldots + w_n \\phi_n (s, a)\\] <p>where all RL rules in production memory are numbered \\(1 \\dots n\\), \\(Q(s, a)\\) is the \\(Q\\)-value of the state-operator pair \\((s, a)\\), \\(w_i\\) is the numeric-indifferent preference value of RL rule \\(i\\), \\(\\phi_i (s, a) = 0\\) if RL rule \\(i\\) does not match \\((s, a)\\), and \\(\\phi_i (s, a) = 1\\) if it does. This interpretation allows RL rules to simulate a number of popular function approximation schemes used in RL such as tile coding and sparse coding.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#reward-representation","title":"Reward Representation","text":"<p>RL updates are driven by reward signals. In Soar, these reward signals are given to the RL mechanism through a working memory link called the reward-link. Each state in Soar\u2019s state stack is automatically populated with a <code>reward-link</code> structure upon creation. Soar will check each structure for a numeric reward signal for the last operator executed in the associated state at the beginning of every decision phase. Reward is also collected when the agent is halted or a state is retracted.</p> <p>In order to be recognized, the reward signal must follow this pattern:</p> <pre><code>(&lt;r1&gt; ^reward &lt;r2&gt;)\n(&lt;r2&gt; ^value [val])\n</code></pre> <p>where <code>&lt;r1&gt;</code> is the <code>reward-link</code> identifier, <code>&lt;r2&gt;</code> is some intermediate identifier, and <code>[val]</code> is any constant numeric value. Any structure that does not match this pattern is ignored. If there are multiple valid reward signals, their values are summed into a single reward signal. As an example, consider the following state:</p> <pre><code>(S1 ^reward-link R1)\n   (R1 ^reward R2)\n      (R2 ^value 1.0)\n   (R1 ^reward R3)\n      (R3 ^value -0.2)\n</code></pre> <p>In this state, there are two reward signals with values 1.0 and -0.2. They will be summed together for a total reward of 0.8 and this will be the value given to the RL update algorithm.</p> <p>There are two reasons for requiring the intermediate identifier. The first is so that multiple reward signals with the same value can exist simultaneously. Since working memory is a set, multiple WMEs with identical values in all three positions (identifier, attribute, value) cannot exist simultaneously. Without an intermediate identifier, specifying two rewards with the same value would require a WME structure such as</p> <pre><code>(S1 ^reward-link R1)\n   (R1 ^reward 1.0)\n   (R1 ^reward 1.0)\n</code></pre> <p>which is invalid. With the intermediate identifier, the rewards would be specified as</p> <pre><code>(S1 ^reward-link R1)\n   (R1 ^reward R2)\n      (R2 ^value 1.0)\n   (R1 ^reward R3)\n      (R3 ^value 1.0)\n</code></pre> <p>which is valid. The second reason for requiring an intermediate identifier in the reward signal is so that the rewards can be augmented with additional information, such as their source or how long they have existed. Although this information will be ignored by the RL mechanism, it can be useful to the agent or programmer. For example:</p> <pre><code>(S1 ^reward-link R1)\n   (R1 ^reward R2)\n      (R2 ^value 1.0)\n      (R2 ^source environment)\n   (R1 ^reward R3)\n      (R3 ^value -0.2)\n      (R3 ^source intrinsic)\n      (R3 ^duration 5)\n</code></pre> <p>The <code>(R2 ^source environment)</code>, <code>(R3 ^source intrinsic)</code>, and <code>(R3 ^duration 5)</code> WMEs are arbitrary and ignored by RL, but were added by the agent to keep track of where the rewards came from and for how long.</p> <p>Note that the <code>reward-link</code> is not part of the io structure and is not modified directly by the environment. Reward information from the environment should be copied, via rules, from the <code>input-link</code> to the reward-link. Also note that when collecting rewards, Soar simply scans the <code>reward-link</code> and sums the values of all valid reward WMEs. The WMEs are not modified and no bookkeeping is done to keep track of previously seen WMEs. This means that reward WMEs that exist for multiple decision cycles will be collected multiple times if not removed or retracted.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#updating-rl-rule-values","title":"Updating RL Rule Values","text":"<p>Soar\u2019s RL mechanism is integrated naturally with the decision cycle and performs online updates of RL rules. Whenever an RL operator is selected, the values of the corresponding RL rules will be updated. The update can be on-policy (Sarsa) or off-policy (Q-Learning), as controlled by the learning-policy parameter of the <code>rl</code> command. Let \\(\\delta_t\\) be the amount of change for the \\(Q\\)-value of an RL operator in a single update. For Sarsa, we have</p> \\[ \\delta_t = \\alpha \\left[ r_{t+1} + \\gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t) \\right] \\] <p>where</p> <ul> <li>\\(Q(s_t, a_t)\\) is the \\(Q\\)-value of the state and chosen operator in decision     cycle \\(t\\).</li> <li>\\(Q(s_{t+1}, a_{t+1})\\) is the \\(Q\\)-value of the state and chosen RL operator in     the next decision cycle.</li> <li>\\(r_{t+1}\\) is the total reward collected in the next decision cycle.</li> <li>\\(\\alpha\\) and \\(\\gamma\\) are the settings of the <code>learning-rate</code> and     <code>discount-rate</code> parameters of the <code>rl</code> command, respectively.</li> </ul> <p>Note that since \\(\\delta_t\\) depends on \\(Q(s_{t+1}, a_{t+1})\\), the update for the operator selected in decision cycle \\(t\\) is not applied until the next RL operator is chosen. For Q-Learning, we have</p> \\[ \\delta_t = \\alpha \\left[ r_{t+1} + \\gamma \\underset{a \\in A_{t+1}}{\\max} Q(s_{t+1}, a) - Q(s_t, a_t) \\right] \\] <p>where \\(A_{t+1}\\) is the set of RL operators proposed in the next decision cycle.</p> <p>Finally, \\(\\delta_t\\) is divided by the number of RL rules comprising the \\(Q\\)-value for the operator and the numeric-indifferent values for each RL rule is updated by that amount.</p> <p>An example walkthrough of a Sarsa update with \\(\\alpha = 0.3\\) and \\(\\gamma = 0.9\\) (the default settings in Soar) follows.</p> <ol> <li> <p>In decision cycle \\(t\\), an operator <code>O1</code> is proposed, and RL rules <code>rl-1</code>     and <code>rl-2</code> create the following numeric-indifferent preferences for it:</p> <pre><code>rl-1: (S1 ^operator O1 = 2.3)\nrl-2: (S1 ^operator O1 = -1)\n</code></pre> <p>The \\(Q\\)-value for <code>O1</code> is \\(Q(s_t, \\textbf{O1}) = 2.3 - 1 = 1.3\\).</p> </li> <li> <p><code>O1</code> is selected and executed, so \\(Q(s_t, a_t) = Q(s_t, \\textbf{O1}) = 1.3\\).</p> </li> <li> <p>In decision cycle \\(t+1\\), a total reward of 1.0 is collected on the     <code>reward-link</code>, an operator <code>O2</code> is proposed, and another RL rule <code>rl-3</code>     creates the following numeric-indifferent preference for it:</p> <pre><code>rl-3: (S1 ^operator O2 = 0.5)\n</code></pre> <p>So \\(Q(s_{t+1}, \\textbf{O2}) = 0.5\\).</p> </li> <li> <p><code>O2</code> is selected, so \\(Q(s_{t+1}, a_{t+1}) = Q(s_{t+1}, \\textbf{O2}) = 0.5\\) Therefore,</p> \\[ \\delta_t = \\alpha \\left[r_{t+1} + \\gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t) \\right] = 0.3 \\times [ 1.0 + 0.9 \\times 0.5 - 1.3 ] = 0.045 \\] <p>Since <code>rl-1</code> and <code>rl-2</code> both contributed to the \\(Q\\)-value of <code>O1</code>, \\(\\delta_t\\) is evenly divided amongst them, resulting in updated values of</p> <pre><code>rl-1: (&lt;s&gt; ^operator &lt;o&gt; = 2.3225)\nrl-2: (&lt;s&gt; ^operator &lt;o&gt; = -0.9775)\n</code></pre> </li> <li> <p><code>rl-3</code> will be updated when the next RL operator is selected.</p> </li> </ol>"},{"location":"soar_manual/05_ReinforcementLearning/#gaps-in-rule-coverage","title":"Gaps in Rule Coverage","text":"<p>The previous description had assumed that RL operators were selected in both decision cycles \\(t\\) and \\(t+1\\). If the operator selected in \\(t+1\\) is not an RL operator, then \\(Q(s_{t+1}, a_{t+1})\\) would not be defined, and an update for the RL operator selected at time \\(t\\) will be undefined. We will call a sequence of one or more decision cycles in which RL operators are not selected between two decision cycles in which RL operators are selected a gap. Conceptually, it is desirable to use the temporal difference information from the RL operator after the gap to update the \\(Q\\)-value of the RL operator before the gap. There are no intermediate storage locations for these updates. Requiring that RL rules support operators at every decision can be difficult for agent programmers, particularly for operators that do not represent steps in a task, but instead perform generic maintenance functions, such as cleaning processed output-link structures.</p> <p>To address this issue, Soar's RL mechanism supports automatic propagation of updates over gaps. For a gap of length \\(n\\), the Sarsa update is</p> \\[ \\delta_t = \\alpha \\left[ \\sum_{i=t}^{t+n}{\\gamma^{i-t} r_i} + \\gamma^{n+1} Q(s_{t+n+1}, a_{t+n+1}) - Q(s_t, a_t) \\right] \\] <p>and the Q-Learning update is</p> \\[ \\delta_t = \\alpha \\left[ \\sum_{i=t}^{t+n}{\\gamma^{i-t} r_i} + \\gamma^{n+1} \\underset{a \\in A_{t+n+1}}{\\max} Q(s_{t+n+1}, a) - Q(s_t, a_t) \\right] \\] <p>Note that rewards will still be collected during the gap, but they are discounted based on the number of decisions they are removed from the initial RL operator.</p> <p>Gap propagation can be disabled by setting the temporal-extension parameter of the <code>rl</code> command to off. When gap propagation is disabled, the RL rules preceding a gap are updated using \\(Q(s_{t+1}, a_{t+1}) = 0\\). The rl setting of the <code>watch</code> command is useful in identifying gaps.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#rl-and-substates","title":"RL and Substates","text":"<p>When an agent has multiple states in its state stack, the RL mechanism will treat each substate independently. As mentioned previously, each state has its own <code>reward-link</code>. When an RL operator is selected in a state <code>S</code>, the RL updates for that operator are only affected by the rewards collected on the <code>reward-link</code> for Sand the \\(Q\\)-values of subsequent RL operators selected in <code>S</code>.</p> <p>The only exception to this independence is when a selected RL operator forces an operator-no-change impasse. When this occurs, the number of decision cycles the RL operator at the superstate remains selected is dependent upon the processing in the impasse state. Consider the operator trace in the following figure:</p> r 2 r 3 r 4 O1 O1 O1 O1 O5 O2 O3 O4 S1 S2 Example Soar substate operator trace. <ul> <li>At decision cycle 1, RL operator <code>O1</code> is selected in <code>S1</code> and causes an     operator-no-change impasse for three decision cycles.</li> <li>In the substate <code>S2</code>, operators <code>O2</code>, <code>O3</code>, and <code>O4</code> are selected and     applied sequentially.</li> <li>Meanwhile in <code>S1</code>, rewards \\(r_2\\), \\(r_3\\), and \\(r_4\\) are put on the     <code>reward-link</code> sequentially.</li> <li>Finally, the impasse is resolved by <code>O4</code>, the proposal for <code>O1</code> is retracted,     and RL operator <code>O5</code> is selected in <code>S1</code>.</li> </ul> <p>In this scenario, only the RL update for \\(Q(s_1, O1)\\) will be different from the ordinary case. Its value depends on the setting of the <code>hrl-discount</code> parameter of the <code>rl</code> command. When this parameter is set to the default value on, the rewards on <code>S1</code> and the \\(Q\\)-value of <code>O5</code> are discounted by the number of decision cycles they are removed from the selection of <code>O1</code>. In this case the update for \\(Q(s_1, \\textbf{O1})\\) is</p> \\[ \\delta_1 = \\alpha \\left[ r_2 + \\gamma r_3 + \\gamma^2 r_4 + \\gamma^3 Q(s_5, \\textbf{O5}) - Q(s_1, \\textbf{O1}) \\right] \\] <p>which is equivalent to having a three decision gap separating <code>O1</code> and <code>O5</code>.</p> <p>When <code>hrl-discount</code> is set to <code>off</code>, the number of cycles <code>O1</code> has been impassed will be ignored. Thus the update would be</p> \\[ \\delta_1 = \\alpha \\left[ r_2 + r_3 + r_4 + \\gamma Q(s_5, \\textbf{O5}) - Q(s_1, \\textbf{O1}) \\right] \\] <p>For impasses other than operator no-change, RL acts as if the impasse hadn\u2019t occurred. If <code>O1</code> is the last RL operator selected before the impasse, \\(r_2\\) the reward received in the decision cycle immediately following, and \\(O_n\\), the first operator selected after the impasse, then <code>O1</code> is updated with</p> \\[ \\delta_1 = \\alpha \\left[ r_2 + \\gamma Q(s_n, \\textbf{O}_\\textbf{n}) - Q(s_1, \\textbf{O1}) \\right] \\] <p>If an RL operator is selected in a substate immediately prior to the state\u2019s retraction, the RL rules will be updated based only on the reward signals present and not on the \\(Q\\)-values of future operators. This point is not covered in traditional RL theory. The retraction of a substate corresponds to a suspension of the RL task in that state rather than its termination, so the last update assumes the lack of information about future rewards rather than the discontinuation of future rewards. To handle this case, the numeric-indifferent preference value of each RL rule is stored as two separate values, the expected current reward (ECR) and expected future reward (EFR). The ECR is an estimate of the expected immediate reward signal for executing the corresponding RL operator. The EFR is an estimate of the time discounted \\(Q\\)-value of the next RL operator. Normal updates correspond to traditional RL theory (showing the Sarsa case for simplicity):</p> \\[ \\begin{aligned} \\delta_{ECR} &amp;= \\alpha \\left[ r_t - ECR(s_t, a_t) \\right] \\\\ \\delta_{EFR} &amp;= \\alpha \\left[ \\gamma Q(s_{t+1}, a_{t+1}) - EFR(s_t, a_t)\\right] \\\\ \\delta_t &amp;= \\delta_{ECR} + \\delta_{EFR} \\\\     &amp;= \\alpha \\left[ r_t + \\gamma Q(s_{t+1}, a_{t+1}) - \\left( ECR(s_t, a_t) + EFR(s_t, a_t) \\right) \\right] \\\\     &amp;= \\alpha \\left[ r_t + \\gamma Q(s_{t+1}, a_{t+1}) - Q(s_t, a_t) \\right] \\end{aligned} \\] <p>During substate retraction, only the ECR is updated based on the reward signals present at the time of retraction, and the EFR is unchanged.</p> <p>Soar\u2019s automatic subgoaling and RL mechanisms can be combined to naturally implement hierarchical reinforcement learning algorithms such as <code>MAXQ</code> and options.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#eligibility-traces","title":"Eligibility Traces","text":"<p>The RL mechanism supports eligibility traces, which can improve the speed of learning by updating RL rules across multiple sequential steps.</p> <p>The <code>eligibility-trace-decay-rate</code> and <code>eligibility-trace-tolerance</code> parameters control this mechanism. By setting <code>eligibility-trace-decay-rate</code> to 0 (default), eligibility traces are in effect disabled. When eligibility traces are enabled, the particular algorithm used is dependent upon the learning policy. For Sarsa, the eligibility trace implementation is \\(Sarsa(\\lambda)\\). For Q-Learning, the eligibility trace implementation is \\(Watkin's Q(\\lambda)\\).</p>"},{"location":"soar_manual/05_ReinforcementLearning/#exploration","title":"Exploration","text":"<p>The <code>decide indifferent-selection</code> command determines how operators are selected based on their numeric-indifferent preferences. Although all the indifferent selection settings are valid regardless of how the numeric-indifferent preferences were arrived at, the <code>epsilon-greedy</code> and <code>boltzmann</code> settings are specifically designed for use with RL and correspond to the two most common exploration strategies. In an effort to maintain backwards compatibility, the default exploration policy is <code>softmax</code>. As a result, one should change to <code>epsilon-greedy</code> or <code>boltzmann</code> when the reinforcement learning mechanism is enabled.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#gq","title":"GQ(\u03bb)","text":"<p>Sarsa(\\(\\lambda\\)) and Watkin\u2019s Q(\\(\\lambda\\)) help agents to solve the temporal credit assignment problem more quickly. However, if you wish to implement something akin to CMACs to generalize from experience, convergence is not guaranteed by these algorithms. \\(GQ(\\lambda)\\) is a gradient descent algorithm designed to ensure convergence when learning off-policy. Soar\u2019s <code>learning-policy</code> can be set to on-policy-gq-lambda or off-policy-gq-lambda to increase the likelihood of convergence when learning under these conditions. If you should choose to use one of these algorithms, we recommend setting the <code>rl</code> step-size-parameter to something small, such as 0.01 in order to ensure that the secondary set of weights used by \\(GQ(\\lambda)\\) change slowly enough for efficient convergence.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#automatic-generation-of-rl-rules","title":"Automatic Generation of RL Rules","text":"<p>The number of RL rules required for an agent to accurately approximate operator \\(Q\\)-values is usually unfeasibly large to write by hand, even for small domains. Therefore, several methods exist to automate this.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#the-gp-command","title":"The gp Command","text":"<p>The <code>gp</code> command can be used to generate productions based on simple patterns. This is useful if the states and operators of the environment can be distinguished by a fixed number of dimensions with finite domains. An example is a grid world where the states are described by integer row/column coordinates, and the available operators are to move north, south, east, or west. In this case, a single <code>gp</code> command will generate all necessary RL rules:</p> <pre><code>gp {gen*rl*rules\n   (state &lt;s&gt; ^name gridworld\n      ^operator &lt;o&gt; +\n      ^row [ 1 2 3 4 ]\n      ^col [ 1 2 3 4 ])\n   (&lt;o&gt; ^name move\n      ^direction [ north south east west ])\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = 0.0)\n   }\n</code></pre>"},{"location":"soar_manual/05_ReinforcementLearning/#rule-templates","title":"Rule Templates","text":"<p>Rule templates allow Soar to dynamically generate new RL rules based on a predefined pattern as the agent encounters novel states. This is useful when either the domains of environment dimensions are not known ahead of time, or when the enumerable state space of the environment is too large to capture in its entirety using gp, but the agent will only encounter a small fraction of that space during its execution. For example, consider the grid world example with 1000 rows and columns. Attempting to generate RL rules for each grid cell and action a priori will result in \\(1000 \\times 1000 \\times 4 = 4 \\times 10^6\\) productions. However, if most of those cells are unreachable due to walls, then the agent will never fire or update most of those productions. Templates give the programmer the convenience of the <code>gp</code> command without filling production memory with unnecessary rules.</p> <p>Rule templates have variables that are filled in to generate RL rules as the agent encounters novel combinations of variable values. A rule template is valid if and only if it is marked with the :template flag and, in all other respects, adheres to the format of an RL rule. However, whereas an RL rule may only use constants as the numeric-indifference preference value, a rule template may use a variable. Consider the following rule template:</p> <pre><code>sp {sample*rule*template\n   :template\n   (state &lt;s&gt; ^operator &lt;o&gt; +\n      ^value &lt;v&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = &lt;v&gt;)\n   }\n</code></pre> <p>During agent execution, this rule template will match working memory and create new productions by substituting all variables in the rule template that matched against constant values with the values themselves. Suppose that the LHS of the rule template matched against the state</p> <pre><code>(S1 ^value 3.2)\n(S1 ^operator O1 +)\n</code></pre> <p>Then the following production will be added to production memory:</p> <pre><code>sp {rl*sample*rule*template*1\n   (state &lt;s&gt; ^operator &lt;o&gt; +\n      ^value 3.2)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; = 3.2)\n   }\n</code></pre> <p>The variable <code>&lt;v&gt;</code> is replaced by <code>3.2</code> on both the LHS and the RHS, but <code>&lt;s&gt;</code> and <code>&lt;o&gt;</code> are not replaced because they match against identifiers (<code>S1</code> and <code>O1</code>). As with other RL rules, the value of <code>3.2</code> on the RHS of this rule may be updated later by reinforcement learning, whereas the value of <code>3.2</code> on the LHS will remain unchanged. If <code>&lt;v&gt;</code> had matched against a non-numeric constant, it will be replaced by that constant on the LHS, but the RHS numeric-indifference preference value will be set to zero to make the new rule valid.</p> <p>The new production\u2019s name adheres to the following pattern: <code>rl*template-name*id</code>, where <code>template-name</code> is the name of the originating rule template and <code>id</code> is monotonically increasing integer that guarantees the uniqueness of the name.</p> <p>If an identical production already exists in production memory, then the newly generated production is discarded. It should be noted that the current process of identifying unique template match instances can become quite expensive in long agent runs. Therefore, it is recommended to generate all necessary RL rules using the <code>gp</code> command or via custom scripting when possible.</p>"},{"location":"soar_manual/05_ReinforcementLearning/#chunking","title":"Chunking","text":"<p>Since RL rules are regular productions, they can be learned by chunking just like any other production. This method is more general than using the <code>gp</code> command or rule templates, and is useful if the environment state consists of arbitrarily complex relational structures that cannot be enumerated.</p>"},{"location":"soar_manual/06_SemanticMemory/","title":"Semantic Memory","text":""},{"location":"soar_manual/06_SemanticMemory/#semantic-memory","title":"Semantic Memory","text":"<p>Soar\u2019s semantic memory is a repository for long-term declarative knowledge, supplementing what is contained in short-term working memory (and production memory). Episodic memory, which contains memories of the agent\u2019s experiences, is described in Chapter 7. The knowledge encoded in episodic memory is organized temporally, and specific information is embedded within the context of when it was experienced, whereas knowledge in semantic memory is independent of any specific context, representing more general facts about the world.</p> <p>This chapter is organized as follows: semantic memory structures in working memory; representation of knowledge in semantic memory; storing semantic knowledge; retrieving semantic knowledge; and a discussion of performance. The detailed behavior of semantic memory is determined by numerous parameters that can be controlled and configured via the <code>smem</code> command.</p>"},{"location":"soar_manual/06_SemanticMemory/#working-memory-structure","title":"Working Memory Structure","text":"<p>Upon creation of a new state in working memory (see Impasse Types; Impasses in Working Memory and in Production) , the architecture creates the following augmentations to facilitate agent interaction with semantic memory:</p> <pre><code>(&lt;s&gt; ^smem &lt;smem&gt;)\n   (&lt;smem&gt; ^command &lt;smem-c&gt;)\n   (&lt;smem&gt; ^result &lt;smem-r&gt;)\n</code></pre> <p>As rules augment the command structure in order to access/change semantic knowledge (Storing Semantic Knowledge, Retrieving Semantic Knowledge) , semantic memory augments the <code>result</code> structure in response. Production actions should not remove augmentations of the <code>result</code> structure directly, as semantic memory will maintain these WMEs.</p>"},{"location":"soar_manual/06_SemanticMemory/#knowledge-representation","title":"Knowledge Representation","text":"<p>The representation of knowledge in semantic memory is similar to that in working memory \u2013 both include graph structures that are composed of symbolic elements consisting of an identifier, an attribute, and a value. It is important to note, however, key differences:</p> <ul> <li> <p>Currently semantic memory only supports attributes that are symbolic constants     (string, integer, or decimal), but not attributes that are identifiers</p> </li> <li> <p>Whereas working memory is a single, connected, directed graph, semantic     memory can be disconnected, consisting of multiple directed, connected     sub-graphs</p> </li> </ul> <p>From Soar 9.6 onward, Long-term identifiers (LTIs) are defined as identifiers that exist in semantic memory only. Each LTI is permanently associated with a specific number that labels it (e.g. <code>@5</code> or <code>@7</code>). Instances of an LTI can be loaded into working memory as regular short-term identifiers (STIs) linked with that specific LTI. For clarity, when printed, a short-term identifier associated with an LTI is followed with the label of that LTI. For example, if the working memory <code>ID L7</code> is associated with the LTI named <code>@29</code>, printing that STI would appear as <code>L7 (@29)</code>.</p> <p>When presented in a figure, long-term identifiers will be indicated by a double-circle. For instance, the following figure depicts the long-term identifier <code>@1</code>, with four augmentations, representing the addition fact of \\(6 + 7 = 13\\) (or, rather, 3, carry 1, in context of multi-column arithmetic).</p> %3 temp1                  6 @1 @1 @1-&gt;temp1                  digit1 temp0                  1 @1-&gt;temp0                  carry-borrow temp3                  3 @1-&gt;temp3                  sum temp2                  7 @1-&gt;temp2                  digit2 Example long-term identifier with four augmentations."},{"location":"soar_manual/06_SemanticMemory/#integrating-long-term-identifiers-with-soar","title":"Integrating Long-Term Identifiers with Soar","text":"<p>Integrating long-term identifiers in Soar presents a number of theoretical and implementation challenges. This section discusses the state of integration with each of Soar\u2019s memories/learning mechanisms.</p>"},{"location":"soar_manual/06_SemanticMemory/#working-memory","title":"Working Memory","text":"<p>Long-term identifiers themselves never exist in working memory. Rather, instances of long term memories are loaded into working memory as STIs through queries or retrievals, and manipulated just like any other WMEs. Changes to any STI augmentations do not directly have any effect upon linked LTIs in semantic memory. Changes to LTIs themselves only occur though <code>store</code> commands on the command link or through command-line directives such as <code>smem --add</code> (see below).</p> <p>Each time an agent loads an instance of a certain LTI from semantic memory into working memory using queries or retrievals, the instance created will always be a new unique STI. This means that if same long-term memory is retrieved multiple times in succession, each retrieval will result in a different STI instance, each linked to the same LTI. A benefit of this is that a retrieved long-term memory can be modified without compromising the ability to recall what the actual stored memory is.</p> Info <p>Before Soar 9.6, LTIs were themselves retrieved into working memory. This meant all augmentations to such IDs, whether from the original retrieval or added after retrieval, would always be merged under the same ID, unless deep-copy was used to make a duplicate short-term memory.</p>"},{"location":"soar_manual/06_SemanticMemory/#procedural-memory","title":"Procedural Memory","text":"<p>Soar productions can use various conditions to test whether an STI is associated with an LTI or whether two STIs are linked to the same LTI (see Predicates for Values). LTI names (e.g. <code>@6</code>) may not appear in the action side of productions.</p>"},{"location":"soar_manual/06_SemanticMemory/#episodic-memory","title":"Episodic Memory","text":"<p>Episodic memory faithfully captures LTI-linked STIs, including the episode of transition. Retrieved episodes contain STIs as they existed during the episode, regardless of any changes to linked LTIs that transpired since the episode occurred.</p>"},{"location":"soar_manual/06_SemanticMemory/#storing-semantic-knowledge","title":"Storing Semantic Knowledge","text":""},{"location":"soar_manual/06_SemanticMemory/#store-command","title":"Store command","text":"<p>An agent stores a long-term identifier in semantic memory by creating a <code>^store</code> command: this is a WME whose identifier is the command link of a state\u2019s smem structure, the attribute is store, and the value is a short-term identifier.</p> <pre><code>&lt;s&gt; ^smem.command.store &lt;identifier&gt;\n</code></pre> <p>Semantic memory will encode and store all WMEs whose identifier is the value of the store command. Storing deeper levels of working memory is achieved through multiple store commands.</p> <p>Multiple store commands can be issued in parallel. Storage commands are processed on every state at the end of every phase of every decision cycle. Storage is guaranteed to succeed and a status WME will be created, where the identifier is the <code>^result</code> link of the smem structure of that state, the attribute is success, and the value is the value of the store command above.</p> <pre><code>&lt;s&gt; ^smem.result.success &lt;identifier&gt;\n</code></pre> <p>If the identifier used in the store command is not linked to any existing LTIs, a new LTI will be created in smem and the stored STI will be linked to it. If the identifier used in the store command is already linked to an LTI, the store will overwrite that long-term memory. For example, if an existing LTI <code>@5</code> had augmentations <code>^A do</code> <code>^B re</code> <code>^C mi</code>, and a <code>store</code> command stored short-term identifier <code>L35</code> which was linked to <code>@5</code> but had only the augmentation <code>^D fa</code>, the LTI <code>@5</code> would be changed to only have <code>^D fa</code>.</p>"},{"location":"soar_manual/06_SemanticMemory/#store-new-command","title":"Store-new command","text":"<p>The <code>^store-new</code> command structure is just like the <code>^store</code> command, except that smem will always store the given memory as an entirely new structure, regardless of whether the given STI was linked to an existing LTI or not. Any STIs that don\u2019t already have links will get linked to the newly created LTIs. But if a stored STI was already linked to some LTI, Soar will not re-link it to the newly created LTI.</p> <p>If this behavior is not desired, the agent can add a <code>^link-to-new-LTM yes</code> augmentation to override this behavior. One use for this setting is to allow chunking to backtrace through a stored memory in a manner that will be consistent with a later state of memory when the newly stored LTI is retrieved again.</p>"},{"location":"soar_manual/06_SemanticMemory/#user-initiated-storage","title":"User-Initiated Storage","text":"<p>Semantic memory provides agent designers the ability to store semantic knowledge via the <code>add</code> switch of the <code>smem</code> command. The format of the command is nearly identical to the working memory manipulation components of the RHS of a production (i.e. no RHS-functions; see The action side of productions). For instance:</p> <pre><code>smem --add {\n   (&lt;arithmetic&gt; ^add10-facts &lt;a01&gt; &lt;a02&gt; &lt;a03&gt;)\n   (&lt;a01&gt; ^digit1 1 ^digit-10 11)\n   (&lt;a02&gt; ^digit1 2 ^digit-10 12)\n   (&lt;a03&gt; ^digit1 3 ^digit-10 13)\n}\n</code></pre> <p>Unlike agent storage, declarative storage is automatically recursive. Thus, this command instance will add a new long-term identifier (represented by the temporary \u2019arithmetic\u2019 variable) with three augmentations. The value of each augmentation will each become an LTI with two constant attribute/value pairs. Manual storage can be arbitrarily complex and use standard dot-notation.</p> <p>The <code>add</code> command also supports two methods for hardcoding LTIs. You can use an integer, such as <code>@123</code>, which will be the literal ID in semantic memory. You can also use a string, such as <code>@table</code>, which defines a name, or alias, for an LTI. This is purely a user convenience; it allows you to refer to an LTI by name or connect the same LTI across different <code>add</code>s or files.</p> <p>For Example:</p> <pre><code>smem --add {\n    (@red ^name red ^is-a color)\n}\nsmem --add {\n    (&lt;rouge&gt; ^word rouge ^concept @red)\n}\n</code></pre> <p>These aliases are not visible to the agent and cannot be used in productions. However, they can be used in other CLI commands, such as <code>print</code>.</p>"},{"location":"soar_manual/06_SemanticMemory/#storage-location","title":"Storage Location","text":"<p>Semantic memory uses SQLite to facilitate efficient and standardized storage and querying of knowledge. The semantic store can be maintained in memory or on disk (per the database and path parameters; see <code>smem</code> command). If the store is located on disk, users can use any standard SQLite programs/components to access/query its contents. However, using a disk-based semantic store is very costly (performance is discussed in greater detail in Section Performance), and running in memory is recommended for most runs.</p> <p>Note that changes to storage parameters, for example database, path and append will not have an effect until the database is used after an initialization. This happens either shortly after launch (on first use) or after a database initialization command is issued. To switch databases or database storage types while running, set your new parameters and then perform an --init command.</p> <p>The path parameter specifies the file system path the database is stored in. When path is set to a valid file system path and database mode is set to file, then the SQLite database is written to that path.</p> <p>The append parameter will determine whether all existing facts stored in a database on disk will be erased when semantic memory loads. Note that this affects soar init also. In other words, if the append setting is off, all semantic facts stored to disk will be lost when a soar init is performed. For semantic memory,append mode is on by default.</p> <p>Note: As of version 9.3.3, Soar used a new schema for the semantic memory database. This means databases from 9.3.2 and below can no longer be loaded. A conversion utility is available in Soar 9.4 to convert from the old schema to the new one.</p> <p>The lazy-commit parameter is a performance optimization. If set to on(default), disk databases will not reflect semantic memory changes until the Soar kernel shuts down. This improves performance by avoiding disk writes. The optimization parameter (see Section Performance) will have an affect on whether databases on disk can be opened while the Soar kernel is running.</p>"},{"location":"soar_manual/06_SemanticMemory/#retrieving-semantic-knowledge","title":"Retrieving Semantic Knowledge","text":"<p>An agent retrieves knowledge from semantic memory by creating an appropriate command (we detail the types of commands below) on the <code>command</code> link of a state\u2019s <code>smem</code> structure. At the end of the output of each decision, semantic memory processes each state\u2019s smem <code>^command</code> structure. Results, meta-data, and errors are added to the result structure of that state\u2019s <code>smem</code> structure.</p> <p>Only one type of retrieval command (which may include optional modifiers) can be issued per state in a single decision cycle. Malformed commands (including attempts at multiple retrieval types) will result in an error:</p> <pre><code>&lt;s&gt; ^smem.result.bad-cmd &lt;smem-c&gt;\n</code></pre> <p>Where the <code>&lt;smem-c&gt;</code> variable refers to the <code>command</code> structure of the state.</p> <p>After a command has been processed, semantic memory will ignore it until some aspect of the command structure changes (via addition/removal of WMEs). When this occurs, the result structure is cleared and the new command (if one exists) is processed.</p>"},{"location":"soar_manual/06_SemanticMemory/#non-cue-based-retrievals","title":"Non-Cue-Based Retrievals","text":"<p>A non-cue-based retrieval is a request by the agent to reflect in working memory the current augmentations of an LTI in semantic memory. The command WME has a <code>retrieve</code> attribute and an LTI-linked identifier value:</p> <pre><code>&lt;s&gt; ^smem.command.retrieve &lt;lti&gt;\n</code></pre> <p>If the value of the command is not an LTI-linked identifier, an error will result:</p> <pre><code>&lt;s&gt; ^smem.result.failure &lt;lti&gt;\n</code></pre> <p>Otherwise, two new WMEs will be placed on the result structure:</p> <pre><code>&lt;s&gt; ^smem.result.success &lt;lti&gt;\n&lt;s&gt; ^smem.result.retrieved &lt;lti&gt;\n</code></pre> <p>All augmentations of the long-term identifier in semantic memory will be created as new WMEs in working memory.</p>"},{"location":"soar_manual/06_SemanticMemory/#cue-based-retrievals","title":"Cue-Based Retrievals","text":"<p>A cue-based retrieval performs a search for a long-term identifier in semantic memory whose augmentations exactly match an agent-supplied cue, as well as optional cue modifiers.</p> <p>A cue is composed of WMEs that describe the augmentations of a long-term identifier. A cue WME with a constant value denotes an exact match of both attribute and value. A cue WME with an LTI-linked identifier as its value denotes an exact match of attribute and linked LTI. A cue WME with a short-term identifier as its value denotes an exact match of attribute, but with any value (constant or identifier).</p> <p>A cue-based retrieval command has a query attribute and an identifier value, the cue:</p> <pre><code>&lt;s&gt; ^smem.command.query &lt;cue&gt;\n</code></pre> <p>For instance, consider the following rule that creates a cue-based retrieval command:</p> <pre><code>sp {smem*sample*query\n   (state &lt;s&gt; ^smem.command &lt;scmd&gt;\n      ^lti &lt;lti&gt;\n      ^input-link.foo &lt;bar&gt;)\n   --&gt;\n   (&lt;scmd&gt; ^query &lt;q&gt;)\n   (&lt;q&gt; ^name &lt;any-name&gt;\n      ^foo &lt;bar&gt;\n      ^associate &lt;lti&gt;\n      ^age 25)\n   }\n</code></pre> <p>In this example, assume that the <code>&lt;lti&gt;</code> variable will match a short-term identifier which is linked to a long-term identifier and that the <code>&lt;bar&gt;</code> variable will match a constant. Thus, the query requests retrieval of a long-term memory with augmentations that satisfy ALL of the following requirements:</p> <ul> <li>Attribute <code>name</code> with <code>ANY</code> value</li> <li>Attribute <code>foo</code> with value equal to that of variable <code>&lt;bar&gt;</code> at the time this     rule fires</li> <li>Attribute <code>associate</code> with value that is the same long-term identifier as     that linked to by the <code>&lt;lti&gt;</code> STI at the time this rule fires</li> <li>Attribute <code>age</code> with integer value 25</li> </ul> <p>If no long-term identifier satisfies ALL of these requirements, an error is returned:</p> <pre><code>&lt;s&gt; ^smem.result.failure &lt;cue&gt;\n</code></pre> <p>Otherwise, two WMEs are added:</p> <pre><code>&lt;s&gt; ^smem.result.success &lt;cue&gt;\n&lt;s&gt; ^smem.result.retrieved &lt;retrieved-lti&gt;\n</code></pre> <p>The result <code>&lt;retrieved-lti&gt;</code> will be a new short-term identifier linked to the result LTI.</p> <p>As with non-cue-based retrievals, all of the augmentations of the long-term identifier in semantic memory are added as new WMEs to working memory. If these augmentations include other LTIs in smem, they too are instantiated into new short-term identifiers in working memory.</p> <p>It is possible that multiple long-term identifiers match the cue equally well. In this case, semantic memory will retrieve the long-term identifier that was most recently stored/retrieved. (More accurately, it will retrieve the LTI with the greatest activation value. See below.)</p> <p>The cue-based retrieval process can be further tempered using optional modifiers:</p> <ul> <li> <p>The prohibit command requires that the retrieved long-term identifier is not     equal to that linked with the supplied long-term identifier:</p> <pre><code>&lt;s&gt; ^smem.command.prohibit &lt;bad-lti&gt;\n</code></pre> <p>Multiple prohibit command WMEs may be issued as modifiers to a single cue-based retrieval. This method can be used to iterate over all matching long-term identifiers.</p> </li> <li> <p>The neg-query command requires that the retrieved long-term identifier does     NOT contain a set of attributes/attribute-value pairs:</p> <pre><code>&lt;s&gt; ^smem.command.neg-query &lt;cue&gt;\n</code></pre> <p>The syntax of this command is identical to that of regular/ positive query command.</p> </li> <li> <p>The math-query command requires that the retrieved long term identifier     contains an attribute value pair that meets a specified mathematical condition.     This condition can either be a conditional query or a superlative query.     Conditional queries are of the format:</p> <pre><code>&lt;s&gt; ^smem.command.math-query.&lt;cue-attribute&gt;.&lt;condition-name&gt; &lt;value&gt;\n</code></pre> <p>Superlative queries do not use a value argument and are of the format:</p> <pre><code>&lt;s&gt; ^smem.command.math-query.&lt;cue-attribute&gt;.&lt;condition-name&gt;\n</code></pre> <p>Values used in math queries must be integer or float type values. Currently supported condition names are:</p> <ul> <li><code>less</code> A value less than the given argument</li> <li><code>greater</code> A value greater than the given argument</li> <li><code>less-or-equal</code> A value less than or equal to the given argument</li> <li><code>greater-or-equal</code> A value greater than or equal to the given argument</li> <li><code>max</code> The maximum value for the attribute</li> <li><code>min</code> The minimum value for the attribute</li> </ul> </li> </ul>"},{"location":"soar_manual/06_SemanticMemory/#activation","title":"Activation","text":"<p>When an agent issues a cue-based retrieval and multiple LTIs match the cue, the LTI which semantic memory provides to working memory as the result is the LTI which not only matches the cue, but also has the highest <code>activation</code> value. Semantic memory has several activation methods available for this purpose.</p> <p>The simplest activation methods are <code>recency</code> and <code>frequency</code> activation. Recency activation attaches a time-stamp to each LTI and records the time of last retrieval. Using recency activation, the LTI which matches the cue and was also most-recently retrieved is the one which is returned as the result for a query. Frequency activation attaches a counter to each LTI and records the number of retrievals for that LTI. Using frequency activation, the LTI which matches the cue and also was most frequently used is returned as the result of the query. By default, Soar uses recency activation.</p> <p>Base-level activation can be thought of as a mixture of both recency and frequency. Soar makes use of the following equation (known as the Petrov approximation) for calculating base-level activation:</p> Info <p>Petrov, Alexander A. \u201cComputationally efficient approximation of the base-level learning equation in ACT-R.\u201d Proceedings of the seventh international conference on cognitive modeling. 2006.</p> \\[ BLA = \\log \\left[ \\sum\\limits_{i=1}^{k} t_i^{-d} + \\dfrac{(n-k)(t_n^{1-d} - t_k^{1-d})}{(1-d)(t_n-t_k)} \\right] \\] <p>where \\(n\\) is the number of activation boosts, \\(t_n\\) is the time since the first boost, \\(t_k\\) is the time of the \\(k\\)th boost, \\(d\\) is the decay factor, and \\(k\\) is the number of recent activation boosts which are stored. (In Soar, \\(k\\) is hard-coded to \\(10\\).) To use base-level activation, use the following CLI command when sourcing an agent:</p> <pre><code>smem --set activation-mode base-level\n</code></pre> <p>Spreading activation is new to Soar 9.6.0 and provides a secondary type of activation beyond the previous methods. First, spreading activation requires that base-level activation is also being used. They are considered additive. This value does not represent recency or frequency of use, but rather context-relatedness. Spreading activation increases the activation of LTIs which are linked to by identifiers currently present in working memory. Such LTIs may be thought of as spreading sources.</p> Info <p>Specifically, linked to by STIs that have augmentations.</p> <p>Spreading activation values spread according to network structure. That is, spreading sources will add to the spreading activation values of any of their child LTIs, according to the directed graph structure within smem (not working memory). The amount of spread is controlled by the <code>spreading-continue-probability</code> parameter. By default this value is set to 0.9. This would mean that \\(90\\ \\%\\) of an LTI\u2019s spreading activation value would be divided among its direct children (without subtracting from its own value). This value is multiplicative with depth. A \"grandchild\" LTI, connected at a distance of two from a source LTI, would receive spreading according to \\(0.9 \\times 0.9 = 0.81\\) of the source spreading activation value.</p> <p>Spreading activation values are updated each decision cycle only as needed for specific smem retrievals. For efficiency, two limits exist for the amount of spread calculated. The <code>spreading-limit</code> parameter limits how many LTIs can receive spread from a given spreading source LTI. By default, this value is (300). Spread is distributed in a magnitude-first manner to all descendants of a source. (Without edge-weights, this simplifies to breadth-first.) Once the number of LTIs that have been given spread from a given source reaches the max value indicated by <code>spreading-limit</code>, no more is calculated for that source that update cycle, and the next spreading source\u2019s contributions are calculated. The maximum depth of descendants that can receive spread contributions from a source is similarly given by the <code>spreading-depth-limit</code> parameter. By default, this value is (10).</p> <p>In order to use spreading activation, use the following command:</p> <pre><code>smem --set spreading on\n</code></pre> <p>Also, spreading activation can make use of working memory activation for adjusting edge weights and for providing nonuniform initial magnitude of spreading for sources of spread. This functionality is optional. To enable the updating of edge-weights, use the command:</p> <pre><code>smem --set spreading-edge-updating on\n</code></pre> <p>and to enable working memory activation to modulate the magnitude of spread from sources, use the command:</p> <pre><code>smem --set spreading-wma-source on\n</code></pre> <p>For most use-cases, base-level activation is sufficient to provide an agent with relevant knowledge in response to a query. However, to provide an agent with more context-relevant results as opposed to results based only on historical usage, one must use spreading activation.</p>"},{"location":"soar_manual/06_SemanticMemory/#retrieval-with-depth","title":"Retrieval with Depth","text":"<p>For either cue-based or non-cue-based retrieval, it is possible to retrieve a long-term identifier with additional depth. Using the depth parameter allows the agent to retrieve a greater amount of the memory structure than it would have by retrieving not only the long-term identifier\u2019s attributes and values, but also by recursively adding to working memory the attributes and values of that long-term identifier\u2019s children.</p> <p>Depth is an additional command attribute, like query:</p> <pre><code>&lt;s&gt; ^smem.command.query &lt;cue&gt;\n    ^smem.command.depth &lt;integer&gt;\n</code></pre> <p>For instance, the following rule uses depth with a cue-based retrieval:</p> <pre><code>sp {smem*sample*query\n   (state &lt;s&gt; ^smem.command &lt;sc&gt;\n      ^input-link.foo &lt;bar&gt;)\n   --&gt;\n   (&lt;sc&gt; ^query &lt;q&gt;\n      ^depth 2)\n   (&lt;q&gt; ^name &lt;any-name&gt;\n      ^foo &lt;bar&gt;\n      ^associate &lt;lti&gt;\n      ^age 25)\n}\n</code></pre> <p>In the example above and without using depth, the long-term identifier referenced by</p> <pre><code>^associate &lt;lti&gt;\n</code></pre> <p>would not also have its attributes and values be retrieved. With a depth of 2 or more, that long-term identifier also has its attributes and values added to working memory.</p> <p>Depth can incur a large cost depending on the specified depth and the structures stored in semantic memory.</p>"},{"location":"soar_manual/06_SemanticMemory/#performance","title":"Performance","text":"<p>Initial empirical results with toy agents show that semantic memory queries carry up to a \\(40\\ \\%\\) overhead as compared to comparable rete matching. However, the retrieval mechanism implements some basic query optimization: statistics are maintained about all stored knowledge. When a query is issued, semantic memory re-orders the cue such as to minimize expected query time. Because only perfect matches are acceptable, and there is no symbol variablization, semantic memory retrievals do not contend with the same combinatorial search space as the rete. Preliminary empirical study shows that semantic memory maintains sub-millisecond retrieval time for a large class of queries, even in very large stores (millions of nodes/edges).</p> <p>Once the number of long-term identifiers overcomes initial overhead (about 1000 WMEs), initial empirical study shows that semantic storage requires far less than 1KB per stored WME.</p>"},{"location":"soar_manual/06_SemanticMemory/#math-queries","title":"Math queries","text":"<p>There are some additional performance considerations when using math queries during retrieval. Initial testing indicates that conditional queries show the same time growth with respect to the number of memories in comparison to non-math queries, however the actual time for retrieval may be slightly longer. Superlative queries will often show a worse result than similar non-superlative queries, because the current implementation of semantic memory requires them to iterate over any memory that matches all other involved cues.</p>"},{"location":"soar_manual/06_SemanticMemory/#performance-tweaking","title":"Performance Tweaking","text":"<p>When using a database stored to disk, several parameters become crucial to performance. The first is lazy-commit , which controls when database changes are written to disk. The default setting (<code>on</code>) will keep all writes in memory and only commit to disk upon re-initialization (quitting the agent or issuing the init command). The <code>off</code> setting will write each change to disk and thus incurs massive I/O delay.</p> <p>The next parameter is thresh. This has to do with the locality of storing/updating activation information with semantic augmentations. By default, all WME augmentations are incrementally sorted by activation, such that cue-based retrievals need not sort large number of candidate long-term identifiers on demand, and thus retrieval time is independent of cue selectivity. However, each activation update (such as after a retrieval) incurs an update cost linear in the number of augmentations. If the number of augmentations for a long-term identifier is large, this cost can dominate. Thus, the <code>thresh</code> parameter sets the upper bound of augmentations, after which activation is stored with the long-term identifier. This allows the user to establish a balance between cost of updating augmentation activation and the number of long-term identifiers that must be pre-sorted during a cue-based retrieval. As long as the threshold is greater than the number of augmentations of most long-term identifiers, performance should be fine (as it will bound the effects of selectivity).</p> <p>The next two parameters deal with the SQLite cache, which is a memory store used to speed operations like queries by keeping in memory structures like levels of index B+-trees. The first parameter, page-size, indicates the size, in bytes, of each cache page. The second parameter, cache-size, suggests to SQLite how many pages are available for the cache. Total cache size is the product of these two parameter settings. The cache memory is not pre- allocated, so short/small runs will not necessarily make use of this space. Generally speaking, a greater number of cache pages will benefit query time, as SQLite can keep necessary meta-data in memory. However, some documented situations have shown improved performance from decreasing cache pages to increase memory locality. This is of greater concern when dealing with file-based databases, versus in-memory. The size of each page, however, may be important whether databases are disk- or memory-based. This setting can have far-reaching consequences, such as index B+-tree depth. While this setting can be dependent upon a particular situation, a good heuristic is that short, simple runs should use small values of the page size (<code>1k</code>, <code>2k</code>, <code>4k</code>), whereas longer, more complicated runs will benefit from larger values (<code>8k</code>, <code>16k</code>, <code>32k</code>, <code>64k</code>). The episodic memory chapter on performance has some further empirical evidence to assist in setting these parameters for very large stores.</p> <p>The next parameter is optimization. The safety parameter setting will use SQLite default settings. If data integrity is of importance, this setting is ideal. The performance setting will make use of lesser data consistency guarantees for significantly greater performance. First, writes are no longer synchronous with the OS (synchronous pragma), thus semantic memory won\u2019t wait for writes to complete before continuing execution. Second, transaction journaling is turned off (journal_mode pragma), thus groups of modifications to the semantic store are not atomic (and thus interruptions due to application/os/hardware failure could lead to inconsistent database state). Finally, upon initialization, semantic memory maintains a continuous exclusive lock to the database (locking_mode pragma), thus other applications/agents cannot make simultaneous read/write calls to the database (thereby reducing the need for potentially expensive system calls to secure/release file locks).</p> <p>Finally, maintaining accurate operation timers can be relatively expensive in Soar. Thus, these should be enabled with caution and understanding of their limitations. First, they will affect performance, depending on the level (set via the timers parameter). A level of <code>three</code>, for instance, times every modification to long-term identifier recency statistics. Furthermore, because these iterations are relatively cheap (typically a single step in the linked-list of a <code>b+-</code>tree), timer values are typically unreliable (depending upon the system, resolution is 1 microsecond or more).</p>"},{"location":"soar_manual/07_EpisodicMemory/","title":"Episodic Memory","text":""},{"location":"soar_manual/07_EpisodicMemory/#episodic-memory","title":"Episodic Memory","text":"<p>Episodic memory is a record of an agent\u2019s stream of experience. The episodic storage mechanism will automatically record episodes as a Soar agent executes. The agent can later deliberately retrieve episodic knowledge to extract information and regularities that may not have been noticed during the original experience and combine them with current knowledge such as to improve performance on future tasks.</p> <p>This chapter is organized as follows: episodic memory structures in working memory; episodic storage; retrieving episodes; and a discussion of performance.  The detailed behavior of episodic memory is determined by numerous parameters that can be controlled and configured via the <code>epmem</code> command.</p> <p>Please refer to the documentation for the <code>epmem</code> command.</p>"},{"location":"soar_manual/07_EpisodicMemory/#working-memory-structure","title":"Working Memory Structure","text":"<p>Upon creation of a new state in working memory, the architecture creates the following augmentations to facilitate agent interaction with episodic memory:</p> <pre><code>(&lt;s&gt; ^epmem &lt;e&gt;)\n(&lt;e&gt; ^command &lt;e-c&gt;)\n(&lt;e&gt; ^result &lt;e-r&gt;)\n(&lt;e&gt; ^present-id #)\n</code></pre> <p>As rules augment the command structure in order to retrieve episodes, episodic memory augments the result structure in response. Production actions should not remove augmentations of the result structure directly, as episodic memory will maintain these WMEs.</p> <p>The value of the present-id augmentation is an integer and will update to expose to the agent the current episode number. This information is identical to what is available via the time statistic and the present-id retrieval metadata.</p>"},{"location":"soar_manual/07_EpisodicMemory/#episodic-storage","title":"Episodic Storage","text":"<p>Episodic memory records new episodes without deliberate action/consideration by the agent. The timing and frequency of recording new episodes is controlled by the <code>phase</code> and <code>trigger</code> parameters. The phase parameter sets the phase in the decision cycle (default: end of each decision cycle) during which episodic memory stores episodes and processes commands. The value of the trigger parameter indicates to the architecture the event that concludes an episode: adding a new augmentation to the output-link (default) or each decision cycle.</p> <p>For debugging purposes, the force parameter allows the user to manually request that an episode be recorded (or not) during the current decision cycle. Behavior is as follows:</p> <ul> <li>The value of the <code>force</code> parameter is initialized to <code>off</code> every decision cycle.</li> <li>During the phase of episodic storage, episodic memory tests the value of the     <code>force</code> parameter; if it has a value other than <code>off</code>, episodic memory follows     the forced policy irrespective of the value of the <code>trigger</code> parameter.</li> </ul>"},{"location":"soar_manual/07_EpisodicMemory/#episode-contents","title":"Episode Contents","text":"<p>When episodic memory stores a new episode, it captures the entire top-state of working memory. There are currently two exceptions to this policy:</p> <ul> <li> <p>Episodic memory only supports WMEs whose attribute is a constant. Behavior is     currently undefined when attempting to store a WME that has an attribute that     is an identifier.</p> </li> <li> <p>The <code>exclusions</code> parameter allows the user to specify a set of attributes for     which Soar will not store WMEs. The storage process currently walks the     top-state of working memory in a breadth-first manner, and any WME that is not     reachable other than via an excluded WME will not be stored. By default,     episodic memory excludes the <code>epmem</code> and <code>smem</code> structures, to prevent encoding     of potentially large and/or frequently changing memory retrievals.</p> </li> </ul>"},{"location":"soar_manual/07_EpisodicMemory/#storage-location","title":"Storage Location","text":"<p>Episodic memory uses SQLite to facilitate efficient and standardized storage and querying of episodes. The episodic store can be maintained in memory or on disk (per the database and path parameters). If the store is located on disk, users can use any standard SQLite programs/components to access/query its contents. See the later discussion on performance for additional parameters dealing with databases on disk.</p> <p>Note that changes to storage parameters, for example database, path and append will not have an effect until the database is used after an initialization. This happens either shortly after launch (on first use) or after a database initialization command is issued. To switch databases or database storage types while running, set your new parameters and then perform an <code>epmem --init</code> command.</p> <p>The path parameter specifies the file system path the database is stored in. When path is set to a valid file system path and database mode is set to file, then the SQLite database is written to that path.</p> <p>The append parameter will determine whether all existing facts stored in a database on disk will be erased when episodic memory loads. Note that this affects <code>init-soar</code> also. In other words, if the <code>append</code> setting is <code>off</code>, all episodes stored will be lost when an <code>init-soar</code> is performed. For episodic memory, <code>append</code> mode is <code>off</code> by default.</p> <p>Note: As of version 9.3.3, Soar now uses a new schema for the episodic memory database. This means databases from 9.3.2 and below can no longer be loaded. A conversion utility will be available in Soar 9.4 to convert from the old schema to the new one.</p>"},{"location":"soar_manual/07_EpisodicMemory/#retrieving-episodes","title":"Retrieving Episodes","text":"<p>An agent retrieves episodes by creating an appropriate command (we detail the types of commands below) on the command link of a state\u2019s epmem structure. At the end of the phase of each decision, after episodic storage, episodic memory processes each state\u2019s epmem command structure. Results, meta-data, and errors are placed on the result structure of that state\u2019s epmem structure.</p> <p>Only one type of retrieval command (which may include optional modifiers) can be issued per state in a single decision cycle. Malformed commands (including attempts at multiple retrieval types) will result in an error:</p> <pre><code>&lt;s&gt; ^epmem.result.status bad-cmd\n</code></pre> <p>After a command has been processed, episodic memory will ignore it until some aspect of the command structure changes (via addition/removal of WMEs). When this occurs, the result structure is cleared and the new command (if one exists) is processed.</p> <p>All retrieved episodes are recreated exactly as stored, except for any operators that have an acceptable preference, which are recreated with the attribute <code>operator*</code>. For example, if the original episode was:</p> <pre><code>(&lt;s&gt; ^operator &lt;o1&gt; +)\n(&lt;o1&gt; ^name move)\n</code></pre> <p>A retrieval of the episode would become:</p> <pre><code>(&lt;s&gt; ^operator* &lt;o1&gt;)\n(&lt;o1&gt; ^name move)\n</code></pre>"},{"location":"soar_manual/07_EpisodicMemory/#cue-based-retrievals","title":"Cue-Based Retrievals","text":"<p>Cue-based retrieval commands are used to search for an episode in the store that best matches an agent-supplied cue, while adhering to optional modifiers. A cue is composed of WMEs that partially describe a top-state of working memory in the retrieved episode. All cue-based retrieval requests must contain a single ^query cue and, optionally, a single ^neg-query cue.</p> <pre><code>&lt;s&gt; ^epmem.command.query &lt;required-cue&gt;\n&lt;s&gt; ^epmem.command.neg-query &lt;optional-negative-cue&gt;\n</code></pre> <p>A ^querycue describes structures desired in the retrieved episode, whereas a ^neg-query cue describes non-desired structures. For example, the following Soar production creates a ^querycue consisting of a particular state name and a copy of a current value on the input-link structure:</p> <pre><code>sp {epmem*sample*query\n(state &lt;s&gt; ^epmem.command &lt;ec&gt;\n^io.input-link.foo &lt;bar&gt;)\n--&gt;\n(&lt;ec&gt; ^query &lt;q&gt;)\n(&lt;q&gt; ^name my-state-name\n^io.input-link.foo &lt;bar&gt;)\n}\n</code></pre> <p>As detailed below, multiple prior episodes may equally match the structure and contents of an agent\u2019s cue. Nuxoll has produced initial evidence that in some tasks, retrieval quality improves when using activation of cue WMEs as a form of feature weighting. Thus, episodic memory supports integration with working memory activation (see the Soar Manual working memory activation section). For a theoretical discussion of the Soar implementation of working memory activation, consider readingComprehensive Working Memory Activation in Soar (Nuxoll, A., Laird, J., James, M., ICCM 2004).</p> <p>The cue-based retrieval process can be thought of conceptually as a nearest-neighbor search.  First, all candidate episodes, defined as episodes containing at least one leaf WME (a cue WME with no sub-structure) in at least one cue, are identified. Two quantities are calculated for each candidate episode, with respect to the supplied cue(s): the cardinality of the match (defined as the number of matching leaf WMEs) and the activation of the match (defined as the sum of the activation values of each matching leaf WME). Note that each of these values is negated when applied to a negative query. To compute each candidate episode\u2019s match score, these quantities are combined with respect to the balance parameter as follows:</p> \\[ (balance)\\cdot(cardinality) + (1-balance)\\cdot(activation) \\] <p>Performing a graph match on each candidate episode, with respect to the structure of the cue, could be very computationally expensive, so episodic memory implements a two-stage matching process. An episode with perfect cardinality is considered a perfect surface match and, per the graph-match parameter, is subjected to further structural matching. Whereas surface matching efficiently determines if all paths to leaf WMEs exist in a candidate episode, graph matching indicates whether or not the cue can be structurally unified with the candidate episode (paying special regard to the structural constraints imposed by shared identifiers). Cue-based matching will return the most recent structural match, or the most recent candidate episode with the greatest match score.</p> <p>A special note should be made with respect to how short- vs. long-term identifiers (see Knowledge Representation) are interpreted in a cue. Short-term identifiers are processed much as they are in working memory \u2013 transient structures. Cue matching will try to find any identifier in an episode (with respect to WME path from state) that can apply. Long-term identifiers, however, are treated as constants. Thus, when analyzing the cue, episodic memory will not consider long-term identifier augmentations, and will only match with the same long-term identifier (in the same context) in an episode.</p> <p>The case-based retrieval process can be further controlled using optional modifiers:</p> <p>The before command requires that the retrieved episode come relatively before a supplied time:</p> <pre><code>&lt;s&gt; ^epmem.command.before time\n</code></pre> <p>The after command requires that the retrieved episode come relatively after a sup- plied time:</p> <pre><code>&lt;s&gt; ^epmem.command.after time\n</code></pre> <p>The prohibit command requires that the time of the retrieved episode is not equal to a supplied time:</p> <pre><code>&lt;s&gt; ^epmem.command.prohibit time\n</code></pre> <p>Multiple prohibit command WMEs may be issued as modifiers to a single CB retrieval.</p> <p>If no episode satisfies the cue(s) and optional modifiers an error is returned:</p> <pre><code>&lt;s&gt; ^epmem.result.failure &lt;query&gt; &lt;optional-neg-query&gt;\n</code></pre> <p>If an episode is returned, there is additional meta-data supplied (7.3.4).</p>"},{"location":"soar_manual/07_EpisodicMemory/#absolute-non-cue-based-retrieval","title":"Absolute Non-Cue-Based Retrieval","text":"<p>At time of storage, each episode is attributed a unique time. This is the current value of time statistic and is provided as the memory-id meta-data item of retrieved episodes. An absolute non-cue-based retrieval is one that requests an episode by time. An agent issues an absolute non-cue-based retrieval by creating a WME on the command structure with attribute retrieve and value equal to the desired time:</p> <pre><code>&lt;s&gt; ^epmem.command.retrieve time\n</code></pre> <p>Supplying an invalid value for the retrieve command will result in an error.</p> <p>The time of the first episode in an episodic store will have value 1 and each subsequent episode\u2019s time will increase by 1. Thus the desired time may be the mathematical result of operations performed on a known episode\u2019s time.</p> <p>The current episodic memory implementation does not implement any episodic store dynamics, such as forgetting. Thus any integer time greater than 0 and less than the current value of the time statistic will be valid. However, if forgetting is implemented in future versions, no such guarantee will be made.</p>"},{"location":"soar_manual/07_EpisodicMemory/#relative-non-cue-based-retrieval","title":"Relative Non-Cue-Based Retrieval","text":"<p>Episodic memory supports the ability for an agent to \"play forward\" episodes using relative non-cue-based retrievals.</p> <p>Episodic memory stores the time of the last successful retrieval (non-cue-based or cue-based).  Agents can indirectly make use of this information by issuing next or previous commands.  Episodic memory executes these commands by attempting to retrieve the episode immediately proceeding/preceding the last successful retrieval (respectively). To issue one of these commands, the agent must create a new WME on the command link with the appropriate attribute (next or previous) and value of an arbitrary identifier:</p> <pre><code>&lt;s&gt; ^epmem.command.next &lt;n&gt;\n&lt;s&gt; ^epmem.command.previous &lt;p&gt;\n</code></pre> <p>If no such episode exists then an error is returned.</p> <p>Currently, if the time of the last successfully retrieved episode is known to the agent (as could be the case by accessing result meta-data), these commands are identical to performing an absolute non-cue-based retrieval after adding/subtracting 1 to the last time (respectively).  However, if an episodic store dynamic like forgetting is implemented, these relative commands are guaranteed to return the next/previous valid episode (assuming one exists).</p>"},{"location":"soar_manual/07_EpisodicMemory/#retrieval-metadata","title":"Retrieval Metadata","text":"<p>The following list details the WMEs that episodic memory creates in the result link of the epmem structure wherein a command was issued:</p> <p>retrieved <code>&lt;retrieval-root&gt;</code> If episodic memory retrieves an episode, that memory is placed here. This WME is an identifier that is treated as the root of the state that was used to create the episodic memory. If the retrieve command was issued with an invalid time, the value of this WME will be no-memory.</p> <p>success <code>&lt;query&gt; &lt;optional-neg-query&gt;</code> If the cue-based retrieval was successful, the WME will have the status as the attribute and the value of the identifier of the query (and neg-query, if applicable).</p> <p>match-score This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command. The WME value is a decimal indicating the raw match score for that episode with respect to the cue(s).</p> <p>cue-size This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command. The WME value is an integer indicating the number of leaf WMEs in the cue(s).</p> <p>normalized-match-score This WME is created whenever an episode is success- fully retrieved from a cue-based retrieval command. The WME value is the decimal result of dividing the raw match score by the cue size. It can hypothetically be used as a measure of episodic memory\u2019s relative confidence in the retrieval.</p> <p>match-cardinality This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command. The WME value is an integer indicating the number of leaf WMEs matched in the <code>^querycue</code> minus those matched in the <code>^neg-querycue</code>.</p> <p>memory-id This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command. The WME value is an integer indicating the time of the retrieved episode.</p> <p>present-id This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command. The WME value is an integer indicating the current time, such as to provide a sense of \"now\" in episodic memory terms. By comparing this value to the memory-id value, the agent can gain a sense of the relative time that has passed since the retrieved episode was recorded.</p> <p>graph-match This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command and the graph-match parameter was on. The value is an integer with value 1 if graph matching was executed successfully and 0 otherwise.</p> <p>mapping <code>&lt;mapping-root&gt;</code>  This WME is created whenever an episode is successfully retrieved from a cue-based retrieval command, the graph-match parameter was on, and structural match was successful on the retrieved episode. This WME provides a mapping between identifiers in the cue and in the retrieved episode. For each identifier in the cue, there is anodeWME as an augmentation to the mapping identifier. The node has a cue augmentation, whose value is an identifier in the cue, and a retrieved augmentation, whose value is an identifier in the retrieved episode. In a graph match it is possible to have multiple identifier mappings \u2013 this map represents the \"first\" unified mapping (with respect to episodic memory algorithms).</p>"},{"location":"soar_manual/07_EpisodicMemory/#performance","title":"Performance","text":"<p>There are currently two sources of \"unbounded\" computation: graph matching and cue-based queries. Graph matching is combinatorial in the worst case. Thus, if an episode presents a perfect surface match, but imperfect structural match (i.e. there is no way to unify the cue with the candidate episode), there is the potential for exhaustive search. Each identifier in the cue can be assigned one of any historically consistent identifiers (with respect to the sequence of attributes that leads to the identifier from the root), termed a literal. If the identifier is a multi-valued attribute, there will be more than one candidate literals and this situation can lead to a very expensive search process. Currently there are no heuristics in place to attempt to combat the expensive backtracking. Worst-case performance will be combinatorial in the total number of literals for each cue identifier (with respect to cue structure).</p> <p>The cue-based query algorithm begins with the most recent candidate episode and will stop search as soon as a match is found (since this episode must be the most recent). Given this procedure, it is trivial to create a two-WME cue that forces a linear search of the episodic store. Episodic memory combats linear scan by only searching candidate episodes, i.e. only those that contain a change in at least one of the cue WMEs. However, a cue that has no match and contains WMEs relevant to all episodes will force inspection of all episodes.  Thus, worst-case performance will be linear in the number of episodes.</p>"},{"location":"soar_manual/07_EpisodicMemory/#performance-tweaking","title":"Performance Tweaking","text":"<p>When using a database stored to disk, several parameters become crucial to performance.  The first is commit , which controls the number of episodes that occur between writes to disk. If the total number of episodes (or a range) is known ahead of time, setting this value to a greater number will result in greatest performance (due to decreased I/O).</p> <p>The next two parameters deal with the SQLite cache, which is a memory store used to speed operations like queries by keeping in memory structures like levels of index B+-trees. The first parameter, page-size , indicates the size, in bytes, of each cache page. The second parameter, cache-size , suggests to SQLite how many pages are available for the cache.  Total cache size is the product of these two parameter settings. The cache memory is not preallocated, so short/small runs will not necessarily make use of this space. Generally speaking, a greater number of cache pages will benefit query time, as SQLite can keep necessary meta-data in memory. However, some documented situations have shown improved performance from decreasing cache pages to increase memory locality. This is of greater concern when dealing with file-based databases, versus in-memory. The size of each page, however, may be important whether databases are disk- or memory-based. This setting can have far-reaching consequences, such as index B+-tree depth. While this setting can be dependent upon a particular situation, a good heuristic is that short, simple runs should use small values of the page size (<code>1k</code>, <code>2k</code>, <code>4k</code>), whereas longer, more complicated runs will benefit from larger values (<code>8k</code>, <code>16k</code>, <code>32k</code>, <code>64k</code>). One known situation of concern is that as indexed tables accumulate many rows (~millions), insertion time of new rows can suffer an infrequent, but linearly increasing burst of computation. In episodic memory, this situation will typically arise with many episodes and/or many working memory changes. Increasing the page size will reduce the intensity of the spikes at the cost of increasing disk I/O and average/total time for episode storage. Thus, the settings of page size for long, complicated runs establishes the</p> Example episodic memory cache setting data. <p>desired balance of reactivity (i.e. max computation) and average speed. To ground this discussion, the above figure depicts maximum and average episodic storage time (the value of the <code>epmem_storage</code> timer, converted to milliseconds) with different page sizes after 10 million decisions (1 episode/decision) of a very basic agent (i.e. very few working memory changes per episode) running on a 2.8GHz Core i7 with Mac OS X 10.6.5. While only a single use case, the cross-point of these data forms the basis for the decision to default the parameter at 8192 bytes.</p> <p>The next parameter is optimization, which can be set to either <code>safety</code> or <code>performance</code>. The <code>safety</code> parameter setting will use SQLite default settings. If data integrity is of importance, this setting is ideal. The performance setting will make use of lesser data consistency guarantees for significantly greater performance. First, writes are no longer synchronous with the OS (synchronous pragma), thus episodic memory won\u2019t wait for writes to complete before continuing execution. Second, transaction journaling is turned off (journalmode pragma), thus groups of modifications to the episodic store are not atomic (and thus interruptions due to application/os/hardware failure could lead to inconsistent database state).  Finally, upon initialization, episodic memory maintains a continuous exclusive lock to the database (locking mode pragma), thus other applications/agents cannot make simultaneous read/write calls to the database (thereby reducing the need for potentially expensive system calls to secure/release file locks).</p> <p>Finally, maintaining accurate operation timers can be relatively expensive in Soar. Thus, these should be enabled with caution and understanding of their limitations. First, they will affect performance, depending on the level (set via the timers parameter). A level of <code>three</code>, for instance, times every step in the cue-based retrieval candidate episode search. Furthermore, because these iterations are relatively cheap (typically a single step in the linked-list of a b+-tree), timer values are typically unreliable (depending upon the system, resolution is 1 microsecond or more).</p>"},{"location":"soar_manual/08_SpatialVisualSystem/","title":"Spatial Visual System","text":"<p>The Spatial Visual System (SVS) allows Soar to effectively represent and reason about continuous, three dimensional environments. SVS maintains an internal representation of the environment as a collection of discrete objects with simple geometric shapes, called the scene graph. The Soar agent can query for spatial relationships between the objects in the scene graph through a working memory interface similar to that of episodic and semantic memory.  Figure 8.1 illustrates the typical use case for SVS by contrasting it with an agent that does not utilize it. The agent that does not use SVS (a. in the figure) relies on the environment to provide a symbolic representation of the continuous state. On the other hand, the agent that uses SVS (b) accepts a continuous representation of the environment state directly, and then performs queries on the scene graph to extract a symbolic representation internally. This allows the agent to build more flexible symbolic representations without requiring modifications to the environment code. Furthermore, it allows the agent to manipulate internal copies of the scene graph and then extract spatial relationships from the modified states, which is useful for look-ahead search and action modeling. This type of imagery operation naturally captures and propagates the relationships implicit in spatial environments, and doesn't suffer from the frame problem that relational representations have.</p> image/svg+xml Environment Code State A B C table Relations on(C, B) on(A, table) clear(A) clear(C) Soar Agent Input Link (I2 ^on O1 ^on O2 ^clear C1 ^clear C2) (O1 ^top C ^bot B) (O2 ^top A ^bot table) (C1 ^ obj A) (C2 ^ obj C) Environment  Code State A B C table Soar Agent Filters Scene Graph A B C table SVS WM on(A,B) on(B,C) clear(A) (S1 ^ svs S3) (S3 ^command  C3) (C3 ^extract E2) (E2 ^a A1 ^b  B1 ^type on ^result R7 ) (A1 ^id  A ^type node) (B1 ^id  B ^type node) (R7 ^record R17) (R17 ^ params P1 ^value  false) (P1 ^a  A ^b B) (a) (b) (a) Typical environment setup without using SVS. (b) Same environment using SVS."},{"location":"soar_manual/08_SpatialVisualSystem/#the-scene-graph","title":"The scene graph","text":"<p>The primary data structure of SVS is the scene graph. The scene graph is a tree in which the nodes represent objects in the scene and the edges represent \"part-of\" relationships between objects. An example scene graph consisting of a car and a pole is shown in the figure above. The scene graph's leaves are geometry nodes and its interior nodes are group nodes. Geometry nodes represent atomic objects that have intrinsic shape, such as the wheels and chassis in the example. Currently, the shapes supported by SVS are points, lines, convex polyhedrons, and spheres. Group nodes represent objects that are the aggregates of their child nodes, such as the car object in the example. The shape of a group node is the union of the shapes of its children. Structuring complex objects in this way allows Soar to reason about them naturally at different levels of abstraction. The agent can query SVS for relationships between the car as a whole with other objects (e.g. does it intersect the pole?), or the relationships between its parts (e.g. are the wheels pointing left or right with respect to the chassis?). The scene graph always contains at least a root node: the world node.</p> (a) A 3D scene. (b) The scene graph representation. <p>Each node other than the world node has a transform with respect to its parent. A transform consists of three components:</p> <ul> <li>position(x,y,z) Specifies the x, y, and z offsets of the node's origin with     respect to its parent's origin.</li> <li>rotation(x,y,z) Specifies the rotation of the node relative to its     origin in Euler angles.  This means that the node is rotated the specified     number of radians along each axis in the order x-y-z. For more information,     see http://en.wikipedia.org/wiki/Euler_angles.</li> <li>scaling(x,y,z) Specifies the factors by which the node is scaled along     each axis.</li> </ul> <p>The component transforms are applied in the order scaling, then rotation, then position. Each node's transform is applied with respect to its parent's coordinate system, so the transforms accumulate down the tree. A node's transform with respect to the world node, or its world transform, is the aggregate of all its ancestor transforms. For example, if the car has a position transform of (1, 0 ,0) and a wheel on the car has a position transform of (0, 1 ,0), then the world position transform of the wheel is (1, 1 ,0).</p> <p>SVS represents the scene graph structure in working memory under the <code>^spatial-scene</code> link. The working memory representation of the car and pole scene graph is</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (S4 ^child C10 ^child C4 ^id world)\n      (C10 ^id pole)\n      (C4 ^child C9 ^child C8 ^child C7 ^child C6 ^child C5 ^id car)\n        (C9 ^id chassis)\n        (C8 ^id wheel3)\n        (C7 ^id wheel2)\n        (C6 ^id wheel1)\n        (C5 ^id wheel0)\n</code></pre> <p>Each state in working memory has its own scene graph. When a new state is created, it will receive an independent copy of its parent's scene graph. This is useful for performing look-ahead search, as it allows the agent to destructively modify the scene graph in a search state using mental imagery operations. If you wish to turn off the scene graph copying behavior, you can disable it with <code>svs --disable-in-substates</code>. You can also re-enable it with <code>svs --enable-in-substates</code>.</p>"},{"location":"soar_manual/08_SpatialVisualSystem/#svs_viewer","title":"svs_viewer","text":"<p>A viewer has been provided to show the scene graph visually. Run the program <code>svs_viewer -s &lt;PORT&gt;</code> from the soar/out folder to launch the viewer listening on the given port. Once the viewer is running, from within soar use the command <code>svs connect_viewer &lt;PORT&gt;</code> to connect to the viewer and begin drawing the scene graph. Any changes to the scene graph will be reflected in the viewer. The viewer by default draws the top state scene graph; to draw the scene graph of a substate, first stop drawing the top state with <code>svs S1.scene.draw off</code> and then draw the desired substate with <code>svs &lt;STATE ID&gt;.scene.draw on</code>, where <code>&lt;STATE ID&gt;</code> is <code>S7</code>, etc.</p>"},{"location":"soar_manual/08_SpatialVisualSystem/#scene-graph-edit-language","title":"Scene Graph Edit Language","text":"<p>The Scene Graph Edit Language (SGEL) is a simple, plain text, line oriented language that is used by SVS to modify the contents of the scene graph. Typically, the scene graph is used to represent the state of the external environment, and the programmer sends SGEL commands reflecting changes in the environment to SVS via the <code>Agent::SendSVSInput</code> function in the SML API. These commands are buffered by the agent and processed at the beginning of each input phase. Therefore, it is common to send scene changes through <code>SendSVSInput</code> before the input phase. If you send SGEL commands at the end of the input phase, the results won't be processed until the following decision cycle.</p> <p>Each SGEL command begins with a single word command type and ends with a newline. The four command types are</p> <ul> <li> <p>add ID PARENT_ID [GEOMETRY] [TRANSFORM]</p> <p>Add a node to the scene graph with the given <code>ID</code>, as a child of <code>PARENT_ID</code>, and with type <code>TYPE</code> (usually object). The <code>GEOMETRY</code> and <code>TRANSFORM</code> arguments are optional and described below.</p> </li> <li> <p>change ID [GEOMETRY] [TRANSFORM]</p> <p>Change the transform and/or geometry of the node with the given <code>ID</code>.</p> </li> <li> <p>delete ID</p> <p>Delete the node with the given <code>ID</code>.</p> </li> <li> <p>tag [add|change|delete] ID TAG_NAME TAG_VALUE</p> <p>Adds, changes, or deletes a tag from an object. A tag consists of a <code>TAG_NAME</code> and <code>TAG_VALUE</code> pair and is added to the node with the given <code>ID</code>. Both <code>TAG_NAME</code> and <code>TAG_VALUE</code> must be strings. Tags can differentiate nodes (e.g. as a type field) and can be used in conjunction with the <code>tag_select</code> filter to choose a subset of the nodes.</p> </li> </ul> <p>The <code>TRANSFORM</code> argument has the form <code>[p X Y Z] [r X Y Z] [s X Y Z]</code>, corresponding to the position, rotation, and scaling components of the transform, respectively. All the components are optional; any combination of them can be excluded, and the included components can appear in any order.</p> <p>The <code>GEOMETRY</code> argument has two forms:</p> <ul> <li> <p>b RADIUS</p> <p>Make the node a geometry node with sphere shape with radius <code>RADIUS</code>.</p> </li> <li> <p>v X1 Y1 Z1 X2 Y2 Z2</p> <p>Make the node a geometry node with a convex polyhedron shape with the specified vertices. Any number of vertices can be listed.</p> </li> </ul>"},{"location":"soar_manual/08_SpatialVisualSystem/#examples","title":"Examples","text":"<p>Create a sphere <code>ball4</code> with radius 5 at location (4, 4, 0):</p> <pre><code>add ball4 world b 5 p 4 4 0\n</code></pre> <p>Create a triangle <code>tri9</code> in the xy plane, then rotate it vertically, double its size, and move it to (1, 1, 1):</p> <pre><code>add tri9 world v -1 -1 0 1 -1 0 0 0.5 0 p 1 1 1 r 1.507 0 0 s 2 2 2\n</code></pre> <p>Create a <code>snowman</code> shape with 3 spheres stacked on each other and located at (2, 2, 0):</p> <pre><code>add snowman world p 2 2 0\nadd bottomball snowman b 3 p 0 0 3\nadd middleball snowman b 2 p 0 0 8\nadd topball snowman b 1 p 0 0 11\n</code></pre> <p>Set the rotation transform on <code>box11</code> to 180 degrees around the z axis:</p> <pre><code>change box11 r 0 0 3.14159\n</code></pre> <p>Change the color tag on <code>box7</code> to green:</p> <pre><code>tag change box7 color green\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#commands","title":"Commands","text":"<p>The Soar agent initiates commands in SVS via the ^command link, similar to semantic and episodic memory. These commands allow the agent to modify the scene graph and extract filters. Commands are processed during the output phase and the results are added to working memory during the input phase. SVS supports the following commands:</p> <ul> <li><code>add_node</code> Creates a new node and adds it to the scene graph</li> <li><code>copy_node</code> Creates a copy of an existing node</li> <li><code>delete_node</code> Removes a node from the scene graph and deletes it</li> <li><code>set_transform</code> Changes the position, rotation, and/or scale of a node</li> <li><code>set_tag</code> Adds or changes a tag on a node</li> <li><code>delete_tag</code> Deletes a tag from a node</li> <li><code>extract</code> Compute the truth value of spatial relationships in the current     scene graph.</li> <li><code>extract_once</code> Same as extract, except it is only computed once and doesn't     update when the scene changes.</li> </ul>"},{"location":"soar_manual/08_SpatialVisualSystem/#add_node","title":"add_node","text":"<p>This commands adds a new node to the scene graph.</p> <ul> <li><code>^id [string]</code> The id of the node to create</li> <li><code>^parent [string]</code> The id of the node to attach the new node to (default is world)</li> <li><code>^geometry &lt;&lt; group point ball box &gt;&gt;</code> The geometry the node should have</li> <li><code>^position.{ ^x ^y ^z }</code> Position of the node (optional)</li> <li><code>^rotation.{ ^x ^y ^z }</code> Rotation of the node (optional)</li> <li><code>^scale.{ ^x ^y ^z }</code> Scale of the node (optional)</li> </ul> <p>The following example creates a node called box 5 and adds it to the world. The node has a box shape of side length 0.1 and is placed at position (1, 1, 0).</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^add_node A1)\n      (A1 ^id box5 ^parent world ^geometry box ^position P1 ^scale S6)\n        (P1 ^x 1.0 ^y 1.0 ^z 0.0)\n        (S6 ^x 0.1 ^y 0.1 ^z 0.1)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#copy_node","title":"copy_node","text":"<p>This command creates a copy of an existing node and adds it to the scene graph. This copy is not recursive, it only copies the node itself, not its children. The position, rotation, and scale transforms are also copied from the source node but they can be changed if desired.</p> <ul> <li>^id [string] The id of the node to create</li> <li>^source [string] The id of the node to copy</li> <li>^parent [string] The id of the node to attach the new node to (default is <code>world</code>)</li> <li>^position.{^x ^y ^z} Position of the node (optional)</li> <li>^rotation.{^x ^y ^z} Rotation of the node (optional)</li> <li>^scale.{^x ^y ^z} Scale of the node (optional)</li> </ul> <p>The following example copies a node called box5 as new node box6 and moves it to position (2, 0, 2).</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^copy_node A1)\n      (A1 ^id box6 ^source box5 ^position P1)\n        (P1 ^x 2.0 ^y 0.0 ^z 2.0)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#delete_node","title":"delete_node","text":"<p>This command deletes a node from the scene graph. Any children will also be deleted.</p> <ul> <li>`^id [string] The id of the node to delete</li> </ul> <p>The following example deletes a node called <code>box5</code>.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^delete_node D1)\n      (D1 ^id box5)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#set_transform","title":"set_transform","text":"<p>This command allows you to change the position, rotation, and/ or scale of an existing node. You can specify any combination of the three transforms.</p> <ul> <li><code>^id [string]</code> The id of the node to change</li> <li><code>^postion</code> Position of the node (optional)</li> <li><code>^position.{^x ^y ^z}</code> Rotation of the node (optional)</li> <li><code>^scale{^x ^y ^z}</code> Scale of the node (optional)</li> </ul> <p>The following example moves and rotates a node called <code>box5</code>.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^set_transform S6)\n      (S6 ^id box5 ^position P1 ^rotation R1)\n        (P1 ^x 2.0 ^y 2.0 ^z 0.0)\n        (R1 ^x 0.0 ^y 0.0 ^z 1.57)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#set_tag","title":"set_tag","text":"<p>This command allows you to add or change a tag on a node. If a tag with the same id already exists, the existing value will be replaced with the new value.</p> <ul> <li><code>^id [string]</code> The id of the node to set the tag on</li> <li><code>^tag_name [string]</code> The name of the tag to add</li> <li><code>^tag_value [string]</code> The value of the tag to add</li> </ul> <p>The following example adds a shape tag to the node <code>box5</code>.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^set_tag S6)\n      (S6 ^id box5 ^tag_name shape ^tag_value cube)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#delete_tag","title":"delete_tag","text":"<p>This command allows you to delete a tag from a node.</p> <ul> <li>^id [string] The id of the node to delete the tag from</li> <li>^tag_name [string] The name of the tag to delete</li> </ul> <p>The following example deletes the shape tag from the node <code>box5</code>.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^delete_tag D1)\n      (D1 ^id box5 ^tag_name shape)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#extract-and-extract_once","title":"extract and extract_once","text":"<p>This command is commonly used to compute spatial relationships in the scene graph. More generally, it puts the result of a filter pipeline (described in section Filters) in working memory. Its syntax is the same as filter pipeline syntax. During the input phase, SVS will evaluate the filter and put a <code>^result</code> attribute on the command's identifier.  Under the <code>^result</code> attribute is a multi-valued <code>^record</code> attribute. Each record corresponds to an output value from the head of the filter pipeline, along with the parameters that produced the value. With the regular <code>extract</code> command, these records will be updated as the scene graph changes. With the <code>extract_once</code> command, the records will be created once and will not change. Note that you should not change the structure of a filter once it is created (SVS only processes a command once). Instead to extract something different you must create a new command. The following is an example of an extract command which tests whether the car and pole objects are intersecting.  The <code>^status</code> and <code>^result</code> WMEs are added by SVS when the command is finished.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^extract E2)\n      (E2 ^a A1 ^b B1 ^result R7 ^status success ^type intersect)\n        (A1 ^id car ^status success ^type node)\n        (B1 ^id pole ^status success ^type node)\n        (R7 ^record R17)\n          (R17 ^params P1 ^value false)\n            (P1 ^a car ^b pole)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#filters","title":"Filters","text":"<p>Filters are the basic unit of computation in SVS. They transform the continuous information in the scene graph into symbolic information that can be used by the rest of Soar. Each filter accepts a number of labeled parameters as input, and produces a single output. Filters can be arranged into pipelines in which the outputs of some filters are fed into the inputs of other filters. The Soar agent creates filter pipelines by building an analogous structure in working memory as an argument to an \"extract\" command. For example, the following structure defines a set of filters that reports whether the car intersects the pole:</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^extract E2)\n      (E2 ^a A1 ^b B1 ^type intersect)\n        (A1 ^id car ^type node)\n        (B1 ^id pole ^type node)\n</code></pre> <p>The <code>^type</code> attribute specifies the type of filter to instantiate, and the other attributes specify parameters. This command will create three filters: an <code>intersect</code> filter and two node filters. A node filter takes an <code>id</code> parameter and returns the scene graph node with that ID as its result. Here, the outputs of the <code>car</code> and <code>pole</code> node filters are fed into the <code>^a</code> and <code>^b</code> parameters of the filter. SVS will update each filter's output once every decision cycle, at the end of the input phase. The output of the intersect filter is a boolean value indicating whether the two objects are intersecting. This is placed into working memory as the result of the extract command:</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3 ^spatial-scene S4)\n    (C3 ^extract E2)\n      (E2 ^a A1 ^b B1 ^result R7 ^status success ^type intersect)\n        (A1 ^id car ^status success ^type node)\n        (B1 ^id pole ^status success ^type node)\n        (R7 ^record R17)\n          (R17 ^params P1 ^value false)\n            (P1 ^a car ^b pole)\n</code></pre> <p>Notice that a <code>^status</code> success is placed on each identifier corresponding to a filter. A result WME is placed on the extract command with a single record with value false.</p>"},{"location":"soar_manual/08_SpatialVisualSystem/#result-lists","title":"Result lists","text":"<p>Spatial queries often involve a large number of objects. For example, the agent may want to compute whether an object intersects any others in the scene graph. It would be inconvenient to build the extract command to process this query if the agent had to specify each object involved explicitly. Too many WMEs would be required, which would slow down the production matcher as well as SVS because it must spend more time interpreting the command structure. To handle these cases, all filter parameters and results can be lists of values. For example, the query for whether one object intersects all others can be expressed as</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3)\n    (C3 ^extract E2)\n      (E2 ^a A1 ^b B1 ^result R7 ^status success ^type intersect)\n        (A1 ^id car ^status success ^type node)\n        (B1 ^status success ^type all_nodes)\n        (R7 ^record R9 ^record R8)\n          (R9 ^params P2 ^value false)\n            (P2 ^a car ^b pole)\n          (R8 ^params P1 ^value true)\n            (P1 ^a car ^b car)\n</code></pre> <p>The all_nodes filter outputs a list of all nodes in the scene graph, and the intersect filter outputs a list of boolean values indicating whether the car intersects each node, represented by the multi-valued attribute record. Notice that each record contains both the result of the query as well as the parameters that produced that result. Not only is this approach more convenient than creating a separate command for each pair of nodes, but it also allows the intersect filter to answer the query more efficiently using special algorithms that can quickly rule out non-intersecting objects.</p>"},{"location":"soar_manual/08_SpatialVisualSystem/#filter-list","title":"Filter List","text":"<p>The following is a list of all filters that are included in SVS. You can also get this list by using the cli command <code>svs filters</code> and get information about a specific filter using the command <code>svs filters.FILTER_NAME</code>. Many filters have a <code>_select</code> version. The select version returns a subset of the input nodes which pass a test.  For example, the intersect filter returns boolean values for each input (a, b) pair, while the intersect_select filter returns the nodes in set b which intersect the input node a. This is useful for passing the results of one filter into another (e.g.  take the nodes that intersect node a and find the largest of them).</p> <ul> <li>Node: Given an <code>^id</code>, outputs the node with that id.</li> <li>all_nodes: Outputs all the nodes in the scene</li> <li>combine_nodes: Given multiple node inputs as <code>^a</code>, concatenates them     into a single output set.</li> <li>remove_nodes: Removes node <code>^a</code> from the input set and outputs the rest.</li> <li>node_position: Outputs the position of each node in input <code>^a</code>.</li> <li>node_rotation: Outputs the rotation of each node in input <code>^a</code>.</li> <li>node_scale: Outputs the scale of each node in input <code>^a</code>.</li> <li>node_bbox: Outputs the bounding box of each node in input <code>^a</code>.</li> <li> <p>distance and distance_select:</p> <p>Outputs the distance between input nodes <code>^a</code> and <code>^b</code> Distance can be specified by <code>^distance_type &lt;&lt; centroid hull &gt;&gt;</code>, where <code>centroid</code> is the euclidean distance between the centers, and the hull is the minimum distance between the node surfaces. <code>distance_select</code> chooses nodes in set b in which the distance to node a falls within the range <code>^min</code>and <code>^max</code>. -   closest and farthest Outputs the node in set <code>^b</code> closest to or farthest from <code>^a</code> (also uses <code>distance_type</code>). -   axis_distance and axis_distance_select Outputs the distance from input node <code>^a</code> to <code>^b</code> along a particular axis (<code>^axis &lt;&lt; x y z &gt;&gt;</code>). This distance is based on bounding boxes. A value of 0 indicates the nodes overlap on the given axis, otherwise the result is a signed value indicating whether node b is greater or less than node a on the given axis. The <code>axis_distance_select</code> filter also uses <code>^min</code> and <code>^max</code> to select nodes in set b. -   volume and volume_select Outputs the bounding box volume of each node in set <code>^a</code>. For volume_select, it outputs a subset of the nodes whose volumes fall within the range <code>^min</code> and <code>^max</code>. -   largest and smallest Outputs the node in set <code>^a</code> with the largest or smallest volume. -   larger and larger_select Outputs whether input node <code>^a</code> is larger than each input node <code>^b</code>, or selects all nodes in b for which a is larger. -   smaller and smaller_select Outputs whether input node <code>^a</code> is smaller than each input node <code>^b</code>, or selects all nodes in b for which a is smaller. -   contain and contain_select Outputs whether the bounding box of each input node <code>^a</code> contains the bounding box of each input node <code>^b</code>, or selects those nodes in b which are contained by node a. -   intersect and intersect_select Outputs whether each input node <code>^a</code> intersects each input node <code>^b</code>, or selects those nodes in b which intersect node a. Intersection is specified by <code>^intersect_type &lt;&lt; hull box &gt;&gt;</code>; either the convex hull of the node or the axis-aligned bounding box. -   tag_select Outputs all the nodes in input set <code>^a</code> which have the tag specified by <code>^tag_name</code> and <code>^tag_value</code>.</p> </li> </ul>"},{"location":"soar_manual/08_SpatialVisualSystem/#examples_1","title":"Examples","text":"<p>Select all the objects with a volume between 1 and 2.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3)\n    (C3 ^extract E1)\n      (E1 ^type volume_select ^a A1 ^min 1 ^max 2)\n        (A1 ^type all_nodes)\n</code></pre> <p>Find the distance between the centroid of ball3 and all other objects.</p> <pre><code>(S1 ^svs S3)\n(S3 ^command C3)\n    (C3 ^extract E1)\n      (E1 ^type distance ^a A1 ^b B1 ^distance_type centroid)\n        (A1 ^type node ^id ball3)\n        (B1 ^type all_nodes)\n</code></pre> <p>Test where ball2 intersects any red objects.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3)\n    (C3 ^extract E1)\n      (E1 ^type intersect ^a A1 ^b B1 ^intersect_type hull)\n        (A1 ^type node ^id ball2)\n        (B1 ^type tag_select ^a A2 ^tag_name color ^tag_value red)\n          (A2 ^type all_nodes)\n</code></pre> <p>Find all the objects on the table. This is done by selecting nodes where the distance between them and the table along the z axis is a small positive number.</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3)\n    (C3 ^extract E1)\n      (E1 ^type axis_distance_select ^a A1 ^b B1 ^axis z ^min .0001 ^max .1)\n        (A1 ^type node ^id table)\n        (B1 ^type all_nodes)\n</code></pre> <p>Find the smallest object that intersects the table (excluding itself).</p> <pre><code>(S1 ^svs S3)\n  (S3 ^command C3)\n    (C3 ^extract E1)\n      (E1 ^type smallest ^a A1)\n        (A1 ^type intersect_select ^a A2 ^b B1 ^intersect_type hull)\n          (A2 ^type node ^id table)\n          (B1 ^type remove_node ^id table ^a A3)\n            (A3 ^type all_nodes)\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#writing-new-filters","title":"Writing new filters","text":"<p>SVS contains a small set of generally useful filters, but many users will need additional specialized filters for their application. Writing new filters for SVS is conceptually simple.</p> <ol> <li>Write a C++ class that inherits from the appropriate filter     subclass.</li> <li>Register the new class in a global table of all filters ().</li> <li>Recompile the kernel.</li> </ol>"},{"location":"soar_manual/08_SpatialVisualSystem/#filter-subclasses","title":"Filter subclasses","text":"<p>The fact that filter inputs and outputs are lists rather than single values introduces some complexity to how filters are implemented. Depending on the functionality of the filter, the multiple inputs into multiple parameters must be combined in different ways, and sets of inputs will map in different ways onto the output values. Furthermore, the outputs of filters are cached so that the filter does not repeat computations on sets of inputs that do not change. To shield the user from this complexity, a set of generally useful filter paradigms were implemented as subclasses of the basic <code>filter</code> class. When writing custom filters, try to inherit from one of these classes instead of from <code>filter</code> directly.</p>"},{"location":"soar_manual/08_SpatialVisualSystem/#map-filter","title":"Map filter","text":"<p>This is the most straightforward and useful class of filters. A filter of this class takes the Cartesian product of all input values in all parameters, and performs the same computation on each combination, generating one output. In other words, this class implements a one-to-one mapping from input combinations to output values.</p> <p>To write a new filter of this class, inherit from the <code>map_filter</code> class, and define the <code>compute</code> function. Below is an example template:</p> <pre><code>class new_map_filter : public map_filter&lt;double&gt; // templated with output type\n{\n  public:\n    new_map_filter(Symbol *root, soar_interface *si, filter_input *input, scene *scn)\n    : map_filter&lt;double&gt;(root, si, input)   // call superclass constructor\n    {}\n\n    /* Compute\n        Do the proper computation based on the input filter_params\n        and set the out parameter to the result\n        Return true if successful, false if an error occured */\n    bool compute(const filter_params* p, double&amp; out){\n      sgnode* a;\n      if(!get_filter_param(this, p, \"a\", a)){\n        set_status(\"Need input node a\");\n        return false;\n      }\n      out = // Your computation here\n    }\n};\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#select-filter","title":"Select filter","text":"<p>This is very similar to a map filter, except for each input combination from the Cartesian product the output is optional. This is useful for selecting and returning a subset of the outputs.</p> <p>To write a new filter of this class, inherit from the <code>select_filter</code> class, and define the <code>compute</code> function. Below is an example template:</p> <pre><code>class new_select_filter : public select_filter&lt;double&gt; // templated with output type\n{\n  public:\n    new_select_filter(Symbol *root, soar_interface *si, filter_input *input, scene *scn)\n    : select_filter&lt;double&gt;(root, si, input)   // call superclass constructor\n    {}\n\n    /* Compute\n        Do the proper computation based on the input filter_params\n        and set the out parameter to the result (if desired)\n        Also set the select bit to true if you want to the result to be output.\n        Return true if successful, false if an error occurred */\n    bool compute(const filter_params* p, double&amp; out, bool&amp; select){\n      sgnode* a;\n      if(!get_filter_param(this, p, \"a\", a)){\n        set_status(\"Need input node a\");\n        return false;\n      }\n      out = // Your computation here\n      select = // test for when to output the result of the computation\n    }\n};\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#rank-filter","title":"Rank filter","text":"<p>A filter where a ranking is computed for each combination from the Cartesian product of the input and only the combination which results in the highest (or lowest) value is output. The default behavior is to select the highest, to select the lowest you can call <code>set_select_highest(false)</code> on the filter.</p> <p>To write a new filter of this class, inherit from the <code>rank_filter</code> class, and define the <code>rank</code> function. Below is an example template:</p> <pre><code>class new_rank_filter : public rank_filter\n{\n  public:\n    new_rank_filter(Symbol *root, soar_interface *si, filter_input *input, scene *scn)\n    : rank_filter(root, si, input)   // call superclass constructor\n    {}\n\n    /* Compute\n        Do the proper computation based on the input filter_params\n        And set r to the ranking result.\n        Return true if successful, false if an error occured */\n    bool compute(const filter_params* p, double&amp; r){\n      sgnode* a;\n      if(!get_filter_param(this, p, \"a\", a)){\n        set_status(\"Need input node a\");\n        return false;\n      }\n      r = // Ranking computation\n    }\n};\n</code></pre>"},{"location":"soar_manual/08_SpatialVisualSystem/#generic-node-filters","title":"Generic Node Filters","text":"<p>There are also a set of generic filters specialized for computations involving nodes. With these you only need to specify a predicate function involving nodes. (Also see filters/base_node_filters.h ).</p> <p>There are three types of these filters:</p>"},{"location":"soar_manual/08_SpatialVisualSystem/#node-test-filters","title":"Node Test Filters","text":"<p>These filters involve a binary test between two nodes (e.g. intersection or larger). You must specify a test function of the following form:</p> <pre><code>bool node_test(sgnode* a, sgnode* b, const filter_params* p)\n</code></pre> <p>For an example of how the following base filters are used, see filters/intersect.cpp.</p> <ul> <li>node_test_filter     For each input pair (a, b) this outputs the boolean result of .</li> <li>node_test_select_filter     For each input pair (a, b) this outputs node b if .     (Can choose to select b if the test is false by calling ).</li> </ul>"},{"location":"soar_manual/08_SpatialVisualSystem/#node-comparison-filters","title":"Node Comparison Filters","text":"<p>These filters involve a numerical comparison between two nodes (e.g. distance). You must specify a comparison function of the following form:</p> <pre><code>double node_comparison(sgnode* a, sgnode* b, const filter_params* p)\n</code></pre> <p>For an example of how the following base filters are used, see filters/distance.cpp.</p> <ul> <li>node_comparison_filter     For each input pair (a, b), outputs the numerical result of     <code>node_comparison(a, b)</code>.</li> <li>node_comparison_select_filter     For each input pair (a, b), outputs node b if <code>min &lt;= node_comparison(a, b) &lt;=     max</code>. Min and max can be set through calling <code>set_min(double)</code> and     <code>set_max(double)</code>, or as specified by the user through the filter_params.</li> <li>node_comparison_rank_filter     This outputs the input pair (a, b) for which <code>node_comparison(a, b)</code> produces     the highest value.     To instead have the lowest value output call <code>set_select_highest(true)</code>.</li> </ul>"},{"location":"soar_manual/08_SpatialVisualSystem/#node-evaluation-filters","title":"Node Evaluation Filters","text":"<p>These filters involve a numerical evaluation of a single node (e.g. volume). You must specify an evaluation function of the following form:</p> <pre><code>double node_evaluation(sgnode* a, const filter_params* p)\n</code></pre> <p>For an example of how the following base filters are used, see filters/volume.cpp.</p> <ul> <li>node_evaluation_filter     For each input node a, this outputs the numerical result of .</li> <li>node_evaluation_select_filter     or each input node a, this outputs the node if . Min and max can be set     through calling and , or as specified by the user through the     filter_params.</li> <li>node_evaluation_rank_filter     This outputs the input node a for which produces the highest value. To     instead have the lowest value output call .</li> </ul>"},{"location":"soar_manual/08_SpatialVisualSystem/#command-line-interface","title":"Command line interface","text":"<p>The user can query and modify the runtime behavior of SVS using the <code>svs</code> command. The syntax of this command differs from other Soar commands due to the complexity and object-oriented nature of the SVS implementation.  The basic idea is to allow the user to access each object in the SVS implementation (not to be confused with objects in the scene graph) at runtime. Therefore, the command has the form <code>svs PATH [ARGUMENTS]</code>, where <code>PATH</code> uniquely identifies an object or the method of an object. <code>ARGUMENTS</code> is a space separated list of strings that each object or function interprets in its own way. For example, <code>svs S1.scene.world.car</code> identifies the car object in the scene graph of the top state.  As another example, <code>svs connect_viewer 5999</code> calls the method to connect to the SVS visualizer with 5999 being the TCP port to connect on. Every path has two special arguments.</p> <ul> <li><code>svs PATH dir</code> prints all the children of the object at <code>PATH</code>.</li> <li><code>svs PATH help</code> prints text about how to use the object, if available.</li> </ul> <p>See SVS for more details.</p>"},{"location":"soar_manual/09_SoarUserInterface/","title":"The Soar User Interface","text":"<p>This chapter describes the set of user interface commands for Soar. All commands and examples are presented as if they are being entered at the Soar command prompt.</p> <p>This chapter is organized into 7 sections:</p> <ol> <li>Basic Commands for Running Soar</li> <li>Examining Memory</li> <li>Configuring Trace Information and Debugging</li> <li>Configuring Soar\u2019s Run-Time Parameters</li> <li>File System I/O Commands</li> <li>Soar I/O commands</li> <li>Miscellaneous Commands</li> </ol> <p>Each section begins with a summary description of the commands covered in that section, including the role of the command and its importance to the user. Command syntax and usage are then described fully, in alphabetical order.</p> <p>The following pages were automatically generated from the git repository at</p> <p>https://github.com/SoarGroup/Soar/wiki</p> <p>on the date listed on the title page of this manual. Please consult the repository directly for the most accurate and up-to-date information.</p> <p>For a concise overview of the Soar interface functions, see the Function Summary and Index on page . This index is intended to be a quick reference into the commands described in this chapter.</p>"},{"location":"soar_manual/09_SoarUserInterface/#notation","title":"Notation","text":"<p>The notation used to denote the syntax for each user-interface command follows some general conventions:</p> <ul> <li>The command name itself is given in a bold font.</li> <li>Optional command arguments are enclosed within square brackets, <code>[</code> and <code>]</code></li> <li>A vertical bar, <code>|</code>, separates alternatives.</li> <li>Curly braces, <code>{}</code> , are used to group arguments when at least one   argument from the set is required.</li> <li>The commandline prompt that is printed by Soar, is normally the   agent name, followed by \u2019\u2019. In the examples in this manual, we use   \"\".</li> <li>Comments in the examples are preceded by a \u2019#\u2019, and in-line comments   are preceded by \u2019;#\u2019.</li> </ul> <p>For many commands, there is some flexibility in the order in which the arguments may be given. (See the online help for each command for more information.) We have not incorporated this flexible ordering into the syntax specified for each command because doing so complicates the specification of the command. When the order of arguments will affect the output produced by a command, the reader will be alerted.</p> <p>Note that the command list was revamped and simplified in Soar 9.6.0. While we encourage people to learn the new syntax, aliases and some special mechanism have been added to maintain backwards compatibility with old Soar commands. As a result, many of the sub-commands of the newer commands may use different styles of arguments.</p>"},{"location":"soar_manual/09_SoarUserInterface/#basic-commands-for-running-soar","title":"Basic Commands for Running Soar","text":"<p>This section describes the commands used to start, run and stop a Soar program; to invoke on-line help information; and to create and delete Soar productions. It also describes how to configure some general settings for Soar.</p> <p>The specific commands described in this section are:</p> <ul> <li> <p>soar   Commands and settings related to running Soar. Use soar ?   for a summary of sub-commands listed below.</p> <ul> <li> <p>soar init   Reinitialize Soar so a program can be rerun from scratch.</p> </li> <li> <p>soar stop   Interrupt a running Soar program.</p> </li> <li> <p>soar max-chunks   Limit the number of chunks created during a decision cycle.</p> </li> <li> <p>soar max-dc-time   Set a wall-clock time limit such that the agent will be   interrupted when a single decision cycle exceeds this limit.</p> </li> <li> <p>soar max-elaborations   Limit the maximum number of elaboration cycles in a given   phase.</p> </li> <li> <p>soar max-goal-depth   Limit the sub-state stack depth.</p> </li> <li> <p>soar max-memory-usage   Set the number of bytes that when exceeded by an agent,   will trigger the memory usage exceeded event.</p> </li> <li> <p>soar max-nil-output-cycles   Limit the maximum number of decision cycles executed   without producing output.</p> </li> <li> <p>soar max-gp   Set the upper-limit to the number of productions generated   by the gp command.</p> </li> <li> <p>soar stop-phase   Controls the phase where agents stop when running by   decision.</p> </li> <li> <p>soar tcl   Controls whether Soar Tcl mode is enabled.</p> </li> <li> <p>soar timers   Toggle on or off the internal timers used to profile Soar.</p> </li> <li> <p>soar version   Returns version number of Soar kernel.</p> </li> <li> <p>soar waitsnc   Generate a wait state rather than a state-no-change   impasse.</p> </li> </ul> </li> <li> <p>run   Begin Soar\u2019s execution cycle.</p> </li> <li> <p>exit   Shut down the Soar environment. Terminates Soar and exits the kernel. <code>stop exit</code></p> </li> <li> <p>help   Provide formatted, on-line information about Soar commands.</p> </li> <li> <p>decide   Commands and settings related to the selection of operators   during the Soar decision process</p> <ul> <li> <p>decide indifferent-selection   Controls indifferent preference arbitration.</p> </li> <li> <p>decide numeric-indifferent-mode   Select method for combining numeric preferences.</p> </li> <li> <p>decide predict   Predict the next selected operator</p> </li> <li> <p>decide select   Force the next selected operator</p> </li> <li> <p>decide set-random-seed   Seed the random number generator.</p> </li> </ul> </li> <li> <p>alias   Define a new alias, or command, using existing commands and   arguments.</p> </li> </ul> <p>These commands are all frequently used anytime Soar is run.</p>"},{"location":"soar_manual/09_SoarUserInterface/#procedural-memory-commands","title":"Procedural Memory Commands","text":"<p>This section describes the commands used to create and delete Soar productions, to see what productions will match and fire in the next Propose or Apply phase, to watch when specific productions fire and retract, and to configure options for selecting between mutually indifferent operators, along with various other methods for examining the contents and statistics of procedural memory.</p> <p>The specific commands described in this section are:</p> <ul> <li> <p>sp   Create a production and add it to production memory.</p> </li> <li> <p>gp   Define a pattern used to generate and source a set of Soar   productions.</p> </li> <li> <p>production   Commands to manipulate Soar rules and analyze their usage</p> <ul> <li> <p>production break   Set interrupt flag on specific productions.</p> </li> <li> <p>production excise   This command removes productions from Soar\u2019s memory.</p> </li> <li> <p>production find   Find productions that contain a given pattern.</p> </li> <li> <p>production firing-counts   Print the number of times productions have fired.</p> </li> <li> <p>production matches   Print information about the match set and partial matches.</p> </li> <li> <p>production memory-usage   Print memory usage for production matches.</p> </li> <li> <p>production optimize-attribute   Declare an attribute as multi-attributes so as to increase   Rete production matching efficiency.</p> </li> <li> <p>production watch   Trace firings and retractions of specific productions.</p> </li> </ul> </li> </ul> <p>sp is of course used in virtually all Soar programming. Of the remaining commands, soar and production memory-usage are most often used. production find is especially useful when the number of productions loaded is high. production firing-counts is used to see if how many times certain rules fire. production watch is related to wm watch , but applies only to specific, named productions.</p>"},{"location":"soar_manual/09_SoarUserInterface/#short-term-memory-commands","title":"Short-term Memory Commands","text":"<p>This section describes the commands for interacting with working memory and preference memory, seeing what productions will match and fire in the next Propose or Apply phase, and examining the goal dependency set. These commands are particularly useful when running or debugging Soar, as they let users see what Soar is \"thinking.\" Also included in this section is information about using Soar\u2019s Spatial Visual System (SVS), which filters perceptual input into a form usable in symbolic working memory.</p> <p>The specific commands described in this section are:</p> <ul> <li> <p>print   Print items in working, semantic and production memory. Can   also print the print the WMEs in the goal dependency set for each   goal.</p> </li> <li> <p>wm   Commands and settings related to working memory and working memory   activation.</p> <ul> <li> <p>wm activation   Get/Set working memory activation parameters.</p> </li> <li> <p>wm add   Manually add an element to working memory.</p> </li> <li> <p>wm remove   Manually remove an element from working memory.</p> </li> <li> <p>wm watch   Print information about wmes that match a certain pattern   as they are added and removed.</p> </li> </ul> </li> <li> <p>preferences   Examine items in preference memory.</p> </li> <li> <p>svs   Perform spatial visual system commands.</p> </li> </ul> <p>Of these commands, print is the most often used (and the most complex). print \u2013gds is useful for examining the goal dependency set when subgoals seem to be disappearing unexpectedly. preferences is used to examine which candidate operators have been proposed.</p>"},{"location":"soar_manual/09_SoarUserInterface/#learning","title":"Learning","text":"<p>This section describes the commands for enabling and configuring Soar\u2019s mechanisms of chunking and reinforcement learning. The specific commands described in this section are:</p> <ul> <li> <p>chunk   Set the parameters for explanation-based chunking, Soar\u2019s   learning mechanism.</p> </li> <li> <p>rl   Get/Set RL parameters and statistics.</p> </li> </ul>"},{"location":"soar_manual/09_SoarUserInterface/#long-term-declarative-memory","title":"Long-term Declarative Memory","text":"<p>This section describes the commands for enabling and configuring Soar\u2019s long-term semantic memory and episodic memory systems. The specific commands described in this section are:</p> <ul> <li> <p>smem   Get/Set semantic memory parameters and statistics.</p> </li> <li> <p>epmem   Get/Set episodic memory parameters and statistics.</p> </li> </ul>"},{"location":"soar_manual/09_SoarUserInterface/#other-debugging-commands","title":"Other Debugging Commands","text":"<p>This section describes the commands used primarily for debugging or to configure the trace output printed by Soar as it runs. Many of these commands provide options that simplify or restrict runtime behavior to enable easier and more localized debugging. Users may specify the content of the runtime trace output, examine the backtracing information that supports generated justifications and chunks, or request details on Soar\u2019s performance.</p> <p>The specific commands described in this section are:</p> <ul> <li> <p>trace   Control the information printed as Soar runs. (was watch)</p> </li> <li> <p>output   Controls sub-commands and settings related to Soar\u2019s output.</p> <ul> <li> <p>output enabled   Toggles printing at the lowest level.</p> </li> <li> <p>output console   Redirects printing to the the terminal. Most users will not   change this.</p> </li> <li> <p>output callbacks   Toggles standard Soar agent callback-based printing.</p> </li> <li> <p>output log   Record all user-interface input and output to a file.</p> </li> <li> <p>output command-to-file   Dump the printed output and results of a command to a file.</p> </li> <li> <p>output print-depth   Set how many generations of an identifier\u2019s children that   Soar will print</p> </li> <li> <p>output warnings   Toggle whether or not warnings are printed.</p> </li> <li> <p>output verbose   Control detailed information printed as Soar runs.</p> </li> <li> <p>output echo-commands   Set whether or not commands are echoed to other connected   debuggers.</p> </li> </ul> </li> <li> <p>explain   Provides interactive exploration of why a rule was learned.</p> </li> <li> <p>visualize   Creates graph visualizations of Soar\u2019s memory systems or   processing.</p> </li> <li> <p>stats   Print information on Soar\u2019s runtime statistics.</p> </li> <li> <p>debug   Contains commands that provide access to Soar\u2019s internals. Most   users will not need to access these commands</p> <ul> <li> <p>debug allocate   Allocate additional 32 kilobyte blocks of memory for a   specified memory pool without running Soar.</p> </li> <li> <p>debug port   Returns the port the kernel instance is listening on.</p> </li> <li> <p>debug time   Uses a default system clock timer to record the wall time   required while executing a command.</p> </li> <li> <p>debug internal-symbols   Print information about the Soar symbol table.</p> </li> </ul> </li> </ul> <p>Of these commands, trace is the most often used (and the most complex). output print-depth is related to the print command. stats is useful *for understanding how much work Soar is doing.</p>"},{"location":"soar_manual/09_SoarUserInterface/#file-system-io-commands","title":"File System I/O Commands","text":"<p>This section describes commands which interact in one way or another with operating system input and output, or file I/O. Users can save/retrieve information to/from files, redirect the information printed by Soar as it runs, and save and load the binary representation of productions. The specific commands described in this section are:</p> <ul> <li> <p>cd   Change directory.</p> </li> <li> <p>dirs   List the directory stack.</p> </li> <li> <p>load   Loads soar files, rete networks, saved percept streams and   external libraries.</p> <ul> <li> <p>load file   Sources a file containing soar commands and productions.   May also contain Tcl code if Tcl mode is enabled.</p> </li> <li> <p>load library   Loads an external library that extends functionality of   Soar.</p> </li> <li> <p>load rete-network   Loads a rete network that represents rules loaded in   production memory.</p> </li> <li> <p>load library   Loads soar files, rete networks, saved percept streams and   external libraries.</p> </li> </ul> </li> <li> <p>ls   List the contents of the current working directory.</p> </li> <li> <p>popd   Pop the current working directory off the stack and change to   the next directory on the stack.</p> </li> <li> <p>pushd   Push a directory onto the directory stack, changing to it.</p> </li> <li> <p>pwd   Print the current working directory.</p> </li> <li> <p>save   Saves chunks, rete networks and percept streams.</p> <ul> <li> <p>save agent   Saves the agent\u2019s procedural and semantic memories and   settings to a single file.</p> </li> <li> <p>save chunks   Saves chunks into a file.</p> </li> <li> <p>save percepts   Saves future input link structures into a file.</p> </li> <li> <p>save rete-network   Saves the current rete networks that represents rules   loaded in production memory.</p> </li> </ul> </li> <li> <p>echo   Prints a string to the current output device.</p> </li> </ul> <p>(See also the output command.)</p> <p>The load file command, previously known as source, is used for nearly every Soar program. The directory functions are important to understand so that users can navigate directories/folders to load/save the files of interest. Saving and loading percept streams are used mainly when Soar needs to interact with an external environment. Soar applications that include a graphical interface or other simulation environment will often require the use of echo. Users might take advantage of these commands when debugging agents, but care should be used in adding and removing WMEs this way as they do not fall under Soar\u2019s truth maintenance system.</p>"},{"location":"soar_manual/blocksworld/","title":"Blocksworld Soar Rules","text":"<pre><code>###############################################################################\n###\n### File              : blocks.soar\n### Original author(s): John E. Laird &lt;laird@eecs.umich.edu&gt;\n### Organization      : University of Michigan AI Lab\n### Created on        : 15 Mar 1995, 13:53:46\n### Last Modified By  : Clare Bates Congdon &lt;congdon@eecs.umich.edu&gt;\n### Last Modified On  : 17 Jul 1996, 16:35:14\n### Soar Version      : 7\n###\n### Description : A new, simpler implementation of the blocks world\n###               with just three blocks being moved at random.\n###\n### Notes: \n###   CBC, 6/27: Converted to Tcl syntax\n###   CBC, 6/27: Added extensive comments\n###############################################################################\n\n\n###############################################################################\n# Create the initial state with blocks A, B, and C on the table.\n#\n# This is the first production that will fire; Soar creates the initial state\n#   as an architectural function (in the 'zeroth' decision cycle), which will\n#   match against this production.\n# This production does a lot of work because it is creating (preferences for)\n# all the structure for the initial state:\n# 1. The state has a problem-space named 'blocks'. The problem-space limits\n#    the operators that will be selected for a task. In this simple problem,\n#    it isn't really necessary (there is only one operator), but it's a\n#    programming convention that you should get used to.\n# 2. The state has four 'things' -- three blocks and the table.\n# 3. The state has three 'ontop' relations\n# 4. Each of the things has substructure: their type and their names. Note that\n#    the fourth thing is actually a 'table'.\n# 5. Each of the ontop relations has substructure: the top thing and the\n#    bottom thing.\n# Finally, the production writes a message for the user.\n#\n# Note that this production will fire exactly once and will never retract.\n\nsp {blocks-world*elaborate*initial-state\n   (state &lt;s&gt; ^superstate nil)\n--&gt;\n   (&lt;s&gt; ^problem-space blocks\n        ^thing &lt;block-A&gt; &lt;block-B&gt; &lt;block-C&gt; &lt;table&gt;\n        ^ontop &lt;ontop-A&gt; &lt;ontop-B&gt; &lt;ontop-C&gt;)\n   (&lt;block-A&gt; ^type block ^name A)\n   (&lt;block-B&gt; ^type block ^name B)\n   (&lt;block-C&gt; ^type block ^name C)\n   (&lt;table&gt; ^type table ^name TABLE)\n   (&lt;ontop-A&gt; ^top-block &lt;block-A&gt; ^bottom-block &lt;table&gt;)\n   (&lt;ontop-B&gt; ^top-block &lt;block-B&gt; ^bottom-block &lt;table&gt;)\n   (&lt;ontop-C&gt; ^top-block &lt;block-C&gt; ^bottom-block &lt;table&gt;)\n   (write (crlf) |Initial state has A, B, and C on the table.|)}\n\n\n###############################################################################\n# State elaborations - keep track of which objects are clear\n# There are two productions - one for blocks and one for the table.\n###############################################################################\n\n###############################################################################\n# Assert table always clear\n#\n# The conditions establish that:\n#  1. The state has a problem-space named 'blocks'.\n#  2. The state has a thing of type table.\n# The action:\n#  1. creates an acceptable preference for an attribute-value pair asserting\n#     the table is clear.\n#\n# This production will also fire once and never retract.\n\nsp {elaborate*table*clear\n   (state &lt;s&gt; ^problem-space blocks\n              ^thing &lt;table&gt;)\n   (&lt;table&gt; ^type table)\n--&gt;\n   (&lt;table&gt; ^clear yes)}\n\n###############################################################################\n# Calculate whether a block is clear\n#\n# The conditions establish that:\n#  1. The state has a problem-space named 'blocks'.\n#  2. The state has a thing of type block.\n#  3. There is no 'ontop' relation having the block as its 'bottom-block'.\n# The action:\n#  1. create an acceptable preference for an attribute-value pair asserting\n#     the block is clear.\n#\n# This production will retract whenever an 'ontop' relation for the given block\n#  is created. Since the (&lt;block&gt; ^clear yes) wme only has i-support, it will\n#  be removed from working memory automatically when the production retracts.\n\nsp {elaborate*block*clear\n   (state &lt;s&gt; ^problem-space blocks\n              ^thing &lt;block&gt;)\n   (&lt;block&gt; ^type block)\n   -(&lt;ontop&gt; ^bottom-block &lt;block&gt;)\n--&gt;\n   (&lt;block&gt; ^clear yes)}\n\n\n###############################################################################\n# Suggest MOVE-BLOCK operators\n#\n# This production proposes operators that move one block ontop of another block.  \n# The conditions establish that:\n#  1. The state has a problem-space named 'blocks'\n#  2. The block moved and the block moved TO must be both be clear.\n#  3. The block moved is different from the block moved to.\n#  4. The block moved must be type block.\n#  5. The block moved must not already be ontop the block being moved to.\n# The actions:\n#  1. create an acceptable preference for an operator.\n#  2. create acceptable preferences for the substructure of the operator (its\n#     name, its 'moving-block' and the 'destination).\n\nsp {blocks-world*propose*move-block\n   (state &lt;s&gt; ^problem-space blocks\n              ^thing &lt;thing1&gt; {&lt;&gt; &lt;thing1&gt; &lt;thing2&gt;}\n              ^ontop &lt;ontop&gt;)\n   (&lt;thing1&gt; ^type block ^clear yes)\n   (&lt;thing2&gt; ^clear yes)\n   (&lt;ontop&gt; ^top-block &lt;thing1&gt;\n            ^bottom-block &lt;&gt; &lt;thing2&gt;)\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block\n        ^moving-block &lt;thing1&gt;\n        ^destination &lt;thing2&gt;)}\n\n###############################################################################\n# Make all acceptable move-block operators also indifferent\n#\n# The conditions establish that:\n#  1. the state has an acceptable preference for an operator\n#  2. the operator is named move-block\n# The actions:\n#  1. create an indifferent prefererence for the operator\n\nsp {blocks-world*compare*move-block*indifferent\n   (state &lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name move-block)\n--&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; =)}\n\n\n\n###############################################################################\n# Apply a MOVE-BLOCK operator\n# \n# There are two productions that are part of applying the operator.\n# Both will fire in parallel.\n###############################################################################\n\n###############################################################################\n# Apply a MOVE-BLOCK operator\n#   (the block is no longer ontop of the thing it used to be ontop of)\n#\n# This production is part of the application of a move-block operator.\n# The conditions establish that:\n#  1. An operator has been selected for the current state\n#     a. the operator is named move-block\n#     b. the operator has a 'moving-block' and a 'destination'\n#  2. The state has an ontop relation\n#     a. the ontop relation has a 'top-block' that is the same as the\n#        'moving-block' of the operator\n#     b. the ontop relation has a 'bottom-block' that is different from the \n#        'destination' of the operator\n# The actions:\n#  1. create a reject preference for the ontop relation\n\nsp {blocks-world*apply*move-block*remove-old-ontop\n   (state &lt;s&gt; ^operator &lt;o&gt;\n              ^ontop &lt;ontop&gt;)\n   (&lt;o&gt; ^name move-block \n        ^moving-block &lt;block1&gt; \n        ^destination &lt;block2&gt;)\n   (&lt;ontop&gt; ^top-block &lt;block1&gt; \n            ^bottom-block { &lt;&gt; &lt;block2&gt; &lt;block3&gt; })\n--&gt;\n   (&lt;s&gt; ^ontop &lt;ontop&gt; -)}\n\n\n###############################################################################\n# Apply a MOVE-BLOCK operator\n#   (the block is now ontop of the destination)\n#\n# This production is part of the application of a move-block operator.\n# The conditions establish that:\n#  1. An operator has been selected for the current state\n#     a. the operator is named move-block\n#     b. the operator has a 'moving-block' and a 'destination'\n# The actions:\n#  1. create an acceptable preference for a new ontop relation\n#  2. create (acceptable preferences for) the substructure of the ontop\n#     relation: the top block and the bottom block\n\nsp {blocks-world*apply*move-block*add-new-ontop\n   (state &lt;s&gt; ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name move-block\n        ^moving-block &lt;block1&gt;\n        ^destination &lt;block2&gt;)\n--&gt;\n   (&lt;s&gt; ^ontop &lt;ontop&gt;)\n   (&lt;ontop&gt; ^top-block &lt;block1&gt;\n            ^bottom-block &lt;block2&gt;)}\n\n\n###############################################################################\n###############################################################################\n# Detect that the goal has been achieved \n#\n# The conditions establish that:\n#  1. The state has a problem-space named 'blocks'\n#  2. The state has three ontop relations\n#     a. a block named A is ontop a block named B\n#     b. a block named B is ontop a block named C\n#     c. a block named C is ontop a block named TABLE\n# The actions:\n#  1. print a message for the user that the A,B,C tower has been built\n#  2. halt Soar\n\nsp {blocks-world*detect*goal\n   (state &lt;s&gt; ^problem-space blocks\n              ^ontop &lt;AB&gt; \n               { &lt;&gt; &lt;AB&gt; &lt;BC&gt;}\n               { &lt;&gt; &lt;AB&gt; &lt;&gt; &lt;BC&gt; &lt;CT&gt; } )\n   (&lt;AB&gt; ^top-block &lt;A&gt; ^bottom-block &lt;B&gt;)\n   (&lt;BC&gt; ^top-block &lt;B&gt; ^bottom-block &lt;C&gt;)\n   (&lt;CT&gt; ^top-block &lt;C&gt; ^bottom-block &lt;T&gt;)\n   (&lt;A&gt; ^type block ^name A)\n   (&lt;B&gt; ^type block ^name B)\n   (&lt;C&gt; ^type block ^name C)\n   (&lt;T&gt; ^type table ^name TABLE)\n--&gt;\n   (write (crlf) |Achieved A, B, C|)\n   (halt)}\n\n\n###############################################################################\n###############################################################################\n# Monitor the state: Print a message every time a block is moved\n#\n# The conditions establish that:\n#  1. An operator has been selected for the current state\n#     a. the operator is named move-block\n#     b. the operator has a 'moving-block' and a 'destination'\n#  2. each block has a name\n# The actions:\n#  1. print a message for the user that the block has been moved to the\n#     destination. \n\nsp {blocks-world*monitor*move-block\n   (state &lt;s&gt; ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name move-block\n        ^moving-block &lt;block1&gt;\n        ^destination &lt;block2&gt;)\n   (&lt;block1&gt; ^name &lt;block1-name&gt;)\n   (&lt;block2&gt; ^name &lt;block2-name&gt;)   \n--&gt;\n   (write (crlf) |Moving Block: | &lt;block1-name&gt;\n                 | to: | &lt;block2-name&gt; ) }\n</code></pre>"},{"location":"support/","title":"Support","text":"<p>While Soar is an academic, open-source project, there are several options to get help learning Soar and developing Soar systems:</p>"},{"location":"support/#mailing-lists","title":"Mailing Lists","text":"<p>These lists allow you to discuss issues with experienced Soar users. To join a list, sign up on the mailing list page, and then simply send an e-mail to the list.</p> <ul> <li>soar-help is for users to ask questions. If you are experienced with Soar, please consider joining and participating in the discussions.</li> <li>soar-cognitive-architecture is used for announcements and higher level discussions. We recommend that all people who are interested in Soar join the soar-cognitive-architecture mailing list to keep up to date with the latest developments in the Soar community.</li> </ul> <p>Note: All mailing lists have a web archive of previous messages, so you can look for answers to previous questions.</p>"},{"location":"support/#github-issues","title":"GitHub Issues","text":"<p>You can report bugs and request features using Soar's Github repository's issue tracker. Note: If you have a question, please do not post an issue for it and use the soar-help mailing list instead.</p>"},{"location":"tutorials/","title":"Tutorials","text":"<ul> <li>Official Soar Tutorial</li> <li>Engineer's Guide to Soar: A 14-part course on programming Soar for engineers, by Bryan Stearns</li> <li>Introduction to the Soar Debugger</li> <li>Soar Markup Language: Quick Start Guide</li> </ul>"},{"location":"tutorials/SMLQuickStartGuide/","title":"SML Quick Start Guide","text":"","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#sml-quick-start-guide","title":"SML Quick Start Guide","text":"<p>SML (Soar Markup Language) provides an interface into Soar based around sending and receiving commands packaged as XML packets. The interface is designed to support connecting environments to Soar (where input and output data structures are sent back and forth) and to support debuggers (where commands to print out specific productions or working memory elements are sent back and forth).</p> <p>We refer to these environments and debuggers as \"clients\".</p> <p>Users of SML do not need to know the details of the XML dialect, but should instead familiarize themselves with the SML API, which hides the details of the underlying XML messaging system. If you are interested in the details, see Soar XML Interface Specification.</p> <p>We provide a series of classes that together hide the details of the XML messaging system while allowing the client full control over Soar. This guide will provide a quick introduction to using those classes.</p> <p>The SML API is natively implemented in C++, but there are Java, Python, and Tcl bindings automatically generated by SWIG. Although all examples used in this document are in C++, it should be fairly intuitive how they translate into other languages. Later in the document is a section containing example environments written in Java.</p> <p>This page explains how to compile SML clients in various languages.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#simple-sml-example","title":"Simple SML example","text":"<p>This example is something of a \"hello world\" example of how to use the major elements of the SML API. Once you understand this example, you'll be pretty much ready to dive in.</p> <pre><code>// Generally only need this one header file\n#include \"sml_Client.h\"\n\nusing namespace sml ;\nusing namespace std ;\n\nvoid main() {\n\n// Create an instance of the Soar kernel in our process\nKernel* pKernel = Kernel::CreateKernelInNewThread() ;\n\n// Check that nothing went wrong.  We will always get back a kernel object\n// even if something went wrong and we have to abort.\nif (pKernel-&gt;HadError())\n{\ncout &lt;&lt; pKernel-&gt;GetLastErrorDescription() &lt;&lt; endl ;\n        return ;\n}\n\n// Create a Soar agent named \"test\"\n// NOTE: We don't delete the agent pointer.  It's owned by the kernel\nsml::Agent* pAgent = pKernel-&gt;CreateAgent(\"test\") ;\n\n// Check that nothing went wrong\n// NOTE: No agent gets created if there's a problem, so we have to check for\n// errors through the kernel object.\nif (pKernel-&gt;HadError())\n{\ncout &lt;&lt; pKernel-&gt;GetLastErrorDescription() &lt;&lt; endl ;\n        return ;\n}\n\n// Load some productions\npAgent-&gt;LoadProductions(\"testsml.soar\") ;\n\nif (pAgent-&gt;HadError())\n{\n        cout &lt;&lt; pAgent-&gt;GetLastErrorDescription() &lt;&lt; endl ;\n        return ;\n}\nIdentifier* pInputLink = pAgent-&gt;GetInputLink() ;\n\n// Create (I3 ^plane P1) (P1 ^type Boeing747 ^speed 200 ^direction 50.5) on\n// the input link.  (We don't own any of the returned objects).\nIdentifier* pID          = pAgent-&gt;CreateIdWME(pInputLink, \"plane\") ;\nStringElement* pWME1 = pAgent-&gt;CreateStringWME(pID, \"type\", \"Boeing747\") ;\nIntElement* pWME2    = pAgent-&gt;CreateIntWME(pID, \"speed\", 200) ;\nFloatElement* pWME3  = pAgent-&gt;CreateFloatWME(pID, \"direction\", 50.5) ;\n\n// Send the changes to working memory to Soar\n// With 8.6.2 this call is optional as changes are sent automatically.\npAgent-&gt;Commit() ;\n\n// Run Soar for 2 decisions\npAgent-&gt;RunSelf(2) ;\n\n// Change (P1 ^speed) to 300 and send that change to Soar\npAgent-&gt;Update(pWME2, 300) ;\npAgent-&gt;Commit() ;\n// Run Soar until it generates output or 15 decision cycles have passed\n// (More normal case is to just run for a decision rather than until output).\npAgent-&gt;RunSelfTilOutput() ;\n\n// Go through all the commands we've received (if any) since we last ran Soar.\nint numberCommands = pAgent-&gt;GetNumberCommands() ;\nfor (int i = 0 ; i &lt; numberCommands ; i++)\n{\n        Identifier* pCommand = pAgent-&gt;GetCommand(i) ;\n\n        std::string name  = pCommand-&gt;GetCommandName() ;\nstd::string speed = pCommand-&gt;GetParameterValue(\"speed\") ;\n\n        // Update environment here to reflect agent's command\n\n        // Then mark the command as completed\n        pCommand-&gt;AddStatusComplete() ;\n\n// Or could do the same manually like this:\n        // pAgent-&gt;CreateStringWME(pCommand, \"status\", \"complete\") ;\n}\n\n// See if anyone (e.g. a debugger) has sent commands to Soar\n// Without calling this method periodically, remote connections will be ignored if\n// we choose the \"CreateKernelInCurrentThread\" method.\npKernel-&gt;CheckForIncomingCommands() ;\n\n// Create an example Soar command line\nstd::string cmd = \"excise --all\" ;\n\n// Execute the command\nchar const* pResult = pKernel-&gt;ExecuteCommandLine(cmd.c_str(),pAgent-&gt;GetAgentName()) ;\n\n// Shutdown and clean up\npKernel-&gt;Shutdown() ;   // Deletes all agents (unless using a remote connection)\ndelete pKernel ;                // Deletes the kernel itself\n\n} // end main\n</code></pre>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#simple-example-explained","title":"Simple example explained","text":"","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#creating-the-kernel","title":"Creating the kernel","text":"<pre><code>// Create an instance of the Soar kernel in our process\nKernel* pKernel = Kernel::CreateKernelInNewThread() ;\n</code></pre> <p>The client can either create a local Soar kernel or a remote connection to an existing Soar kernel (where commands are sent over a socket to a separate process on the same or a different machine).</p> <p>The local kernel can either be created in the same thread as the caller or in a new thread.</p> <p>Using the same thread will generally be a bit faster, but it requires the client to periodically call <code>pKernel-&gt;CheckForIncomingCommands()</code> so that the kernel has a chance to check for commands coming in from other remote processes (e.g. from a debugger). So if you want maximum speed choose the current thread option, but your code will be a bit more complicated. If speed is not as critical then choose the new thread option. The speed difference isn't that large, perhaps a factor of two on the cost of making a call - which will often be dwarfed by the cost of matching productions or updating the environment.</p> <p>As you are just reading the \"SML Quick Start Guide\" I would strongly recommend you use <code>CreateKernelInNewThread</code> until you are somewhat familiar with the system. If you find you need higher performance later, switching over to the CurrentThread model later only requires changing this one line of code.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#creating-input-link-wmes","title":"Creating input link WME's","text":"<pre><code>// Create (I3 ^plane P1) (P1 ^type Boeing747 ^speed 200 ^direction 50.5) on\n// the input link.  (We don't own any of the returned objects).\nIdentifier* pID          = pAgent-&gt;CreateIdWME(pInputLink, \"plane\") ;\nStringElement* pWME1 = pAgent-&gt;CreateStringWME(pID, \"type\", \"Boeing747\") ;\n</code></pre> <p>The client can build up an arbitrarily complex graph of working memory elements (WMEs) attached to the input-link. Each WME consists of a triplet: <code>(identifier ^attribute value)</code>. The first identifier comes from \"getInputLink\" and then new identifiers are created by <code>CreateIdWME()</code> and new simple WMEs are created through <code>CreateStringWME</code>/<code>CreateIntWME</code>/<code>CreateFloatWME</code>.</p> <p>A WME's value can be updated through the <code>pAgent-&gt;Update()</code> method and it can be removed through <code>pAgent-&gt;DestroyWME()</code> which also makes the working memory object invalid.</p> <p>A graph (rather than a simple tree) can be created through <code>pAgent-&gt;CreateSharedIdWME()</code>. This creates a new identifier WME with the same value as an existing identifier. (E.g. given <code>pOrig = (P7 ^object O3)</code> then <code>CreateSharedIdWME(pInputLink, \"same\", pOrig)</code> would create <code>(I1 ^same O3)</code>).</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#committing-changes","title":"Committing changes","text":"<pre><code>// Send the changes to working memory to Soar\npAgent-&gt;Commit() ;\n</code></pre> <p>The client must explicitly request that changes to working memory be sent over to Soar. This explicit command allows the communication layer to be more efficient, by collecting all changes together and sending them as a single command. With 8.6.2 changes are sent over immediately they are made so Commit() is unnecessary. This produces slightly worse performance (as changes are not collected together into a single packet) so to get maximum performance call SetAutoCommit(false) and write the manual commit calls.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#running-soar","title":"Running Soar","text":"<pre><code>// Run Soar until it generates output or 15 decision cycles have passed\npAgent-&gt;RunSelfTilOutput() ;\n\n// Run Soar for 2 decisions\npAgent-&gt;RunSelf(2) ;\n</code></pre> <p>In most real environments, Soar should be run with <code>pKernel-&gt;RunAllAgentsForever()</code> and then use a call to <code>pKernel-&gt;StopAllAgents()</code> to interrupt. This allows a user to run the environment from a debugger as well as from the environment.</p> <p>There's more discussion of this in Section 2 of this document.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#retrieving-output","title":"Retrieving Output","text":"<pre><code>// Go through all the commands we've received (if any) since we last ran Soar.\nint numberCommands = pAgent-&gt;GetNumberCommands() ;\nfor (int i = 0 ; i &lt; numberCommands ; i++)\n{\n        Identifier* pCommand = pAgent-&gt;GetCommand(i) ;\n\n        std::string name  = pCommand-&gt;GetCommandName() ;\nstd::string speed = pCommand-&gt;GetParameterValue(\"speed\") ;\n\n        // Update environment here to reflect agent's command\n\n        // Then mark the command as completed\n        pCommand-&gt;AddStatusComplete() ;\n\n// Or could do the same manually like this:\n        // pAgent-&gt;CreateStringWME(pCommand, \"status\", \"complete\") ;\n}\n</code></pre> <p>There is direct support provided for an output model where \"commands\" are represented as distinction identifier's on the output-link. For example, if the output-link identifier is O1 then the agent might add a move command with <code>(O1 ^move M1)</code> <code>(M1 ^speed 20)</code>.</p> <p>If you choose to adopt this model for the agent's actions then it is possible to query the agent for the number of commands added since the last time Soar was run and to retrieve each Command in turn, its name and parameter values. In this example, pCommand would point to M1, the name would be move and the parameter value for speed would be 20.</p> <p>If you wish to adopt a different model for agent actions, that is also supported, but the support is less direct.</p> <p>First, notice that GetCommand() returns a standard Identifier WME, so this can be manipulated in the same manner as any other WME. In particular Identifier's offer GetNumberChildren and GetChild methods, so using these it is possible to start from the output link and examine all of working memory beneath the output link. There are also other methods (such as FindByAttribute) that can make this search more efficient.</p> <p>Secondly, you can use <code>IsJustAdded()</code> and <code>AreChildrenModified()</code> on WMEs on the output-link (and below) to determine what has changed since the last time Soar was run.</p> <p>Third, you can call <code>AddOutputHandler()</code> to register a function that is called whenever a specific attribute is added to the output link.</p> <p>Finally, if that is not sufficient, it is possible to call <code>GetNumberOutputLinkChanges()</code> and <code>GetOutputLinkChange()</code> to get a list of all of the WMEs to have been added or removed since the last time Soar was run.</p> <p>From this collection of methods it should be possible to support just about any manner of output model you wish to adopt, but we would recommend the \"Command\" model shown above.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#the-command-line","title":"The Command Line","text":"<pre><code>// Create an example Soar command line\nstd::string cmd = \"excise --all\" ;\n\n// Execute the command\nchar const* pResult = pKernel-&gt;ExecuteCommandLine(cmd.c_str(),pAgent-&gt;GetAgentName()) ;\n</code></pre> <p>To this point the discussion has been purely about environments and supporting I/O. However, the <code>ExecuteCommandLine</code> methods allow a client to send any command to Soar that can be typed at the Soar command prompt. Using this method, productions can be loaded, excised, printed out etc.</p> <p><code>ExecuteCommandLineXML()</code> is also available which returns the output as a structured XML message, making it easier and safer for a client to parse values from the output. See the online documentation for details the format of that XML output for each command.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#capturing-print-output","title":"Capturing print output","text":"<p>To capture output during a run you need to register for the <code>smlEVENT_PRINT</code> event which will be called periodically during the course of the run. To do this you need to define a handler function which will be called during the run. Here's a simple example:</p> <pre><code>void MyPrintEventHandler(smlPrintEventId id, void* pUserData, Agent* pAgent, char const* pMessage)\n{\n        // In this case the user data is a string we're building up\n        std::string* pTrace = (std::string*)pUserData ;\n\n        (*pTrace) += pMessage ;\n}\n</code></pre> <p>The method includes a piece of \"userData\" which is defined by you when you register for the event. In this case we would have:</p> <pre><code>std::string trace ;\nint callbackp = pAgent-&gt;RegisterForPrintEvent(smlEVENT_PRINT, MyPrintEventHandler, &amp;trace) ;\n</code></pre> <p>Note how the string \"trace\" is passed into the registration function. This object is then passed back to the handler, which uses it to build up a complete trace. After this handler has been registered calling:</p> <pre><code>result = pAgent-&gt;Run(4) ;\n</code></pre> <p>would run Soar for 4 decisions and the trace output would be collected in the string \"trace\".</p> <p>There is now also another way to get this output by registering for <code>smlEVENT_XML_TRACE_OUTPUT</code>. This event sends XML objects rather than text strings. Displaying these to the user requires more work by the client, but if the client wishes to parse the text working with XML is much easier. This is the approach taken in the Java debugger.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#events","title":"Events","text":"<p>There are a lot of events you can register for and the list given here will surely grow over time. Here are the types of the handlers in C++ and Java (the Java ones are a little different from the C++ and are more error prone as they're checked at runtime not at compile time):</p> <p>C++ event handlers (if you're not sure how to convert these types into functions look at the example of the print handler in the previous section):</p> <pre><code>// Handler for Run events.\n// Passed back the event ID, the agent and the phase together with whatever user data we registered with the client\ntypedef void (*RunEventHandler)(smlRunEventId id, void* pUserData, Agent* pAgent, smlPhase phase);\n\n// Handler for Agent events (such as creation/destruction etc.).\ntypedef void (*AgentEventHandler)(smlAgentEventId id, void* pUserData, Agent* pAgent) ;\n\n// Handler for Print events.\ntypedef void (*PrintEventHandler)(smlPrintEventId id, void* pUserData, Agent* pAgent, char const* pMessage) ;\n\n// Handler for Production manager events.\ntypedef void (*ProductionEventHandler)(smlProductionEventId id, void* pUserData, Agent* pAgent, char const* pProdName, char const* pInstantion) ;\n\n// Handler for System events.\ntypedef void (*SystemEventHandler)(smlSystemEventId id, void* pUserData, Kernel* pKernel) ;\n\n// Handler for XML events.  The data for the event is passed back in pXML.\n// NOTE: To keep a copy of the ClientXML* you are passed use ClientXML* pMyXML = new ClientXML(pXML) to create\n// a copy of the object.  This is very efficient and just adds a reference to the underlying XML message object.\n// You need to delete ClientXML objects you create and you should not delete the pXML object you are passed.\ntypedef void (*XMLEventHandler)(smlXMLEventId id, void* pUserData, Agent* pAgent, ClientXML* pXML) ;\n\n// Handler for RHS (right hand side) function firings\n// pFunctionName and pArgument define the RHS function being called (the client may parse pArgument to extract other values)\n// The return value is a string which allows the RHS function to create a symbol: e.g. ^att (exec plus 2 2) producing ^att 4\n// NOTE: This is the one place in clientSML where we use a std::string in an interface.  If you wish to compile with a pure \"C\" interface\n// this can be replaced by a handler that is passed a buffer and a length.  The length is passed within the framework already (from the kernel to here)\n// so this is an easy transition.\ntypedef std::string (*RhsEventHandler)(smlRhsEventId id, void* pUserData, Agent* pAgent, char const* pFunctionName, char const* pArgument) ;\n</code></pre> <p>Java event handlers are based on implementing an interface within an object:</p> <p>From Kernel:</p> <pre><code>public interface SystemEventInterface {\n    public void systemEventHandler(int eventID, Object data, Kernel kernel) ;\n}\n\npublic interface UpdateEventInterface {\n    public void updateEventHandler(int eventID, Object data, Kernel kernel, int runFlags) ;\n}\n\npublic interface StringEventInterface {\n    public void stringEventHandler(int eventID, Object userData, Kernel kernel, String callbackData) ;\n}\n\npublic interface AgentEventInterface {\n            public void agentEventHandler(int eventID, Object data, String agentName) ;\n}\n\npublic interface RhsFunctionInterface {\n            public String rhsFunctionHandler(int eventID, Object data, String agentName, String functionName, String argument) ;\n}\n\npublic interface ClientMessageInterface {\n            public String clientMessageHandler(int eventID, Object data, String agentName, String functionName, String argument) ;\n</code></pre> <p>From Agent:</p> <pre><code>public interface RunEventInterface {\n    public void runEventHandler(int eventID, Object data, Agent agent, int phase) ;\n}\n\npublic interface ProductionEventInterface {\n    public void productionEventHandler(int eventID, Object data, Agent agent, String prodName, String instantiation) ;\n}\n\npublic interface PrintEventInterface {\n            public void printEventHandler(int eventID, Object data, Agent agent, String message) ;\n}\n\npublic interface xmlEventInterface {\n            public void xmlEventHandler(int eventID, Object data, Agent agent, ClientXML xml) ;\n}\n\npublic interface OutputEventInterface {\n            public void outputEventHandler(Object data, String agentName, String attributeName, WMElement pWmeAdded) ;\n}\n\npublic interface OutputNotificationInterface {\n            public void outputNotificationHandler(Object data, Agent agent) ;\n}\n</code></pre> <p>Examples of implementations:</p> <pre><code>public void runEventHandler(int eventID, Object data, Agent agent, int phase)\n{\n        System.out.println(\"Received run event in Java\") ;\n}\n\n// We pass back the agent's name because the Java Agent object may not yet\n// exist for this agent yet.  The underlying C++ object *will* exist by the\n// time this method is called.  So instead we look up the Agent object\n// from the kernel with GetAgent().\npublic void agentEventHandler(int eventID, Object data, String agentName)\n{\n        System.out.println(\"Received agent event in Java\") ;\n}\n\npublic void productionEventHandler(int eventID, Object data, Agent agent, String prodName, String instantiation)\n{\n        System.out.println(\"Received production event in Java\") ;\n}\n\npublic void systemEventHandler(int eventID, Object data, Kernel kernel)\n{\n        System.out.println(\"Received system event in Java\") ;\n}\n\npublic void printEventHandler(int eventID, Object data, Agent agent, String message)\n{\n        System.out.println(\"Received print event in Java: \" + message) ;\n}\n\npublic void xmlEventHandler(int eventID, Object data, Agent agent, ClientXML xml)\n{\n        String xmlText = xml.GenerateXMLString(true) ;\n        System.out.println(\"Received xml trace event in Java: \" + xmlText) ;\n\n        String allChildren = \"\" ;\n\n        if (xml.GetNumberChildren() &gt; 0)\n        {\n                ClientXML child = new ClientXML() ;\n                xml.GetChild(child, 0) ;\n\n                String childText = child.GenerateXMLString(true) ;\n                allChildren += childText ;\n\n                child.delete() ;\n        }\n\n}\n\npublic String testRhsHandler(int eventID, Object data, String agentName, String functionName, String argument)\n{\n        System.out.println(\"Received rhs function event in Java for function: \" + functionName + \"(\" + argument + \")\") ;\n        return \"My rhs result \" + argument ;\n}\n</code></pre> <p>To see more about events look at the sml_ClientEvents.h header file or the TestSMLEvents test program (currently located in the Tools folder).</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#events-in-tcl","title":"Events in Tcl","text":"<p>Tcl requires that callbacks to a Tcl interpreter happen in the same thread as the interpreter is executing in. By default, this will not always happen for SML events. This is because there is an event thread started up by SML (running in the client) which is used to check for incoming events and make the necessary callback calls.</p> <p>Therefore for Tcl we recommend shutting down this event thread and polling explicitly for incoming events. This can be done in a few lines of code like this:</p> <pre><code># We want to make sure to handle events in the Tcl thread\n# so we turn off the event thread and poll for events instead.\n$_kernel StopEventThread\ncheckForEvents $_kernel\n\n# Explicitly check for incoming commands and events every n milliseconds\nproc checkForEvents {k} {\n   $k CheckForIncomingCommands\n   after 10 checkForEvents $k\n}\n</code></pre> <p>This assumes <code>$_kernel</code> is a variable set to the SML kernel object. Note, the after 10 triggers another call to the <code>checkForEvents()</code> method after a 10ms delay. Making this value larger will make Tcl less responsive to events. Making it smaller will consume more CPU time checking for events.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#building-an-environment","title":"Building an Environment","text":"<p>If you are converting an existing SGIO environment you should also read the \"Moving from SGIO to SML\" document as well as this section.</p> <p>The Java implementation of Towers of Hanoi (TOH) is a useful reference, showing a simple environment environment. I'll use that to as an example here, so the code snippets will be in Java, but a very similar approach can be taken in other languages (currently Tcl or C++).</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#initialization","title":"Initialization","text":"<p>The first step is to create an instance of the kernel and then create an agent. The name passed to <code>CreateKernelInNewThread</code> is the name of the library to load (DLL on Windows). This is optional in 8.6.2 and defaults to SoarKernelSML.</p> <p>It is important to check for an error using the <code>kernel.HadError()</code> method. CreateKernel will not return an empty kernel object even if initialization fails. This is deliberate design to ensure that meaningful errors can be reported to the user.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#initialization-code-sample","title":"Initialization Code Sample","text":"<pre><code>// create our Soar kernel\nkernel = Kernel.CreateKernelInNewThread();\n\nif (kernel.HadError())\n{\n    // Better to use a \u0093Message Box\u0094 to display this if your platform/toolkit allows.\n    System.out.println(\"Error creating kernel: \" + kernel.GetLastErrorDescription()) ;\n    System.exit(1);\n}\n\nagent = kernel.CreateAgent(AGENT_NAME);\nboolean load = agent.LoadProductions(\"towers-of-hanoi-SML.soar\");\nif (!load || agent.HadError()) {\n    throw new IllegalStateException(\"Error loading productions: \"\n        + agent.GetLastErrorDescription());\n}\n</code></pre>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#input","title":"Input","text":"<p>Mapping from the environment's state to input values involves calls to create, update and destroy working memory elements using calls like these:</p> <pre><code>agent.Create&lt;type&gt;WME (e.g. agent.CreateIntWME)\nagent.Update()\nagent.DestroyWME\n</code></pre> <p>Working memory elements are linked together to form a tree (actually a graph) with the input link as the root of the tree. To get the input link identifier (the top of the tree) call <code>agent.GetInputLink()</code>.</p> <p>A key step after making multiple calls to modify the input link is to call Commit(). All changes to working memory are buffered (in the environment) until the moment Commit is called, at which point they are all sent over as a single large message to the kernel. This greatly improves performance, but you must remember to call Commit before running the agent or your changes won't actually appear on the agent's input link. This was changed in 8.6.2 so the default now is that Commit() is called automatically each time a wme is modified on the input link. To enable the faster version which then requires manual calls to Commit() call SetAutoCommit(false). Calling Commit multiple times during a single input cycle will not cause problems.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#output","title":"Output","text":"<p>The most common way to examine output from an agent is to use the \"Commands\" model. With this method the agent places each output command on the output-link using the format:</p> <pre><code>(X ^output-link I3)\n(I3 ^command-name C1)\n(C1 ^param1 value ^param2 value)\n</code></pre> <p>Thus the name of the command appears directly under the output-link and all parameters are added to the command identifier and can only be one level deep. (If you wish to use an alternative model see below).</p> <p>If the agent adopts this format for output commands they can be easily retrieved by the environment using code like this:</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#update-world-code-sample","title":"Update World Code Sample","text":"<p>Procedure:</p> <ol> <li>Get Output</li> <li>Change-World-State</li> <li>Send Input</li> </ol> <pre><code>private void updateWorld()\n        // See if any commands were generated on the output link\n        // (In general we might want to update the world when the agent\n        // takes no action in which case some code would be outside this if statement\n        // but for this environment that's not necessary).\n        if (agent.Commands())\n        {\n                // perform the command on the output link\n                Identifier command = agent.GetCommand(0);\n                if (!command.GetCommandName().equals(MOVE_DISK)) {\n                    throw new IllegalStateException(\"Unknown Command: \"\n                            + command.GetCommandName());\n                }\n                if (command.GetParameterValue(SOURCE_PEG) == null ||\n                        command.GetParameterValue(DESTINATION_PEG) == null) {\n                    throw new IllegalStateException(\"Parameter(s) missing for Command \"\n                            + MOVE_DISK);\n                }\n                int srcPeg = command.GetParameterValue(\"source-peg\").charAt(0) - 'A';\n                int dstPeg = command.GetParameterValue(\"destination-peg\").charAt(0) - 'A';\n\n                // Change the state of the world and generate new input\n                moveDisk(srcPeg, dstPeg);\n\n                // Tell the agent that this command has executed in the environment.\n                command.AddStatusComplete();\n\n                // Send the new input link changes to the agent\n                agent.Commit();\n\n                // \"agent.GetCommand(n)\" is based on watching for changes to the output link\n                // so before we do a run we clear the last set of changes.\n                // (You can always read the output link directly and not use the\n                //  commands model to determine what has changed between runs).\n                agent.ClearOutputLinkChanges() ;\n\n                if (isAtGoalState())\n                    fireAtGoalState();\n        }\n}\n</code></pre> <p>The method <code>GetCommandName</code> and <code>GetParameterValue</code> extract the appropriate attributes and values from the output link and return them to the environment.</p> <p>The method <code>AddStatusComplete()</code> adds <code>(C1 ^status complete)</code> to the command structure, indicating to the agent that this command has executed and can now be removed by the agent.</p> <p>(Note that this is simple form of input that in this case is sent to the output link rather than the input link. This is technically a bit of \"back door\" input, but is simpler than passing a large structure to the input link and having the agent match up the two. This addition is made during the agent's next input cycle as with all input).</p> <p>In order for the Commands method to work, the system has to keep track of changes to working memory as only newly added commands are reported through the GetCommand method. For this process to work, the environment must call <code>ClearOutputLinkChanges()</code> before running the agent again.</p> <p>While this Command model should be sufficient for almost all environments, if there is a need to process other structures, the environment can always choose to ignore this model partially or completely. First, the method <code>GetCommand</code> returns an Identifier object. The environment can use the methods <code>GetNumberChildren</code> and <code>GetChild</code> to walk this Identifier and locate any arbitrary working memory element beneath an Identifier or the environment can use the <code>FindByAttribute</code> method to retrieve the values of working memory elements that have a particular attribute.</p> <p>In fact a environment can abandon the Command model completely and simply call <code>GetOutputLink()</code> to get the Identifier object at the top of the output link and proceed to examine the tree (graph) from there.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#running-the-agents","title":"Running the agent(s)","text":"<p>There are two main methods for running an agent:</p> <ul> <li><code>RunSelfForever()</code> and it's twin <code>RunAllAgentsForever()</code></li> <li><code>RunSelf(1)</code> and <code>RunAllAgents(1)</code> (to step the environment rather than running it).</li> </ul> <p>The trick here is that the code for running the agents should be separate from the code for updating the world (collecting output; updating world state; sending input). By separating the two we can either issue the run from the environment or from a debugger (or other client) and everything works correctly.</p> <p>Let's assume we have the <code>updateWorld()</code> method from above, which should have the form:</p> <pre><code>void updateWorld()\n{\n    check-for-output() ;\n    update-world-state() ;\n    send-new-input() ;\n}\n</code></pre> <p>Then the code samples below show how to connect up the system so that updateWorld() is only called once all agents have completed the output phase (i.e. at the end of a decision cycle).</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#run-sample-code","title":"Run Sample Code","text":"<pre><code>public void run()\n{\n    m_StopNow = false ;\n\n    // Start a run\n    // (since this is single agent could use agent.RunSelfForever() instead, but this shows how to run multi-agent environments)\n    kernel.RunAllAgentsForever() ;\n}\n\npublic void step()\n{\n    // Run one decision\n    kernel.RunAllAgents(1) ;\n}\n\npublic void stop()\n{\n    // We'd like to call StopSoar() directly from here but we're in a different\n    // thread and right now this waits patiently for the runForever call to finish\n    // before it executes...not really the right behavior.  So instead we use a flag and\n    // issue StopSoar() in a callback.\n    m_StopNow = true ;\n}\n</code></pre>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#event-based-method-for-updating-the-world","title":"Event-based method for updating the world","text":"<pre><code>public void registerForUpdateWorldEvent()\n{\nint updateCallback = kernel.RegisterForUpdateEvent(sml.smlUpdateEventId.smlEVENT_AFTER_ALL_OUTPUT_PHASES, this, \"updateEventHandler\", null) ;\n    }\n\npublic void updateEventHandler(int eventID, Object data, Kernel kernel, int runFlags)\n{\n        // Might not call updateWorld() depending on runFlags in a fuller environment.\n        // See the section below for more on this.\n        updateWorld() ;\n\n        // We have a problem at the moment with calling Stop() from arbitrary threads\n        // so for now we'll make sure to call it within an event callback.\n        // Do this test after calling updateWorld() so that method can set m_StopNow if it\n        // wishes and trigger an immediate stop.\n        if (m_StopNow)\n        {\n        m_StopNow = false ;\n        kernel.StopAllAgents() ;\n        }\n}\n</code></pre> <p>The Run code is pretty simple. The only issues to be aware of are:</p> <ul> <li><code>RunAllAgentsForever()</code> is currently (8.6.2) a blocking call, so we usually   spawn a thread and issue this call in that thread.</li> <li><code>StopAllAgents()</code> can currently not be called from an arbitrary thread (or it   blocks waiting for the Run to terminate). This may be fixed in a later version,   but for now calling it from an event callback solves this problem.</li> </ul> <p>The way <code>updateWorld()</code> is called is after the <code>smlEVENT_AFTER_ALL_OUTPUT_PHASES</code> event fires. Why bother to do this rather than writing run as:</p> <pre><code>while (!stopped)\n{\n    run(1) ;\n    update-world() ;\n}\n</code></pre> <p>There are two basic reasons. First, there are no guarantees that <code>run(1)</code> will run for a decision. If we include breakpoints on productions or phase transitions this call may run for less time, possibly confusing the environment (as the agents have not progressed as far as expected). Second, by making the call to <code>updateWorld()</code> event based, we can issue arbitrary run commands from a debugger and the environment will function correctly. For more on this see the \"Event-Driven Environments Proposal.doc\" file.</p> <p>Also in Tcl please be sure to read about how to poll for events in Tcl (see Section 1.6.1).</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#supporting-running-without-updating-the-environment","title":"Supporting running without updating the environment","text":"<p>For some environments it may make sense to allow the user to run an agent without starting the environment. This can be helpful when debugging one agent or having reached a particular situation in the world, stopping and wanting to step slowly to observe the reasoning.</p> <p>To support this the environment should check the runFlags parameter passed to the updateEventHandler. This is a bit field which currently consists of the values in this enum:</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#run-flags","title":"Run Flags","text":"<pre><code>typedef enum\n{\n    sml_NONE                =  0,           // No special flags set\n    sml_RUN_SELF            =  1 &lt;&lt; 0,      // User included --self flag when running agent\n    sml_RUN_ALL             =  1 &lt;&lt; 1,      // User ran all agents\n    sml_UPDATE_WORLD        =  1 &lt;&lt; 2,      // User explicitly requested world to update\n    sml_DONT_UPDATE_WORLD   =  1 &lt;&lt; 3,      // User explicitly requested world to not update\n} smlRunFlags ;\n</code></pre> <p>Based on these flags, the environment should decide whether to update or not. We leave this entirely to the discretion of the designer because different combinations may make sense for different situations but this might be a typical set (for a multi-agent environment):</p> <p>if <code>sml_RUN_SELF</code> set and <code>SML_UPDATE_WORLD</code> not set or <code>sml_DONT_UPDATE_WORLD</code> set then don't call <code>updateWorld()</code>.</p> <p>The meaning of this would be that:</p> <ul> <li><code>run --self</code> would cause the agent to run but not the environment</li> <li><code>run --noupdate</code> would cause all agents to run but not the environment</li> <li><code>run --self --update</code> would cause one agent to run and update the environment</li> <li><code>run</code> would cause all agents to run and update the environment.</li> </ul> <p>You are free to make other choices if there's a compelling reason.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#integrating-with-other-clients-esp-the-debugger","title":"Integrating with other clients (esp. the debugger)","text":"<p>One final issue is updating the controls in the environment correctly if the user runs Soar from the debugger and not the environment (e.g. disabling the run button and enabling stop during a run).</p> <p>There are two approaches to this. First, ignore the problem and don't enable/disable controls. Instead, just handle errors if the user tries to issue a second run while a run is already going ahead. The second option is to register for the <code>smlEVENT_SYSTEM_START</code> and <code>smlEVENT_SYSTEM_STOP</code> events and use these to enable/ disable the UI in the environment in appropriate ways.</p> <p>Here's an example for implementing this support:</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#registering-and-handling-startstop-sample-code","title":"Registering and Handling Start/Stop Sample Code","text":"<pre><code>public void registerForStartStopEvents()\n{\n    if (kernel != null)\n    {\n        int startCallback = kernel.RegisterForSystemEvent(smlSystemEventId.smlEVENT_SYSTEM_START, this, \u0093systemEventHandler\u0094, null) ;\n        int stopCallback  = kernel.RegisterForSystemEvent(smlSystemEventId.smlEVENT_SYSTEM_STOP, this, \u0093systemEventHandler\u0094, null) ;\n    }\n}\n\npublic void systemEventHandler(int eventID, Object data, Kernel kernel)\n{\n        if (eventID == sml.smlSystemEventId.smlEVENT_SYSTEM_START.swigValue())\n        {\n                // The callback comes in on Soar's thread and we have to update the buttons\n                // on the UI thread, so switch threads.\n                dpy.asyncExec(new Runnable() { public void run() { updateButtons(true) ; } } ) ;\n        }\n\n        if (eventID == sml.smlSystemEventId.smlEVENT_SYSTEM_STOP.swigValue())\n        {\n                // The callback comes in on Soar's thread and we have to update the buttons\n                // on the UI thread, so switch threads.\n                dpy.asyncExec(new Runnable() { public void run() { updateButtons(false) ; } } ) ;\n        }\n}\n\npublic void updateButtons(boolean running)\n{\n        boolean done = game.isAtGoalState() ;\n\n        startButton.setEnabled(!running &amp;&amp; !done) ;\n        stopButton.setEnabled(running) ;\n        resetButton.setEnabled(!running &amp;&amp; !done) ;\n        stepButton.setEnabled(!running &amp;&amp; !done) ;\n}\n</code></pre>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#further-details","title":"Further details","text":"<p>To learn more about ClientSML and SML in general, the best documentation is the header files for the methods in ClientSML. In particular, <code>sml_ClientKernel.h</code>, <code>sml_ClientAgent.h</code> and <code>sml_ClientIdentifier.h</code> contain a lot of useful methods and explanations.</p> <p>Beyond that check the Soar XML Interface Spec and any other documentation in its vicinity.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#using-other-languages","title":"Using other languages","text":"<p>The Tcl and Java interfaces were generated by SWIG. We have provided some custom code to help SWIG out in a few places, mostly with callbacks. If you're interested in creating interfaces for other languages that SWIG supports, check out the SWIG documentation and try to follow our existing solutions.</p> <p>A Tcl package, called Tcl_sml_ClientInterface is available. On Windows it is located in the soar-library directory. This can be used by including the following line in your Tcl code:</p> <pre><code>package require tcl_sml_clientinterface\n</code></pre> <p>Note that the directory where the package resides must be added to Tcl's auto_path variable. The available functions are direct translations of their C++ counterparts. See TOHtest.tcl in soar-library for examples showing how to use the Tcl interface. The Tcl package includes Tcl_sml_ClientInterface.dll (or the equivalent for other platforms), which is required.</p>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#example-environments-in-java","title":"Example Environments in Java","text":"<p>Here are two example clients written in Java, intended to explain the basics of using SML in that language. Thorough explanatory comments are inlined.</p> <ol> <li>A very simple Soar environment.</li> <li>HelloWorld.java</li> <li>helloworld.soar</li> <li>A more complex interactive asynchronous environment.</li> <li>SimpleAsyncEnv.java</li> <li>simpleasyncenv.soar</li> </ol>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#helpful-tips","title":"Helpful Tips","text":"","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#memory-management","title":"Memory Management","text":"<p>Memory management is actually really easy. Generally, the only objects you should explicitly delete are the kernel object and any objects you directly allocated through a call to new. In Java and Tcl, this generally means you can just let things go out of scope when you're done with them. There are a couple special cases you should be aware of, though:</p> <ul> <li>Agent objects are automatically deleted when the owning Kernel object is   deleted (actually, when the call to Kernel::Shutdown is made, which you should   always make before deleting the kernel). If you want to destroy an agent   earlier, you can by making a call to <code>Kernel::destroyAgent</code>. Under no circumstances   should you delete (in the C++ sense) an Agent object.</li> <li>In Java if you create a ClientXML object through <code>xml = new ClientXML()</code> you   should call <code>xml.delete()</code> on it when you're done. This isn't strictly required   (the garbage collector will get it eventually) but is good practice and will   avoid messages about leaked memory when the application shuts down. As per the   general rule, in C++ if you create it with new you're responsible for destroying   it with delete.</li> <li>Since there can be multiple clients interacting with the same kernel and   agents, your application needs to be listening for the appropriate events so if   some other client deletes/destroys a kernel or agent your application is using,   you don't crash. Specifically, listen for the <code>BEFORE_AGENT_DESTROYED</code> and   <code>BEFORE_SHUTDOWN</code> events so you can clean things up as needed in your application.</li> </ul>","tags":["sml"]},{"location":"tutorials/SMLQuickStartGuide/#boosting-performance","title":"Boosting Performance","text":"<p>It is often desirable to maximize the performance of your SML application. This section assumes that you just want to make things as fast as possible after you have finished debugging your application. Debugging is an inherently slow process, so these tips will be less helpful while you're still debugging.</p> <ul> <li>Compile with optimizations turned on. In Visual Studio this means doing a   release build. On Linux and OS X, the default settings are probably sufficient,   but you can experiment with new settings if you want (let us know if you find   better settings).</li> <li>Put primary application and Soar in the same process. That is, use   <code>CreateInNewThread</code> or <code>CreateInCurrentThread</code>, not <code>CreateRemoteConnection</code>. Using a   remote kernel means socket communications are used, which is slow.</li> <li>Don't register for unnecessary events. Every event that is registered for   causes extra work to be done. Try to find an appropriate event to register for   so you don't end up getting more event calls than you actually need - that is,   try to avoid registering for events which occur more frequently than you need   and then filtering them on the application side.</li> <li>Don't connect the debugger. Connecting the debugger creates a remote   connection and also registers for several events.</li> <li>Set watch level 0. Even if you don't have a client registered for any of the   print or XML events, work is still done internally to generate some of the   information that would have been sent out. Setting watch level 0 avoids this   work.</li> <li>Disable monitor productions. Again, even if no client is registered to print   out the text of monitor productions, work is still done internally to prepare   the text. Monitor productions can be disabled by excising them or commenting   them out, but an easier method is to have each monitor production test a debug   flag in working memory which is set by some initialization production or   operator. Thus all of the monitor productions can be turned on or off by   changing one line of code.</li> <li>Disable timers. Soar uses timers internally to generate the output of the   stats command. If you don't need this information, you can use the timers - off   command to disable this bookkeeping. This can make a significant difference in   the watch 0 case.</li> <li>Avoid running agents separately. Instead of calling <code>RunSelf</code> or   <code>RunSelfTilOutput</code> on each agent, just call <code>RunAllAgents</code> on the kernel itself.   This runs all agents together and avoids the overhead of running them   separately. The absolute best you can do is to call <code>RunAllAgentsForever</code> as   described in section 2.4 - this avoids repeatedly calling the run functions at   all and will make it easier to stop and restart your application from the   debugger (or other clients).</li> <li>In the case where the absolute best performance under SML is desired, use   <code>CreateKernelInCurrentThread</code> instead of <code>CreateKernelInNewThread</code> and set the   \"optimized\" flag to true in the parameters passed to   <code>CreateKernelInCurrentThread</code>. This means Soar will execute in the same thread as   your application. Without this each call to and from the Soar kernel requires a   context switch (assuming a single processor machine). This method also   eliminates the thread which polls for new events. This means you must poll for   the events yourself by periodically calling <code>CheckForIncomingCommands</code>, which is   a little more work for the programmer.</li> </ul>","tags":["sml"]},{"location":"tutorials/IntroSoarDebugger/","title":"Introduction to the Soar Debugger","text":"<p>The Soar Java Debugger is distributed with Soar, and can be launched by double-clicking either <code>SoarJavaDebugger.bat</code> or <code>SoarJavaDebugger.sh</code> in the root directory of Soar.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#overview","title":"Overview","text":"<p>With Soar 8.6 we made a new method for interfacing into Soar based around SML (Soar Markup Language). This interface allows tools to be built that have a higher level understanding of the data being sent back and forth to the Soar kernel and allows for more dynamic debugging sessions (connecting and disconnecting from an existing kernel instance).</p> <p>In order to take advantage of these features we needed a new debugger and we chose to implement it in Java due to its cross-platform support and the relative ease of working with the language.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#quick-tour","title":"Quick Tour","text":"<p>On launch you should see a display similar to this:</p> Screenshot of default debugger display <p>The window on the left side is the main trace window. As Soar executes, debug information is streamed to this window.</p> <p>On the right are a series of other utility windows which we'll discuss later.</p> <p>To get things going load the towers of Hanoi demo. This can be done by either pressing the \"towers of Hanoi\" button or from the \"Demos\" menu. Then type <code>run 20</code> into the line to the left of the Expand button.</p> <p>You should be rewarded with a display like this:</p> Screenshot showing output of <code>run 20</code> <p>This is hard to read but the trace window on the left shows the series of operators that have just fired during the course of the first 20 decisions. You should also have noticed that at the end of the run the windows on the right updated automatically to print the current state and stack. In fact, they are just issuing the command typed at the top of the window, so you can customize the window to print any values you'd like to see at the end of a run. Because the windows only update after the run completes there is no performance hit from these windows during a run.</p> <p>The different tabbed windows at the top right of the display (state, operator, stack etc.) show examples of some values you might find useful. In a real debugging session you can use this simple mechanism to watch a particular part of working memory (e.g. printing the input link) while you step forward.</p> <p>The default layout that you started with uses a tree view for the main trace window. To see this in action press the \"watch 5\" button and then type <code>run 20</code> again at the command prompt.</p> <p>This should result in a display like this:</p> Screenshot showing output of <code>run 20</code> with watch level set to 5 <p>The trace looks similar, but doing the obvious thing of expanding the tree nodes will reveal the detailed trace information collected during the run:</p> Screenshot showing some expanded output nodes <p>You can also expand the current page of trace information using the \"expand\" button or the drop down menu next to it. (Once the expand button has been pressed future trace output will appear in the window already expanded until collapse is pressed).</p> <p>The window in the lower right is something of a scratch pad. Commands typed at the top of this window (e.g. print s4) are printed below and just stay there. This helps solve the problem of output \"scrolling off the top\" of the main trace window.</p> <p>If you want to keep information in the main trace window from scrolling away during a run (i.e. in the case where stopping Soar isn't an option), you can click in the trace window. This puts a cursor in the trace window which \"freezes\" the trace at that point; new trace information just gets appended to the bottom of the trace. The cursor can be moved with the arrow keys and page up/page down. To continue scrolling with the trace, put the cursor on the last line of the trace. The easiest way to do this while Soar is still running is to press Ctrl-End.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#agents","title":"Agents","text":"<p>The debugger can be used with multiple agents. To see this, select \"Agents | Create Agent -- New Window\" and you'll get a new top level window for agent \"soar2\".</p> <p>If you load another demo here (e.g. \"Water Jug Demo\") and then type <code>run 20</code> you will see both sets of windows updating as both agents run.</p> Screenshot showing multiple debugger windows, one per agent <p>The relationship between a top level debugger window (a frame) and the agent is pretty loose. For instance, we can switch the second window to observe the first agent (Agent | Select Agent and choose \"soar1\"). This gives you two windows pointed at the same agent. Probably not very useful, but it illustrates the point that the debugger windows and the agent are separate entities.</p> <p>The Agent menu also allows you to create a new agent without a new window or create a new window without a new agent. You also should be aware that closing a debugger window does not delete the agent. If you want to delete an agent you must do so explicitly from the Agent menu.</p> <p>There's also a checkbox for whether a new window is created when an agent is created. This only matters when you're connected to another environment and that environment is creating agents. The checkbox determines whether or not windows pop open in the debugger as this happens.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#kernels","title":"Kernels","text":"<p>When you launch the debugger it creates a new instance of the Soar kernel as part of the debugger's process. We refer to this as a \"local\" kernel.</p> <p>You can also connect the debugger to a \"remote\" kernel which is running inside another process or even on another machine.</p> <p>All Soar kernels (using the SML interface) support this sort of remote connection automatically, so we can see an example of this by using two debuggers (with a little care). To see this launch a second instance of the debugger so you have two running. You'll need to keep track of which debugger was launched first.</p> <p>On the debugger launched second choose \"Kernel | Connect to remote Soar\". You'll get a warning that there's a local kernel running. Say \"OK\" to shut that down. You'll see a dialog like this:</p> Screenshot of remote kernel connection dialog <p>This allows you to enter an IP address (for a truly remote machine) or a different port number (which requires a change to the kernel you are connecting to). For this example and in almost all cases you'll want to leave these as the default settings.</p> <p>Clicking ok connects this debugger to the remote kernel and selects an agent to focus on. (You could use the Agent menu to select which agent if there were multiple agents running in this kernel).</p> <p>Now you can type commands into either debugger (e.g. type \"run 10\") and you'll see both windows update.</p> <p>Obviously, the idea isn't to connect two debuggers together, but to connect to environments. This sort of connecting and disconnecting allows us to build environments that run a local or embedded kernel (for maximum performance) and then connect a debugger to them to see what they are doing.</p> <p>There's nothing special about the way the debugger is doing this. All instances of an SML kernel support this sort of remote connecting, so it's also possible (by changing a single line of code) to build an environment that connects to a remote debugger instance and so on. Also multiple tools (or clients) can connect to a single kernel at the same time, allowing different types of debuggers to be connected to an environment as necessary.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#using-the-debugger-with-an-environment","title":"Using the debugger with an environment","text":"","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#java-towers-of-hanoi-toh","title":"Java Towers of Hanoi (TOH)","text":"<p>To walkthrough this demonstration, start by launching the Java version of Towers of Hanoi:</p> Screenshot showing Java Towers of Hanoi starting position <p>The simulation starts an embedded Soar kernel when it's launched. You can run the environment by pressing \"run\"/\"stop\" as you'd expect.</p> <p>To debug what's happening launch the debugger and then choose Kernel | Connect to remote Soar and say \"OK\" to the two dialogs (keep the defaults for the IP/port values).</p> <p>You should now see the name of the agent (in the title bar of the debugger) change to \"remote TOH\" like this:</p> Screenshot of debugger showing name of agent as \"remote TOH\" <p>At this point pressing run in the environment will generate trace output in the debugger. (The agent starts at watch 0 in this simulation so you just see <code>write</code> statements from productions).</p> Screenshot of debugger output for TOH <p>Pressing \"stop\" in the environment again stops the run. So far this is simple enough.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#controlling-an-environment-from-the-debugger","title":"Controlling an environment from the debugger","text":"<p>Another option is controlling the environment from the debugger.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#run-and-stop-soar","title":"\"run\" and \"stop-soar\"","text":"<p>To run the environment, type <code>run 10</code> in the debugger or <code>run</code> and then press \"stop\" in either the debugger or the environment. You can run Soar in any step size and the environment should update correctly, e.g. you can use <code>run 1 --p</code> to run by phases and the environment will only update once the agent passes through its output phase.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#running-the-agent-without-the-environment","title":"Running the agent without the environment","text":"<p>With a suitably designed environment it is possible for the user to type <code>run --self</code> in the debugger to indicate that we wish to only run the agent and not the environment. They can also force the environment to update in this situation <code>run --self --update</code>. These values are passed to the environment when it is run and it is up to the environment to interpret them appropriately.</p> <p>Running without updating the environment makes little sense in towers of Hanoi anyway and once these commands function as intended you would just get a series of state no changes here. But for other environments this would be a useful capability.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#init-soar","title":"<code>init-soar</code>","text":"<p>You can also type <code>init-soar</code> in the debugger which will reset the agent to its initial state (as usual) but also transmits the current state of the simulation over the input link, so that the agent can potentially pick up and continue to reason.</p> <p>(As of the writing of this document this doesn't work for towers-of-hanoi, but this is just a reflection of the way the agent has been written, rather than a limitation of the system. For large environments the ability to restart the agent without having to restart a simulation can save a lot of time when debugging.)</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#connecting-and-disconnecting","title":"Connecting and Disconnecting","text":"<p>It is also possible to start the environment running before connecting to it with the debugger and then making a connection. The trace information will pick it in mid-stride.</p> <p>Similarly it is possible to start the environment or agent running from the debugger and then disconnect from it.</p> <p>These capabilities open the door to \"dropping-in\" on agents in a large environment, stopping the agent, figuring out what's going wrong, possibly make adjustments and then restarting it.</p> <p>In all cases, the standard model is for the agent to run embedded within the environment, ensuring maximum performance when the debugger is not connected and still excellent performance even if the debugger is connected, as long as the agent is not generating much trace output. This is the reverse of the relationship with the 8.5 TSI debugger, where the environment was always external to the kernel, so even when set to watch 0 all I/O traffic would pass over a socket making performance significantly slower.</p> <p>It's worth pointing out that if for a particular situation the debug information will dominate the I/O traffic, it's also possible to change a single line of code in the environment and have it establish a remote connection to a kernel running inside the debugger (thus recreating the 8.5 relationship between debugger and simulation).</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#customizing-the-debugger","title":"Customizing the Debugger","text":"","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#layouts","title":"Layouts","text":"<p>A particular arrangement of windows within the debugger is referred to as a layout. The Layout menu allows you to select from two basic window layouts based around a text trace window or a tree trace window.</p> <p>You can also create your own preferred window layout. To start this process, right click on a window in the debugger. The context menu will either look like this:</p> Screenshot of the debugger's Window context menu <p>Or it will offer this menu as a \"Window\" pop out on the context menu like this:</p> Screenshot of the debugger's Window context menu as a child of another context menu <p>This window menu allows you to customize the collection of windows by adding, removing or replacing windows. The types of windows you can add is based on the list of modules loaded into the debugger and should grow in time. Right now there are just five:</p> Screenshot of \"Select a New Window\" dialog <p>Creating a new layout can take a while as we don't yet have a \"Move Window\" option. This is something to be added in the future. Once you've created a new layout it will be saved automatically as your layout for the future (technically it's the layout of the last frame window closed if you're using multiple agent windows).</p> <p>You can also share window layouts that you find useful by saving the layout file (a DLF file) or loading other layout files. This is offered through both the File menu and the Layout menu.</p> <p>These DLF files are pretty simple XML files, so it's sometimes easier to adjust the layout by just editing this file directly (e.g. to move windows around in the display).</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#properties","title":"Properties","text":"<p>The window right-click menu from above includes a \"Properties...\" item which allows you to bring up a dialog and adjust certain properties for a particular window.</p> <p>For instance, right clicking and choosing \"Properties\" for one of the automatically updating windows (top right in the default layout) brings up these properties:</p> Screnshot of window properties dialog <p>By adjusting these properties you can allow the results to collect in the window rather than being cleared each time a command is executed or you can have a window that updates every 10th decision during a run rather than just at the end of a run.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#known-limitations","title":"Known Limitations","text":"<p>Also the modules we've so far implemented are all fairly basic -- with simple text entry of commands and text displays of the output.</p> <p>The great saving grace of this debugger is that if you know Java and want to spend a little time, you can write your own module to add to the framework and build the debugger you wished you had. If you find yourself wanting to do this, please drop us a line (soar-sml-list@umich.edu) before you start coding and we'll help you along and hopefully share in the results.</p> <p>If you run Soar from within the debugger for long periods of time (i.e. tens of thousands of decision cycles), you may notice that memory usage grows over time. In fact, eventually, Soar will start running very slowly and then not at all. This is because the Java virtual machine is running out of heap memory. The increasing memory usage is actually because of a very old Soar kernel bug. As a workaround, you can tell Java to allow more memory to be used by using the <code>--Xmx</code> command line switch for Java. For example, to tell Java to use up to 256 megabytes for the heap, you would would add a <code>--Xmx256m</code> parameter. This parameter should be added after the <code>java</code> command in the <code>SoarJavaDebugger.sh</code> or after the <code>javaw</code> command in the <code>SoarJavaDebugger.bat</code> file shipped with Soar.</p> <p>This and other <code>--X</code> options are non-standard and may not exist on non-Sun JVMs.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#design-principles","title":"Design Principles","text":"<p>The central design principles for the Soar debugger in Java are:</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#1-plug-in-architecture","title":"1. Plug-in architecture","text":"<p>Each window within the debugger is designed as a separate module, with control over its own user interface and its own methods for accepting commands from a user, submitting those to Soar and receiving the results. The intention is that the list of modules will grow over time and that the user community will (in time) be able to develop and submit their own modules, extending the capability of the debugger in ways they deem important.</p> <p>For example, if you were working on learning you might find a module that displays a tree of information showing all of the working memory elements that were tested in creating a chunk very helpful. By creating this as a module within the debugger you would be provided with substantial support (e.g. methods for sending commands to Soar and listening to events Soar generates\u2014such as notification when a new chunk was formed) and the new module could then be shared with all other developers increasing the overall power of the debugger.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#2-user-configurable","title":"2. User configurable","text":"<p>There's a basic tension in designing a debugger for a diverse user community (such as the Soar community) in that many users have very different needs from a debugger. When a new feature is added some rejoice at the new capability and others curse at the performance hit or the loss of screen real estate to a feature they don't care about. To alleviate this problem this debugger has been designed from the start to be highly configurable. Windows can be added or removed at will from the display and the behavior of individual windows can be adjusted through properties.</p> <p>This allows us as a community to build the new modules (described just above) without concern for whether they are of universal appeal as each user is free to include a given module (window) in their debugger or not as they please.</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#performance-comparison","title":"Performance Comparison","text":"<p>A key concern with any debugger is how fast is it? In the initial release of the debugger we're offering two main forms of \"trace\" window---one based around a simple text display and the other based around a structured tree display. We compared the performance of these two different forms of window to the performance of the TSI debugger included with 8.5.2 on the towers of Hanoi task.</p> <p>Method is to maximize each window then use <code>time {run x}</code> in TSI or <code>time run x</code> in Java Debugger to time each run. Obviously, times could vary from run to run, but in practice the variance is usually small. Maximizing the windows ensures that scrolling effort is similar.</p> <p>These are the timing results:</p> TSI (8.5.2) Java Debugger (Tree View) Java Debugger (Text View) Watch 0 (run to completion) 15.51s 7.828s 8.047s Watch 1 (run 100 dc) 1.25s 0.75s 0.734s Watch 5 (run 100 dc) 59.68s 1.51s (0.579 with full filtering) 2.141s <p>Watch 0 of TOH still generates output (write commands in productions).</p> <p>So the conclusions are that the Tree and Text view in the Java debugger run at about the same speed. The tree view can actually run a bit faster on a high watch trace because it's not displaying all of the text at the moment it is created. (The base watch 5 times assume the trace is displayed as a collapsed tree with the full-filtering value showing the performance if the user initially filters out all of the display -- filtering will be explained more later on). Also, running at watch 5 is no longer vastly slower than running at watch 1 (for this Towers of Hanoi task).</p> <p>The other observation is that the new debugger is substantially faster than the previous version (sometimes order of magnitude faster), especially when tracing at high watch levels. (The reason we can go faster even while doing more work is that we have optimized the path for generating trace output).</p>","tags":["debugger","agent debugging"]},{"location":"tutorials/IntroSoarDebugger/#related","title":"Related","text":"<ul> <li>Command line options</li> <li>Tutorial 1</li> </ul>","tags":["debugger","agent debugging"]},{"location":"tutorials/soar_tutorial/","title":"Soar Tutorial","text":"<ul> <li>Part I: Simple Soar Programs</li> <li>Part II Simple External Interaction</li> <li>Part III Subgoals</li> <li>Part IV More Simple Problem Solving</li> <li>Part V Planning and Learning</li> <li>Part VI Reinforcement Learning</li> <li>Part VII Semantic Memory</li> <li>Part VIII Episodic Memory</li> </ul> <p>Additional Files:</p> <ul> <li>Tank Eaters Config</li> </ul>"},{"location":"tutorials/soar_tutorial/01/","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/01/#part-i-simple-soar-programs","title":"Part I: Simple Soar Programs","text":"<p>Throughout this tutorial, you will be writing and running Soar programs for simple tasks. In this part, you will be writing simple programs that do not use Soar subgoaling or chunking mechanisms.</p>"},{"location":"tutorials/soar_tutorial/01/#installing-soar","title":"Installing Soar","text":"<p>Before reading further in the tutorial, you should install Soar and its associated software on your computer so that you can run the examples and exercises. Using your favorite browser, visit the Soar tutorial downloads page which you can find off the following link: https://soar.eecs.umich.edu/articles/downloads/soar-suite. Follow the directions on that page for installation. This will allow you to install three downloads that include with the most recent release of Soar, the Soar Debugger, the Eaters game, the TankSoar game, and VisualSoar.</p>"},{"location":"tutorials/soar_tutorial/01/#building-a-simple-soar-agent-using-rules","title":"Building a Simple Soar Agent Using Rules","text":"<p>All of the knowledge in a Soar agent is represented as if-then rules. In Soar, rules are called productions, and we will use the terms interchangeably. Rules are used to select and apply things called operators, and much of this tutorial will be describing how rules and operators fit together. But before we get to operators, we are going to learn about writing rules for a very simple agent \u2013 one that just prints \u201cHello World.\u201d Before we dive into rules, you will need to start up Soar so that we can run the programs you write.</p>"},{"location":"tutorials/soar_tutorial/01/#creating-a-soar-agent-and-using-the-soar-debugger","title":"Creating a Soar Agent and Using the Soar Debugger","text":"<p>To start Soar, double click (or whatever is appropriate on your platform) on the Soar Debugger script in the folder where you installed Soar. After Soar has started, you will have a new window on your screen. This window is the Soar Debugger, which is shown below. This program will be used to run all of your Soar programs. Your version may look somewhat different, depending on the features added since this document was written.</p> The Soar Debugger <p>The large window to the left is called the Interaction window (above). During Soar execution, all debugging information and print statements will be displayed in the Interaction window. Just below the interaction window is the Command Box for typing in user commands. The windows on the right display information that you will find useful later.</p> <p>When the Soar Debugger starts, a default agent entitled \u2018soar1\u2019 is created. The name of the agent can be seen on the title bar. The bottom of the window contains buttons for single stepping, running, or stopping an agent. When it is time to run your Soar programs, commands can either be entered by typing them into the command box, or by clicking the buttons</p> Debugger Command Interface"},{"location":"tutorials/soar_tutorial/01/#hello-world-rule-english","title":"Hello-World Rule: English","text":"<p>The first Soar agent we will examine prints \u201cHello World\u201d. In general, an operator should perform this type of activity, but in order to ease you slowly into Soar, we start with a single rule. Below is a simple rule written in English.</p> <pre><code>hello-world:\nIf I exist, then write \u201cHello World\u201d and halt.\n</code></pre> <p>Soar cannot directly interpret English, so you must write rules in Soar\u2019s very stylized and precise language. A major component of the rest of this tutorial is teaching you that language.</p> <p>Soar works by testing the \u201dif\u201d parts of rules (\u201cIf I exist\u201d). These \u201dif\u201d parts are called conditions. If all of the conditions of a rule are true in the current situation, the \u201dthen\u201d parts, or actions, of the rule (\u201cwrite \u2018Hello World\u2019 and halt\u201d) are executed, which usually involves making changes to working memory, which holds all of the dynamic data structures in a Soar program. Executing the actions of a rule is called firing the rule. To determine if the conditions are true, Soar compares them to data structures in working memory. Working memory defines the current situation, which for an agent consists of its perception of its world, results of intermediate calculations, active goals, and operators.</p> <p>The figure below shows a high level view of Soar. On the right are all of the underlying architectural processes that select operators, create states, learn new rules, etc. These are all written in C and you will not be changing them at all (so don\u2019t worry if you don\u2019t know C). In the upper center is the rule memory, which contains all of the rules. Rules encode the long-term knowledge in Soar and adding them is the way Soar is programmed \u2013 you do not change the way Soar creates states or learns, but you create rules. Working memory is where short-term information is stored and your rules will create and test structures in working memory. In contrast to C or Java, which have programs that are executed sequentially, Soar has rules that are matched and executed in parallel. C and Java have data structures, variables, etc. while Soar has working memory. While these other languages have a combination of local and global data, Soar has no local data \u2013 everything in working memory is global. Working memory consists of a graph structure of individual elements. The elements are created by rules as well as from sensors (not shown in the diagram), and the Soar architecture creates a limited set of working memory elements (the core part of states) automatically. Working memory is matched against rule memory to determine which rules will fire. When rules fire, they can make changes to working memory, as well as performing simple actions such as printing messages in the interaction window.</p>"},{"location":"tutorials/soar_tutorial/01/#loading-and-running-hello-world","title":"Loading and Running Hello-World","text":"<p>Before going through the nitty-gritty of Soar syntax, let\u2019s see an example of Soar executing the hello-world rule. In order to execute the hello-world rule, it must be loaded from a file into Soar\u2019s rule memory. You can load in the rules from a file via the Interaction window by either clicking the \u201csource\u201d button or by using the File menu at the top left (you can also type the source command directly into the interaction window, but for that you need to know the path to the file).</p> <p>To use the File menu, click on the toolbar as shown in the figure below.</p> <p>The following menu will pop up; select Load source file\u2026</p> <p>Alternatively, click on the \u201csource\u201d button at the bottom of the interaction window. In both cases, a menu to select the file will pop up, such as below (your menu might have a different set of files available). You can navigate in this menu to get to the correct directory (<code>&lt;soardir&gt;/Agents/</code>) and then select the file you want to load (hello-world-rule.soar).</p> <p>When rules are loaded into Soar, an \u201c*\u201d is printed for each rule. When the file has loaded, you will see the word \u201csource\u201d followed by the location of the file in the interaction window,</p> <p>At this point you can type run, or click on the run button in the bottom left of the interaction window. The first thing that happens is that Soar automatically creates the initial state, S1 (but this is not shown in the interaction window, but is shown in the window on the right where the state S1 is printed). All of working memory is organized as states, so even before any rules fire, a state is created. After the state is created the rule matches (details explained later) and it fires, performing its actions, printing \u201cHello World\u201d and then halting.</p>"},{"location":"tutorials/soar_tutorial/01/#hello-world-rule-soar","title":"Hello-World Rule: Soar","text":"<p>As stated earlier, Soar has a stylized and precise language for writing rules. Here is the Soar rule for hello-world.</p> <pre><code>sp {hello-world\n(state &lt;s&gt; ^type state)\n--&gt;\n(write |Hello World|)\n(halt)}\n</code></pre> <p>Every rule starts with the symbol \u201csp\u201d, which stands for \u201cSoar production.\u201d The remainder of the rule body is enclosed in curly braces: \u201c{\u201c and \u201c}\u201d. The body consists of the rule name, followed by one or more conditions (the \u201cif\u201d part), then the symbol \u201c--&gt;\u201c, and then one or more actions (the \u201cthen\u201d part). Below is a template for rules:</p> <pre><code>sp {rule\\*name\n(condition)\n(condition)\n\n\u2026\n--&gt;\n(action)\n(action)\n\n\u2026}\n</code></pre> <p>The name of the rule can be any arbitrary combination of letters, numbers, dashes (\u201c-\u201c), and asterisks (\u201c*\u201d). The one exception is that a name cannot be a single letter followed by a number such as S1 or O45. Soar reserves those names for its own purposes. The specific name is irrelevant to the operation of the rule, but you should always pick a name that is meaningful. Following the name, there must be at least one condition. A condition tests for the existence (or absence) of data in working memory. If all of the conditions match, then the rule will fire and all of the actions are performed. Most actions create new working memory elements or remove existing working memory elements. Some actions create preferences for selecting operators (more on that later), while others perform functions such as writing text to the screen or halting as in hello-world.</p> <p>In the next several sections we will explore the structure of conditions and actions and explain what all of the special symbols, such as <code>&lt;s&gt;</code> and ^type, mean. Before doing that, we need to first look at the structure of working memory in more detail.</p>"},{"location":"tutorials/soar_tutorial/01/#working-memory","title":"Working Memory","text":"<p>Working memory contains all of a Soar agent\u2019s dynamic information about its world and its internal reasoning. It contains sensor data, intermediate calculations, current operators and goals. In Soar, all of working memory is organized as graph structures in states. Thus, every working memory element is connected directly or indirectly to a state symbol. For the first agents you will build, there will be a single state. Below is a simple example of what the structure of working memory might be like if the agent were representing that there were two blocks, one on top of the other, which is then on a table as shown in the figure below.</p> <p>Below is a graphic picture of the working memory structures that Soar creates automatically for every agent \u2013 so although not shown in the above figure, S1 would have these additional structures.</p> <p>As a graph, there are nodes (or vertices) and links (or edges). The nodes, such as S1, B1, B2, A, and blue, are connected by links, such as block, table, name, color, and superstate. Soar has two kinds of nodes: identifiers and constants. The nodes that can have links emanating from them (they are non-terminal nodes), such as S1 and B1, are called identifiers, while the others (they are terminal nodes), such as state, blue, block, and nil, are called constants.</p> <p>In the example above, S1 is the identifier for the state. All of the identifiers symbols are created automatically by Soar and consist of a single letter followed by a number. Although I2 and I3 in the lower figure do not have any links emanating from them, they are identifiers and can have additional substructures added later. In contrast, the symbol state is not an identifier and cannot have links emanating from it. The links are called attributes in Soar and are prefaced by a \u201c^\u201d. Only identifiers have attributes. In the bottom figure, S1 has three attributes: superstate, io, and type. I1 has two: output-link and input-link.</p> <p>Working memory is actually built of individual elements which are triples of an identifier, an attribute, and value, and where the value is that node pointed to by the attribute. The value can be either a constant or an identifier. In the example above, the symbols nil, I1, state, I2, and I3 are all values. It is these triples that you add and delete when writing Soar programs.</p> <p>There are five working memory elements in the figure above:</p> <pre><code>S1 ^superstate nil\nS1 ^io I1\nS1 ^type state\nI1 ^output-link I2\nI1 ^input-link I3\n</code></pre> <p>This is the minimal contents of working memory, and as your programs get larger and more complex, they will manipulate many more working memory elements.</p> <p>A collection of working memory elements that share the same first identifier is called an object. For example, the three working memory elements that have S1 as their identifier are all part of the state object. The working memory elements that make up an object are called augmentations. Although we call them objects, they consist of the individual working memory elements that share the same identifier. Objects are usually written as a list of the augmentations surrounded by parentheses. The first item in the list is the identifier that is shared by all of the augmentations, followed by the pairs of attributes and values for each augmentation. The objects for the above working memory elements are:</p> <pre><code>(S1 ^io I1 ^superstate nil ^type state)\n(I1 ^input-link I3 ^output-link I2)\n</code></pre> <p>An individual augmentation can also be written in this form: <code>(S1 ^type state)</code></p> <p>A working memory object usually represents something about the world, such as a block, a wall, a piece of food, or a cell on the board. The individual augmentations represent properties (such as color, size, or weight), or relations with other objects (such as on top of, behind, or inside).</p> <p>Soar can be used for many different tasks, and for each different task, working memory will contain descriptions of the task objects. The working memory elements for the blocks would be as follows:</p> <p>Working memory usually also contains objects that are only conceptual things and do not have an identifiable physical existence, such as state s1, which organizes other objects, relations, and properties. The exact representation of objects is up to you, the designer of a Soar program.</p> <p>Soar does not require any declarations of the possible attributes and constants. In fact, some Soar programs generate new attributes and constant values as they execute. The Soar editing and development tool, VisualSoar, does require declarations for the structure of working memory elements, and those declarations are used to check for errors in your rules but they are not used by Soar when it is executing a program.</p>"},{"location":"tutorials/soar_tutorial/01/#hello-world-rule-soar-details","title":"Hello-World Rule: Soar Details","text":"<p>You now know enough to return to the first example rule. The original English version included the test</p> <p>\u201cIf I exist\u201d</p> <p>Remember that when every Soar agent is created, it has <code>(s1 ^type state)</code> in working memory, which signifies in someway that the agent does exist. Thus, you can test for the presence of that structure in working memory to determine if the agent exists. The obvious condition to write would be <code>(s1 ^type state)</code>. However, s1 is just an arbitrary symbol and might not be the identifier of that state every time the agent is run.[1] Thus, we need a test that there is an identifier, but without testing a specific value. That is exactly what a variable does \u2013 it matches any symbol in working memory with the only constraint being that all occurrences of the same variable in a rule match the same symbol. A variable can match an identifier, an attribute, or a value, depending on its position in a condition - if it is first in a condition it will match the identifier, second the attribute, and third the value. A variable is a symbol surrounded by <code>&lt;</code> and <code>&gt;</code>, such as <code>&lt;s&gt;</code>. The exact symbol used in the variable (such as \u201cs\u201d) is irrelevant but should be picked to be meaningful to you.</p> <p>Putting these pieces together gives: <code>(&lt;s&gt; ^type state)</code>. That is almost correct, but in Soar, every rule must start by matching a structure in a state, and to remind you of this, the first condition of every rule must start with the word \u201cstate\u201d.</p> <pre><code>sp {hello-world\n(state &lt;s&gt; ^type state)\n--&gt;\n(write |Hello World|)\n(halt)}\n</code></pre> <p>The original text for the rule\u2019s actions was: then write \u201cHello World\u201d and halt.</p> <p>The rule\u2019s first action prints \u201cHello World\u201d in the Interaction window. Vertical bars, \u201c|\u201d, mark constants with special characters. These constants can contain any characters, which allows you to print spaces, upper and lower-case letters. The second action is a special command in Soar that halts the agent. From this simple example, you should be able to write your own rules that print out different messages for Soar.</p> <p>If you wish to try this out yourself, you have two choices. The first is to use VisualSoar. VisualSoar is the Soar development environment and it lets you develop and manage Soar programs. It has its own documentation and tutorial and can be found at the Soar web pages. Also, the Water-Jug problem that is presented later in this tutorial contains an explanation of how to use VisualSoar. Although it will initially slow you down to learn VisualSoar, it will be worth it in the long run.</p> <p>If you want to use a text editor, almost any will do, such as Word, WordPerfect, Wordpad, Notepad, or Emacs. In this editor, create a new file hello-world.soar in your new folder/directory. Make sure the file ends in \u201c.soar\u201d. This may be difficult to do in Wordpad or Notepad, which automatically add \u201c.txt\u201d to the end of a file, but this will be important for the Eaters and Tanksoar tasks. If you are having trouble with this in Windows, go to the Settings item off the Start menu. Select Folder Options and the pick the File Type tab. Select \"New Type\u2026\" and in the pop-up window define the soar type. You need to fill in \"soar\" (without quotes) under the \"Associated extension\" and select \"text/plain\" under \"Content Type.\" Whenever you save the file, make sure you save it as a text file with linefeeds. Soar cannot handle formatted text and text without linefeeds.</p>"},{"location":"tutorials/soar_tutorial/01/#building-simple-agents-using-operators","title":"Building Simple Agents Using Operators","text":"<p>In this section, you will learn how to use rules to select and apply operators. Operators perform actions, either in the world or internally in the \u201cmind\u201d of an agent. In the Water Jug problem, they \u201cpour\u201d water between jugs in the mind of the agent. In Eaters, the operators will create commands to move the eater around the board. There could also be operators to remember uneaten food, count food, or remember where walls are that only make changes to the working memory of the Eater. Operators in a Tic Tac Toe program would mark X\u2019s or O\u2019s on the board. Operators for a soccer program would probably include move, turn, kick the ball, send messages to teammates, interpret messages from teammates, choose a tactic or strategy, and so on.</p> <p>Because operators perform actions, they are the locus of decision making. They are where knowledge is used to decide what to do (or not to do). Thus, Soar\u2019s basic operation is a cycle in which operators are continually proposed, selected, and applied. Rules fire to propose and apply operators, while the decision procedure selects the current operator. This may seem restrictive; however, it forces you to separate out where decisions are being made (proposal and selection) and where actions are being performed (application).</p> <p>For Soar to use operators, they must first be created in working memory by proposal rules. Proposal rules test features of the state to ensure that the operator is appropriate and then they create a representation of the operator in working memory along with an acceptable preference for that operator. The preference is a way of telling the architecture that this operator is a candidate for selection. For simple operators, the representation in working memory is often just a name of the operator. For example, in section 3.1 we will create an operator to print \u201cHello World\u201d and that operator will just have the name hello-world in working memory. More complex operators can also contain representations of parameters. For example, when we encode the water jug problem in Soar, one operator will fill a jug with water and it will have a parameter as to which jug should be filled. At an extreme, the representation of an operator can specify exactly which changes should be made to working memory when it is applied.</p> <p>Once the operator is selected, rules that apply the operator will match and perform whatever actions are appropriate by creating or removing working memory elements. If the chosen operator is represented in working memory as just a name, rules that explicitly test that name will be required to apply that operator. If the operator already includes a representation of what changes need to be made, then very general rules can be used to apply the operator that can also be used with other operators. Thus, working memory acts as an intermediary for actions by being the place where alternative operators are proposed, one is selected, and then rules apply the operator by making changes to the state.</p>"},{"location":"tutorials/soar_tutorial/01/#hello-world-operator-english-version","title":"Hello World Operator: English Version","text":"<p>To demonstrate a very simple operator, you will now write an operator instead of a single rule to print \u201cHello World\u201d. Operators allow you to have an action considered in multiple situations (rules that propose the operator), allow multiple reasons for selecting an action (rules for selecting operators), and allow multiple ways for doing it (rules that apply the operator). For printing \u201cHello World\u201d, an operator is not necessary because there are no alternatives, but as soon as other actions are possible and choices must be made, operators become necessary.</p> <p>To use an operator, we need two rules: one to propose the operator and one to apply it:</p> <pre><code>Propose*hello-world:\nIf I exist, propose the hello-world operator.\n\nApply*hello-world:\nIf the hello-world operator is selected, write \u201cHello World\u201d and halt.\n</code></pre> <p>The first rule proposes the hello-world operator, and the second performs its actions after the operator has been selected. Notice that the first rule only proposes the hello-world operator. As described earlier, an operator is selected by Soar\u2019s decision procedure, which collects together proposed operators and selects one.</p> <p>To see this operator run, you can either create a new agent and then destroy your previous agent (this is done on the same pull down menu that was used to create an agent), or you can remove all of the existing rules in your agent by using the \u201cexcise --all\u201d command, which removes all of the rules from memory and initializes Soar. Next, load in the hello-world-operator file using source. To see the individual productions fire, you can modify the \u201cwatch\u201d level. There are many different watch levels: and watch level 3 (and higher) includes traces of production firings. Go ahead and set the highest level: watch 5. You can use the \u201cWatch 5\u201d button at the bottom of the interaction window or use the Debug Level entry in the menu bar at the top. Then click the run button.</p> <p>The interaction window allows you to trace the execution of Soar at many different levels (decisions, phases, production firings, working memory changes), but selectively view the trace by expanding and collapsing the trace (using the \u201c+\u201d and \u201c-\u201d items on the left of the trace) and setting filters. Make sure you have the \u201ctree view,\u201d which is set under the layout tab in the top tool bar. A standard practice is to do a full trace (Watch 5), but only view decisions by collapsing the trace. If an error arises, or you want to look at the behavior in more detail, you can expand the trace. The button at the lower right corner of the interaction window allows you to toggle between \u201ccollapse\u201d and \u201cexpand\u201d easily. You can then control the level of the trace by using the \u201cfilters\u201d button that is next to the collapse/expand button. This allows you to view the trace at a high level and only dive into the details when necessary.</p> <p>After typing run, expand the \u201crun\u201d and \u201c1: O: O1 (hello-world)\u201d lines by clicking on the \u201c+\u201d signs next to them. The trace shows that proposehello-world fires first to propose the operator. The operator hello-world (O1) is then selected (by the decision procedure). After hello-world is selected, applyhello-world fires and performs the actions of the operator by printing out \u201cHello World\u201d and halting.</p>"},{"location":"tutorials/soar_tutorial/01/#hello-world-operator-soar-version","title":"Hello-World Operator: Soar Version","text":"<p>In this case, there is a one-to-one mapping of the English rules to Soar rules. The condition of <code>propose*hello-world</code> is the same as the condition for the original hello-world rule. The difference is in the action, where <code>propose*hello-world</code> proposes the hello-world operator. A rule proposes an operator by creating an acceptable preference for the operator. An acceptable preference is a statement that an operator is as a candidate for selection. The rule below proposes the hello-world operator:</p> <pre><code>sp {propose*hello-world\n(state &lt;s&gt; ^type state)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name hello-world)}\n</code></pre> <p>The first action creates an acceptable preference for a new operator (which is added to working memory) and the second action creates a working memory element that augments the operator with its name.</p> <p>A preference looks just like other working memory elements except that it has a fourth item: the type of preference, which in this case is \u201c+\u201d. The identifier of the preference is <code>&lt;s&gt;</code>, which means that the identifier matched to <code>&lt;s&gt;</code> in the condition is used in creating the action. For example, if working memory contained <code>(s1 ^type state)</code>, then when this rule fired the preference would begin with (<code>s1 ^operator</code>. The value of the preference, <code>&lt;o&gt;</code>, is a new variable that did not occur in the condition. When new variables appear in actions, Soar automatically creates a new identifier and uses it for all occurrences of that variable in the action. For example, if o1 is the identifier created for <code>&lt;o&gt;</code>, then <code>(s1 ^operator o1 +)</code> and <code>(o1 ^name hello-world)</code> are added to working memory. For variables in actions, such as <code>&lt;o&gt;</code>, a different identifier is created each time a rule fires.</p> <p>Additional rules may create preferences to compare operators. The decision procedure selects an operator based on all the created preferences. If a single operator is proposed, that operator is selected. In this case, <code>propose*hello-world</code> fires creating a single acceptable preference for o1, and then the decision procedure selects o1 to be the current operator and adds <code>(s1 ^operator o1)</code> to working memory. Note that this working memory augmentation does not have the \u201c+\u201d following the value. Only the decision procedure can add such an operator augmentation for a state to working memory (while proposal rules can add acceptable preferences for operators that differ by ending with the \u201c+\u201d).</p> <p>Once the operator is selected, <code>apply*hello-world</code> should fire.</p> <pre><code>sp {apply*hello-world\n  (state &lt;s&gt; ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name hello-world)\n--&gt;\n  (write |Hello World|)\n  (halt)}\n</code></pre> <p>This rule has exactly the same actions as <code>hello*world</code>, but with conditions that test that the operator hello-world has been selected. The first condition tests that some operator has been selected. We cannot include a specific identifier for the value (such as o1) because the exact value of the identifier can be different each time we run the program, so a variable, in this case , is used. <p>The second condition tests that some object in working memory has name hello-world. The rule will only match if both <code>&lt;o&gt;</code>\u2019s match the same identifier (such as o1). This is true for all variables in Soar; if the same variable shows up multiple times in the conditions of a rule, the rule will not match (and fire) unless all occurrences of the variable in the rule match the same symbol in working memory. In this case, they both match o1, and this rule fires.</p> <p>If the same variable is used in multiple rules, it can match completely different identifiers or constants \u2013 that is, the identity of variables only matters within a rule. The exact symbols used in a variable are irrelevant, although as a general convention, <code>&lt;s&gt;</code> is usually used to match state identifiers and <code>&lt;o&gt;</code> is usually used to match operator identifiers.</p>"},{"location":"tutorials/soar_tutorial/01/#examining-working-memory","title":"Examining Working Memory","text":"<p>We can get an even more detailed look at Soar\u2019s processing by examining the data structures in working memory. You can print out working memory in the Interaction Window using the print command. To print out all of the attributes and values that have s1 as the identifier, first click in command box below the interaction window, and type <code>print s1</code> followed by the \u201cEnter\u201d key. The debugger also has additional windows to the right of the Interaction Window that display common structures, such as the current state, the current operator, etc. The topmost window on the right should already show the state. This window has tabs for examining different structures in working memory. You can modify the command in these windows by typing in a new command (such as replacing \u201cprint s1\u201d with \u201cprint s1 \u2013d 2\u201d), or you can add new tabs or create a new window that executes different commands. You do this by right clicking on a blank part of the window, and a menu will appear that let\u2019s you create a new window or a new tab.</p> <p>You now see all of the attributes and values that have S1 as their identifier. The attributes io, superstate, and type are created automatically for the state before the program starts to run. The operator attribute is created when the hello-world operator (o1) is selected. Only the selected operator has a working memory element without the following \u201c+\u201d. In addition to the selected operator, the acceptable preference for the operator is there, marked with the \"+\". If there were additional operators proposed with acceptable preferences, there would be additional working memory elements with the operator attribute with the ids of the operators followed by the \u201c+\u201d, but for a given state there is only one working memory element with the operator attribute without the \u201c+\u201d, which signifies the selected operator. The attributes are ordered alphabetically when they are printed, but that is just to make it easier to find a specific attribute.</p> <p>We can examine more of the structure of o1 using the print command. This time, select the operator tab or type <code>p o1</code>. The letter p means \u201cprint.\u201d Almost all commands in Soar also have one or two-character shortcuts.</p> <p>Operator o1 has an augmentation with attribute name and value hello-world. We can also examine the augmentations of some of the other values. I1 is the value of the ^io attribute, which stands for input-output. To see more about input and output, print I1. However, instead of using the print or p command, you can use the mouse to print information about I1. (If you don\u2019t have a mouse, just use print.) To do this, type print s1 again as before and move the cursor over I1 in the upper right window, then press the right mouse button. A menu will appear that has a list of commands: print, preferences, WMEs, productions, and run. Move the mouse over the print command and click the left button once.</p> <p>The information for I1 now appears in the Interaction window to the left where the trace is displayed.</p> <p>There are two attributes of io: input-link and output-link. The input-link is where an agent\u2019s sensory information is available in working memory. The output-link is where action commands must be created for the agent to move in its world. Using the mouse, explore the structure of the input-link (I2). You can also try out some of the other commands available through the mouse, although we will work our way through them later in the tutorial.</p> <p>You now know the basic structure of rules and operators in Soar. You should be able to create your own agents that print out simple messages with operators.</p>"},{"location":"tutorials/soar_tutorial/01/#an-introduction-to-visualsoar","title":"An Introduction to VisualSoar","text":"<p>To create your own Soar programs, you can use almost any editor. We recommend VisualSoar because it has internal support for creating Soar programs. VisualSoar can be found in the same place that the Soar debugger was found. On launch, a fairly blank window entitled VisualSoar will pop-up. At the top, click File | New Project\u2026 and you will see a new pop-up window entitled New Agent. In the new window under Agent Name type \u201cwater-jug\u201d (without the quotes) and under Agent Path, click Browse (if you receive a \u201cno disk\u201d error, ignore it by simply clicking continue) and locate the folder to which you want to save the project to. When this is done, click New.</p> <p>You will see a new window on the left that should contain 5 things in the form of a tree. This is called the operator window. At the root is the name of your project, and the four things below it are the default files that are automatically created. The specifics of these four files will be explained as the tutorial proceeds. It is files like these that will contain the rules you write for an agent. The rules will be grouped into different files and file types depending on their function. It is from this window that you will control the way the rules are grouped together. The actual grouping of rules in VisualSoar is actually completely arbitrary to Soar but will make maintaining and debugging your code much easier for you. Due to this arbitrariness, do not feel that you can create an error by grouping your rules wrong.</p> <p>One of the toughest parts of writing Soar code is visualizing the tree-like structure of working memory. VisualSoar has a structure called the Datamap for describing working memory structure. In some ways, it is like making type definitions in other languages. To examine the Datamap, right-click on the root of the tree entitled \u2018water-jug\u2019 and click on Open Datamap in the pop-up window. Doing this displays the hierarchical structure of the working memory of your agent in the Datamap water-jug window. VisualSoar not only lets you visually construct what memory should look like, it also lets you run tests to make sure your code follows the proper structure, automatically finding spelling mistakes, misplaced structures, and so on. You can close the Datamap water-jug window by clicking on the  in its top-right corner.</p> <p>Throughout the rest of Part 1 of this manual you will write code to solve the water jug problem. Write this code into your Soar editor as you go. Once you get the hang of it, try and write the next step in the code before you look at it (make sure to double-check it with our code of course).</p>"},{"location":"tutorials/soar_tutorial/01/#creating-agents-to-solve-the-water-jug-problem","title":"Creating Agents to Solve the Water Jug Problem","text":"<p>This part of the tutorial will teach you how to build Soar programs that solve problems through internal problem solving. You will build a Soar program for a classic AI problem: The Water Jug. Other classic AI problems, including Blocks World, the Eight Puzzle, Missionaries and Cannibals, and Towers of Hanoi are included in the set of demonstration programs that comes with the Soar release. The Soar programs you develop will solve these problems through search and the manipulation of internal data structures. You will start by building the operators, state descriptions, and goal tests that are required to define the problem. You will also be introduced to more of the theory of problem solving based on search in problem spaces. In Part V, you will learn how to modify and extend to your programs so that they use planning and learning to solve problems. If you run into problems debugging your programs, you might want to skip ahead to Part II, Section 5.3, which contains details on debugging commands for Soar.</p>"},{"location":"tutorials/soar_tutorial/01/#water-jug","title":"Water Jug","text":"<p>Water Jug Problem Statement:</p> <p>You are given two empty jugs. One holds five gallons of water and the other holds three gallons. There is a well that has unlimited water that you can use to completely fill the jugs. You can also empty a jug or pour water from one jug to another. There are no marks for intermediate levels on the jugs. The goal is to fill the three-gallon jug with one gallon of water.</p> <p>The first step in formulating a problem is determining the space of possible states that the problem solver can be in. The space of states, or problem space, is determined by the objects that are available to be manipulated (the two jugs) and their possible values (0-5 gallons full). A problem is then defined as an initial state that the problem solver starts at, (in this case two empty jugs) and a set of desired states (any state where the three-gallon jug has one gallon of water). Problem solving consists of starting at the initial state, then searching for a desired state by applying operators, which transform one state into another. For the water jug problem, the operators are fill a jug, empty a jug, and pour from one jug to the other.</p> <p>In addition to the knowledge required to formulate the problem, knowledge can be used to select which operator to apply at each state. In the water jug, you might have knowledge that specifies never emptying a jug immediately after it has been filled. In Soar, this knowledge is often called search control knowledge, because operator selection is the locus of all decision making in Soar. It is the one place where multiple alternatives can be proposed, compared and evaluated before a selection is made. An important part of Soar\u2019s design is that it makes it possible to separate all of the problem formulation knowledge from the knowledge that is used to control the search.</p> <p>At an abstract level, a trace of the problem solving starts with the creation of the initial state and is followed by the selection and application of operators. To represent the states in the water jug problem, we will have two values: the amount of water in the five gallon jug, and the amount of water in the three gallon jug. For example: 5:0,3:0 will represent that the 5 gallon container has 0 gallons of water, and the 3 gallon container has 0 gallons of water. Below is a trace of the optimal solution for the problem showing the states and the operators that are applied to each state.</p> <pre><code>(5:0,3:0) Fill 3 gallon jug\n(5:0,3:3) Pour 3 gallon jug into 5 gallon jug\n(5:3,3:0) Fill 3 gallon jug\n(5:3,3:3) Pour 3 gallon jug into 5 gallon jug\n(5:5,3:1)\n</code></pre> <p>The rest of this section will take you through all of the steps of representing the problem in Soar, including determining the representation of the states in working memory, creating the initial state, representing the operators in rules (and working memory), and so on.</p>"},{"location":"tutorials/soar_tutorial/01/#state-representation","title":"State Representation","text":"<p>For tasks that involve interaction with the outside world, much of the state structure is determined by what comes in via perception. For the water jug problem, we could hook up Soar to a water jug simulator (or real world robot) and have it issue commands to pour water into and out of jugs, but to simplify learning Soar, we will have Soar solve the problem through the manipulation of internal data structures. . Moreover, this will prepare you for planning, where your program will need to create an internal representation of the problem even if there is an external world.</p> <p>What are the parts of the problem that must be represented on the state? There are really two types of information: dynamic information that changes during problem solving, such as how much water is in each jug, and static information that doesn\u2019t change, such as the size of each jug.</p> <p>So one state representation might include:</p> <ul> <li>The amount of water each jug currently holds.</li> <li>The amount of water each jug can hold.</li> </ul> <p>You can combine these together by having the volume of the jug as an attribute with the value being the current contents. Under this scheme, the initial state would look something like:</p> <pre><code>(state &lt;s&gt; ^five-gallon-jug-contents 0\n^three-gallon-jug-contents 0)\n</code></pre> <p>This is a very compact representation; however you will have to write very specific rules for proposing and applying operators. You will need one set of rules to propose the operators for the five-gallon jug and one for the three-gallon jug.</p> <p>A more general approach would be to represent each jug as an object that had two attributes:</p> <ul> <li>The amount of water each jug currently holds (^contents).</li> <li>The amount of water each jug can hold (^volume).</li> </ul> <p>In this scheme, the initial state would look something like this.</p> <pre><code>(state &lt;s&gt; ^jug &lt;j1&gt;\n  ^jug &lt;j2&gt;)\n(&lt;j1&gt; ^volume 5\n  ^contents 0)\n(&lt;j2&gt; ^volume 3\n  ^contents 0)\n</code></pre> <p>Note that jug is an attribute that can have multiple values at the same time. We call this a multi-valued attribute. Multi-valued attributes allow you to represent sets of objects, such as the set of two jugs.</p> <p>Using this representation, you can write one set of rules for manipulating both jugs. Although this representation is sufficient for defining and solving the problem, as you will see later, the rules to propose operators can be simplified if you add an attribute for the amount of water that can be added to a jug to fill it (^empty). As you will see later, the value of this augmentation can be computed dynamically using state elaboration rules that test the volume and contents augmentations and subtract the volume from the contents. Thus, states will include the following structures:</p> <ul> <li>An object for each jug (^jug).</li> <li>The amount of water each jug can hold (^volume).</li> <li>The amount of water each jug currently holds (^contents).</li> <li>The amount of empty space available in each jug (^empty).</li> </ul> <p>Although this representation is sufficient, one more working memory structure is extremely useful: a description of the task that is being attempted, in this case water-jug. By having some description of the task, the rules we create can be specific to that task and easily combined with rules from other tasks without interference. Thus, a common Soar convention is to label the state with information about the task being attempted. The simplest approach is to have a ^name attribute, where the value is the name of the task. For some tasks, other information is useful, but this will be sufficient for the water jug task.</p> <ul> <li>The task name (^name water-jug)</li> </ul>"},{"location":"tutorials/soar_tutorial/01/#initial-state-creation-the-initialize-water-jug-operator","title":"Initial State Creation: The initialize-water-jug Operator","text":"<p>In order for Soar to start on a problem, the structures of initial state must be in working memory. For tasks involving interaction with an external environment, much of the state will be created by the perceptual information that comes in from sensors. That information would be created on the input-link structure of the state. But for this task, we are assuming there is no external environment, so the initial state must be created by rules that you add to the system.</p> <p>Thus, the first step is to define an operator that will create the initial state. By using an operator instead of a single rule, the act of initialization is a choice that can be controlled \u2013 that is, the operator to initialize the problem will be proposed and a decision will be made whether to do it. If other tasks are possible, the agent can decide which task will be attempted by using control knowledge to pick among the different initialization operators.</p> <p>The first step in creating an operator is to write down the proposal rule in English.</p> <p>Type the English versions of the proposal and application rules for the initialize-water-jug operator. These versions will be documentation, so we have to tell Soar to ignore them. You can do this by starting each line with the pound-sign (\u201c#\u201d). Soar ignores lines that start with a pound sign.</p> <p>In Soar, the name of the rule can be almost any string of characters, but it is a good idea for it to be a meaningful summary of the purpose of the rule. A useful convention is to split the name into parts separated by asterisks (\u201c*\u201d). The first part is the task, the second part is the function (propose, apply, elaborate), and the third is the name of the operator. There may be additional parts for more details of what the rule does.</p> <p>As with every operator, we must define two types of rules: one to propose the operator and one to apply the operator. This operator should be proposed only at the beginning, before any task is selected. Thus, the proposal should be:</p> <pre><code>water-jug*propose*initialize-water-jug\n</code></pre> <p>If no task is selected, then propose the initialize-water-jug operator.</p> <p>Writing this rule in Soar is a challenge given what you know so far. How can you test that no task has been selected or that no jugs are defined? In Soar it is possible to test for the absence of working memory elements by preceding the attribute with \u201c-\u201c. Every rule in Soar must have at least one positive condition, so you still need to test that the state exists and in this case we use (^superstate nil).</p> <pre><code>sp {water-jug*propose*initialize-water-jug\n  (state &lt;s&gt; ^superstate nil)\n    -(&lt;s&gt; ^name)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; +)\n  (&lt;o&gt; ^name initialize-water-jug)}\n</code></pre> <p>VisualSoar \u2013 The purpose of this production is to propose the operator that will initialize the water-jug. If you look at the operator window in VisualSoar you will see that the file at the bottom is titled \u201cinitialize-water-jug.\u201d This is created automatically when you created the water-jug project because a standard practice is to use an initialization operator for a new task. Either double-click on that file or right-click on the file and click Open Rules. This will open up a rule editor in which you will see two rules already partially written. The initialization written above is a very standard one, and because of this VisualSoar automatically creates a template of it for you (it is the first rule at the top). It may look a little different because VisualSoar uses a few shortcuts that you will learn later, feel free to leave it how it is or change it to the way it is above, it will not matter. Leave this rule window open.</p> <p>Just a reminder that the order of the conditions don\u2019t matter except that the first condition must be a positive test of the state. Thus, there is no difference between the above rule and one where the test for the absence of the jug comes before the absence of the name. Soar analyzes the rule and automatically reorders the conditions in order to improve the efficiency of matching the rules.</p> <p>The second condition will match only if there is not any working memory element on the state with attribute name. The condition does no test for a value, because it doesn\u2019t matter what the value is. You could include variables in the value position (such as ) if you wanted, and that would not change the meaning of the rule. <p>All the conditions test attributes of the same object (the state), and you can simplify the rule by combining these conditions (just as VisualSoar did) into a single structure where the identifier <code>(&lt;s&gt;)</code> is followed by the attributes:</p> <pre><code>sp {water-jug*propose*initialize-water-jug\n(state &lt;s&gt; ^type state\n\n-^name)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name initialize-water-jug)}\n</code></pre> <p>Soar automatically translates this structure into the one above.</p> <p>To apply the initialize-water-jug operator, we need another rule. The initialization application rule adds the name to the state and creates the jugs with contents of 0. The rule needs to add working memory elements for the initial values of the jugs and their attributes.</p> <pre><code>water-jug*apply*initialize-water-jug\n</code></pre> <p>If the initialize water-jug operator is selected, then create an empty 5 gallon jug and an empty 3 gallon jug.</p> <pre><code>sp {water-jug*apply*initialize-water-jug\n(state &lt;s&gt; ^operator &lt;o&gt;)\n(&lt;o&gt; ^name initialize-water-jug)\n--&gt;\n(&lt;s&gt; ^name water-jug\n^jug &lt;j1&gt;\n^jug &lt;j2&gt;)\n(&lt;j1&gt; ^volume 5\n^contents 0)\n(&lt;j2&gt; ^volume 3\n^contents 0)}\n</code></pre> <p>This rule does not include the creation of the ^empty attribute \u2013 it will be created by another rule that dynamically computes it based on the volume and contents (see Section 4.5).</p> <p>VisualSoar \u2013 In the initialize-water-jug rule window you will notice that VisualSoar has attempted to write this rule for you also. The application of initializing the water-jug is not as standard as the proposal and VisualSoar is not able to initialize all of the attributes that this project will need. Modify the second rule in the rule window to match the rule above.</p> <p>Now, at the top of VisualSoar, click on Datamap | Check All Productions Against the Datamap. In the feedback window at the bottom you will see a list of blue warnings. What you just did was make VisualSoar check all of your rules to see if they matched the Datamap for this project. Recall that the Datamap is a representation of the structure of working memory. Since you just added new augmentations to the state in your rule, but not to the Datamap, warnings are created. To fix this, right-click in the operator window on \u201cwater-jug\u201d and click on Open Datamap so that now you have the Datamap and initialize-water-jug windows open. You will notice that VisualSoar has already included the structure for the Initialize-water-jug operator \u2013 this is automatically created whenever a new operator is added to the operator set. The Datamap is a hierarchical structure that looks like folders and files as in the operator window, but it is really the structure of working memory. The folders are used to represent working memory elements (such as operator) whose values are identifiers, and thus can have substructure. The file-like structures are attributes that have constants as values \u2013 either sets of symbols (enumeration), integers, floating point numbers (floats), or strings. You must now add entries into the Datamap for the water-jug state structure.</p> <p>What you need to add to the Datamap are the jug structures that are created by initialize-water-jug and that will be used by the remaining operator. In order to add a new attribute to the Datamap, you start by right clicking on the \u201cwater-jug\u201d folder in the Datamap (not in the operator window). The water-jug folder in the Datamap represents the top-state structure in Soar. After right-clicking, a menu will appear that let\u2019s you select the type of value that will be associated with the attribute you are creating. Since the jug attribute will have an identifier as its value, select \u201cAdd Identifier \u2026\u201d</p> <p>You will then be prompted for the attribute name. Type in \u201cjug\u201d.</p> <p>This will add the jug structure to the Datamap. You can now right click on the jug structure, and select \u201cAdd Integer \u2026\u201d to add the contents attribute to the jug structure. Type in the name, and then repeat this for the empty and volume attributes. If the attribute had values that were different possible symbols, you would use the \u201cAdd Enumeration \u2026\u201d selection. Your screen should now look like this:</p> <p>Now have VisualSoar check all productions against the Datamap (using the command under the Datamap tab in the toolbar), you should have no errors. Make sure to save and feel free to close the Datamap and initialize-water-jug windows.</p> <p>In the above rule, the variable  is used to connect the first condition to the second. To simplify the writing and reading of rules, Soar allows you to combine conditions that are linked by variables. To do this, you can just string together attributes, replacing the intermediate variables with a period, \u201c.\u201d, to separate the attributes. In Soar, we call this \u201cdot\u201d or \u201cpath\u201d notation. Below is the same rule as before using dot notation. <pre><code>sp {water-jug*apply*initialize-water-jug\n  (state &lt;s&gt; ^operator.name initialize-water-jug)\n--&gt;\n  (&lt;s&gt; ^name water-jug\n    ^jug &lt;j1&gt;\n    ^jug &lt;j2&gt;)\n  (&lt;j1&gt; ^volume 5\n    ^contents 0)\n  (&lt;j2&gt; ^volume 3\n    ^contents 0)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/01/#persistence-of-working-memory-elements","title":"Persistence of Working Memory Elements","text":"<p>When the water-jugapplyinitialize-water-jug rule fires, all of the structures in its action are added to working memory. At this point, it would be desirable for the initialize-water-jug operator to be removed from working memory so that other operators can be selected. This is exactly what Soar does because the conditions of the proposal rule no longer match (the conditions testing for the absence of a task and the absence of the jug augmentation fail to match because those structures have been added to working memory). Once that rule retracts, the rule that applied the operator also no longer matches because the operator is no longer in working memory. However, we do not want the application rule to remove the structures it created when it no longer matches. If it did, the system would never be able to make any real progress \u2013 it would get in an infinite loop of proposing and applying an operator, retracting its results, and then proposing and applying the operator again.</p> <p>In order to support the different needs of different problem solving functions (in this case operator proposal and operator application), Soar makes a distinction between the persistence of working memory elements created by operator application rules and the persistence of working memory elements created by other types of rules. Operator application needs to create persistent results because operators are the deliberate commitments that the system has made \u2013 it has decided to apply the operator and make potentially non-monotonic changes to the state \u2013 to move itself to a new state in the problem space. All other rules in Soar compute the entailments/elaborations of the current state without actually changing it and should be retracted when they no longer match the current state. This is a very important feature of Soar \u2013 it makes a distinction between knowledge that modifies the current state (knowledge in operator applications), and knowledge that just computes the entailments of the current situation (including which operators should be considered for the current state).</p> <p>Soar automatically classifies rules as to whether they are part of an operator application or not. A rule is an operator application rule if it tests the selected operator and modifies the state. The working memory elements created by such a rule persist and are said to have operator-support, or o-support because they are created as part of an operator. These working memory elements can be removed by other operator applications rules (this type of removal has yet to be introduced in the tutorial), or if they become disconnected from the state (because of the removal of other working memory elements).</p> <p>For non-operator application rules, including rules that propose an operator, rules that compare operators, rules that elaborate operators, or rules that elaborate the state, the working memory elements created by the rules are removed from working memory if the rule no longer matches. These working memory elements are said to have instantiation-support or i-support \u2013 meaning they will persist only as long as the rule instantiation that created them still matches.</p> <p>We will examine the persistence of working memory elements in more detail when we create the rules for the Water Jug, but this is a fundamental and sometimes difficult part of Soar for people to learn. It differentiates Soar from most other rule-based systems that don\u2019t have rules that automatically retract their results when they no longer match and it gives Soar its own Truth-Maintenance System (TMS).</p>"},{"location":"tutorials/soar_tutorial/01/#water-jug-state-elaboration","title":"Water Jug State Elaboration","text":"<p>The initialization operator creates jugs that include the volume and content. As mentioned earlier, it will be useful for each jug to include the amount of additional water that can be added to it before it is full. Although this could be created by the initialization operator, it would have to be maintained by every operator application and that would make the operator application rules more complex. An alternative is to compute the available volume for each jug in the state with a separate rule. This rule will test the state and create a new structure on the state. This type of rule is called a state elaboration rule. State elaboration rules are ubiquitous in large Soar systems because they can create useful abstractions of combinations of other working memory elements and represent them directly on the state as a new augmentation. These new augmentations can then be tested in other rules in place of complex combinations of conditions, simplifying rules and making the structures in working memory more meaningful. A critical aspect of state elaboration rules is that they create i-supported working memory elements so that when the parts of the state they test change, they recompute their actions automatically.</p> <p>For the Water Jug problem, the state elaboration will compute the amount of empty space in a jug:</p> <pre><code>water-jug*elaborate*empty\n</code></pre> <p>If the state is named water-jug and a jug can hold volume v and currently has contents c, then add that it has v \u2013 c available (empty) space.</p> <p>The first condition that it tests is that the state is named water-jug, so that it will only apply for water-jug problems. This test will be included in all of the water jug rules. It then tests that there is a jug and adds an appropriate empty attribute. Translating the conditions of this rule to Soar is straightforward. We have to include conditions for the jug, its volume and its contents.</p> <p>The action requires adding a new attribute to the jug (thus using the same variable as matched in the condition, <code>&lt;j&gt;</code>) and then computing the value by doing some math. In Soar, all math is done using prefix notation where the math operations <code>(+, -, *, /)</code> come before the arguments, with parentheses surrounding the computation. For example, if the value was going to be the sum of <code>&lt;v&gt;</code> and <code>&lt;c&gt;</code>, you would put <code>(+ &lt;v&gt; &lt;c&gt;)</code> where the value should be (right after the <code>^empty</code> attribute). You can nest operations using additional parentheses, such as <code>(+ 2 (* &lt;v&gt; &lt;c&gt;))</code> to add 2 to the product of <code>&lt;v&gt;</code> and <code>&lt;c&gt;</code>, but for this case, nesting is not necessary. See if you can write the rule yourself before looking below:</p> <pre><code>sp {water-jug*elaborate*empty\n  (state &lt;s&gt; ^name water-jug\n    ^jug &lt;j&gt;)\n  (&lt;j&gt; ^volume &lt;v&gt;\n    ^contents &lt;c&gt;)\n--&gt;\n  (&lt;j&gt; ^empty (- &lt;v&gt; &lt;c&gt;))}\n</code></pre> <p>When the contents of a jug changes through an operator application rule, this rule will retract the old value of ^empty and fire to compute a new value.</p> <p>VisualSoar \u2013 This rule is an elaboration. VisualSoar has a folder named elaborations in the operator window to hold files for state elaborations. Right-click on this folder and click \u201cAdd a File\u2026\u201d. You will see a text box pop-up. In the Name category type \u201cempty\u201d and click OK. Expand the elaborations folder and you should see the file you just created and two default files named \u201c_all\u201d and \u201ctop-state.\u201d These files are provided for all Soar programs and have a few simple rules that are useful for tasks with substates. You should now open the \u201cempty\u201d file by double clicking on it. You can add the rule from scratch and just type it in, or you can use a template. To use a template, click on Insert Template in the toolbar and select elaborate-state. That will give you the basic structure of an elaboration rule. Just as before, check your file against the Datamap.</p>"},{"location":"tutorials/soar_tutorial/01/#water-jug-state-initialization-and-elaboration","title":"Water Jug State Initialization and Elaboration","text":"<p>At this point you should have written your initialization rule and the state elaboration rule into your Soar editor. Make sure to save this file then start up the Soar Debugger and load these rules in using the source command.</p> <p>Now set the watch level to 5 and expand the trace so you can see rules fire and the creation on working memory elements.</p> <p>As you step through the execution,</p> <ol> <li>The water-jugproposeinitialize-water-jug rule fires to propose     the initialization operator. Expand the plus sign next to 1:O: O1     (initialize-water-jug)</li> <li>The operator and the acceptable preference for it are added to     working memory: (s1 ^operator o1 +), (o1 ^name     initialize-water-jug). The \u201c+\u201d signifies that the operator is     proposed and not selected.</li> <li>The initialization operator is selected by the decision procedure.</li> </ol> <p>A working memory element is added to working memory to indicate that the operator is selected: (s1 ^operator o1). Note that the operator preference is still in working memory.</p> <ol> <li>The application operator fires and creates the jugs on the state and     the name.</li> <li>The operator proposal retracts because the condition that tests for     the absence of the name fails and the water-jugelaborateempty     rule fires twice, once for each jug, and computes the empty     augmentation for each of the jugs.</li> <li>A substate is created (ignore for now) because there are no other     rules to fire.</li> </ol> <p>Note that in number 4, <code>water-jug*elaborate*empty</code> fires twice because there are two jugs and this rule matches successfully with each jug. Each of these matches is called an instantiation. An instantiation consists of a set of working memory elements that successfully match a rule. In this case, there will be two sets of three working memory elements that are completely separate. Sometimes a rule will have multiple instantiations that share some of the same working memory elements, while in other cases such as this one, they are all different.</p> <p>Given that there are two instantiations, which one should fire first? There really is no way to say that one is more important than another, and in Soar, we attempt to avoid decisions when we really don\u2019t have to make them, so in Soar, all rules that newly match fire at the same time, in parallel. Of course the Soar program is running on a serial computer (usually), so it isn\u2019t really in parallel, but for all intents and purposes, the rules fire in parallel. This is very different than most programming languages and can be confusing (and liberating) because you will find that rules fire as soon as they match.</p> <p>Below is a more complete look at Soar\u2019s basic cycle. For this problem there is no input and output, so those boxes are skipped. Starting at the left, rules fire (or retract) that elaborate the state or propose operators. There might be multiple rules firing (or retracting) in parallel, and the results of one rule firing (or retraction) might lead to additional rules firing (or retracting), and Soar continues to fire these waves of rules until there are no new firings (or retractions). Once there are no more rules to fire (or retract), quiescence is reached and the decision procedure is entered to select the operator. This approach guarantees that when a decision is made, all of the available knowledge from rules is available.</p> <p>After the operator is selected, rules that apply the operator can fire. Operator application will usually lead to firing and retracting of state elaboration and operator proposal rules and that will also happen during the operator application phase. When that phase reaches quiescence, output and then input are processed followed by the first phase described above. In tasks where there is an external environment, many operators require action in the world, and so changes to the state will appear during input. In the water jug task, all state changes happen in operator application, so that the elaborate state and propose operator phase do not lead to additional rule firings after the first time through the cycle.</p>"},{"location":"tutorials/soar_tutorial/01/#water-jug-operator-proposals","title":"Water Jug Operator Proposals","text":"<p>In the Water Jug problem, there are three operators: fill, empty, and pour. In this section we will create the rules that propose these operators. One thing Soar lets us do is separately compute when an operator can apply (proposal rules that create acceptable preferences for operators) from when it should apply (search control rules that create other types of preferences).</p> <p>Listed below with each operator are the conditions under which an operator is legal. These conditions will be the basis for the operator proposals.</p> <ul> <li>Fill a jug with water from the well, if that the jug is not full.</li> <li>Empty the water from a jug to the well, if there is water in the     jug.</li> <li>Pour water from one jug to another jug, if there is water in the     source jug and the destination jug is not full.</li> </ul> <p>Although one could attempt to fill a jug that is already full; in Soar, operators must change the state in some way so that another operator can be selected. Thus, in our formulation, filling a full jug must be disallowed. Now write English descriptions of the proposals.</p> <pre><code>water-jug*propose*fill\n</code></pre> <p>If the task is water-jug and there is a jug that is not full, then propose filling that jug.</p> <pre><code>water-jug*propose*empty\n</code></pre> <p>If the task is water-jug and there is a jug that is not empty, then propose emptying that jug.</p> <pre><code>water-jug*propose*pour\n</code></pre> <p>If the task is water-jug and there is a jug that is not full and the other jug is not empty, then propose pouring water from the second jug into the first jug.</p> <p>Each of these rules can potentially match either one of the jugs.</p> <p>In translating these rules into Soar, we need to write the tests in the conditions, but we also need to write actions that will create the operator. The hello-world and initialization operators were just a name; however, with these new operators, you want to have some parameters that specify which jugs are being filled, emptied, or poured. If you really wanted to, you could encode everything in the name of the operators, but then we would need six different operators, such as \u201cfill-jug-three\u201d or \u201cpour-jug-five-into-jug-three\u201d, and this would require separate rules to apply each of those operators. Instead, by having parameters with the operators, you can have fewer rules that apply the appropriate changes to the state. For this task, a set of operator parameters and possible labels are listed below:</p> <ul> <li>The name of the operator: <code>^name fill/empty/pour</code>.</li> <li>The jug that is being filled by the fill operator: <code>^fill-jug &lt;j&gt;</code>.</li> <li>The jug that is being emptied by the empty operator: <code>^empty-jug &lt;j&gt;</code>.</li> <li>The jug that is being poured out of by pour: <code>^empty-jug &lt;j1&gt;</code>.</li> <li>The jug being poured into by pour: <code>^fill-jug &lt;j2&gt;</code>.</li> </ul> <p>For example, with this representation, the operator representation for pouring from jug <code>&lt;j1&gt;</code> to <code>&lt;j2&gt;</code> would be:</p> <pre><code>(&lt;o&gt; ^name pour\n^empty-jug &lt;j1&gt;\n^fill-jug &lt;j2&gt;)\n</code></pre> <p>There are lots of other possibilities and it is not necessary to share the name of the parameters between the pour operators and the others.</p> <p>Now try to write the first proposal as a Soar rule for proposing fill. The only test besides the name of the state is that the jug is not full. Using what you know already, one way to write this rule is:</p> <pre><code>sp {water-jug*propose*fill\n(state &lt;s&gt; ^name water-jug\n^jug &lt;j&gt;)\n(&lt;j&gt; -^empty 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name fill\n^fill-jug &lt;j&gt;)}\n</code></pre> <p>This rule tests that jug <code>&lt;j&gt;</code> does not have an empty augmentation of 0. This is a double negative, and although correct in the context of what has been written, it is difficult to understand. An alternative is to test that the ^empty augmentation has a value greater than 0. Soar supports simple tests in conditions including greater than (&gt;), greater than or equal (&gt;=), less than (&lt;), less than or equal (&lt;=), and not equal (&lt;&gt;). The tests are associated with the value (or variable) that follows them. So an alternative way to write this rule is:</p> <pre><code>sp {water-jug*propose*fill\n(state &lt;s&gt; ^name water-jug\n^jug &lt;j&gt;)\n(&lt;j&gt; ^empty &gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name fill\n^fill-jug &lt;j&gt;)}\n</code></pre> <p>Another alternative condition would be to replace the test of empty being greater than zero with a test that the contents don\u2019t equal the volume: (<code>&lt;j&gt; ^volume &lt;v&gt; ^contents &lt;&gt; &lt;v&gt;</code>).</p> <p>One alternative that is not possible is to do some simple math in the conditions to test whether the volume minus the contents equal 0. Soar does not allow any math in conditions \u2013 you should use elaborations instead so that the math is always done in actions.</p> <p>VisualSoar \u2013 If you look in the operator window in VisualSoar, you will not see anything relating to a \u201cfill\u201d operator . You need to create a new operator file that will hold all of the rules related to fill. To do this, right-click on \u201cwater-jug\u201d in the operator window and click on \u201cAdd a Suboperator\u2026\u201d, name it \u201cfill\u201d and click OK. Open the newly created fill operator and add the rule above (using the propose operator templates).</p> <p>When finished adding the rule, open the Datamap. You will notice that an operator structure for fill has automatically been created, but you need to add empty-jug as an attribute. The value for empty-jug is an identifier, but it is really the same structure as a jug on the state. So instead of creating a new empty-jug structure from scratch, we want to create a \u201clink\u201d from empty-jug to the state jug structure. Note, we don\u2019t want a copy of the jug structure, because if the jug substructure changes, we want those changes reflected in the empty-jug structure. To create the link is the \u201ctrickiest\u201d operation in VisualSoar. First, left-click and hold (don\u2019t let up on the left-mouse button!) on the \u201cjug\u201d structure on the state. Then with drag that structure onto the fill operator structure in the Datamap. If you let up on the button now, it would move the jug structure, but we want to create a link. To do that, hold down the \u201cctrl\u201d and \u201cshift\u201d keys (usually with your left hand). This should make a new icon appear that has a little arrow (see diagram below). Then let up on the mouse button (while keeping \u201cctrl\u201d and \u201cshift\u201d down. This will create an attribute of the operator with name \u201cjug\u201d. (Note: sometimes the display of the Datamap in VisualSoar is not correctly updated. You might need to close the Datamap and reopen it for it to refresh correctly).</p> <p>At this point, you should rename the attribute. Do this by right-clicking on the attribute, and then select \u201cRename Attribute \u2026\u201d from the menu. Type in \u201cfill-jug\u201d and then click OK.</p> <p>Now try to write the proposal for emptying a jug. This requires only minimal changes to the previous rule, changing the test that a jug is not full to a test that the jug is not empty.</p> <pre><code>sp {water-jug*propose*empty\n(state &lt;s&gt; ^name water-jug\n^jug &lt;j&gt;)\n(&lt;j&gt; ^contents &gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name empty\n^empty-jug &lt;j&gt;)}\n</code></pre> <p>VisualSoar \u2013 This is very similar to before. Add a suboperator (just like \u201cfill\u201d) called \u201cempty\u201d to water-jug, type in the rule, and create the Datamap entries for it.</p> <p>Writing the third proposal for pour requires a test that one jug is not empty (so it can have water poured from it) and the other jug is not full (so water can pour into it). You might think that this is a simple combination of the tests in the previous two rules so that the rule should be:</p> <pre><code>sp {water-jug*propose*pour\\*wrong\n(state &lt;s&gt; ^name water-jug\n^jug &lt;i&gt;\n^jug &lt;j&gt;)\n(&lt;i&gt; ^contents &gt; 0)\n(&lt;j&gt; ^empty &gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name pour\n^empty-jug &lt;i&gt;\n^fill-jug &lt;j&gt;)}\n</code></pre> <p>This rule is not correct because the tests for jug <code>&lt;i&gt;</code> and jug <code>&lt;j&gt;</code> can match the same jug. That is because there is nothing in Soar that prevents different conditions from matching the same working memory element. For example, if working memory holds <code>(s1 ^jug j1)</code> <code>(j1 ^contents 3 ^empty 2 ^volume 5)</code>, this rule would create a proposal for a pour operator that would pour from jug j1 to itself because it would successfully match the conditions for both <code>&lt;j&gt;</code> and <code>&lt;i&gt;</code>. To correct this rule, the conditions must be modified so the <code>&lt;i&gt;</code> and <code>&lt;j&gt;</code> can not match the same identifier, that is, that <code>&lt;j&gt;</code> is not equal to <code>&lt;i&gt;</code>. That test in Soar is <code>&lt;&gt; &lt;i&gt;</code>. But where should that test be added in the rule? In Soar, multiple tests of a value (and multiple tests for an identifier or attribute) can be specified by surrounding all of the tests with curly brackets: { \u2026 }. In this case, we can combine the test for <code>&lt;j&gt;</code> with <code>&lt;&gt; &lt;i&gt;</code> to be <code>{&lt;j&gt; &lt;&gt; &lt;i&gt;}</code>. This demonstrates both the use of curly brackets and the use of not equals. Note that the test could also be <code>{ &lt;&gt; &lt;i&gt; &lt;j&gt; }</code> and it would mean exactly the same thing \u2013 what matches in this position cannot equal <code>&lt;i&gt;</code> and must equal <code>&lt;j&gt;</code>.</p> <pre><code>sp {water-jug*propose*pour\n(state &lt;s&gt; ^name water-jug\n^jug &lt;i&gt;\n^jug { &lt;j&gt; &lt;&gt; &lt;i&gt; })\n(&lt;i&gt; ^contents &gt; 0)\n(&lt;j&gt; ^empty &gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name pour\n^empty-jug &lt;i&gt;\n^fill-jug &lt;j&gt;)}\n</code></pre> <p>VisualSoar \u2013 Once again this is very similar to before. Add a suboperator (just like \u201cfill\u201d) called \u201cpour\u201d to water-jug, type in the rule, and add the Datamap entries for it.</p> <p>Now that you have all of the proposals written, you can load them in with your other rules. What happens when you run them? You will see that only <code>water-jug*propose*fill</code> matches in the initial state. It fires twice since it matches both jugs, right after ^empty is added to each jug. What happens next? When Soar does not have enough knowledge to select between the two operators, it has a tie impasse and it automatically creates a substate where it can do reflective problem solving to decide what to do next. We will cover substates in a later section. For now, we just want Soar to select randomly between these operators. You can tell Soar that it doesn\u2019t matter which operator is selected by creating an indifferent preference, using \u201c=\u201d for the operator. This can be created in the same rule that proposes the operator.</p> <pre><code>sp {water-jug*propose*fill\n(state &lt;s&gt; ^name water-jug\n^jug &lt;j&gt;)\n(&lt;j&gt; ^empty &gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +\n^operator &lt;o&gt; =)\n(&lt;o&gt; ^name fill\n^fill-jug &lt;j&gt;)}\n</code></pre> <p>The two actions for <code>^operator</code> can be shortened by using just: <code>(&lt;s&gt; ^operator &lt;o&gt; + =)</code></p> <p>which means create an acceptable and indifferent preference (you always need the acceptable preference, even if there are other preferences created). You should modify all of the operator proposals to include the = preference.</p>"},{"location":"tutorials/soar_tutorial/01/#operator-application","title":"Operator Application","text":"<p>The next step is to write the operator application rules that will fire once an operator is selected. In the Water Jug problem, your rules apply operators by adding and removing working memory elements to reflect the pouring of the water.</p> <p>What keeps the operator application productions from applying over and over again? When the operator rules apply, they change the part of the state either directly (through rules that change working memory) or indirectly (by doing some action in the world that changes what the Soar agent perceives \u2013 more on that in later sections). These changes will cause the acceptable preference for the selected operator to retract because at least one of the working memory elements that matched the proposal rule changed. The changes to working memory will cause new matches of proposal rules, which will be followed by the selection of a new operator, its application, and so on.</p> <p>Given the state representation used in this problem, there are two different ways that the operators can change the state representation. The most straightforward is to add and delete the ^contents attributes of the jug objects. However, the operators could also remove a jug and create a completely new jug object with the correct contents and volume attributes. Although this is less efficient, it has some advantages for planning and we will return to this approach in Part IV. For now you should write operator application rules that modify the ^contents attribute of the jug objects (it is not necessary to modify the ^empty attribute because it will be automatically recomputed whenever the ^contents change).</p> <p>In the Water Jug, there are three separate operators and each one requires its own operator application rules. We will examine them one at a time. The first is fill. Try to write an English version of its operator application rule.</p> <pre><code>water-jug*apply*fill\n</code></pre> <p>If the task is water-jug and the fill operator is selected for a given jug, then set that jug\u2019s contents to be its volume.</p> <p>This rule requires replacing the current value of the contents with a new value (the volume). To replace a value in Soar, you must remove the original working memory element and create a new one. There is no way to just replace the value field in an existing working memory element. This is an important attribute of Soar \u2013 all changes require the addition or deletion of working memory elements. You cannot modify a working memory element once it is created. You already know how to create a working memory element. To delete one, you specify the working memory element in the action but with a minus \u201c-\u201c at the end.</p> <pre><code>sp {water-jug*apply*fill\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;\n^jug &lt;j&gt;)\n(&lt;o&gt; ^name fill\n^fill-jug &lt;j&gt;)\n(&lt;j&gt; ^volume &lt;volume&gt;\n^contents &lt;contents&gt;)\n--&gt;\n(&lt;j&gt; ^contents &lt;volume&gt;)\n(&lt;j&gt; ^contents &lt;contents&gt; -)}\n</code></pre> <p>VisualSoar \u2013 In VisualSoar, we group all of the rules for an operator in a single file. In this case, you should reopen the fill operator file, and add this rule (using a template) directly under water-jugproposefill.</p> <p>The rule to apply the empty operator is essentially the inverse of fill.</p> <pre><code>water-jug*apply*empty\n</code></pre> <p>If the task is water-jug and the empty operator is selected for a given jug, then set that jug\u2019s contents to be 0 and its empty to be its volume.</p> <pre><code>sp {water-jug*apply*empty\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;\n^jug &lt;j&gt;)\n(&lt;o&gt; ^name empty\n^empty-jug &lt;j&gt;)\n(&lt;j&gt; ^volume &lt;volume&gt;\n^contents &lt;contents&gt;)\n--&gt;\n(&lt;j&gt; ^contents 0\n^contents &lt;contents&gt; -)}\n</code></pre> <p>This rule shows a shortcut in that two changes to working memory that involve the same identifier can be written without repeating the identifier.</p> <p>VisualSoar \u2013 Once again, put the application of empty in the same file that holds the proposal of empty.</p> <p>The pour operator is more complex because there are two different situations. One situation is where pouring the water into the jug being filled can hold all of the water being poured in, such as pouring from the three gallon jug into an empty five gallon jug. The other situation is where the jug being filled cannot hold all of the water, so that some water is left in the source jug, such as when pouring from the full five gallon jug into an empty three gallon jug. As a result, we have to write two rules that cover these two situations.</p> <pre><code>water-jug*apply*pour*will-empty-empty-jug\n</code></pre> <p>If the task is water-jug and the pour operator is selected, and the contents of the jug being emptied are less than or equal to the empty amount of the jug being filled, then set the contents of the jug being emptied to 0; set the contents of the jug being filled to the sum of the two jugs.</p> <pre><code>sp {water-jug*apply*pour\\*will-empty-empty-jug\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name pour\n^empty-jug &lt;i&gt;\n^fill-jug &lt;j&gt;)\n(&lt;j&gt; ^volume &lt;jvol&gt;\n^contents &lt;jcon&gt;\n^empty &lt;jempty&gt;)\n(&lt;i&gt; ^volume &lt;ivol&gt;\n^contents { &lt;icon&gt; &lt;= &lt;jempty&gt; })\n--&gt;\n(&lt;i&gt; ^contents 0\n^contents &lt;icon&gt; -)\n(&lt;j&gt; ^contents (+ &lt;jcon&gt; &lt;icon&gt;)\n^contents &lt;jcon&gt; -)}\n</code></pre> <p>VisualSoar \u2013 Put this rule, along with the next one, into the file containing the proposal for pour.</p> <p>This rule shows why it is useful to have the <code>^empty</code> augmentation on the jugs. Without it, it would be very difficult to have the test that the jug being filled could hold the water from the jug being poured from.</p> <pre><code>water-jug*apply*pour*will-not-empty-empty-jug\n</code></pre> <p>If the task is water-jug and the pour operator is selected, and the contents of the jug being emptied are greater than the empty amount of the jug being filled, then set the contents of the jug being emptied to its contents minus the empty of the jug being filled; set the contents of the jug filled to its volume.</p> <pre><code>sp {water-jug*apply*pour*will-not-empty-empty-jug\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name pour\n^empty-jug &lt;i&gt;\n^fill-jug &lt;j&gt;)\n(&lt;i&gt; ^volume &lt;ivol&gt;\n^contents { &lt;icon&gt; &gt; &lt;jempty&gt; })\n(&lt;j&gt; ^volume &lt;jvol&gt;\n^contents &lt;jcon&gt;\n^empty &lt;jempty&gt;)\n--&gt;\n(&lt;i&gt; ^contents (- &lt;icon&gt; &lt;jempty&gt;)\n^contents &lt;icon&gt; -)\n(&lt;j&gt; ^contents &lt;jvol&gt;\n^contents &lt;jcon&gt; -)}\n</code></pre> <p>Now that you have written both operator proposals and application rules, you can load them into Soar and try them out. It may be difficult to follow the problem solving, so before running your program you should probably add the monitoring rules described in the next section.</p>"},{"location":"tutorials/soar_tutorial/01/#state-and-operator-monitoring","title":"State and Operator Monitoring","text":"<p>Monitoring rules are useful for printing out the details of the operator being applied and the contents of each state. Below are four rules that monitor the selected operator and the state (one rule for each operator and one for the state). One of the nice things about Soar is that all of the monitoring rules fire in parallel with the other rules and don\u2019t interfere with the problem solving at all.</p> <p>The write command concatenates all of its arguments, which can include constants and variables. To make the output readable, you want to have a linefeed before writing out any text, using the (crlf) command, which stands for <code>carriage-return</code> and <code>line-feed</code>.</p> <pre><code>sp {water-jug\\*monitor\\*state\n(state &lt;s&gt; ^name water-jug\n^jug &lt;i&gt; &lt;j&gt;)\n(&lt;i&gt; ^volume 3 ^contents &lt;icon&gt;)\n(&lt;j&gt; ^volume 5 ^contents &lt;jcon&gt;)\n--&gt;\n(write (crlf) | 3:| &lt;icon&gt; | 5:| &lt;jcon&gt; )}\n\nsp {water-jug\\*monitor\\*operator-application*empty\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name empty\n^empty-jug.volume &lt;volume&gt;)\n--&gt;\n(write | EMPTY(| &lt;volume&gt; |)|)}\n\nsp {water-jug\\*monitor\\*operator-application*fill\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name fill\n^fill-jug.volume &lt;volume&gt;)\n--&gt;\n(write | FILL(| &lt;volume&gt; |)|)}\n\nsp {water-jug\\*monitor\\*operator-application*pour\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name pour\n^empty-jug &lt;i&gt;\n^fill-jug &lt;j&gt;)\n(&lt;i&gt; ^volume &lt;ivol&gt; ^contents &lt;icon&gt;)\n(&lt;j&gt; ^volume &lt;jvol&gt; ^contents &lt;jcon&gt;)\n--&gt;\n(write | POUR(| &lt;ivol&gt; |:| &lt;icon&gt; |,| &lt;jvol&gt; |:| &lt;jcon&gt; |)|)}\n</code></pre> <p>With these rules, your program will apply operators and pour water. At some point it might even reach the desired state; however, it will not recognize that state and it will just keep going.</p> <p>VisualSoar \u2013 The logical place to add these rules is in a new file called \u201cmonitor\u201d in the elaborations folder.</p>"},{"location":"tutorials/soar_tutorial/01/#desired-state-recognition","title":"Desired State Recognition","text":"<p>The final step in creating a program that not only solves Water Jug, but knows that it solved it is generating a rule that recognizes when a desired state has been achieved. You need to write a rule that recognizes when the three-gallon jug has one gallon in it. The action of the rule should be to print out a message that the problem has been solved and halt. Write an English version of this rule.</p> <pre><code>water-jug*detect*goal*achieved\n</code></pre> <p>If the task is water-jug and there is a jug with volume three and contents one, write that the problem has been solved and halt.</p> <p>Translating this into Soar is relatively straightforward.</p> <pre><code>sp {water-jug*detect*goal\\*achieved\n(state &lt;s&gt; ^name water-jug\n^jug &lt;j&gt;)\n(&lt;j&gt; ^volume 3\n^contents 1)\n--&gt;\n(write (crlf) |The problem has been solved.|)\n(halt)}\n</code></pre> <p>Another approach that is often used is to create a representation of the desired state in working memory and write a rule that compares that desired state to the current state. There are two advantages to this approach. First, if you want to try to solve many different Water Jug problems, a new desired state can be attempted by modifying working memory (possibly by getting input from a sensor) instead of changing a rule. Second, in many problems, the description of the desired state can be used to guide the search using a technique called means-ends analysis. Using means-ends analysis in Soar will be included in a future tutorial.</p> <p>Below is an example rule that creates the desired state, which in this case is the three-gallon jug containing 1 gallon. This rule will fire when the initialization operator is selected, in parallel with the other initialization rule.</p> <pre><code>sp {water-jug*apply*initialize\\*create\\*desired-state\n(state &lt;s&gt; ^operator.name initialize-water-jug)\n--&gt;\n(&lt;s&gt; ^desired.jug &lt;k&gt;)\n(&lt;k&gt; ^volume 3\n^contents 1)}\n</code></pre> <p>Below is the modified goal recognition rule. It compares the contents and volume of the desired jug to one in the current state. This rule is correct only for desired states that describe a single jug. If the desired state required specific amounts in each of the two jugs, a more elaborate rule would be required.</p> <pre><code>sp {water-jug*detect*goal\\*achieved\n(state &lt;s&gt; ^name water-jug\n^desired.jug &lt;dj&gt;\n^jug &lt;j&gt;)\n(&lt;dj&gt; ^volume &lt;v&gt; ^contents &lt;c&gt;)\n(&lt;j&gt; ^volume &lt;v&gt; ^contents &lt;c&gt;)\n--&gt;\n(write (crlf) |The problem has been solved.|)\n(halt)}\n</code></pre> <p>If you add these to the earlier rules, the program will halt; however, it can take a long time. When I ran it ten times, it took an average of decisions to solve the problem, with a range of 4 (the optimal) to</p> <p>VisualSoar \u2013 There were two different ways of writing the rule(s) that detects the desired-state. In each case, the purpose of the rule named water-jugdetectgoal*achieved is to continually monitor the state to see if the goal has been reached. Because the purpose of this rule is to monitor, it makes sense to create a new file (possibly named \u201cgoal-test\u201d) in the elaborations folder and enter it there. If you chose to go with the second way of writing the goal detection, then where should water-jugapplyinitialize*create*desired-state be placed? Since it tests the initialize-water-jug operator, it naturally should be added to the folder that holds that operator. Remember, how you group your rules is completely up to you. It makes sense to think of grouping in VisualSoar as an advanced way to comment code: it doesn\u2019t affect the way the code is interpreted by the computer, but if you or anyone else ever has to alter the code, it will make it much easier to understand. From here on out, it is up to you to choose how you want to group your code.</p>"},{"location":"tutorials/soar_tutorial/01/#search-control","title":"Search Control","text":"<p>In order to make the search more efficient; you need to add rules that prefer operators that have the best chance of leading to one of the desired states. There are few general heuristics that you can use in the water jug. The total number of possible states is only 16; however, they are highly connected, and it is difficult to avoid revisiting the same state over and over again unless a list of visited states is maintained. Maintaining such a list is possible in Soar, but it is not easy \u2013 it would require creating a copy of every state after an operator has applied and then comparing a new state to the states in the list. In the section on planning you will learn about an alternative approach that is a more natural way for Soar programs to avoid repeated visits to the same state. For now, we will concentrate on avoiding undoing the last operator that was applied, such as emptying a jug right after it has been filled, filling a jug after it has been emptied, or pouring water from one jug into the other right after the opposite pouring has been done. These heuristics will be even more effective when for the Missionaries and Cannibals problem and planning, but for now they allow us to look at how to maintain a history of the last operator application.</p> <p>In order to avoid undoing the last operator, the program must remember the operator in the state after it applies. In Soar, this memory is not automatic. The selected operator is retracted as soon as it applies. In order to have a record of the previous operator; you must add some rules that deliberately record the operator each time one is applied. The rules will be part of the operator application because they will test the operator in order to record it, which in turn will make the record persistent (which is what you want).</p> <p>Recording an operator has two parts. The first is creating a structure on the state that is the memory of the most recent operator. The second is removing any record of an older operator. Given the representation of the water jug operators in working memory, you will have to write three rules to record the last operator \u2013 one for each operator. If all of the operators had exactly the same augmentations, then it would be possible to do this with one rule, and we could change the operator representations to make this easy, but for now, we will go with the existing operator representations. The action of these rules should be to create an augmentation of the state that includes the augmentation of the selected operator (name, fill-jug, empty-jug as appropriate). It should not create a link to the original operator because all of the substructure of that operator will be removed as soon as the rule that created operator retracts. Try to write English versions of these rules. We will show only rules for the pour operator.</p> <pre><code>water-jug*apply*operator*record*last-operator*pour\n</code></pre> <p>If the task is water-jug and the pour operator is selected, then create an augmentation of the state (last-operator) with the name of the operator and a copy of the augmentations augmentation.</p> <p>This can then be converted into a Soar rule:</p> <pre><code>sp {water-jug*apply*operator*record*last-operator*pour\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name pour\n^fill-jug &lt;fj&gt;\n^empty-jug &lt;ej&gt;)\n--&gt;\n(&lt;s&gt; ^last-operator &lt;last-op&gt;)\n(&lt;last-op&gt; ^name pour\n^fill-jug &lt;fj&gt;\n^empty-jug &lt;ej&gt;)}\n</code></pre> <p>The rule to remove old records has to test only if the name of the current operator and the jug augmentation are different because it is not possible to apply an operator twice in a row.</p> <pre><code>water-jug*apply*operator*remove*old*last-operator*pour\n</code></pre> <p>If the task is water-jug and a pour operator is selected and last-operator does not have the same name and fill-jug, then remove the last-operator.</p> <pre><code>sp {water-jug*apply*operator*remove*last-operator*pour\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt;\n^last-operator &lt;last-op&gt;)\n(&lt;o&gt; ^name pour\n^fill-jug &lt;fj&gt;\n^empty-jug &lt;ej&gt;)\n\n-(&lt;last-op&gt; ^name pour\n^fill-jug &lt;fj&gt;\n^empty-jug &lt;ej&gt;)\n--&gt;\n(&lt;s&gt; ^last-operator &lt;last-op&gt; -)}\n</code></pre> <p>Once you add these rules, add rules that avoid applying an operator that undoes the previous operator (you should write these yourself).</p> <pre><code>water-jug*select*operator*avoid*inverse*fill\n</code></pre> <p>If the task is water-jug and the last operator is empty then avoid a fill.</p> <pre><code>water-jug*select*operator*avoid*inverse*empty\n</code></pre> <p>If the task is water-jug and the last operator is fill then avoid an empty.</p> <pre><code>water-jug*select*operator*avoid*inverse*pour\n</code></pre> <p>If the task is water-jug and the last operator is pour from one jug then avoid a pour the opposite way.</p> <pre><code>sp {water-jug*select*operator*avoid*inverse*fill\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt; +\n^last-operator &lt;lo&gt;)\n(&lt;o&gt; ^name fill ^fill-jug &lt;i&gt;)\n(&lt;lo&gt; ^name empty ^empty-jug &lt;i&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; &lt;)}\n\n```Soar\nsp {water-jug*select*operator*avoid*inverse*empty\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt; +\n^last-operator &lt;lo&gt;)\n(&lt;o&gt; ^name empty ^empty-jug &lt;i&gt;)\n(&lt;lo&gt; ^name fill ^fill-jug &lt;i&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; &lt;)}\n\n```Soar\nsp {water-jug*select*avoid*inverse*pour\n(state &lt;s&gt; ^name water-jug\n^operator &lt;o&gt; +\n^last-operator &lt;lo&gt;)\n(&lt;o&gt; ^name pour ^fill-jug &lt;j&gt;)\n(&lt;lo&gt; ^name pour ^empty-jug &lt;j&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; &lt;)}\n</code></pre> <p>Adding these rules, should shorten your search on average. My ten-run average went from to 108.</p>"},{"location":"tutorials/soar_tutorial/01/#water-jug-problem-space","title":"Water Jug Problem Space","text":"<p>Given a specific problem space, many different problems can be defined by selecting different initial and desired states. For example, you could define the problem of starting with both jugs full and getting four gallons of water into the five-gallon jug. Should that problem be easier or harder than the original problem? The difficulty can also vary with the definition of the problem space. The original problem becomes easy if we expand the problem space to include a jug that holds four gallons of water (changing the objects in the space), and it becomes impossible if there is no pour operator.</p> <p>One way to understand the Water Jug problems better is to visualize the complete problem space. The diagram below shows all the states and operator transitions in the Water Jug problem space. Each state contains the contents of the five-gallon and three-gallon jugs in order. The operator transitions are color coded. The goal states are shared in light green. In this problem, there are two distinct paths to the solution, one path much shorter (4 steps) than the other path (10 steps). The difficulty of the problem stems from the fact that there are usually four operators that can apply to each state but only one leads toward the solution. The remaining operators lead back toward one of four states, all of which are at least three steps from the solution. Therefore it is unlikely that this problem will be solved quickly via a random search.</p> <p>Although we can layout the complete problem space and the connections between states, the problem solver usually doesn\u2019t have that information available for examination \u2013 it only has the information available in a single state. For the purposes of this tutorial, we assumed that the agent starts with only an internal description of the initial state, the set of legal operators, and the desired state so that the problem will be solved by starting from the initial state and then searching for a desired state by selecting and applying operators. At any time the agent is at only one state and is faced with selecting an operator to apply to the state to move to a new state. Often AI planners reformulate problems so that they are searching through a space of plans (and not states of the problem). In those cases, the states are partial plans and the operators modify the plan by adding, removing, or reordering plan steps. For the problems we consider in this tutorial, the problem solver will always be in the space of states of the problem (task states) and not in a planning space (although you could use Soar to work in the planning space, but it would complicate the description of Soar).</p>"},{"location":"tutorials/soar_tutorial/01/#summary-of-problem-formulation-in-soar","title":"Summary of Problem Formulation in Soar","text":"<p>Below is a summary of the main steps in formulating and representing a problem in Soar.</p> <ol> <li> <p>The state representation. These are the attributes and values that     are used to describe the different states of the problem. For this     problem the state must represent how much water is in each jug.</p> </li> <li> <p>The initial state creation. An operator will generate the state     where the problem solving starts. In this problem, the initial state     has both jugs empty.</p> </li> <li> <p>State elaboration rules. These rules elaborate the state with     additional structures that aren\u2019t fundamental to the state (they     aren\u2019t created and deleted by operator application rules), but are     derived from the core aspect of the state. Thus, they are     entailments that are useful abstractions, often making it possible     to create simpler rules for proposing and comparing operators.</p> </li> <li> <p>The operator proposal rules. These are the rules that propose the     legal state transformations that can be made toward solving the     problem. For this problem there are three classes of operators:</p> <ol> <li>Pour water from the well into a jug.</li> <li>Pour water from a jug to a jug.</li> <li>Pour water from a jug to the well.</li> </ol> </li> <li> <p>The operator application rules. These are the rules that transform     the state when an operator is selected.</p> </li> <li> <p>The operator and state monitoring rules. These are optional rules     that print out the operator as it applies and prints out the current     state.</p> </li> <li> <p>The desired state recognition rule. This is a rule that notices when     one of the desired states is achieved. In this problem, the desired     states have one gallon of water in the three-gallon jug.</p> </li> <li> <p>The search control rules. These are optional rules that prefer the     selection of one operator over another. Their purpose is to avoid     useless operators and/or direct the search toward the desired state.     Theoretically you could encode enough rules so that the correct     operator is always selected for each state. However, you would have     had to already solved the problem yourself to figure out those     rules. Our goal is to have the program solve the problem, using only     knowledge available from the problem statement and possibly some     general knowledge about problem solving. Therefore, search control     will be restricted to general problem solving heuristics.</p> </li> <li> <p>S1 will always be the identifier of the first state, but that is an     artifact of the way Soar is implemented.</p> </li> </ol>"},{"location":"tutorials/soar_tutorial/02/","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/02/#part-ii-simple-external-interaction","title":"Part II: Simple External Interaction","text":""},{"location":"tutorials/soar_tutorial/02/#the-eaters-game","title":"The Eaters Game","text":"<p>The game used in this part is called \u201cEaters.\u201d In Eaters, PACMAN-like eaters compete to consume food in a simple grid world. Below is the Eaters Playing Board near the beginning of a game with four eaters.</p> <p>The Eaters world consists of a rectangular grid, 15 squares wide by 15 squares high. Walls bound all four sides. Interior wall sections are randomly generated for each new game. No two walls will touch, so there are no corners, except for exterior walls and no \u201cdead ends\u201d anywhere on the board. Each eater starts at a random location. Food pellets are in all other squares of the grid. There are two kinds of food: normal food (blue circles and worth 5 points) and bonus food (red squares and worth 10 points). An eater consumes food by moving into a square. When an eater moves out of a square it will be empty (unless another eater moves into it).</p> <p>An eater can sense the contents of cells (eater, normal food, bonus food, and empty) up to 2 squares away in all directions. On each turn, an eater can move one square north, south, east, or west. An eater can also jump two squares north, south, east, or west. An eater can jump over a wall or another eater. An eater does not consume any food in the space it jumps over. A jump costs the eater 5 points.</p> <p>Whenever two eaters try to occupy the same cell at the same time, they collide. As a result of the collision, their scores are averaged and they are teleported to new, random locations on the board.</p>"},{"location":"tutorials/soar_tutorial/02/#creating-an-eater","title":"Creating an Eater","text":"<p>Start the Eaters environment:</p> <p>Open the directory where you installed Eaters and launch the appropriate script file (Eaters.bat on Windows, Eaters.sh on Mac or Linux)</p> <p>Once Eaters has started, you will have a new window on your computer screen. The configuration of the playing board, or map, may look different than shown. You will use this window to create and destroyer eaters and run the game.</p> <p>Individual Eaters are controlled by Soar programs, which are automatically loaded when an eater is created. Press the \u201cNew\u201d button in the \u201cAgents\u201d area of the Eaters game. A dialog will pop up.</p> <p>The first thing you must do is select the productions that will define the behavior of the Eater. Pressing the button \u201cSoar\u201d will pop up a file selection box:</p> <p>Select the \u201cAgents/Eaters/Tutorial\u201d directory with the mouse, and then Choose \u201cOpen\u201d (or dbl-click on \u201cTutorial\u201d). The dialog will display the Soar production files that will be used in this tutorial. Each set of production rules defines specific behaviors for an Eater. Select the file \u201cmove-to-food.soar\u201d</p> <p>After you have selected the move-to-food eater, the Create Agent dialog should look as follows:</p> <p>The productions in the file \u201cmove-to-food.soar\u201d will now be loaded whenever the \u201cCreate Agent\u201d button is pressed. The production set can be changed before creating another agent by pressing the \u201cSoar\u201d button to choose a different file.</p> <p>You can also pick a color for your eater by clicking on the button to the right of \u201cColor:\u201d labeled \u201cred\u201d. The color does not affect on the eater\u2019s behavior, so pick your favorite color. Once you have selected the productions file, and a color, you are ready to create your eater by clicking on the Create Agent button.</p> <p>After clicking on Create Agent, the agent\u2019s Soar Debugger window will appear. Arrange the Java Eaters window and the Soar Debugger windows so that they do not overlap. You might need to resize the Soar Debugger window to make it shorter. Don\u2019t make it too narrow or it will be difficult to view Soar\u2019s output.</p> <p>The Soar Debugger Window will look as shown above, although it may be larger, and have additional panes. The eater is referred to by its color, which is listed in the window title (remote red). Once you are familiar with the Debugger, you can completely customize its appearance. Across the top are a series of pull down menus, which are described later. On the left side of the window is the Interaction Window where trace and debugging information will be displayed. Just below it is the Command Box where you can type in commands. The bottom of the window contains buttons for single stepping, running, or stopping the eater, setting Watch levels, and printing information. The layout of the buttons may change depending on the size of the window and user preferences. Features available in the Debugger will be described throughout this document as they are needed. More details are provided in Intro to the Soar Debugger.</p> <p>You should also see that the Java Eaters window has changed. The Red Eater is shown on the map, and the Eater name and score are shown in the Agent List. To the right of the Agent List is the sensor data for the Eater, showing the contents of the map cells that surround the Eater.</p>"},{"location":"tutorials/soar_tutorial/02/#running-an-eater","title":"Running an Eater","text":"<p>Your eater is now ready to start eating. Click the Run button on either the Eater Control Panel (highlighted above) or the Soar Debugger Window. The eater will start to move and consume food. After a few moves, click the Stop button on either the Eater Control Panel (next to the \u201cRun\u201d button) or the Interaction Window.</p> <p>At this point, the Eaters Playing Board will look something like the one below. Your board will look different because the walls and eater starting position are different each time the game is played.</p> <p>During the run, the Eaters Sensor window will change with each move, showing the food pellets, walls, and empty squares that the eater senses. As shown above, an eater can sense a 5x5 grid of cells, although the move-to-food rules consider only the four neighboring cells (north, south, east and west).</p> <p>The Interaction window (shown below) displays a trace of the eater\u2019s decisions.</p> <p>The line starting with 1: O: O2 shows the first selection of the move-to-food operator This is followed by successive selections of move-to-food operators. The move-to-food operator causes the eater to move to a new cell. Some of the eaters will also jump; others will halt when they cannot sense any food.</p> <p>If the trace gets longer than the window can hold, the printing will scroll up. You can look at decisions that scroll off the window by using the scroll bar to the right of the window. You can search for information in the trace by using the find function that is found under Edit at the top of the Interaction window.</p> <p>In Soar, a program consists of rules, and move-to-food has only three simple rules that move the eater to a neighboring cell that contains food. As your eaters get more sophisticated, more rules will be loaded. If you let the eater run for a long time, it will eventually get to a place where there is no food directly next to it. The move-to-food eater does not have any rules to respond to this situation (although you could easily add some) so the eater will stop moving. The trace will look as follows:</p> <p>When an eater does not know how to respond to a situation, it will start generating new states, such as S6, S7, S8, \u2026 in the above trace above. In later sections of the tutorial you will learn how to write rules that take advantage of these new states, but for now you just need to know that when they arise, the eater does not know what to do.</p> <p>At anytime you can create more eaters. You can create additional eaters from the same or different files, so that you can create a set of identical eaters (except for color), or sets of different eaters. Each time a new eater is created, a new Interaction Window is created, and the Eaters Agent List is expanded to include the new eater. To make a new agent with the same set of rules as an existing agent, you can use the \u201cClone\u201d button. To create an eater with a different set of rules, press \u201cNew\u201d and use the dialog to select the desired rule set just as you did when creating your first move-to-food eater.</p> <p>From the Agent List, you can select which eater\u2019s sensor data is displayed by selecting the eater color with the mouse. When an eater is highlighted, it can also be \u201ccloned\u201d or destroyed. To destroy an eater, click on the eater Name in the Agent List (highlight it) and press the \u201cDestroy\u201d button.</p> <p>To reload the production rules for the eater, you should use the reload button (not implemented yet!), or if you create an Eater using VisualSoar you can use the runtime tab to reload the agent, reload a file, or change a single rule. Reloading is useful if you have found a bug, modified the rules in the file, and then wish to immediately test them on the current situation. Soar will replace existing rules with new versions (a \u201c#\u201d is printed in the Interaction Window whenever a rule is replaced), as well as adding any new rules. This can be done at any time as Soar will match new and modified rules against working memory.</p> <p>The upper right portion of the JavaEaters window has options for controlling the Eaters \u201cSimulation.\u201d</p> <p>Spend some time creating, running and destroying different eaters. Notice how the eaters move around the board differently, some being much more efficient at consuming food.</p>"},{"location":"tutorials/soar_tutorial/02/#building-a-simple-eater-using-rules","title":"Building a Simple Eater Using Rules","text":"<p>In contrast to the Water Jug, an Eater does not have to initialize the state with an operator \u2013 the Eater will start with information about its situation coming in through a structure called the input-link. We will keep the Eater very simple, so all we will do initially is create operators, which means creating operator proposal and application rules.</p> <p>The first operator you will create moves an eater north one step. (It might not even do that if there is a wall to its north when it is created.)</p>"},{"location":"tutorials/soar_tutorial/02/#english-version","title":"English Version","text":"<p>Here is one possible version of the move-north operator.</p> <pre><code># Propose*move-north:\n# If I exist, then propose the move-north operator.\n# Apply*move-north:\n# If the move-north operator is selected, then generate an output command to\n# move north.\n</code></pre> <p>To write the Soar rule for apply*move-north, you have to know how to get an eater to move. All external actions are issued by creating working memory elements that are augmentations of the output-link. The output-link is an augmentation of the io object, which in turn is an augmentation of the state. In Eaters, a move command is issued by creating a \u201cmove\u201d augmentation on the output-link object, which in turn has an augmentation called \u201cdirection\u201d with a value of the direction to move: \u201cnorth\u201d, \u201csouth\u201d, \u201ceast\u201d, or \u201cwest\u201d. For each task in Soar, a set of output commands is defined, and in Eaters there are two commands: move and jump.</p> <p>You should now try to write the Soar rules for the move-north operator.</p> <p>To create your own agent for eaters, use your favorite text editor, and save the file that you create with a .soar file extension. To create an agent that loads the production that you have written, create an agent as in section 1.1, but this time instead of loading \u201cmove-to-food.soar\u201d, load the file that you just created.</p>"},{"location":"tutorials/soar_tutorial/02/#soar-version","title":"Soar Version","text":"<p>Below is the proposal rule I wrote. You can find this rule in the file \u201cmove-north.soar\u201d in the \u201cAgents\\ \\Eaters\\Tutorial\u201d directory where you found \u201cmove-to-food.soar\u201d. The proposal rule is exactly the same as the proposal rule for hello-world, except that the names of the rule and the operator are changed.</p> <pre><code>sp {propose*move-north\n(state &lt;s&gt; ^type state)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move-north)}\n</code></pre> <p>The rule that applies the operator has more differences. Its action is to add a move command to the output-link. This command will cause the eater to move one cell to the north. In order to add the command to the output-link, the rule must match the output-link identifier in its conditions with a variable. Therefore, conditions are included that match the io (<code>&lt;io&gt;</code>) object, and then the output-link (<code>&lt;out&gt;</code>).</p> <pre><code>sp {apply*move-north\n(state &lt;s&gt; ^operator &lt;o&gt;\n^io &lt;io&gt;)\n(&lt;io&gt; ^output-link &lt;out&gt;)\n(&lt;o&gt; ^name move-north)\n--&gt;\n(&lt;out&gt; ^move &lt;move&gt;)\n(&lt;move&gt; ^direction north)}\n</code></pre> <p>The exact order of the conditions (and actions) does not matter, except that the first condition must match the state identifier.</p> <p>You should change your rules if they were significantly different than these. Then create a move-north eater and type \u201cwatch 3\u201d on the command line so that you can watch the productions fire. Run the eater by clicking on the \u201cStep\u201d button until your eater moves north. If your eater doesn\u2019t seem to be working, skip ahead to the Debugging Your Eater section. Once your eater has moved north, your interaction window should look like the following:</p> <p>But what happened to your eater? After selecting move-north and taking one step, the eater had nothing more to do and a new state is created (s6 in the above Figure). Unfortunately, the rules you wrote are not sufficient to get the eater to continually move north. In the next section, you will modify your eater so that it continues to move north.</p>"},{"location":"tutorials/soar_tutorial/02/#shortcuts","title":"Shortcuts","text":"<p>The apply*move-north rule has lots of variables in it whose sole purpose is to make connections between attributes. For example, <code>&lt;o&gt;</code> is used to later match the name of the operator and <code>&lt;io&gt;</code> is used to later match the output-link. Similarly, <code>&lt;move&gt;</code> is used in the action to connect the output-link to the final direction. None of these variables is used in both conditions and the actions.</p> <pre><code>sp {apply*move-north\n(state &lt;s&gt; ^operator &lt;o&gt;\n^io &lt;io&gt;)\n(&lt;io&gt; ^output-link &lt;out&gt;)\n(&lt;o&gt; ^name move-north)\n--&gt;\n(&lt;out&gt; ^move &lt;move&gt;)\n(&lt;move&gt; ^direction north)}\n</code></pre> <p>To simplify the writing and reading of rules, Soar allows you to combine conditions that are linked by variables. To do this, you can just string together attributes, replacing the intermediate variables with a period, \u201c.\u201d, to separate the attributes. In Soar, we call this \u201cdot\u201d or \u201cpath\u201d notation. Below is the same rule as before using dot notation.</p> <pre><code>sp {apply*move-north\n(state &lt;s&gt; ^operator.name move-north\n^io.output-link &lt;out&gt;)\n(&lt;out&gt; ^move.direction north)}\n</code></pre> <p>This rule is exactly the same as the original from Soar\u2019s perspective.</p> <p>One mistake you want to avoid making is to use dot notation in the action when you are creating multiple sub-attributes of a new object. This will create multiple objects, each with a single sub-attribute. For example, if you want create a second augmentation of the move object called speed (which is irrelevant in Eaters), you do not want to do the following:</p> <pre><code>--&gt;\n(&lt;out&gt; ^move.direction north\n  ^move.speed fast)\n</code></pre> <p>This is equivalent to:</p> <pre><code>--&gt;\n(&lt;out&gt; ^move &lt;move1&gt;\n  ^move &lt;move2&gt;)\n(&lt;move1&gt; ^speed fast)\n(&lt;move2&gt; ^direction north)\n</code></pre> <p>These actions will create two move augmentations on the output-link, each with a single attribute. The correct action is:</p> <pre><code>--&gt;\n(&lt;out&gt; ^move &lt;move&gt;)\n(&lt;move&gt; ^speed fast\n  ^direction north)\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#move-north-operator-multiple-moves","title":"Move-North Operator: Multiple Moves","text":"<p>Although the move-north operator did move one step north, the eater never takes a second step. In this section, you are going to find out why it takes only one step and modify the eater so that it can take multiple steps. This is one of the most complex sections of the tutorial, so study it carefully.</p>"},{"location":"tutorials/soar_tutorial/02/#operator-selection-multiple-instances","title":"Operator Selection: Multiple Instances","text":"<p>In Soar, each action in the world, such as moving an eater, should be performed by a separate operator instance. An operator instance is a separate operator in working memory element created by the firing of an operator proposal rule. Thus, each action should test for the creation of a new operator object in working memory. Different instances of the same operator will have the same name, and sometimes will have the same augmentations, but a given instance will be used for only one move. Some operator instances may include many actions, but they will be selected and applied only once.</p> <p>Therefore, new instances of the move-north operator should be created in working memory for each new move. You should not attempt to have the move-north operator selected once, and have it move an eater multiple times. Instead, you should design you eater so that a new instance of the move-north operator is created for each move. You can do this by having the operator proposal rule fire each time the eater is to move. How can you change propose*move-north so that it fires after each move? As the rule is currently written, it will fire only once because it only tests ^type state, which stays in working memory forever. Your rule needs to test working memory elements that change each time the eater moves \u2013 those working memory elements that correspond to the eater\u2019s senses on the input-link. Soar is designed so that changes to the input-link are made following output, just in time to affect operator proposals.</p> <p>The information that comes in on the input-link consists of objects with attributes and values.</p> <pre><code>(I2 ^eater I4 ^my-location I5)\n(I4 ^direction south ^name red ^score 25 ^x 1 ^y 10)\n</code></pre> <p>The input-link object, I2, has two augmentations. The first, ^eater, has information about the eater: its current direction, its name, its current score, and its x, y coordinates. The second, ^my-location, has additional substructure (not shown) that includes the eater\u2019s sensing of nearby cells. Some of the ^eater information changes during the game:</p> <ul> <li>The x location will change when the eater moves east or west.</li> <li>The y location will change when the eater moves north or south.</li> </ul> <p>Thus, whenever the eater moves, either the x or y location will change. We can modify the conditions of our proposal rule to test both of these working memory elements, and eliminate the test for ^type state.</p> <pre><code>sp {propose*move-north\n(state &lt;s&gt; ^io.input-link.eater &lt;e&gt;)\n(&lt;e&gt; ^x &lt;x&gt; ^y &lt;y&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move-north)}\n</code></pre> <p>What will happen? First, when the original working memory elements for x and y are removed from working memory, the original move-north operator will be removed from working memory because the rule instantiation that created it no longer matches \u2013 some of the working memory elements responsible for the match are gone. We call this retracting the rule firing. Rules such as propose*move-north maintain their actions in working memory only as long as they match exactly the same working memory elements.</p> <p>Second, a new instance of the move-north operator will be created because propose*move-north will match the new values of x and y and fire. To see these changes, modify your move-north operator as above and then rerun it. This time, we are going to increase the tracing so that we can see the individual changes to working memory. To do this, type <code>watch 4 --timetags</code> in the interaction window.</p> <p>The figure below shows the end of the trace. The trace is long because it includes the addition and removal of all of the sensory data that changes during a move (not shown below). In the trace, an addition to working memory is shown preceded by an <code>=&gt;</code>, while a removal from working memory is preceded by an <code>&lt;=</code>. Each working memory element also contains a number, such as 119 for the top element in the trace below. This is the timetag of the working memory element \u2013 a unique number generated when a working element is created. Soar sometimes displays only timetags instead of the full working memory element, and the timetag can be used in the print and wmes commands for displaying the full working memory element (more details later).</p> <p>Your eater will now move north a second time (and a third, etc, if not blocked) because the proposal matches against a new set of x and y coordinates, apply*move fires again, and a second move command is created. But there are still problems. Step the eater a few more times and then choose the \u201coutput\u201d tab on the upper right section of the eater Debugger window to see the eater\u2019s ^output-link. You will notice that the original move command (I3 ^move M2) is not removed from the output-link, and the output-link will gradually accumulate stale commands. The old move command is not removed because it is the action of an operator application rule. Such actions are not automatically removed when the rule no longer matches.</p>"},{"location":"tutorials/soar_tutorial/02/#operator-application-persistence","title":"Operator Application: Persistence","text":"<p>As noted above, proposing and selecting a second operator makes the eater move a second time, but the accumulation of more and more move commands will eventually become a problem. Why aren\u2019t these commands automatically removed like the preferences for operators? The reason is that the rule that creates them is part of the application of an operator, and operator applications create persistent working memory elements.</p> <p>Persistence is necessary for creating memories of prior events, such as the memory of something sensed in the environment. For example, if an eater needed to remember the location of uneaten food so that it could return to it later, the eater would have to create a persistent structure in its working memory. Otherwise, as soon as it stopped sensing the food, it would forget about it. In Soar, all working memory elements created by an operator application rule are persistent. A rule is an operator application rule if it tests a selected operator and modifies the state. Persistent working memory elements are said to be operator-supported, or o-supported, because they are created by operators. For example, apply*move-north is an operator application rule and creates o-supported working memory elements.</p> <pre><code>sp {apply*move-north\n(state &lt;s&gt; ^operator.name move-north\n^io.output-link &lt;out&gt;)\n--&gt;\n(&lt;out&gt; ^move.direction north)}\n</code></pre> <p>Just as it is important to have persistent memories, it is also important to have structures that are removed automatically when the reason for creating them goes away. Actions of rules that test only the state, or that test the operator and elaborate only the operator create non-persistent preferences or working memory elements. Obvious examples of non-persistent structures are the preferences for operators. These are created by operator proposal rules, which retract the operators when the proposal conditions change. Other examples include state elaboration rules and operator elaboration rules. Non-persistent working memory elements and preferences are called instantiation-supported, or i-supported, because they only persist as long as the rule instantiation that created them. For example, proposemove-north is not an operator application rule because it does not test a selected operator. All of its actions are i-supported and they will be removed from working memory when proposemove-north no longer matches.</p> <pre><code>sp {propose*move-north\n(state &lt;s&gt; ^io.input-link.eater &lt;e&gt;)\n(&lt;e&gt; ^x &lt;x&gt; ^y &lt;y&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move-north)}\n</code></pre> <p>Returning to the problem of moving the eater, you need to add a rule that removes old move commands from the output-link after the move is finished. In Eaters, the output system creates an augmentation on the move object after the action has executed: ^status complete. To remove a structure from working memory, a rule \u201crejects\u201d a working memory element in its action. A reject must be part of an operator application rule because it is a persistent change to working memory. Therefore, the removal must test the move-north operator so that it is an operator application rule. In English, the rule is:</p> <pre><code># Apply*move-north*remove-move:\n# If the move-north operator is selected,\n# and there is a completed move command on the output link,\n# then remove that command.\n</code></pre> <p>In Soar, the action of a rule can remove a working memory element by following it by a reject preference, which is designated with a minus sign (\u201c-\u201c). The above rule is translated in to Soar as follows:</p> <pre><code>sp {apply*move-north*remove-move\n(state &lt;s&gt; ^operator.name move-north\n^io.output-link &lt;out&gt;)\n(&lt;out&gt; ^move &lt;move&gt;)\n(&lt;move&gt; ^status complete)\n--&gt;\n(&lt;out&gt; ^move &lt;move&gt; -)}\n</code></pre> <p>The action of this rule removes the working memory element specified by <code>(&lt;out&gt; ^move &lt;move&gt;)</code>, which would be something like <code>(i3 ^move m1)</code>. When this working memory element is removed, all of the augmentations of m1 are automatically removed because they are no longer linked to the rest of working memory. In this case, <code>(m1 ^direction north)</code> and <code>(m1 ^status complete)</code> are removed. These would not be removed if they remained linked via another working memory element that had m1 as a value.</p> <p>This is an operator application rule, so it will not fire during the following operator proposal phase. Instead, it will fire during the next operator application phase, after a new move-north operator has been selected. It will not interfere with other operator application rules because rules fire (and retract) in parallel as a wave. The parallelism is only simulated, but the effect is as if all the rules fire or retract at the same time. Once a wave of rules has fired, their actions may cause additional rules to match or retract. Soar will continue to fire or retract additional waves of rules until no more rules match. Thus, within the phases of proposing and applying operators, Soar fires all rules that match until quiescence, that is, until no more rules match. During the propose phase, only rules that have i-supported actions will fire. During the apply phase, both o-supported and i-supported rules fire.</p> <p>Returning to our diagram of the phases of Soar, both the propose operator and apply operator phases can be expanded to show that multiple rules fire and retract in parallel until quiescence.</p>"},{"location":"tutorials/soar_tutorial/02/#running-and-tracing","title":"Running and Tracing","text":"<p>When running your new eater, it will go north until it hits a wall or the border. When it can no longer move, it will start generating states because it cannot successfully apply and terminate the move-north operator. Below is a sample trace, with the <code>watch 3 --timetags</code> in use, of the interaction window for the first two moves to the north by an eater.</p> <p>If you look closely at this trace, you see that two rules are firing at the same time: apply*move-north, and apply*move-north*remove-move. One is adding the new move command to the output-link at the same time that the other is removing the previous move command. There are also examples of rules firing and retracting at the same time where an operator is being removed from working memory at the same time that a new operator is being created.</p> <p>Instead of letting Soar run free, you can step Soar through each decision using the \u201cStep\u201d button on either the Soar Debugger or the Java Eaters window. The default will stop each step before the application phase, right after Soar has made an operator selection (decision phase). It\u2019s possible to change the location where Soar will stop when stepping, using the Soar Cycle widget in the Debugger.</p> <p>The red icon in the diagram shows the point where Soar will stop when the Step button is used. The green icon shows where Soar is in its execution cycle. Move the Stop Point to the location between \u201cWorld\u201d and \u201cInput\u201d as shown above. This is just after the output commands have been added to the output-link and just before the eaters are about to move. In the following trace, the Watch level is 1, the step button has been used, and then the output-link is examined. This is repeated twice.</p> <p>From prior runs, you know that I3 is the identifier of the output-link. Although Soar does not guarantee that I3 will always be the identifier of the output-link, it always is, just as I1 is the identifier of the io object, I2 is the identifier of the input-link, and S1 is the identifier of the first state.</p> <p>When you print I3, you see that the move command is correctly added to the output-link. You can see more than one level of augmentation by using the <code>-d</code> flag on the print command as shown in the upper right monitoring window.</p> <p>You can also step through one phase at a time by using the <code>run 1 \u2013p</code> command.</p>"},{"location":"tutorials/soar_tutorial/02/#move-to-food-operator","title":"Move-To-Food Operator","text":"<p>In this section you will create an eater that greedily moves to any food it senses. You will use the lessons you learned from the move-north operator, and learn more about the structure of the input-link and operator preferences.</p> <p>Each eater can sense the food and walls that surround it, two steps in each direction. The Eaters Info window shows what an eater can sense. For this eater, you will write an operator that moves the eater to one of the neighboring cells (north, east, south, or west) that contains normalfood or bonusfood. Since food can be in more than one of the neighboring cells, more than one operator may be proposed. Soar does not automatically select randomly from among a set of proposed operators \u2013 it will get a tie impasse if there are multiple operators with only acceptable preferences. To avoid ties, Soar has additional preferences. For this exercise, it does not matter which food an eater consumes first, so you can use a preference that makes the decision procedure arbitrarily select one of the proposed operators.</p> <p>Based on the above discussion, you will need four rules for the move-to-food operator.</p> <ul> <li> <p>You need one rule to propose the operator when there is normal-food     in a neighboring cell and a second rule to propose the operator when     bonus-food is in a neighboring cell. Unlike the move-north operator,     these proposal rules do not have to test the coordinates of the     eater because the contents of the neighboring cells will change when     the eater moves. The contents will change (the working memory     elements for contents of all of the sensed cells are removed and     re-added to working memory) even if the sensed object is the same     type. The operator proposal rules can also create the indifferent     preferences that lead to a random selection.</p> </li> <li> <p>You need a third rule to apply the operator and move the eater in     the correct direction.</p> </li> <li> <p>You need a fourth rule to remove the move command from the     output-link.</p> </li> </ul> <p>Now try to write English versions of the move-to-food operator. Use the English versions of the move-north operator as a guide:</p> <pre><code> Move-north operator\n# Propose*move-north:\n# If I am at a specific location, then propose the move-north operator.\n\n# Apply*move-north:\n# If the move-north operator is selected,\n# generate an output command to move north.\n\n# Apply*move-north*remove-move:\n# If the move-north operator is selected,\n# and there is a completed move command on the output link,\n# then remove that command.\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#english-version_1","title":"English Version","text":"<p>Here is one possible set of rules for the move-to-food operator.</p> <pre><code># Move-to-food operator\n# Propose*move-to-food*normalfood\n# If there is normalfood in an adjacent cell,\n# propose move-to-food in the direction of that cell\n# and indicate that this operator can be selected randomly.\n#\n# Propose*move-to-food*bonusfood\n# If there is bonusfood in an adjacent cell,\n# propose move-to-food in the direction of that cell\n# and indicate that this operator can be selected randomly.\n#\n# Apply*move-to-food\n# If the move-to-food operator for a direction is selected,\n# generate an output command to move in that direction.\n#\n# Apply*move-to-food*remove-move:\n# If the move-to-food operator is selected,\n# and there is a completed move command on the output link,\n# then remove that command.\n</code></pre> <p>Converting these rules to Soar requires a more detailed examination of preferences and the input-link.</p> <ul> <li> <p>Preferences. To select randomly among the proposed operators, Soar     has a preference called indifferent. The equal sign, \u201c=\u201d, is used     to signify an indifferent preference for an operator, just as \u201c+\u201d     signifies acceptable. The indifferent preference means that the     decision procedure can randomly select among all operators with     indifferent preferences, so it is important that all proposed     operators have indifferent preferences. Even though we will create     an indifferent preference for these operators, the acceptable     preference is still necessary and an operator will not be selected     if it does not have an acceptable preference.</p> </li> <li> <p>Input-link representation. The input-link has two augmentations:     eater and my-location. Remember that the value of the my-location     augmentation is the eater\u2019s current position and is a cell in middle     of the 5x5 Eaters Info sensory field. On the next page there is a     graphic depiction of this cell and all of the other cells in the     sensory field. Adjacent cells are augmentations labeled north, east,     south, and west. Every cell also has a ^content augmentation, whose     value can be wall, empty, eater, normalfood, or bonusfood. If the     cell has an eater in it, there will be additional augmentations (not     shown in the figure) for the color of the eater (^eater-color), and     the eater\u2019s current score (^eater-score). Below the figure for the     input-link structure is the corresponding Eaters Info window.</p> </li> </ul> <p>Based on the information in those figures, you should try to write a Soar rule for propose*move-to-normalfood. Two hints:</p> <ol> <li> <p>Write down the sequence of attributes that go from the state to the     value of the content of a cell, separating each attribute with a     \u201c.\u201d.</p> </li> <li> <p>Use a variable to match the direction augmentations to a neighboring     cell and then test that the content is normalfood. That variable in     the attribute position will match any direction augmentation between     cell: north, east, south, or west. You can write it: <code>^&lt;variable&gt;</code></p> </li> </ol>"},{"location":"tutorials/soar_tutorial/02/#soar-version_1","title":"Soar Version","text":"<p>Below is the proposal rule I wrote without dot notation so that it is clear which working memory elements are being matched. The proposal rule tests a sequence of linked identifier-attribute-values, and includes a variable for the attribute that leads to an adjacent cell. The variable will match north, east, south, or west if the final condition matches an adjacent cell containing (has \u201c^content\u201d) normalfood.</p> <pre><code>sp {propose*move-to-normalfood\n(state &lt;s&gt; ^io &lt;io&gt;)\n(&lt;io&gt; ^input-link &lt;input-link&gt;)\n(&lt;input-link&gt; ^my-location &lt;my-loc&gt;)\n(&lt;my-loc&gt; ^&lt;direction&gt; &lt;cell&gt;)\n(&lt;cell&gt; ^content normalfood)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;s&gt; ^operator &lt;o&gt; =)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;direction&gt;)}\n</code></pre> <p>The indifferent preference tells Soar that a random selection can be made between proposed operators. The <code>&lt;direction&gt;</code> in the action augments the operator with the direction of an adjacent cell containing normalfood. When an eater is surrounded by food, the <code>&lt;direction&gt;</code> variable will match all directions, leading to four matches of the rule. In Soar, all new matches fire in parallel, creating new operators, each with a different ^direction augmentation. For example, if there was normalfood to the south and west, two operators would be created, one with ^direction south and one with ^direction west.</p> <p>This rule can be written much more concisely using dot notation, and a short cut for the preferences.</p> <pre><code>sp {propose*move-to-normalfood\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content normalfood)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)}\n</code></pre> <p>The rule that proposes the operator to move to consume bonusfood is very similar.</p> <pre><code>sp {propose*move-to-bonusfood\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content bonusfood)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)}\n</code></pre> <p>The rule to create the move command on the output link is very similar to the one used in move-north. The only difference is that instead of always using \u201cnorth\u201d as the direction, it uses the direction created by the operator proposal rule and matched by variable <code>&lt;dir&gt;</code>.</p> <pre><code>sp {apply*move-to-food\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)\n--&gt;\n(&lt;out&gt; ^move.direction &lt;dir&gt;)}\n</code></pre> <p>The final rule removes the move command from the output-link when it has completed.</p> <pre><code>sp {apply*move-to-food*remove-move\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator.name move-to-food)\n(&lt;out&gt; ^move &lt;move&gt;)\n(&lt;move&gt; ^status complete)\n--&gt;\n(&lt;out&gt; ^move &lt;move&gt; -)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#shortcuts-and-extensions","title":"Shortcuts and Extensions","text":"<p>The rules proposemove-to-normalfood and proposemove-to-bonusfood differ only in the tests for normalfood and bonusfood. Instead of writing an individual rule for each of those values, it is possible to write a single rule that tests for any one of a set of alternative values. The alternative values are written in the same position as a single value, but are surrounded by double angle brackets: &lt;&lt; normalfood bonusfood &gt;&gt;. Any number of different values can be included, but none of them can be a variable. Using this notation, the two rules can be rewritten as the following rule:</p> <pre><code>sp {propose*move-to-food\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content &lt;&lt; normalfood bonusfood &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)}\n</code></pre> <p>This notation can also be used for testing alternative values of attributes.</p> <p>Soar supports another shortcut, similar in spirit to dot notation that allows you to eliminate variables in conditions whose sole purpose is to link conditions. Dot notation works if there is a single augmentation. However, if there are multiple augmentations, dot notation doesn\u2019t help. Grouping, using parentheses, handles this case. In place of where a variable would go as an action, you can insert the augmentations of the value. For example, the original apply*move-to-food was:</p> <pre><code>sp {apply*move-to-food\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)\n--&gt;\n(&lt;out&gt; ^move.direction &lt;dir&gt;)}\n</code></pre> <p>This can be replaced by</p> <pre><code>sp {apply*move-to-food\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator (^name move-to-food\n^direction &lt;dir&gt;))\n--&gt;\n(&lt;out&gt; ^move.direction &lt;dir&gt;)}\n</code></pre> <p>Although this does eliminate unnecessary variables, it often makes the rules more difficult to read, so this notation will not be used in the rest of the tutorial.</p> <p>One more thing you might want to add is the ability to trace the direction of the selected operator. You can do this with a rule that tests that the operator is selected and uses the write action.</p> <pre><code>sp {monitor*move-to-food\n(state &lt;s&gt; ^operator &lt;o&gt;)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;direction&gt;)\n--&gt;\n(write |Direction: | &lt;direction&gt;)}\n</code></pre> <p>This rule will fire in parallel with apply*move-to-food because it matches a selected operator.</p>"},{"location":"tutorials/soar_tutorial/02/#example-trace","title":"Example Trace","text":""},{"location":"tutorials/soar_tutorial/02/#debugging-soar-programs","title":"Debugging Soar Programs","text":"<p>In trying to write the operators in the previous section, you may have made some mistakes. In this section, you will learn techniques for finding and fixing bugs in Soar programs. The techniques are separated based on the cause of the error:</p> <ul> <li> <p>When the rules for an eater are read into Soar, Soar checks to make     sure that the rules are legal and displays messages when it finds     errors. These types of errors are called syntax errors.     Visual-Soar will also check for syntax errors in rules. I recommend     using Visual-Soar to check for errors first.</p> </li> <li> <p>If your rules load into Soar without any error messages, there can     still be mistakes in the underlying logic of the rules. These are     semantic errors.</p> </li> </ul> <p>This section starts with a subsection on Syntax Errors. Subsections follow this on different techniques for monitoring and examining your program while it is running. The last subsection is a walk through of using these techniques to debug a program.</p>"},{"location":"tutorials/soar_tutorial/02/#syntax-errors","title":"Syntax Errors","text":"<p>There are many different types of syntactic errors that you can have in your programs. The eight most common errors are:</p> <ol> <li>Missing comment character</li> <li>Missing {</li> <li>Missing )</li> <li>Extra )</li> <li>Missing }</li> <li>Missing state</li> <li>Missing ^</li> <li>Disconnected rhs action variable.</li> </ol> <p>Fortunately, with the development of VisualSoar, locating and fixing syntax errors in Soar productions has become relatively easy. Before loading rules into the debugger to execute a Soar program, check for syntax errors using VisualSoar. To do this, click Datamap | Check All Productions for Syntax Errors.</p> <p>VisualSoar will check all of your productions to make sure that they conform to the standard syntax rules. The results of this check will appear in the feedback window (which is located at the bottom of the VisualSoar window). If an error is found, an informative error message will appear in blue. The first part of the error message will be the name of the file where the error was found and its line number in the format <code>&lt;file-name&gt;(line number):</code> This is then followed by more output which will include the specific path of the file the error was found in, and why VisualSoar considers it a syntax error:</p> <p>One of the best features of VisualSoar is that double-clicking on an error message allows you to see exactly where the error occurred. Double-clicking an error message automatically opens the window in which the error was found, and highlights the illegal area in yellow. For instance, double-clicking this error message would cause this window to pop-up:</p> <p>If no errors are found, \u201cThere were no errors detected in this project\u201d will be printed in the feedback window.</p> <p>We suggest playing around with this tool. Delete brackets and braces, # signs and --&gt;\u2019s to see what errors VisualSoar gives you so that you are able to quickly recognize what types of messages certain errors give. This will make future debugging much easier.</p>"},{"location":"tutorials/soar_tutorial/02/#write-statements","title":"Write Statements","text":"<p>One of the oldest debugging techniques in traditional programming languages is to add print statements throughout the program. Although not the most effective technique, it can be easily used in Soar by adding write statements in the action of rules. To make the output readable, you want to have a linefeed before writing out any text, using the (crlf) command, which stands for carriage-return and linefeed.</p> <p>For example, if you want to keep track of all of the move-to-food operators that are proposed, including their direction and expected food, you could take the original rule given below:</p> <pre><code>sp {propose*move-to-food\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content &lt;&lt; normalfood bonusfood &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)}\n</code></pre> <p>and modify it by adding a write statement. To get the right values in the action requires a variable for the food type in the condition.</p> <pre><code>sp {propose*move-to-food\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content\n{ &lt;type&gt; &lt;&lt; normalfood bonusfood &gt;&gt; })\n--&gt;\n(write (crlf) | Propose move | &lt;dir&gt; |, for | &lt;type&gt;)\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-to-food\n^direction &lt;dir&gt;)}\n</code></pre> <p>The write command concatenates all of its arguments, which can include constants and variables.</p>"},{"location":"tutorials/soar_tutorial/02/#runtime-debugging-commands","title":"Runtime Debugging Commands","text":"<p>While Soar is running, there are many commands you can use to get information on what the current state of the system is, what happened in the past, and what is about to happen. This subsection is organized by the different commands. To learn the details of all of these commands, you should check the Soar User\u2019s Manual.</p>"},{"location":"tutorials/soar_tutorial/02/#print","title":"print","text":"<p>You have already seen the print command, which is used to print out working memory structures. Print can take a variety of arguments. One of the most useful is to print to a given depth. This prints not only the current identifier and all of its augmentations, but also all of their augmentations recursively to a given depth. For example, you can print out the current state to a depth of 2 by using the following command:</p> <pre><code>red&gt; print -\u2013depth 2 s1\n</code></pre> <p>The order is important and s1 must come at the end of the print statement. The result is:</p> <pre><code>(S1 ^type state ^superstate nil ^io I1 ^operator O2 ^operator O4 +\n^operator O3 + ^operator O2 + ^operator O1 +)\n(I1 ^input-link I2 ^output-link I3)\n(O2 ^name move-to-food ^direction south)\n(O4 ^name move-to-food ^direction west)\n(O3 ^name move-to-food ^direction north)\n(O1 ^name move-to-food ^direction east)\n</code></pre> <p>You can also use the mouse to print working memory objects by right clicking on an identifier. If you select the print option, you will see that there a many other options for printing objects in working memory.</p>"},{"location":"tutorials/soar_tutorial/02/#wmes","title":"wmes","text":"<p>The wmes command can also be used to print out individual working memory elements instead of complete objects. This command also prints out the timetag of an individual working memory element. This is a unique number that Soar uses to keep track of each working memory element.</p> <pre><code>red&gt; wmes o1\n(120: o1 ^name move-to-food)\n(121: o1 ^direction east)\n</code></pre> <p>Timetags can also be used as arguments in the print and wmes commands. Print will display all of the working memory elements that have the given timetag as their identifier, while wmes will display only the specified working memory element.</p> <pre><code>red&gt; print 120\n(O1 ^name move-to-food ^direction east)\n</code></pre> <pre><code>red&gt; wmes 120\n(120: o1 ^name move-to-food)\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#matches","title":"matches","text":"<p>One of the questions you will frequently want to ask is, \u201cWhat rules are about to fire?\u201d The matches command will return a list of all rules that are ready to fire, separated into those that will be operator applications (O Assertions), those that are will create I-support augmentations (I Assertions), and those that will remove I-supported augmentations (Retractions).</p> <pre><code>red&gt; matches\n\nO Assertions:\nI Assertions:\nRetractions:\n</code></pre> <p>Matches also can be invoked through the \u201cshow\u201d item on the menu list, or by right clicking on the interaction window, then selecting the production item on the menu that appears. Note; matches will not show rules that completely match, but have already fired. Thus, if you stop Soar after a rule has fired, matches alone will not show it.</p> <p>Matches can also take as an argument the name of a rule. It will then print out the rule, condition by condition, with information on how many working memory elements match that condition and are consistent with all of the variables in the previous conditions. When Soar loads in a rule, it automatically reorders the conditions of the rule so that it can efficiently match it, so the ordering of the conditions from matches will not be the same as the ordering of the rule when you wrote it.</p> <p>If a rule completely matches, then it has either already fired, or is about to fire.</p> <pre><code>red&gt; matches propose*move-to-food\n1 (state &lt;s&gt; ^io &lt;i*1&gt;)\n1 (&lt;i*1&gt; ^input-link &lt;i*2&gt;)\n1 (&lt;i*2&gt; ^my-location &lt;m*1&gt;)\n7 (&lt;m*1&gt; ^&lt;dir&gt; &lt;d*1&gt;)\n3 (&lt;d*1&gt; ^content { &lt;&lt; normalfood bonusfood &gt;&gt; &lt;c*1&gt; })\n3 complete matches.\n</code></pre> <p>In this example, the first three conditions have a single match, and then the fourth condition matches seven different working memory elements. These are all of the augmentations of my-location. The final condition then restricts the matches to be only those that have content normalfood or bonusfood.</p> <p>If a rule does not completely match, the condition that failed to match will be preceded by <code>&gt;&gt;&gt;&gt;</code> as in:</p> <pre><code>red&gt; matches apply*move-to-food*remove-move\n1 (state &lt;s&gt; ^operator &lt;o*1&gt;)\n1 (&lt;o*1&gt; ^name move-to-food)\n1 (&lt;s&gt; ^io &lt;i*1&gt;)\n1 (&lt;i*1&gt; ^output-link &lt;out&gt;)\n1 (&lt;out&gt; ^move &lt;move&gt;)\n&gt;&gt;&gt;&gt; (&lt;move&gt; ^status complete)\n0 complete matches.\n</code></pre> <p>Matches can also print out working memory elements that match the conditions by using the <code>--timetags</code> (for just the timetags) or <code>-\u2013wmes</code> (for complete working memory elements) arguments. Matches can be invoked by clicking with the right mouse button on the name of a production and then selecting \u201cproduction\u201d from the menu that appears.</p>"},{"location":"tutorials/soar_tutorial/02/#preferences","title":"preferences","text":"<p>There is a special command to print out the preferences for selecting an operator. This command also works for any working memory element (prior versions of Soar allowed preferences for all working memory elements and there are still vestiges of them in the current version). To use the preference command, you give an identifier and an attribute. Soar will then print out all of the preferences for all values of that identifier attribute pair. For example, to print out all of the preferences for the operator attribute:</p> <pre><code>red&gt; preferences s1 operator\nPreferences for S1 ^operator:\nacceptables:\nO7 (move-to-food) +\nO8 (move-to-food) +\nO9 (move-to-food) +\nunary indifferents:\nO7 (move-to-food) =\nO8 (move-to-food) =\nO9 (move-to-food) =\n</code></pre> <p>This example shows that there are three operators proposed (O7, O8, O9), and each one has an acceptable and indifferent preference.</p> <p>The preferences command has another feature that makes it extremely useful. Using the <code>--name</code> argument, it will tell you the name of the production that created the preference. For example, if you want to discover why there is the working memory element <code>(I3 move m3)</code>, you can type:</p> <pre><code>red&gt; preferences I3 move --names\nPreferences for I3 ^move:\nacceptables:\nM3 +\nFrom apply*move-to-food\n</code></pre> <p>This tells you that apply*move-to-food creates this working memory element. If you want to find out what working memory elements matched apply*move-to-food when it created <code>(I3 move m3)</code>, you can type:</p> <pre><code>red&gt; preferences I3 move --wmes\nPreferences for I3 ^move:\nacceptables:\nM3 +\nFrom apply*move-to-food\n(212: S1 ^operator O8)\n(205: O8 ^name move-to-food)\n(206: O8 ^direction north)\n(3: S1 ^io I1)\n(5: I1 ^output-link I3)\n</code></pre> <p>You can also invoke preferences by clicking with the right mouse button on an attribute of a working memory element in the interaction window. Select the preferences command from the menu that appears and then select the appropriate preferences command.</p>"},{"location":"tutorials/soar_tutorial/02/#semantic-errors","title":"Semantic Errors","text":"<p>In this section you will use the techniques from the prior section to fix semantic errors. In a rule-based system, semantic errors have three general results:</p> <ol> <li>A rule does not fire when it should.</li> <li>A rule fires when it shouldn\u2019t.</li> <li>The action of the rule is incorrect.</li> </ol> <p>Unfortunately, when you have an error, you don\u2019t know which type it is. Luckily, there are general techniques for finding all types of semantic errors.</p> <p>The first, and most important, step in finding semantic errors is knowing what you think the program should be doing at each step. Only by knowing what the program should do, will you be able to detect when it does something wrong. Usually you will notice that the wrong operator is selected, or that no operator is selected (a substate is created).</p> <p>I\u2019ve created a file called \u201csemantic-errors.soar\u201d in the \u201cAgents\\Eaters\\Tutorial\u201d directory for move-to-food that has some bugs. Create an eater with this file and also open the file in a text editor so you can modify as we go along. You should expect that propose*move-to-food to fire during the first step, so be bold and click on the step button and see what happens. You should get a trace like:</p> <pre><code>red&gt; ***\n0: ==&gt;S: S1\n1: ==&gt;S: S2 (state no-change)\n</code></pre> <p>This clearly indicates that proposemove-to-food did not fire. To find out why, try matches proposemove-to-food.</p> <pre><code>red&gt; matches propose*move-to-food\n1 (state &lt;s&gt; ^io &lt;i*1&gt;)\n1 (&lt;i*1&gt; ^input-link &lt;i*2&gt;)\n1 (&lt;i*2&gt; ^my-location &lt;m*1&gt;)\n7 (&lt;m*1&gt; ^&lt;dir&gt; &lt;d*1&gt;)\n&gt;&gt;&gt;&gt; (&lt;d*1&gt; ^contant { &lt;&lt; normalfood bonusfood &gt;&gt; &lt;c*1&gt; })\n0 complete matches.\n</code></pre> <p>There is a problem with the last condition. You can examine working memory to find out what it should be matching and after some examination, you should realize that the name of the attribute should be \u201ccontent\u201d, not \u201ccontant\u201d. Change the rule in the file. If you have been using Visual-Soar, it would have found this error while you were creating the Eater. To avoid destroying and creating a new eater, you can just reload the rules by clicking on the Commands menu of the Interaction Window and selecting \u201cReload Productions\u201d. Now you can try going one step again. You should have the following in your interaction window:</p> <pre><code>red&gt; ***\n0: ==&gt;S: S1\n1: O: O1 (move-to-food)\n</code></pre> <p>At this point, you can check which rules are about to fire by using the matches command.</p> <pre><code>red&gt; matches\nO Assertions:\napply*move-to-food\nI Assertions:\nRetractions:\n</code></pre> <p>That looks fine, so take one more step. Unfortunately, the eater doesn\u2019t move. What\u2019s the problem? You should examine the output-link to see if the move command was correctly created:</p> <pre><code>red&gt; print --depth 2 i3\n(I3 ^moves M1)\n(M1 ^direction east)\n</code></pre> <p>Unfortunately, you have to inspect this structure and realize that the command it creates is \u201cmoves\u201d not \u201cmove\u201d. Correct this, reload, and take another step. Now the eater moves and runs appropriately.</p>"},{"location":"tutorials/soar_tutorial/02/#generalized-move-operator","title":"Generalized Move Operator","text":"<p>The move-to-food operator you created in the last section would get stuck when there was no food in the cells adjacent to the eater. It also did not prefer bonusfood to normalfood. In this section, you will generalize the move-to-food operator to be an operator that can move to a cell with any type of content. Once you have created such a generalized move operator, we will introduce additional preferences that allow you to create a greedy eater that never gets stuck.</p>"},{"location":"tutorials/soar_tutorial/02/#move-operator-proposal","title":"Move Operator Proposal","text":"<p>The proposal for the move operator needs to test that there is an adjacent square that it can move into. It should not propose moving into a wall. There are two possible approaches to write this test. The first is to test all of the content values that are ok to move into: normalfood, bonusfood, eater, or empty. The second is to test that the content does not equal wall. Taking the first approach gives us the following English version of the proposal:</p> <pre><code># Propose*move*1:\n# If there is normalfood, bonusfood, eater, or empty in an adjacent cell,\n# propose move in the direction of that cell\n# and indicate that this operator can be selected randomly.\n</code></pre> <p>It is straightforward to translate this into Soar based on the move-to-food operator proposal:</p> <pre><code>sp {propose*move*1\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content\n\n&lt;&lt; empty normalfood bonusfood eater &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^direction &lt;dir&gt;)}\n</code></pre> <p>Although this is adequate, it will make future selection rules simpler if the operator also contains the contents of the cell. Thus, an alternative version is:</p> <pre><code># Propose*move*1a:\n# If there is normalfood, bonusfood, eater, or empty in an adjacent cell,\n# propose move in the direction of that cell, with the cell\u2019s content,\n# and indicate that this operator can be selected randomly.\n</code></pre> <p>To translate this into Soar requires matching the cell\u2019s content to a variable and then using that variable in the action as an augmentation of the operator, such as <code>^content &lt;content&gt;</code>. However, the value is already matched by &lt;&lt; empty normalfood bonusfood eater &gt;&gt;. What is needed is a way to match both a variable and the list at the same time. In Soar this is done by surrounding the two (or more) things to match against the same item with curly braces: \u201c{ }\u201d. Thus, the Soar version of the proposal becomes:</p> <pre><code>sp {propose*move*1a\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content\n{ &lt;content&gt; &lt;&lt; empty normalfood bonusfood eater &gt;&gt; })\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^direction &lt;dir&gt;\n^content &lt;content&gt;)}\n</code></pre> <p>Although this rule is adequate, it forces you to list all of the contents except walls. This rule will have to be changed if we ever add other types of food (e.g., superbonusfood). It might be better to write a rule that tests that the content is not equal to wall. This can be done in Soar by using \u201c&lt;&gt;\u201d. The not equal test can also be combined with the variable as in propose*move*1a, giving the following rule:</p> <pre><code>sp {propose*move*2a\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content\n{ &lt;content&gt; &lt;&gt; wall })\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^direction &lt;dir&gt;\n^content &lt;content&gt;)}\n</code></pre> <p>The \u201c&lt;&gt;\u201d must be placed directly before the value it compares, and in the example above, it is correctly before wall. The rule can also be written with the variable after the test that the content is not equal to wall:</p> <pre><code>sp {propose*move*2a\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content\n{ &lt;&gt; wall &lt;content&gt; })\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^direction &lt;dir&gt;\n^content &lt;content&gt;)}\n</code></pre> <p>The not equal test can also be used with variables. For example, if you want to test that the content of the cells to the north and south of the eater are not equal, you could use the following conditions:</p> <pre><code>(state &lt;s&gt; ^io.input-link.my-location &lt;my-loc&gt;)\n(&lt;my-loc&gt; ^north.content &lt;north&gt;\n^south.content &lt;&gt; &lt;north&gt;)\n</code></pre> <p>If you wanted to match the contents of both the north and south cells for use in the action, you could use the following conditions:</p> <pre><code>(state &lt;s&gt; ^io.input-link.my-location &lt;my-loc&gt;)\n(&lt;my-loc&gt; ^north.content &lt;north&gt;\n^south.content { &lt;south&gt; &lt;&gt; &lt;north&gt; })\n</code></pre> <p>Remember, the not equal test, \u201c&lt;&gt;\u201d, must directly precede the symbol or variable it refers to. Soar also has tests for greater than (&gt;), less than (&lt;), greater than or equal to (&gt;=), and less than or equal to (&lt;=). These can be used when matching numbers and also precede the value they refer to. For example, to test that the eater\u2019s score is greater than 25, the following condition can be used. <code>(state &lt;s&gt; ^io.input-link.eater.score &gt; 25)</code></p>"},{"location":"tutorials/soar_tutorial/02/#move-operator-application","title":"Move Operator Application","text":"<p>This application rule for the move operator is a copy of the move-to-food operator application. The English and Soar versions are the same except for the name of the operator:</p> <pre><code># Apply*move\n# If the move operator for a direction is selected,\n# generate an output command to move in that direction.\n</code></pre> <pre><code>sp {apply*move\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name move\n^direction &lt;dir&gt;)\n--&gt;\n(&lt;out&gt; ^move.direction &lt;dir&gt;)}\n</code></pre> <pre><code># Apply*move*remove-move:\n# If the move operator is selected,\n# and there is a completed move command on the output link,\n# then remove that command.\n</code></pre> <p>.</p> <pre><code>sp {apply*move*remove-move\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator.name move)\n(&lt;out&gt; ^move &lt;direction&gt;)\n(&lt;direction&gt; ^status complete)\n--&gt;\n(&lt;out&gt; ^move &lt;direction&gt; -)}\n</code></pre> <p>The proposal rule together with these two rules will give you an eater that randomly moves around, avoiding walls. We can greatly improve its behavior by using more preferences.</p>"},{"location":"tutorials/soar_tutorial/02/#move-operator-selection","title":"Move Operator Selection","text":"<p>To improve the performance of the eater, we can add rules that prefer moving to bonusfood over normalfood or an empty cell and prefer moving to normalfood over moving into an empty cell or a cell with another eater. The preference language in Soar is rich enough to support a variety of ways of ordering the choices and we will explore different possibilities in this section.</p> <p>To get started, you need to create a rule to prefer bonusfood to normalfood or empty or an eater. The condition part of the rule must match against operator proposals, while the action part must prefer the operator that moves to the bonusfood. In English this would be:</p> <pre><code># Select*move*bonusfood-better-than-normalfood\n# If there is a proposed operator to move to a cell with bonusfood and\n# there is a second proposed operator to move to a cell that is empty or\n# has normalfood or another eater\n# prefer the first operator.\n``\n\nThe conditions of this operator must match against proposed operators\nbefore they have been selected. A proposed operator can be matched by\nmatching the acceptable preference for the operator, which is written in\nthe condition as the ^operator augmentation of the state, with a value\nfor the operator identifier, followed by a plus sign, \u201c+\u201d.\n(state &lt;s&gt; ^operator &lt;o&gt; +)\n\nAcceptable preferences are the only preferences that are added to\nworking memory. All of the other preferences (better, best, worse,\nworst, and reject) are not added to working memory. They are held in\npreference memory and persist as long as the rule instantiations that\ncreated them still match. They are not in working memory because there\nis little advantage to having them available for other rules to match\nagainst, whereas the acceptable preferences must be in working memory\nbecause they define what operators are candidates for selection.\n\nAn operator can be preferred by creating a *better* than preference and\nthe decision procedure will use that preference in determining which\noperator to select \u2013 it will never select an operator if it is worse\nthan another candidate operator, unless that candidate is rejected. In\naddition to the better preference, there is a *worse* preference that is\nexactly the opposite. In an action, the better preference is the greater\nthan sign: \u201c&gt;\u201d. It is used in the same place as an acceptable or\nindifferent preference, except that a variable that matched the\nidentifier of the better operator is put before the greater than sign,\nand the variable that matched the identifier of the worse operator is\nput after the greater than sign. Therefore, the Soar rule is as follows:\n\n```Soar\nsp {select*move*bonusfood-better-than-normalfood-empty-eater\n(state &lt;s&gt; ^operator &lt;o1&gt; +\n^operator &lt;o2&gt; +)\n(&lt;o1&gt; ^name move\n^content bonusfood)\n(&lt;o2&gt; ^name move\n^content &lt;&lt; normalfood empty eater &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o1&gt; &gt; &lt;o2&gt;)}\n</code></pre> <p>This rule will match two different proposed operators (operators with acceptable preferences), <code>&lt;o1&gt;</code> and <code>&lt;o2&gt;</code>. Both have name move, while one matches operators that move to bonusfood while the other will match operators that move to normalfood, empty squares, or squares with another eater.</p> <p>If there are adjacent cells with both bonusfood and normalfood, this rule will fire right after propose*move creates acceptable preferences, but during the same proposal phase so that it will influence the next operator selection. It will fire multiple times if there are multiple cells with bonusfood or normalfood. After these preferences are created, the decision procedure will gather them up to make a decision.</p> <p>You can use exactly the same approach to prefer moving to cells with normalfood over moving to empty cells or cells with eaters. Soar provides an alternative with the worst preference, which means don\u2019t select the operator unless there are no other choices. In this case, you can create worse preferences for operators that move the eater into an empty cell or a cell with another eater. With these additional preferences, operators that move into cells with bonusfood or normalfood will always be selected if they exist, and otherwise the eater will randomly select between moving into an empty cell or into a cell with another eater. The new selection rule can be written in English as:</p> <pre><code># Select*move*avoid-empty-eater\n# If there is a proposed operator to move to an empty cell or a cell with\n# another eater,\n# then avoid that operator.\n</code></pre> <p>Here we use the word avoid to mean that the operator will only be selected if there is nothing worse. A worst preference is written as a less than sign: \u201c&lt;\u201d. This is similar to a worse preference, except that there is no second variable that the first variable is compared to.</p> <pre><code>sp {select*move*avoid-empty-eater\n(state &lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move\n^content &lt;&lt; empty eater &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; &lt;)}\n</code></pre> <p>Just as there is a worst preference, there is also a best preference. The best preference means that an operator should be selected as long as there is no other operator better than it (or it is not worse than another operator is). Thus the meaning of best is a bit odd in that better preferences are more important than the best preferences and an operator with a best preference will not be selected if another operator is better than it.</p> <p>You could have used a best preference for a move into a cell with normalfood instead of using the worst preference. The move to normalfood would then be selected over a move to an empty cell or a cell with an eater. Select*move*bonusfood-better-than-normalfood-empty-eater will ensure that bonusfood is preferred to normalfood.</p> <pre><code># Select*move*prefer-normalfood\n# If there is a proposed operator to move to a cell with normalfood,\n# prefer that operator.\n</code></pre> <pre><code>sp {select*move*prefer-normalfood\n(state &lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move\n^content normalfood)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; &gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#summary-of-preferences","title":"Summary of Preferences","text":"<p>This section summarizes the meaning of the preferences presented earlier. There are two additional preferences (require and prohibit) that are only rarely used and are not covered in this tutorial, but are described in the Soar 8 Manual. The preferences can be thought of as a sequence of filters, processed in the following order.</p> <ul> <li> <p>Acceptable (+) An acceptable preference states that a value is a     candidatefor selection. Only values with an acceptable preference     have the potential of being selected. If there is only one value     with an acceptable preference, that value will be selected if it     does not also have a reject preference.</p> </li> <li> <p>Reject (-) A reject preference states that the value is not a     candidatefor selection. A value will not be selected if it has a     reject preference.</p> </li> <li> <p>Better (&gt;), Worse (&lt;) These preferences state that a value     should not be selected if the better value is a candidate. If the     better value does not have an acceptable preference, or is rejected,     the better/worse preference is ignored. Otherwise, the worse value     is removed from consideration. Better and worse are simple inverses     of each other, so that A better than B is equivalent to B worse than     A.</p> </li> <li> <p>Best (&gt;) A best preference states that the value should be     selected if it is not rejected, or if there is no other value better     than it. If a value is best (and not rejected, or worse than     another),it will be selected over any other value that is not also     best. If two values are best, then the remaining preferences (worst,     indifferent) will be examined to determine the selection. If a value     (that is not rejected) is better than a best value, the better value     will be selected. (This result is counter-intuitive, but allows     explicit knowledge about the relative worth of two values to     dominate knowledge of only a single value.)</p> </li> <li> <p>Worst (&lt;) A worst preference states that the value should be     selected only if there are no alternatives. A worst will only be     considered if the above preferences have not filtered the choices to     a single choice. In this case, any value with a worst preference     will be discarded, unless all of the values have worst preferences.</p> </li> <li> <p>Indifferent (=) An indifferent preference states that there is     positive knowledge that it does not matter which value is selected.     This may be a binary preference, to say that two values are mutually     indifferent, or a unary preference, to say that a single value is as     good or as bad a choice as other expected alternatives. Indifferent     preferences are used to signal that it does not matter which     operator is selected, which results in a random selection is made     from among the alternatives.</p> </li> </ul>"},{"location":"tutorials/soar_tutorial/02/#example-run","title":"Example Run","text":"<p>The following trace shows how Soar fires and retracts many rules in parallel, with operator proposals following selections.</p>"},{"location":"tutorials/soar_tutorial/02/#advanced-move-operator","title":"Advanced Move Operator","text":"<p>The eater you created in the last section will greedily consume food and never get stuck. However, its behavior doesn\u2019t always appear to be very intelligent, especially if it is surrounded by empty cells. The specific problem addressed in this section is that the eater will sometimes move randomly back and forth when it is surrounded by empty cells. That is clearly wasted effort and the eater should at least move to a cell different from the one it just came from. There are other approaches to improving the eater, such as having it test for food two spaces away, but the point of this section is to avoid moving back to the same cell, which will give you experience with creating persistent structures in working memory.</p> <p>In order for the eater to avoid moving back to the cell it just came from, the eater must remember which direction it moved to get to the current cell. That information is available as an augmentation of the move operator while the eater is moving, but it disappears, along with the operator, once the move is completed. What is needed is a persistent augmentation of the state that records the direction of the last operator. This direction can then be used to avoid moving in the opposite direction. You will need to change the operator proposal to avoid moving back to the prior cell and the operator application to record the direction of the prior cell. A further change is needed to initialize some data structures in working memory that will make it easy to determine the opposite of each direction, which is needed to avoid moving back to the last cell.</p> <p>In this section we start with the initialization rules, and then cover the operator application rules and operator proposals.</p>"},{"location":"tutorials/soar_tutorial/02/#initialization-opposite-directions","title":"Initialization: Opposite Directions","text":"<p>The rules that you will write for operator application and selection need to determine the opposite of the direction the eater moved last, because that is the direction that needs to be avoided. The easiest way to do this is to create a structure in working memory that contains each direction, and each direction has an attribute that is its opposite direction. This structure can be on the state and the following rule creates one possible structure that encodes this information:</p> <pre><code>sp {initialize*state*directions\n(state &lt;ss&gt; ^type state)\n--&gt;\n(&lt;ss&gt; ^directions &lt;n&gt; &lt;e&gt; &lt;s&gt; &lt;w&gt;)\n(&lt;n&gt; ^value north ^opposite south)\n(&lt;e&gt; ^value east ^opposite west)\n(&lt;s&gt; ^value south ^opposite north)\n(&lt;w&gt; ^value west ^opposite east)}\n</code></pre> <p>This is the first rule you\u2019ve seen where there is an action with multiple values <code>(&lt;n&gt; &lt;e&gt; &lt;s&gt; &lt;w&gt;)</code> for a single attribute (^direction). Each value can be written as individual actions; however, as a shortcut, all of the values can be listed following their common attribute.</p> <p>One might be tempted to have the values of ^direction be the symbols north, east, south, and west. However, these values cannot be further augmented with their opposites; only identifiers can have augmentations. It is not legal to have augmentations of the form: (north ^opposite south).</p> <p>Rules such as initializestatedirections are quite common in Soar program because they create fixed working memory structures. These structures simplify operators by making it possible to directly match relations such as opposite instead of having to write rules that are specific to each of the directions. This rule will fire during the first cycle when (s1 ^type state) is added to working memory. The structures it creates will have i-support because the rule conditions do not test an operator. However, the structures will never be removed because the conditions match throughout the life of the eater.</p>"},{"location":"tutorials/soar_tutorial/02/#advanced-move-operator-application","title":"Advanced Move Operator Application","text":"<p>Our planned extension to the move operator does not require any changes to the existing application rules. However, you must add two rules to maintain a memory of the last direction moved. One of the rules must create the memory by adding the persistent (o-supported) structure when an operator is applied, and one must remove the old value when the next operator is selected. (You may think that you could write a single rule that both creates the last-direction and removes any old value for last-direction, but then a second rule would have to be written to cover the initial situation when there is no existing last-direction.) Try to write the English and Soar versions of these two rules.</p> <pre><code># Apply*move*create*last-direction\n# If the move operator for a direction is selected,\n# create an augmentation called last-direction with that direction.\n\nsp {apply*move*create*last-direction\n(state &lt;s&gt; ^operator &lt;o&gt;)\n(&lt;o&gt; ^name move\n^direction &lt;direction&gt;)\n--&gt;\n(&lt;s&gt; ^last-direction &lt;direction&gt;)}\n</code></pre> <pre><code># Apply*move*remove*last-direction\n# If the move operator for a direction is selected,\n# and the last-direction is not equal to that direction,\n# then remove the last-direction.\n\nsp {apply*move*remove*last-direction\n(state &lt;s&gt; ^operator &lt;o&gt;\n^last-direction &lt;direction&gt;)\n(&lt;o&gt; ^direction &lt;&gt; &lt;direction&gt;\n^name move)\n--&gt;\n(&lt;s&gt; ^last-direction &lt;direction&gt; -)}\n</code></pre> <p>Since both of these rules test the current operator, their actions are persistent. The first rule creates an augmentation of the state with attribute ^last-direction. This augmentation will always contain the direction of the last operator applied by copying the direction from the move operator. The next rule removes the ^last-direction attribute if it does not equal the direction on the current operator by using a reject preference. These rules will fire during the operator application phase.</p> <p>Why can\u2019t you use an i-supported rule? Conceptually, you need the <code>^last-direction</code> augmentation to persist after the operator is no longer selected because it is going to be tested to select and apply the next operator. More pragmatically, Soar will automatically make the augmentation o-supported because it is created as part of an operator application.</p> <p>This section and the previous one demonstrate two different ways to create persistent structures in working memory. If the structure can persist throughout the life of the eater, you can use a rule that tests that the state exists and then creates the structure in working memory in the action. Whenever the structure must change during the life of the eater, you must use a pair of rules that are part of the application of an operator \u2013 one to add the structure when appropriate, and one to remove the structure when it is no longer appropriate.</p>"},{"location":"tutorials/soar_tutorial/02/#advanced-move-operator-proposal","title":"Advanced Move Operator Proposal","text":"<p>There are two ways to modify the proposal and selection rules so that the eater does not move backward. One requires modifying the proposal rule so that the operator is never proposed, and the second is to create a new selection rule that creates a preference that prevents the operator from being selected. We will look at both possibilities.</p> <p>In order to modify the proposal rule, recall the final move proposal:</p> <pre><code># Propose*move:\n# If the content of an adjacent cell is not a wall,\n# propose move in the direction of that cell, with the cell\u2019s content,\n# and indicate that this operator can be selected randomly.\n</code></pre> <p>A condition can easily be added that tests that the direction of the adjacent cell (<code>&lt;d&gt;</code>) is not equal to the opposite of the direction of the last move. However, this will not work for the first move when there is no direction for the last move because no operator has applied to create the memory of a previous move. An alternative is test that there does not exist an opposite of last direction that is equal to the direction of the adjacent cell. How is that different? The first tests that there does exist in working memory an augmentation of the state, but its value is not equal. The second tests that there does not exist in working memory an augmentation that is equal. The second one will be correct for the first move. Thus the revised English description is:</p> <pre><code># Propose*move*no-backward:\n# If there is normalfood, bonusfood, eater, or empty in an adjacent cell,\n# and there is no last direction equal to the opposite direction for that cell,\n# propose move in the direction of that cell, with the cell\u2019s content,\n# and indicate that this operator can be selected randomly.\n</code></pre> <p>To test for the absence of an augmentation, Soar uses a dash, \u201c-\u201c. The dash, called negation, precedes the augmentation that must not be in working memory for the rule to match. The new proposal rule is as follows:</p> <pre><code>sp {propose*move*no-backward\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.content { &lt;co&gt; &lt;&gt;\nwall }\n^directions &lt;d&gt;\n\n-^last-direction &lt;o-dir&gt;)\n(&lt;d&gt; ^value &lt;dir&gt;\n^opposite &lt;o-dir&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^direction &lt;dir&gt;\n^content &lt;co&gt;)}\n</code></pre> <p>A negation can also precede a complete object, where the identifier is followed by multiple attribute-values. In that case, its is a test that there is no object with all of those attributes in working memory. The semantics of using negation can be a bit tricky and the details of it are spelled out in the manual.</p>"},{"location":"tutorials/soar_tutorial/02/#advanced-move-operator-selection","title":"Advanced Move Operator Selection","text":"<p>The alternative to modifying the proposal rule is to add a rule that eliminates from consideration any operator that moves opposite to the last direction. This requires a new preference, called reject, represented by a dash, \u201c-\u201c. This is different from the operator application action that is also called rejection because that rejection removes a working memory element. When a reject preference is created for an operator, the decision procedure will not select that operator, no matter which other preferences have been created. However, the reject preference will be retracted when the rule that creates it no longer fires, allowing the rejected operator to be selected when the situation changes. Reject is used when an operator should not be selected for the current situation even if there are no other options. In contrast, a worst preference is used when an operator can be selected, but only if there are no better options.</p> <p>One side effect of reject is that it disables better/worse preferences where the rejected operator is better than some other operator. Normally, that other operator would not be selected, but if the better operator is rejected, the better/worse preference is ignored.</p> <p>Try writing both English and Soar versions of this rule.</p> <pre><code># Select*move*reject*backward\n# If there is a proposed operator to move in the direction\n# opposite the last move,\n# reject that operator.\n\nsp {select*move*reject*backward\n(state &lt;s&gt; ^operator &lt;o&gt; +\n^directions &lt;d&gt;\n^last-direction &lt;dir&gt;)\n(&lt;d&gt; ^value &lt;dir&gt;\n^opposite &lt;o-dir&gt;)\n(&lt;o&gt; ^name move\n^direction &lt;o-dir&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; -)}\n</code></pre> <p>Note that this rule will not reject the proposed operator for the first move because the attribute ^last-direction will not initially exist.</p>"},{"location":"tutorials/soar_tutorial/02/#jump-operator","title":"Jump Operator","text":"<p>All of the eaters you\u2019ve created so far have a single type of operator: move. In many situations, more than one instance of the operator is created, but still, there was only one operator. Adding operators does not change the way Soar operates, but it does give you a chance to use what you\u2019ve learned on a slightly different problem. In this section, you are going to write the jump operator. An eater can jump over a cell to a cell two moves away; however, a jump costs the eater 5 points (the same as it gains from a normalfood). The eater can jump over a wall, but it cannot jump into a cell with a wall.</p> <p>In writing the jump operator, you should write and test the proposal and application rules without including the move operator. This will let you debug the jump rules first, without getting things mixed up with the rules for the move operator. You should then write operator selection rules and combine your jump operator with the move operator. In writing the jump operator, you will want to use the initialization rule for directions from the previous section, so you will want to copy that to your file in which you are writing the jump operator.</p> <p>The rest of this section goes through the rules for jump. If you feel confident in your knowledge of the aspects of Soar that have been presented so far, you should try to write your own jump operator before reading this section. As you are writing your own jump operator, you should try to reuse or generalize some of the rules you wrote for the move operator. You might find it is a bit tricky for your eater to correctly keep track of the previous direction it moved or jumped. If you get stuck, or are unsure about what to do, you should read these sections.</p> <p>After you finish this section, you can try your own strategies by creating different eaters with different control knowledge. You can even have contests between them to see which strategies work best.</p>"},{"location":"tutorials/soar_tutorial/02/#jump-operator-proposal","title":"Jump Operator Proposal","text":"<p>There are only two differences between the proposal for the move operator and the jump operator.</p> <ul> <li> <p>The first difference is that the name of the operator should be     jump, not move.</p> </li> <li> <p>The second is that instead of testing that an adjacent cell does not     contain a wall, the jump operator needs to test that a cell two     moves away in a direction does not contain a wall. This is easy to     add because every cell has the same four directional pointers, so     the desired cell can be tested via the direction augmentation on the     adjacent cell: instead of just <code>&lt;dir&gt;</code> use <code>&lt;dir&gt;</code>.<code>&lt;dir&gt;</code> which     tests two steps in the same direction because the same directional     pointer must match both uses of <code>&lt;dir&gt;</code>.</p> </li> </ul> <p>In these examples, we will use the proposal that does not test for the absence of backward moves. We will include that in the selection knowledge. Thus the English version is:</p> <pre><code># Propose*jump:\n# If the content of a cell two steps away in a direction is not a wall,\n# propose jump in the direction of that cell, with the cell\u2019s content,\n# and indicate that this operator can be selected randomly.\n\nsp {propose*jump\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.&lt;dir&gt;.content\n{ &lt;content&gt; &lt;&gt; wall })\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name jump\n^direction &lt;dir&gt;\n^content &lt;content&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#jump-operator-application","title":"Jump Operator Application","text":"<p>The application of jump is exactly the same as the application of move, except that the jump name must be issued instead of a move. Instead of creating a new rule for each operator, you can reuse and generalize the original operator application rules by allowing them to match an operator named either move or jump, and then copying the operator name to the output link.</p> <pre><code># Apply*move*jump\n# If the move or jump operator for a direction is selected,\n# generate an output name to move in that direction.\n\nsp {apply*move\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator &lt;o&gt;)\n(&lt;o&gt; ^name { &lt;name&gt; &lt;&lt; move jump &gt;&gt; }\n^direction &lt;dir&gt;)\n--&gt;\n(&lt;out&gt; ^&lt;name&gt;.direction &lt;dir&gt;)}\n</code></pre> <pre><code># Apply*move*jump*remove-name:\n# If the move or jump operator is selected,\n# and there is a completed action (&lt;name&gt;) on the output link,\n# then remove that name.\n\nsp {apply*move*remove-move\n(state &lt;s&gt; ^io.output-link &lt;out&gt;\n^operator.name &lt;name&gt;)\n(&lt;out&gt; ^&lt;name&gt; &lt;direction&gt;)\n(&lt;direction&gt; ^status complete)\n--&gt;\n(&lt;out&gt; ^&lt;name&gt; &lt;direction&gt; -)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#simplified-operators","title":"Simplified Operators","text":"<p>In writing the operator application rules for the jump operator, you have probably noticed that both operators include a rule to create the action command (move or jump) on the output-link, and then remove that command when it has completed. You can simplify the writing of future operators by writing two general rules that perform these functions for every operator that performs external actions.</p> <p>The first rule creates the action command on the output-link. To make this a completely general rule, you need to have a standard way of representing action commands on operators so that a single rule can create the commands on the output-link. The simplest convention is to have the action command be an augmentation of the operator, such as: <code>^jump.direction &lt;direction&gt;</code>. Another possibility would be to have a specific augmentation on the operator, say ^actions, that had the commands as subobjects:</p> <pre><code>(&lt;o&gt; ^actions.jump.direction &lt;direction1&gt;)\n</code></pre> <p>You probably want to adopt this second approach because it makes it possible to write a single rule that copies the action commands to the output-link without risk of copying other augmentations. Under that convention, the general command creation rule is:</p> <pre><code>sp {apply*operator*create-action-command\n(state &lt;s&gt; ^operator.actions.&lt;att&gt; &lt;value&gt;\n^io.output-link &lt;out&gt;)\n--&gt;\n(&lt;out&gt; ^&lt;att&gt; &lt;value&gt;)}\n</code></pre> <p>The <code>&lt;att&gt;</code> variable will match jump and the value will match the identifier of the object that has direction as an augmentation. It copies ^jump and that identifier on to the output-link.</p> <p>The second general rule removes a completed action command.</p> <pre><code>sp {apply*operator*remove-command\n(state &lt;s&gt; ^operator.actions\n^io.output-link &lt;out&gt;)\n(&lt;out&gt; ^&lt;att&gt; &lt;value&gt;)\n(&lt;value&gt; ^status complete)\n--&gt;\n(&lt;out&gt; ^&lt;att&gt; &lt;value&gt; -)}\n</code></pre> <p>With these rules included in an Eater, both the move and the jump operator require only proposals (except when other actions are performed, such as remembering prior moves). To use both of these rules, you need to modify the proposal rules so that they create the actions structure. Below is an example of the jump operator proposal.</p> <pre><code>sp {propose*jump\n(state &lt;s&gt; ^io.input-link.my-location.&lt;dir&gt;.&lt;dir&gt;.content\n{ &lt;content&gt; &lt;&gt; wall })\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name jump\n^actions.jump.direction &lt;dir&gt;\n^content &lt;content&gt;)}\n</code></pre> <p>Rules like this simplify the writing of Soar programs by creating conventions; however these conventions also restrict what can be written in a Soar program. For example, if this rule is used in a Soar program, then the status complete augmentation will always be removed and will not be available for other rules to test. For this domain, it doesn\u2019t seem like that will be a problem, and it might not be for others as well. It is just that before creating a rule that applies to all operators, you should be careful. Throughout this tutorial you will see additional rules that are used to simplify the writing of programs. We have tried to be careful in selecting these types of rules.</p>"},{"location":"tutorials/soar_tutorial/02/#jump-operator-selection","title":"Jump Operator Selection","text":"<p>There are many strategies for selecting jump operators. One simple strategy is to prefer operators that jump into cells with bonusfood to operators that move into empty cells, while rejecting operators that jump into empty cells. We can generalize some of the rules for move to cover both jump and move.</p> <pre><code>sp {select*move*bonusfood-better-than-normalfood-empty-eater\n(state &lt;s&gt; ^operator &lt;o1&gt; +\n^operator &lt;o2&gt; +)\n(&lt;o1&gt; ^name { &lt;&lt; jump move &gt;&gt; &lt;name&gt; }\n^content bonusfood)\n(&lt;o2&gt; ^name &lt;name&gt;\n^content &lt;&lt; normalfood empty eater &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o1&gt; &gt; &lt;o2&gt;)}\n</code></pre> <pre><code>sp {select*jump*bonusfood-better-than*move*empty\n(state &lt;s&gt; ^operator &lt;o1&gt; +\n^operator &lt;o2&gt; +)\n(&lt;o1&gt; ^name jump\n^content bonusfood)\n(&lt;o2&gt; ^name move\n^content empty)\n--&gt;\n(&lt;s&gt; ^operator &lt;o1&gt; &gt; &lt;o2&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/02/#jump-and-move-operator-selection","title":"Jump and Move Operator Selection","text":"<p>In order to cover all of the cases of move and jump operators for all of the different cell contents, you would need to write lots of rules. Is there an easier way? One way is to translate the different names and contents into numbers that correspond to the number of points the eater will get. A rule could then compare the numbers and create better preferences for operators with higher numbers. You can translate the names and contents into numbers by writing one rule for each name and content pair; however, it is much easier to create a structure in working memory with the information and have a general rule match against it and do the translation. This is similar to the way opposite directions were computed.</p> <p>The first rule to write is the one that creates the structure in working memory. It needs to include an object for each pair of name and content, and for each pair, the expected value to the eater.</p> <pre><code>sp {init*elaborate*name-content-value\n(state &lt;s&gt; ^type state)\n--&gt;\n(&lt;s&gt; ^name-content-value &lt;c1&gt; &lt;c2&gt; &lt;c3&gt; &lt;c4&gt;\n\n&lt;c5&gt; &lt;c6&gt; &lt;c7&gt; &lt;c8&gt;)\n(&lt;c1&gt; ^name move ^content empty ^value 0)\n(&lt;c2&gt; ^name move ^content eater ^value 0)\n(&lt;c3&gt; ^name move ^content normalfood ^value 5)\n(&lt;c4&gt; ^name move ^content bonusfood ^value 10)\n(&lt;c5&gt; ^name jump ^content empty ^value -5)\n(&lt;c6&gt; ^name jump ^content eater ^value -5)\n(&lt;c7&gt; ^name jump ^content normalfood ^value 0)\n(&lt;c8&gt; ^name jump ^content bonusfood ^value 5)}\n</code></pre> <p>To compare two operators, you can write a rule that matches the operators and the name-content-value structure, but it is easier to understand the reasoning if you break it into two rules. The first rule matches each operator and the appropriate name-content-value and copies the value onto the operator.</p> <pre><code>sp {elaborate*operator*value\n(state &lt;s&gt; ^operator &lt;o&gt; +\n^name-content-value &lt;ccv&gt;)\n(&lt;o&gt; ^name &lt;name&gt; ^content &lt;content&gt;)\n(&lt;ccv&gt; ^name &lt;name&gt; ^content &lt;content&gt; ^value &lt;value&gt;)\n--&gt;\n(&lt;o&gt; ^value &lt;value&gt;)}\n</code></pre> <p>Now you can write a rule that compares the values associated with each operator and then creates a better preference for the operators with higher values.</p> <pre><code>sp {select*compare*best*value\n(state &lt;s&gt; ^operator &lt;o1&gt; +\n^operator &lt;o2&gt; +)\n(&lt;o1&gt; ^value &lt;v&gt;)\n(&lt;o2&gt; ^value &lt; &lt;v&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o1&gt; &gt; &lt;o2&gt;)}\n</code></pre> <p>During a run, the first rule will fire for every proposed operator, and the second rule will fire for every pair of operators with different values. All of these firings, including the proposals of the operators, happen during the proposal phase.</p>"},{"location":"tutorials/soar_tutorial/02/#advanced-eaters","title":"Advanced Eaters","text":"<p>If you want to build more complex eaters, here are a few ideas. You will find it easier to build some of these after you complete the next part of the tutorial.</p> <ol> <li>An eater that chases another eater.</li> <li>An eater that tries to stay away from other eaters.</li> <li>An eater that systematically searches for food when empty cells     surround it.</li> <li>An eater that looks ahead to see what move would be better based on     what surrounds the cell it is going to move into.</li> <li>An eater that takes advantage of the fact that bonus food comes in     vertical lines, each 4 cells apart.</li> </ol>"},{"location":"tutorials/soar_tutorial/02/#top-state-structure","title":"Top-state Structure","text":"<p>This page has a summary of the structure of the top-state for every eater. It is a useful reference when you build your own eaters and you will probably want to make a copy of it. All of the attributes of an object appear below it in outline form, with indentation used to signify sub-objects. Possible values are listed on the same line as the attribute.</p> <pre><code>^io\n^input-link\n^eater\n^direction east/north/south/west\n^name red/blue/yellow/green/purple/black\n^score 0-1000\n^x 1-15\n^y 1-15\n^my-location\n^content bonusfood/normalfood/eater/empty/wall\n^east\n^content bonusfood/normalfood/eater/empty/wall\n\n...\n^north\n^content bonusfood/normalfood/eater/empty/wall\n\n...\n^south\n^content bonusfood/normalfood/eater/empty/wall\n\n...\n^west\n^content bonusfood/normalfood/eater/empty/wall\n\n...\n^output-link\n^move\n^direction east/north/south/west\n^status complete - created by Soar as feedback\n^jump\n^direction east/north/south/west\n^status complete - created by Soar as feedback\n^superstate nil\n^type state\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/03/#part-iii-subgoals","title":"Part III: Subgoals","text":"<p>This part of the tutorial will teach you to build Soar programs that use subgoals to dynamically decompose complex problems into simpler problems. This part starts with a description of TankSoar. This is followed by an exercise where you will build a simple tank that wanders about. From there, subgoals and high-level operators are developed. The intermediate sections teach you to write high-level operators. The end concentrates on refinements of these operators so that your tank is more effective.</p> <p>You should use VisualSoar in developing your tank. The release includes default datamaps for the input and output links so that you do not have to define them yourself. You use them by opening the default project and then using the SAVE AS feature in Visual Soar to save the project under a new name. You will need to modify the datamap and included rules to use the new name of your tank (if you desire).</p>"},{"location":"tutorials/soar_tutorial/03/#tanksoar","title":"TankSoar","text":"<p>TankSoar is similar to Eaters in that your Soar program will control a tank in a grid-based world with walls. However, in TankSoar, your tank has many more sensors and many more actions than the eaters did. There are also more interactions between tanks (they shoot at each other), and all of these factors mean that the TankSoar programs can be much more complicated than those you developed for Eaters.</p> <p>Below is an example of the main map in TankSoar.</p>"},{"location":"tutorials/soar_tutorial/03/#installing-and-playing-tanksoar","title":"Installing and Playing TankSoar","text":"<p>To launch TankSoar, open the directory where you installed it and launch the appropriate script file (TankSoar.bat on Windows, TankSoar.sh on Mac or Linux)</p> <p>Within the top level folder, there will be an \u201cAgents\\TankSoar\\Tutorial\u201d directory, which is where you will create directories and files for Soar tanks. (If you installed the stand-alone version of TankSoar rather than the full tutorial, this directory will simply be \u201cAgents\\Tutorial\u201d).</p> <p>After starting TankSoar, you will have a new window on your computer screen:</p> <p>This is the TankSoar environment for creating tanks and controlling the game.</p> <p>Tanks are created, modified and destroyed much as the Eaters were in Part 2 of this Tutorial: Press the \u201cNew\u201d button in the \u201cAgents\u201d area of the TankSoar game and follow the dialogs to select productions that will be loaded when a Tank is created.</p>"},{"location":"tutorials/soar_tutorial/03/#tank-resources","title":"Tank Resources","text":"<p>Each tank has three resources. A summary of these is shown, along with a score, for each tank to the right of the Map window.</p> <ul> <li> <p>Health     A tank has a maximum of 1000 health points, and dies when its health     goes to 0. When a tank dies, it is resurrected at a random open     square with the initial values of all of its resources (health=1000,     energy=1000, missiles=15). When created, a tank has 1000 health     points. If a missile hits a tank while its shields are down, its     health decreases by 400. A tank's health is increased when it sits     on a healthcharger at a rate of 150 per turn.</p> </li> <li> <p>Energy     A tank has a maximum of 1000 energy points. A tank's energy is     decreased when it uses its radar (proportional to the range it has     set the radar) or when it uses its shields (20 units per turn). A     tank's energy is increased when it sits on an energycharger at a     rate of 250 per turn. A tank's energy is decreased by 250 if it is     hit by a missile while its shields are up. If a tank\u2019s energy goes     to 0, it will not be able to use its radar or shields until it     recharges (or dies).</p> </li> <li> <p>Missiles     A tank starts off with 15 missiles. A tank's supply of missiles is     increased by 7 when it picks up a pack of missiles. A tank's supply     of missiles is decreased by one each time it fires a missile.</p> </li> </ul>"},{"location":"tutorials/soar_tutorial/03/#tank-primary-sensors","title":"Tank Primary Sensors","text":"<p>A tank has six primary sensors for perceiving its world. All of these sensors are always active, except the radar sensor, which must be turned on to use. The information from these sensors is made available to a tank on the input-link. The structure of the input-link augmentation is shown for each sensor.</p> <ul> <li> <p>Blocked sensor     The blocked sensor detects whether the squares immediately adjacent     to a tank are blocked or open (yes=blocked, no=open). A square can     be blocked by an obstacle or by another tank, but the blocked sensor     gives no information to distinguish between these cases. The blocked     sensor will be updated on the input link (\u201cblink\u201d) even if the tank     doesn\u2019t move or if the sensor does not otherwise change.</p> <pre><code>^blocked\n^backward yes/no\n^forward yes/no\n^left yes/no\n^right yes/no\n</code></pre> </li> <li> <p>Incoming sensor     The incoming sensor detects whether there is a missile approaching a     tank at any distance, unless the missile is on the other side of an     obstacle or tank. It does not detect a tank's own missiles.</p> <pre><code>^incoming\n^backward yes/no\n^forward yes/no\n^left yes/no\n^right yes/no\n</code></pre> </li> <li> <p>Radar sensor</p> <p>The radar is functional when a tank has turned the radar on and has enough energy to power it. This sensor detects objects in front of the tank in a column that is three squares wide. The distance d which the radar can see is either the current radar setting or the number of squares between the tank and the closest blocking object (i.e. tank or obstacle) in front of it, whichever is lower. The objects visible on the radar are those that are a distance of d squares or less away from the tank directly in front of it, directly in front of one square to the left of it, and directly in front of one square to the right of it. Radar also picks up any objects directly to the right or left of the tank. Additionally, if the effective distance is greater than d, i.e. the radar is being blocked by an object, then the object(s) d+1 squares directly in front of this tank is also visible on the radar. Multiple objects in the same square are visible if their square is visible. The information returned about visible objects is their type and where they were seen (e.g. an obstacle 5 squares in front on the left). If an object is a tank, then its color is also given.</p> <pre><code>^radar\n^energy\n^distance 0-d\n^position left/center/right\n^health\n^distance 0-d\n^position left/center/right\n^missiles\n^distance 0-d\n^position left/center/right\n^obstacle\n^distance 0-d\n^position left/center/right\n^open\n^distance 0-d\n^position left/center/right\n^tank\n^distance 0-d\n^position left/center/right\n^color red/blue/purple/\u2026\n</code></pre> </li> <li> <p>Rwaves sensor      The rwave sensor detects if the radar of another tank is detecting     the tank from the four directions.</p> <pre><code>^rwaves\n^backward yes/no\n^forward yes/no\n^left yes/no\n^right yes/no\n</code></pre> </li> <li> <p>Smell sensor      The smell sensors detects the closest tank, and provides information     on how close that tank is and what its color is. If there are two or     more tanks equally close, then one of them is chosen at random. The     distance is the number of cells in x and y between the two tanks     (Manhattan distance). Smell penetrates obstacles, so the smelled     tank may not be the tank that is closest to move to. If there are no     other tanks, the value of both color and distance will be none.</p> <pre><code>^smell\n^color none/red/blue/purple/\u2026\n^distance none/0-28\n</code></pre> </li> <li> <p>Sound sensor      The sound sensor detects the closest tank that moved during the last     decision, as long as that tank is currently 7 or less squares away.     If two or more tanks moved during the last decision and are equally     close, then the sensor chooses one randomly. If a tank is within 7     squares but did not move during the last decision, it will not make     a noise and will not be picked up by this sensor. The information     returned about the closest tank is the direction to move on the     shortest path toward the sensed tank. If there is more than one     possible direction, then the sensor chooses one randomly. If there     is no tank within 7 squares that moved, the sound sensor will have     value silent.</p> <pre><code>^sound silent/left/right/forward/backward\n</code></pre> </li> </ul> <p>You can select a tank by clicking on the tank in the Main Map Window. The sensors of the selected tank are shown to the right of the Map.</p>"},{"location":"tutorials/soar_tutorial/03/#tank-secondary-sensors","title":"Tank Secondary Sensors","text":"<p>In addition to the primary sensors, a tank has additional sensors that give it information about its own state. These sensors are available via the input-link and are always functional.</p> <ul> <li> <p>Clock</p> <p>Clock is initialized to 1 and is incremented each decision. It is a global counter for all tanks and thus, if a tank is created after others have run for a while, the initial value will not be 1. ^clock 1-N</p> </li> <li> <p>Direction</p> <p>The direction that the tank is facing: north, east, south, or west. It changes when the tank turns.</p> <pre><code>^direction north/east/south/west\n</code></pre> </li> <li> <p>Energy</p> <p>The current energy level. If energy is 0, the tank will not be able to use its radar or shields.</p> <pre><code>^energy 0-1000\n</code></pre> </li> <li> <p>Energy recharger</p> <p>If a tank is on an energy recharger (battery), this has value yes. Otherwise it is no.</p> <pre><code>^energyrecharger no/yes\n</code></pre> </li> <li> <p>Health</p> <p>The current health level. If health is 0, the tank dies and is resurrected at a random square.</p> <pre><code>^health 0-1000\n</code></pre> </li> <li> <p>Health recharger</p> <p>If a tank is on a health recharger, this has value yes. Otherwise it is no.</p> <pre><code>^healthrecharger no/yes\n</code></pre> </li> <li> <p>Missiles</p> <p>The number of missiles the tank currently has.</p> <pre><code>^missiles 0-N\n</code></pre> </li> <li> <p>My-color</p> <p>The color of the tank.</p> <pre><code>^my-color blue/red/purple/\u2026\n</code></pre> </li> <li> <p>Radar-distance</p> <p>The effective distance of the radar the last time it was used. This is the distance that the radar reached before it was blocked. If there were no obstacles, it will be the same as the radar-setting.</p> <pre><code>^radar-distance 1-14\n</code></pre> </li> <li> <p>Radar-setting</p> <p>Radar-setting is the distance that the radar has been set to using the radar-power output command.</p> <pre><code>^radar-setting 1-14\n</code></pre> </li> <li> <p>Radar-status</p> <p>Radar-status tells whether the radar is turned on or not.</p> <pre><code>^radar-status on/off\n</code></pre> </li> <li> <p>Random</p> <p>A random real number between 0 and 1. It changes every decision.</p> <pre><code>^random 0.0-1.0\n</code></pre> </li> <li> <p>Resurrected</p> <p>Whenever a tank dies and is resurrected, this has value yes.</p> <pre><code>^resurrected no/yes\n</code></pre> </li> <li> <p>Shield-status</p> <p>Shield-status tells whether the shields are turned on or not.</p> <pre><code>^shield-status on/off\n</code></pre> </li> <li> <p>X</p> <p>X is the x location on the map. X goes from 1 (left side) to 14 (right side).</p> <pre><code>^x 1-14\n</code></pre> </li> <li> <p>Y</p> <p>Y is the y location on the map. Y goes from 1 (top) to 14 (bottom).</p> <pre><code>^y 1-14\n</code></pre> </li> </ul>"},{"location":"tutorials/soar_tutorial/03/#tank-actions","title":"Tank Actions","text":"<p>A tank has several actions it can perform. All actions are performed by augmenting the output-link. All actions can be performed in parallel except for move and rotate.</p> <ul> <li> <p>Move      A tank can move forward, backward, left, or right. Moving is     mutually exclusive with rotating. If a tank tries to move but is     blocked, it remains where it is and loses 100 health units. A tank     may also move in no direction, which indicates a wait action.</p> <pre><code>^move.direction left/right/forward/backward/none\n</code></pre> </li> <li> <p>Rotate      A tank can rotate left or right. Rotating is mutually exclusive with     moving. A rotate will never fail (assuming the tank is neither     killed nor tries to simultaneously move).</p> <pre><code>^rotate.direction left/right\n</code></pre> </li> <li> <p>Fire      A tank can fire one missile per decision. Firing can be done in     conjunction with any other action. The missile is fired straight     ahead in the direction the tank is facing. Firing a missile     decreases a tank's missile supply by one, and it will fail if a tank     has no missiles. This failure will be reflected by the tank's     missile supply remaining zero.</p> </li> </ul> <p>\u00a7 <code>Soar     ^fire.weapon missile.</code></p> <ul> <li> <p>Radar      A tank can turn its radar on and off. Turning the radar on will fail     if a tank does not have enough energy to supply the radar. This     failure will be reflected in that ^radar-distance will adjust itself     to the highest actually attainable level.</p> <pre><code>^radar.switch on/off\n</code></pre> </li> <li> <p>Radar Range</p> <p>A tank can change the range of its radar by using the radar-power command. The value can be from 1 to 14. The higher the power setting of the radar, the more energy is used.</p> <pre><code>^radar-power.setting 1-14\n</code></pre> </li> <li> <p>Shields</p> <p>A tank can turn its shields on and off, and this can be done in conjunction with any other action. Turning shields on uses 20 energy units per decision. It will fail if a tank does not have enough energy. The failure will be reflected in that ^shield-status will be off.</p> <pre><code>^shields.switch on/off\n</code></pre> </li> </ul>"},{"location":"tutorials/soar_tutorial/03/#types-of-game-objects","title":"Types of Game Objects","text":"<p>The following are the objects that can appear on the map:</p> <ul> <li> <p> ObstaclesObstacles     Obstacles look like trees and they are there to get in the way. They     never move and they cannot be blown up. There will not be any part     of the playing field that is inaccessible purely due to wall     placement. (Part of the playing field could be temporarily     inaccessible due to a tank blocking the way.)</p> </li> <li> <p> HealthchargerHealthcharger     There is one healthcharger per map. The healthcharger never moves.     For each decision a tank stays on a healthcharger, its health is     increased by 150 minus and any damage it may incur by bumping into     something.</p> </li> <li> <p> EnergychargerEnergycharger     There is one energycharger (battery) per map. The energycharger     never moves. For each decision that a tank stays on an     energycharger, its energy is increased by 250 units minus whatever     energy it uses for its shields and/or radar.</p> </li> <li> <p> Packs of missilesPacks of     missiles     Packs of missiles are scattered around in random squares. They never     move of their own accord nor can they be moved. Missiles flying     through squares with packs of missiles do not hit those packs. Packs     of missiles are created at random locations and times. A tank can     pick up a pack of missiles by moving to its square. The pack of     missiles disappears and the tank's missile supply is increased by 7.</p> </li> <li> <p> TanksTanks     Tanks are controlled by TankSoar agents. They do fun stuff like fire     missiles and move around, as described above.</p> </li> </ul> <p>All objects take up only one square. Obstacles cannot exist in the same square as any other object. Both chargers will never be in the same square. A tank cannot be in the same square as a pack of missiles because it will pick up that pack. All other combinations of objects are allowed together in a square.</p> <p>Tanks will never spawn on top of energychargers, healthchargers, or missile packs.</p>"},{"location":"tutorials/soar_tutorial/03/#summary-of-input-link-and-output-link","title":"Summary of Input-link and Output-link","text":"<pre><code>^io\n^input-link\n^blocked\n^backward yes/no\n^forward yes/no\n^left yes/no\n^right yes/no\n^incoming\n^backward yes/no\n^forward yes/no\n^left yes/no\n^right yes/no\n^radar\n^energy\n^distance 0-13\n^position left/center/right\n^health\n^distance 0-13\n^position left/center/right\n^missiles\n^distance 0-13\n^position left/center/right\n^obstacle\n^distance 0-13\n^position left/center/right\n^open\n^distance 0-13\n^position left/center/right\n^tank\n^distance 0-13\n^position left/center/right\n^io\n^input-link\n^rwaves\n^backward yes/no\n^forward yes/no\n^left yes/no\n^right yes/no\n^smell\n^color none/red/blue/purple/\u2026\n^distance none/0-28\n^sound silent/left/right/\n\nforward/backward\n^clock 1-N\n^direction north/east/south/west\n^energy 0-1000\n^energyrecharger no/yes\n^health 0-1000\n^healthrecharger no/yes\n^missiles 0-N\n^my-color blue/red/purple/\u2026\n^radar-distance 1-14\n^radar-setting 1-14\n^radar-status on/off\n^random 0.0-1.0\n^resurrect no/yes\n^shield-status on/off\n^x 1-14\n^y 1-14\n^io\n^output-link\n^move.direction left/right/forward/backward/none\n^rotate.direction left/right\n^fire.weapon missile\n^radar.switch on/off\n^radar-power.setting 1-14\n^shields.switch on/off\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#tank-combat","title":"Tank Combat","text":"<p>A tank destroys another tank by hitting it with missiles. A missile can damage any tank it hits, even the tank that fired it (in the rare case a tank is killed and recreated in the path of its own missile). Missiles fly at about 1.3 times as fast as tanks move. A tank that is hit by a missile while its shields are down has its health decreased by 400 units. If a tank is hit while its shields are up, the tank will not lose any health but will lose 250 energy units. If a tank is sitting on a healthcharger or an energycharger when a missile hits it, the tank dies instantly, no matter what its health level or shield status. This is to discourage camping out on the chargers during a battle. When a tank is killed, it is resurrected at a random, unoccupied square on the next decision.</p> <p>The scoring of a game is as follows: a tank gets two points for each of its missiles that hits another tank while its shields are down and three points for every tank it kills. A tank loses one point for each missile that hits it while its shields are down, and two points each time it is killed. This is to encourage aggressive, but not fanatical tactics. Tanks have an unlimited number of lives. The game ends when one of the tanks gets 50 points.</p> <p>If 100 game cycles elapse without any tank firing a missile, then all tanks are reset as if they had been killed to avoid endless cycles in agents\u2019 behavior. No tanks incur a penalty for this respawning.</p>"},{"location":"tutorials/soar_tutorial/03/#tank-scheduler","title":"Tank Scheduler","text":"<p>In Eaters, a new operator was selected on every decision, and every operator performed an external action, either a move or a jump. In TankSoar, some of the decisions will not result in new operators being selected and some operators will perform only internal actions. If we continue to use the scheduling approach in Eaters in TankSoar, where each tank would get only one decision before the simulation world is updated, tanks that are not performing external actions will appear to just sit in place. This can be quite a disadvantage if a tank is under attack. To avoid penalizing tanks that are \u201cthinking\u201d a bit, TankSoar provides an alternative scheduler. With this scheduler, every tank is run until it generates output commands. Usually this will be a single decision, but sometimes will be many decisions. To handle cases where a tank does not attempt to perform an external action given the current situation, the tank will be run a maximum of fifteen decisions. This parameter is set by the TankSoar environment.</p> <p>From this point on, each of your tanks will run until it has produced new output on the output-link before another tank will run (but the simulator will not run and change the inputs for other tanks until all tanks have run). Below is a graphic depiction of how everything works under this approach with three tanks.</p>"},{"location":"tutorials/soar_tutorial/03/#simple-wandering-tank","title":"Simple Wandering Tank","text":"<p>In this section, you will create a tank that wanders around the board looking for objects. This will help you to get familiar with the TankSoar software. This tank will be the basis for a more complex tank you will build later.</p> <p>Wandering consists of moving around the map, using sensors to avoid bumping into obstacles and to detect other objects. A tank\u2019s main sensor for seeing other objects is its radar, which works from the front of the tank. Therefore, even though a tank can move in all four directions, it is best to move forward and turn to avoid obstacles. The radar uses up energy, so it is best to use it sparingly. The simplest thing to do is to turn on the radar when the tank turns, and turn it off if there is nothing interesting to see (such as tanks, missiles, the energy recharger, or the health recharger). One interesting issue is how much power should be used with the radar. To simplify things, you can always turn it on to 13, the maximum distance it can see. You will get a chance to improve your tank later, but for now it is best if it is simple.</p> <p>This analysis leads to the three operators and the search control described below:</p> <ul> <li>Move: move forward if not blocked.</li> <li>Turn: if front is blocked, rotate and turn on the radar with power 13.</li> <li>Radar-off: if the radar is on and there are no objects visible, turn     off the radar.</li> <li>If radar-off is proposed, then prefer it to move.</li> </ul> <p>This set of knowledge for wandering is just the start of a more complex tank, and you will have to add attacking other tanks, picking up missiles, and recharging later.</p> <p>The rest of this section goes through the creation of these operator and search control, step by step. If you feel confident that you can write these three operators and associated search control by yourself, go ahead and do it. All of the rules necessary to write the tanks in the tutorial are in the directory named Agents\\TankSoar\\Tutorial.</p> <p>Throughout the development of operators for TankSoar, you will use the general rules that were created in Eaters for copying actions from operators to the output-link. If you use these rules, many of the operators will have only proposals.</p> <p>To get started, create a new agent in Visual-Soar by loading in the default agent provided in the release and then saving it as a new project. The default agent includes the general output rules you created for the Eaters as well as a full data map for the TankSoar input-link and output-link. It also includes an initialization operator. This operator adds a name to the top state as the task name, which you should rename (probably along with the operator itself). For the rest of this part of the tutorial, we will assume the name of the top state is tanksoar.</p>"},{"location":"tutorials/soar_tutorial/03/#move-operator","title":"Move Operator","text":"<p>This operator is very similar to the move operator in Eaters, except that the sensors for detecting open spaces in front of the tank are in a different structure than the one in Eaters.</p> <p>To write the move operator, you should first write comments for operator proposal. The application of this operator is handled by the general rules from Eaters section 10.4. You should type these comments into your file as documentation.</p> <p>Below is one possible version:</p> <pre><code># Move Operator Proposal\n# If the task is tanksoar and the tank is not blocked in the forward\n# direction, propose the move operator.\n</code></pre> <p>For brevity, we will not include \u201cif the task is tanksoar\u201d in future English descriptions, although the test for ^name tanksoar will be included in the rules.</p> <p>In writing the Soar version of the operator proposal, you can reuse parts of the rules you wrote in Eaters. One part of those operators that was a bit tricky was the termination of the operator. In Eaters, we had to make sure that the proposal would retract after the operator applied. For Eaters that tested the cells surrounding them, no additional conditions were required because the contents of these cells changed on every move. The same holds true in TankSoar. Whenever the tank moves, the working memory elements that are the attributes of the blocked sensor change, even if the value is exactly the same. Thus, the proposal will retract and rematch each time a tank moves.</p> <p>After writing the proposal rule, you can test it, together with the general rules, by creating a tank with just those rules. The tank should move forward until it is blocked.</p> <pre><code>sp {tanksoar*propose*move\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.blocked.forward no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move\n^actions.move.direction forward)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#turn-operator","title":"Turn Operator","text":"<p>The original definition of the turn operator was:</p> <ul> <li>If the front is blocked, rotate and turn on the radar to power 13.</li> </ul> <p>Which direction should the tank turn? A reasonable approach is to turn left or right only if that direction is not blocked. If both directions are blocked, the tank can turn in either direction. Once the tank has turned, it will detect that it should turn again, so that the tank would turn completely around. Try to write the comments for the proposals. The turn operators should be indifferent because it is possible to have both a left and right turn proposed at the same time, and it doesn\u2019t matter which direction the tank turns.</p> <pre><code>## Turn Operator Proposal\n#  If the tank is blocked in the forward direction, and not blocked in the\n#  right or left directions, then propose the turn operator for the unblocked\n#  direction. Also create an indifferent preference for the operator.\n#  This operator will also turn on the radar and set the radar-power to 13.\n#  If the tank is blocked in the forward direction, and in both the right or\n#  left directions, then propose the turn operator left.\n</code></pre> <p>After the comments are written, try to write the Soar rules. Once they are written and debugged, your tank should wander around the map indefinitely, although it will never turn off its radar and will quickly run out of energy.</p> <p>Below are possible rules for proposing the turns.</p> <pre><code>sp {propose\\*turn\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.blocked &lt;b&gt;)\n(&lt;b&gt; ^forward yes\n^ { &lt;&lt; left right &gt;&gt; &lt;direction&gt; } no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name turn\n^actions &lt;a&gt;)\n(&lt;a&gt; ^rotate.direction &lt;direction&gt;\n^radar.switch on\n^radar-power.setting 13)}\n</code></pre> <p>The propose*turn rule uses a variable (<code>&lt;direction&gt;</code>) to match a blocked direction with value no, meaning that there is not an object in the square. That attribute is restricted to match only left and right because those are the only two directions a tank can rotate. The actions of the rule are more complex than other rules you\u2019ve written. The action of this rule creates three different action commands that will be copied in parallel to the output-link by apply*operator*create-action-command. As a result, the tank rotates, turns on its radar, and sets the radar-power all at the same time.</p> <p>Propose*turn handles the cases where there is an open square to the left or right. The following rule handles the case when the three forward directions are blocked. I arbitrarily decided to have the tank turn left to start turning around. After it rotates left once, the propose*turn rule will match and propose a further turn to the left.</p> <pre><code>sp {propose\\*turn\\*backward\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.blocked &lt;b&gt;)\n(&lt;b&gt; ^forward yes ^left yes ^right yes)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name turn\n^actions.rotate.direction left)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#radar-off-operator","title":"Radar-off Operator","text":"<p>In addition to moving and turning, your tank needs to turn off its radar to conserve energy. You should write a proposal for radar-off, and some search control so that radar-off is preferred to move.</p> <ul> <li>Radar-off: if the radar is on and there are no interesting objects     visible, turn off the radar. The radar is left on for energy,     health, missiles, so that the tank can either pick up the object. It     is left on for tanks so they can be attacked.</li> <li>If radar-off is proposed, then prefer it to move and turn.</li> </ul> <p>The English versions of the rules for this operator are straightforward:</p> <pre><code>## Radar-off Operator Proposal\n#  If the radar is on but no energy, health, missiles and tanks visible,\n#  then propose the radar-off operator\n## Radar-off Search Control\n#  If radar-off is proposed, then prefer it to move and turn.\n</code></pre> <p>The only tricky part of this operator is that there must be a condition in the proposal that tests that there are not any objects on radar. Remember that the radar\u2019s input structures are attributes of the radar augmentation. For every object on radar, there is an augmentation of the radar object, where the value of the attribute is the type of object: energy, health, missiles, obstacle, open, and tank. For example, if there is a tank on radar, the following condition could match it: <code>(&lt;s&gt; ^io.input-link.radar.tank)</code>. You need to write a single condition that detects if radar does not detect a tank, missiles, energy, or health. You need to include a test that the radar is on (otherwise, your rule will turn the radar off when it is already off).</p> <pre><code>sp {propose\\*radar-off\n(state &lt;s&gt; ^name tanksoar\n^io.input-link &lt;il&gt;)\n(&lt;il&gt; ^radar-status on\n\n-^radar.&lt;&lt; energy health missiles tank &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name radar-off\n^actions.radar.switch off)}\n</code></pre> <pre><code>sp {select\\*radar-off*move\n(state &lt;s&gt; ^name tanksoar\n^operator &lt;o1&gt; +\n^operator &lt;o2&gt; +)\n(&lt;o1&gt; ^name radar-off)\n(&lt;o2&gt; ^name &lt;&lt; turn move &gt;&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o1&gt; &gt; &lt;o2&gt;)}\n</code></pre> <p>A different approach is to turn off the radar as part of the move operator. Turning the radar off can happen in parallel with moving and turning. It is implemented as an additional action of those operators.</p> <pre><code>sp {apply*move*radar-off\n(state &lt;s&gt; ^name tanksoar\n^operator &lt;o&gt;\n^io.input-link &lt;il&gt;)\n(&lt;il&gt; ^radar-status on\n-^radar.&lt;&lt; energy health missiles tank &gt;&gt;)\n(&lt;o&gt; ^name &lt;&lt; turn move &gt;&gt;\n^actions &lt;a&gt;)\n--&gt;\n(&lt;a&gt; ^radar.switch off)}\n</code></pre> <p>This rule is included in the all folder/directory instead of the operator rules because it will fire in parallel with other actions.</p>"},{"location":"tutorials/soar_tutorial/03/#wander-trace","title":"Wander Trace","text":"<p>If you create a tank with your wander rules and the radar-off operator and run it, the trace will look something like this.</p> <p>Usually turn is followed by radar-off, but whenever there is an object on radar, the radar will not be turned off until after the tank has passed that object.</p>"},{"location":"tutorials/soar_tutorial/03/#wander-operator-subgoals","title":"Wander Operator - Subgoals","text":"<p>The rules you wrote for the previous section could be extended and rules for chasing and attacking enemy tanks, recharging, and picking up missiles could be added to make a more complete tank. However, you would either have to add many more search control rules to keep the wandering rules from firing during these other activities, or you\u2019d have to modify the operator proposals. Both approaches are not very appealing. It would be better if you could package the wander rules and operators into a unit that can be used when the tank should wander. An alternative but related problem is that there are high-level activities that a tank can perform involving complex combinations of low-level actions. One such set of high-level activities consists of wandering, chasing, attacking, and retreating. Although these are high-level activities, a tank should be able to use its knowledge to select between these activities based on the current situation, just as it selects between different operators. Both of these problems are handled in Soar by allowing abstract high-level operators to be implemented in subgoals where a new state is created that allows low-level operators to be selected in pursuit of the high-level operators.</p> <p>The hierarchy of operators you will build looks like the following:</p> <p>In addition to this hierarchical structure, there will be additional rules for turning the shields on and off, and remembering sounds. These rules are independent of the hierarchy \u2013 they will be proposed and applied in any active goal.</p> <p>This section introduces subgoals by tracing through the proposal, selection, and application of the high-level operator for wander. In later sections, you will add other high-level operators for chase, attack, and retreat.</p> <p>Visual-Soar makes this easy to do. It allows you to create the abstract operators, such as wander and chase, and then create suboperators that are embedded within the abstract operators. See the documentation for Visual-Soar for details.</p> <p>The tank you will create will not be the best or smartest tank, but building it will teach you many new things about Soar.</p>"},{"location":"tutorials/soar_tutorial/03/#wander-operator-proposal","title":"Wander Operator Proposal","text":"<p>If you think of wandering as an operator, then in Soar it consists of rules to propose it and then apply it. When should a tank wander? When it is not attacking, chasing, or under attack by another tank. Thus, wandering is an activity to be performed when no other tanks are detected, or at least threatening. A tank has many senses by which it can detect other tanks.</p> <ul> <li>Blocked: does not tell if an obstacle is a tank, so it not useful     for deciding to wander.</li> <li>Incoming: indicates that a missile is approaching the tank.</li> <li>Radar: detects exactly where another tank is. However it is limited     to seeing in front of the tank and can be blocked by obstacles.</li> <li>Rwaves: indicates that another tank can detect the tank from a given     direction.</li> <li>Smell: detects the closest tank, but that tank may be on the other     side of a wall.</li> <li>Sound: gives the direction to another tank that is close (seven     square or less); however it does not work if the other tank has     stopped moving.</li> </ul> <p>Although rwaves is a very useful sensor in this case, in order to keep the examples simple it is not included. You will want to add it to your tank later on. The other sensors for detecting a nearby tank are incoming, radar, and sound.</p> <pre><code>## Wander Operator Proposal\n#  If there is no tank detected on radar, and the sound is silent, and there\n#  is no incoming, then propose the wander operator.\n</code></pre> <p>Translating this into Soar is a bit tricky because there are two tests for negations (no tank on radar, no incoming), but you should give it a try.</p> <pre><code>sp {propose\\*wander\n(state &lt;s&gt; ^name tanksoar\n^io.input-link &lt;io&gt;)\n(&lt;io&gt; ^sound silent\n-^radar.tank\n-^incoming.&lt;dir&gt; yes)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name wander)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#impasses-and-state-creation","title":"Impasses and State Creation","text":"<p>All of the previous operators you\u2019ve written have had rules to apply them. However, wandering is not an activity that is easily represented by individual rules \u2013 it is better represented as the repeated selection and application of the operators you wrote in Section 2. How does Soar make it possible to use operators, such as move and turn, to apply a higher level operator such as wander? To find out, create a tank with only your wander operator proposal rule. Run it for two steps.</p> <p>What happens is that Soar detects that there are no rules that match and can fire when the wander operator is selected, which means that Soar cannot make progress. In Soar, this is called an operator no-change impasse, because an operator has been selected and there is no new decision to be made. There are three other types of impasses in Soar.</p> <ul> <li>A state no-change impasse is when no operators are proposed for the     current state.</li> <li>An operator tie impasse is when there are multiple operators     proposed, but insufficient preferences to select between them.</li> <li>An operator conflict impasse is when there are multiple operators     proposed, and the preferences conflict.</li> </ul> <p>Whenever an impasse arises, Soar automatically creates a new state (S3 in the trace above). The purpose of this state is to provide a context for selecting and applying operators to resolve the impasse (in the case, moving to a state where wander is no longer selected).</p> <p>Once a substate is created, operators can be selected and applied just as they are in the original state. These operators can change the local state, but they can also change the contents of original state (S1) by modifying the original state directly or by performing external actions that indirectly lead to changes in sensors, which in turn change the state. An impasse can also arise in the substate, which then leads to a stack of states. In the trace above, no operator is proposed in state S3, so another substate, S4, is created.</p> <p>To see all of the selected operators and their states, use the print-stack command. When a substate is created, it has some initial augmentations that distinguish it from other states. Take a look at the augmentations for state S3 above by printing S3.</p> <p>The most important of these is the superstate augmentation, which has as its value the identifier of the state in which the impasse arose (S2). You will use this augmentation to match the wander operator and other structures, such as the input-link and output-link.</p> <p>The processing in a substate can lead to the creation of structures that are part of the original state (the superstate). These are called results. In this example, the only results will be output commands for controlling the tank, but results can be any structure including operator acceptable preferences, other operator preferences, elaborations of the state, or changes to the state that are part of an operator application.</p> <p>All of the states in working memory are \u201cactive\u201d in that rules can fire for any level \u2013 it is not the case that processing in the top state comes to a halt while the processing goes on in the substate. In fact, it is the ability of the processing in the original state to start up that often resolves the impasse and leads to the termination of the subgoal. For example, in the substate for wander, we will add the operators for moving and turning. At some point, this may cause the tank to see and enemy tank, and fire a rule (in the top state) to propose the attack operator; while at the same time retract the rule that proposed the wander operator.</p> <p>Operator no-change impasses are resolved when the current operator is no longer preferred in the original state (S1 in the trace above). That can be because either the proposal for the current operator is retracted (the rule creating the proposal no longer matches), or because of the set of operator preferences changes so that another operator is preferred. State no-change impasses are resolved when an operator has been proposed (with an acceptable preference), so that there is at least one candidate operator. Tie and conflict impasses are resolved when sufficient preferences have been created so that the decision procedure can select an operator.</p> <p>When the impasse is resolved, the substate is automatically removed from working memory \u2013 it has served its purpose and is no longer needed. However, all of the results that were created in the subgoal can still persist. This is important because the results are changes to the superstate and are usually responsible for eliminating the impasse. Sometimes the results directly resolve the impasses, such as when a new preference is created that makes one of the tied operators best, but sometimes a result only indirectly resolves an impasse, such as a motor command to a tank that causes it to turn on its radar so it sees an enemy and decides to attack.</p> <p>Just as with all other working memory elements, the persistence of results must be determined by Soar. This is tricky because the rule for creating a result usually tests structures in a substate that will be removed once the impasse is resolved. If the result is an operator proposal, we don\u2019t want to remove the operator when the rule that created it no longer fires \u2013 that would defeat the purpose of the subgoal. Instead, Soar analyzes what structures had to exist in the superstate for that result to be produced by recursively backtracing through the conditions of the rule that created the result, finding the rules that fired in the subgoal that created the working memory elements that caused the rule to fire, until it finds all of the structures in the superstate that the result depended on. It collects these together and forms a justification that is essentially a fully instantiated rule. It then analyzes the rule to determine the persistence of the result (i-support or o-support). If it is i-support, then the justification is maintained until one of its conditions is no longer in working memory and then the result is retracted. If the justification gives o-support, then the result is maintained in working memory until it is explicitly deleted (or removed because it becomes disconnected from the state).</p>"},{"location":"tutorials/soar_tutorial/03/#wander-operator-suboperators","title":"Wander Operator Suboperators","text":"<p>As mentioned in the previous section, the wander operator is applied by selecting and applying operators in the substate. The original rules you wrote for wander need to be changed because they now need to apply only if the wander operator is selected. Consider the original move operator:</p> <pre><code>## Move Operator Proposal\n#  If the state is named tanksoar and tank is not blocked in the forward\n# direction, propose the move operator.\n\nsp {propose*move\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.blocked.forward no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^actions.move.direction forward)}\n</code></pre> <p>This must be modified to include tests for the wander operator as the superoperator.</p> <pre><code>## Wander: Move Operator Proposal\n#  If the wander operator is selected as the superoperator, and tank is not\n#  blocked in the forward direction, then propose the move operator.\n</code></pre> <p>Using what you know about the superstate augmentation, here is what you might have come up with:</p> <pre><code>sp {wander*propose*move\n(state &lt;s&gt; ^superstate.operator.name wander\n^io.input-link.blocked.forward no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^actions.move.direction forward)}\n</code></pre> <p>Unfortunately, this rule will not match because there is no ^io augmentation of the substate. Further, the missing io means that the general rules you wrote to perform the action of this operator by creating and removing the move action command on the output-link won\u2019t fire. One approach would be to rewrite this rule so that instead of testing ^io.input-link\u2026 it tested ^superstate.io.input-link\u2026 However, that doesn\u2019t solve the other problem and if there were a deeper hierarchy, you would have to know exactly how many levels of superstates there were. An alternative is to copy the io augmentation down to the state. A simple, general rule can do this and solve both problems.</p> <pre><code>sp {elaborate*state*io\n(state &lt;s&gt; ^superstate.io &lt;io&gt;)\n--&gt;\n(&lt;s&gt; ^io &lt;io&gt;)}\n</code></pre> <p>This rule copies the io pointer to each new substate. You should add this rule to your set of general rules.</p> <p>With this rule, the only change that has to be made to your operator proposals is to add a test for: ^superstate.operator.name wander. This tests that the selected superoperator is wander. It will not match against any other proposed operators because they will have only acceptable preferences (+). An alternative approach, which simplifies these operator proposals, and is consistent with the convention adopted earlier for naming the top state, is to create a rule that copies the name of the superoperator to the state, so that your rules can directly test the name on the state:</p> <pre><code>sp {elaborate*state*name\n(state &lt;s&gt; ^superstate.operator.name &lt;name&gt;)\n--&gt;\n(&lt;s&gt; ^name &lt;name&gt;)}\n</code></pre> <p>This rule is always created by VisualSoar and is in the default set of rules, so you don\u2019t have to add it. With these two changes, the new rule is essentially the original, but with the name of the state being tested changed to wander.</p> <p>Based on the analysis above, you can now rewrite the proposal rules for the operators that apply as part of the wander operator. In order to keep better track of your rules, you should also adopt the convention of including the name of the state (wander) at the beginning of the name of the rules.</p> <pre><code>sp {wander*propose*move\n(state &lt;s&gt; ^name wander\n^io.input-link.blocked.forward no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^actions.move.direction forward)}\n</code></pre> <pre><code>sp {wander*propose*turn\n(state &lt;s&gt; ^name wander\n^io.input-link.blocked &lt;b&gt;)\n(&lt;b&gt; ^forward yes\n^ { &lt;&lt; left right &gt;&gt; &lt;dir&gt; } no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name turn\n^actions &lt;a&gt;)\n(&lt;a&gt; ^rotate.direction &lt;dir&gt;\n^radar.switch on\n^radar-power.setting 13)}\n</code></pre> <pre><code>sp {wander*propose*turn\\*backward\n(state &lt;s&gt; ^name wander\n^io.input-link.blocked &lt;b&gt;)\n(&lt;b&gt; ^forward yes\n^left yes\n^right yes)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name turn\n^actions.rotate.direction left)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#general-rule-summary","title":"General Rule Summary","text":"<p>Using the rules you\u2019ve written in this section so far, together with the general rules, your tank should wander around until it encounters another tank. Below is the complete set of general rules you should have in your tank. The appropriate place to put them is in the elaborations folder/directory.</p> <pre><code>sp {apply\\*operator\\*create-action-command\n(state &lt;s&gt; ^operator &lt;o&gt;\n^io.output-link &lt;out&gt;)\n(&lt;o&gt; ^actions &lt;act&gt;)\n(&lt;act&gt; ^&lt;att&gt; &lt;value&gt;)\n(&lt;value&gt; ^&lt;att2&gt; &lt;value2&gt;)\n--&gt;\n(&lt;out&gt; ^&lt;att&gt; &lt;value3&gt;)\n(&lt;value3&gt; ^&lt;att2&gt; &lt;value2&gt;)}\n</code></pre> <pre><code>sp {apply\\*operator\\*remove-command\n(state &lt;s&gt; ^operator.actions\n^io.output-link &lt;out&gt;)\n(&lt;out&gt; ^&lt;att&gt; &lt;value&gt;)\n(&lt;value&gt; ^status complete)\n--&gt;\n(&lt;out&gt; ^&lt;att&gt; &lt;value&gt; -)}\n</code></pre> <pre><code>sp {elaborate*state*io\n(state &lt;s&gt; ^superstate.io &lt;io&gt;)\n--&gt;\n(&lt;s&gt; ^io &lt;io&gt;)}\n</code></pre> <pre><code>sp {elaborate*state*name\n(state &lt;s&gt; ^superstate.operator.name &lt;name&gt;)\n--&gt;\n(&lt;s&gt; ^name &lt;name&gt;)}\n</code></pre> <p>The trace of your tank should look something like the following, where wander is selected, and then the move and turn operators are selected for the substate.</p>"},{"location":"tutorials/soar_tutorial/03/#chase-attack-and-retreat","title":"Chase, Attack, and Retreat","text":"<p>Remember that the hierarchy of operators that you build will look like the following:</p> <p>In this section you will write the rules for Chase, Attack, and Retreat. By now you should know Soar well enough to try to write these on your own. However, some tricky issues will come up and the rest of this section will lead you through writing them step-by-step. Even if you do write the operators yourself, you will find it valuable to go through the tutorial sections because they introduce a few new ideas in how to write Soar programs.</p>"},{"location":"tutorials/soar_tutorial/03/#chase-operator-proposal","title":"Chase Operator Proposal","text":"<p>The chase operator should be selected when a tank senses that another tank is close, but it doesn\u2019t know exactly where the other tank is. As discussed earlier, the sound sensor gives a good indication of whether another tank is close (if the other tank is moving), but it is not sufficient for attacking the other tank. If a tank has another tank on radar, it can attack and need not chase. However, if the tank has no missiles, or is very low on energy (so it cannot use shields or radar), it should not chase another tank. Finally, the chase operator should only be proposed for the top state. If you put all of these together, you will come up with the conditions for proposing the chase operator.</p> <pre><code>## Propose Chase Operator\n#  If the task is tanksoar, and sound sensor is not silent, and there\n#  is no tank on radar, and energy or missiles is not low, then propose the\n#  chase operator.\n</code></pre> <p>To write a Soar rule that tests these conditions requires coming up with a definition of low health and low missiles. You could just pick a number, such as 100, and test that the energy is not below that number, but you will have to remember that number when you write other operators, such as retreat, that handle the cases when the energy is below that number. You will also include two conditions, one to test energy and one to test missiles in every rule. A more general approach is to create rules that test for either the energy levels being low or no missiles, and create a structure in working memory that can be tested in the future.</p> <p>Rules for generating these classifications should be restricted to firing only in the top state. Otherwise, these rules will fire every time a new state is created, because the ^io attribute is copied to all states. It is easy to restrict this to firing only in the top state by adding the condition: ^name tanksoar.</p> <pre><code>sp {elaborate*state*missiles\\*low\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.missiles 0)\n--&gt;\n(&lt;s&gt; ^missiles-energy low)}\n</code></pre> <pre><code>sp {elaborate*state*energy\\*low\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.energy &lt;= 200)\n--&gt;\n(&lt;s&gt; ^missiles-energy low)}\n</code></pre> <p>These rules have exactly the same action \u2013 the same identifier, attribute, and value. What happens when both rules fire at the same time? Soar never allows duplicate working memory elements, so although both rules fire, only one working memory element is created.</p> <p>The chase proposal then is:</p> <pre><code>sp {propose\\*chase\n(state &lt;s&gt; ^name tanksoar\n^io.input-link &lt;io&gt;\n\n-^missiles-energy low)\n(&lt;io&gt; ^sound &lt;&gt; silent\n\n-^radar.tank)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name chase)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#chase-operator-application","title":"Chase Operator Application","text":"<p>The chase operator is applied through the selection of the move and turn operators. Both operators test the direction of the sound, which can be accessed directly from the input-link, or to simplify the rules, you can add an elaboration rule that copies the sound to the local state. For example, you can add the rule:</p> <pre><code>sp {chase*elaborate*state\\*sound-direction\n(state &lt;s&gt; ^name chase\n^io.input-link.sound &lt;sound&gt;)\n--&gt;\n(&lt;s&gt; ^sound-direction &lt;sound&gt;)}\n</code></pre> <p>One advantage of this approach is that if you later change the way in which the sound direction is computed, only this rule needs to be modified, and not the ones that test sound-direction. This is exactly what is going to happen later when we add operators to remember sounds in Section 5.2.</p> <p>Since the goal of the chase operator is to get a radar contact with the enemy tank, the radar should be turned on if it is off, which can be done in parallel with the other operators. The following rule elaborates a selected operator with commands to turn on the radar if it is off.</p> <pre><code>sp {chase*elaborate*radar\n(state &lt;s&gt; ^name chase\n^operator.actions &lt;a&gt;\n^io.input-link.radar-status off)\n--&gt;\n(&lt;a&gt; ^radar.switch on\n^radar-power.setting 13)}\n</code></pre> <pre><code>## Propose Move Operator\n# If the state is named chase and the sound is coming from the\n# forward position, propose move forward.\n\nsp {chase*propose*move\n(state &lt;s&gt; ^name chase\n^sound-direction forward\n^io.input-link.blocked.forward no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name move\n^actions.move.direction forward)}\n</code></pre> <pre><code>## Propose Turn Operator\n# If the state is named chase and the sound is coming from left or\n# right, turn that direction.\n\nsp {chase*propose*turn\n(state &lt;s&gt; ^name chase\n^sound-direction {&lt;&lt; left right &gt;&gt; &lt;direction&gt;})\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name turn\n^actions.rotate.direction &lt;direction&gt;)}\n</code></pre> <pre><code>## Propose Turn Operator Backward\n## If the state is named chase and the sound is coming from backward, turn left.\nsp {chase*propose*backward\n(state &lt;s&gt; ^name chase\n^sound-direction backward)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name turn\n^actions.rotate.direction left)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#attack-operator-proposal","title":"Attack Operator Proposal","text":"<p>The purpose of the attack operator is to shoot missiles and hit the other tank. Thus, the attack operator should be selected when a tank can see another tank on radar. However, if a tank is low on health or energy, it may be better to retreat instead of attack. As with chase, the attack operator should only be proposed for the top state. If you put all of these together, you will come up with the conditions for proposing the attack operator.</p> <pre><code>## Propose Attack Operator\n#  If the state is tanksoar, and there is a tank on radar, and health and energy are not low, then\n#  propose the attack operator.\n</code></pre> <p>The above proposal can be written as a single rule. There should be an indifferent preference for the operator because there can be more than one tank on the radar and thus, more than one operator instantiation created.</p> <pre><code>sp {propose\\*attack\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.radar.tank\n\n-^missiles-energy low)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name attack)}\n</code></pre> <p>An alternative approach that avoids the possibility of multiple instantiations is to have an elaboration rule that detects when there is a tank on radar and creates and augmentation of the top-state, something like ^tank detected. Even if there are multiple tanks, only one augmentation will be created (working memory is a set). Then a proposal rule can be written that test that augmentation and proposes a single attack operator.</p>"},{"location":"tutorials/soar_tutorial/03/#attack-operator-application","title":"Attack Operator Application","text":"<p>The attack operator is applied through the selection of the move, turn, and fire operators.</p> <ul> <li>If an enemy is on radar in the center, the tank can just fire a     missile.</li> <li>If an enemy is off center and in front, the tank should move to the     left or right to get an open shot.</li> <li>If it can\u2019t slide because it is blocked, the tank should move     forward.</li> <li>If the enemy is right next to the tank, it should turn.</li> </ul> <p>If you want your tank to be aggressive, it could move and shoot in one operator.</p> <pre><code>## Propose Fire-missile Operator\n# If the state is attack and there is a tank on radar in the center, then propose the fire missile operator.\n\nsp {attack*propose*fire-missile\n(state &lt;s&gt; ^name attack\n^io.input-link &lt;il&gt;)\n(&lt;il&gt; ^radar.tank.position center\n^missiles &gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + &gt;)\n(&lt;o&gt; ^name fire-missile\n^actions.fire.weapon missile)}\n</code></pre> <p>The number of missiles is tested so that the action will be attempted only if there are missiles available. This operator needs a best preference so that is preferred to the following operators.</p> <pre><code>## Propose Slide Operator If the state is attack and there is a tank on radar\n# that is not in the center, and there is not a tank in the center, and there is\n# an open spot in the direction of the tank, then propose the slide operator in\n# the direction of the tank.\n\nsp {attack*propose*slide\n(state &lt;s&gt; ^name attack\n^io.input-link &lt;input&gt;)\n(&lt;input&gt; ^blocked.&lt;dir&gt; no\n^radar &lt;r&gt;)\n(&lt;r&gt; ^tank.position { &lt;&lt; left right &gt;&gt; &lt;dir&gt; }\n-^tank.position center)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name slide\n^actions.move.direction &lt;dir&gt;)}\n</code></pre> <p>This operator must be indifferent in case there is more than one tank on radar.</p> <pre><code>## Propose Move-Forward Operator\n#  If the state is attack and there is a tank on radar that is not in the center, and there is not a tank in the\n#  center, and the tank is blocked in that direction then propose move-forward.\n\nsp {attack*propose*move-forward\n(state &lt;s&gt; ^name attack\n^io.input-link &lt;input&gt;)\n(&lt;input&gt; ^blocked.&lt;dir&gt; yes\n^radar &lt;r&gt;)\n(&lt;r&gt; ^tank &lt;t&gt;\n-^tank.position center)\n(&lt;t&gt; ^position { &lt;&lt; left right &gt;&gt; &lt;dir&gt; }\n^distance &lt;&gt; 0)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-forward\n^actions.move.direction forward)}\n</code></pre> <p>The final condition tests that the opposing tank is not at distance 0, which would be true if the opposing tank were immediately next to the tank under control. In that case, the tank should turn and fire on the enemy tank. That operator is proposed in the next rule.</p> <pre><code>### Propose Turn Operator\n## If the state is attack and there is a tank on radar that right next to the tank, then propose turning in that\n## direction and firing.\n\nsp {attack*propose*turn\n(state &lt;s&gt; ^name attack\n^io.input-link.radar.tank &lt;tank&gt;)\n(&lt;tank&gt; ^distance 0\n^position { &lt;&lt; left right &gt;&gt; &lt;dir&gt; })\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name turn\n^actions &lt;a&gt;)\n(&lt;a&gt; ^rotate.direction &lt;dir&gt;\n^fire.weapon missile)}\n</code></pre> <p>This rule has two actions: rotating and firing a missile. In TankSoar, both actions will happen during the same decision, but the rotate will occur first, followed by firing the missile. This has nothing to do with the order of the actions, but is a feature of TankSoar.</p>"},{"location":"tutorials/soar_tutorial/03/#retreat-operator-proposal","title":"Retreat Operator Proposal","text":"<p>The purpose of the retreat operator is to get the tank out of harm\u2019s way when it is low on missiles or energy. Thus, the retreat operator should be selected when a tank has low missiles or energy and it senses that there is another tank near. As discussed earlier, the sound and radar indicates if another tank is close, while the incoming sensor tells if the tank is under attack. Another situation in which the tank can retreat is when it is under attack, but does not detect the enemy tank so that it can attack or chase it. As with chase, the retreat operator should only be proposed for the top state. If you put all of these together, you will come up with these conditions for proposing the retreat operator.</p> <pre><code># Propose Retreat Operator\n# If the state is tanksoar and the sound sensor is not silent or there is a tank on radar or there is an\n# incoming missile, and health is low or the energy is low, then propose the retreat operator.\n```Soar\n\nThe above proposal cannot easily be written as a single rule, but can be\nwritten as three rules. Since more than one of these conditions can be\ntrue at a given time, these proposals should be indifferent.\n\n```Soar\nsp {propose\\*retreat\\*sound\n(state &lt;s&gt; ^name tanksoar\n^missiles-energy low\n^io.input-link.sound {&lt;direction&gt; &lt;&gt; silent})\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name retreat)}\n</code></pre> <pre><code>sp {propose\\*retreat\\*radar\n(state &lt;s&gt; ^name tanksoar\n^missiles-energy low\n^io.input-link.radar.tank)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name retreat)}\n</code></pre> <pre><code>sp {propose\\*retreat\\*incoming\n(state &lt;s&gt; ^name tanksoar\n^missiles-energy low\n^io.input-link.incoming.&lt;dir&gt; yes)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name retreat)}\n</code></pre> <pre><code># Propose Retreat Operator\n# If the state is tanksoar and the tank is under attack but cannot not directly sense the other tank, then\n# propose the retreat operator.\n\nsp {propose\\*retreat\\*incoming\\*not-sensed\n(state &lt;s&gt; ^name tanksoar\n^io.input-link &lt;io&gt;)\n(&lt;io&gt; ^incoming.&lt;dir&gt; yes\n-^radar.tank\n^sound silent)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name retreat)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#retreat-operator-application-state-elaboration","title":"Retreat Operator Application: State Elaboration","text":"<p>In applying the retreat operator, the direction of the enemy is important in deciding which way to move. That is, the tank should attempt to move out of the line of possible fire from another tank (side-step), or if that cannot be done, move away until a sidestep action is possible. It is easy to determine the direction for sound, but is subtle for radar. In radar, the general direction of the enemy is forward, but if the enemy is off center, the tank should not move in that direction, because that is probably right in the line of fire. In addition, there might be multiple tanks around, some detected via sound, some via radar, so that multiple directions need to be avoided. To handle this, you can add rules that elaborate the substate that has been created with the directions that enemies are detected, and directions that should be avoided (if an enemy is off center on radar).</p> <p>In this case the following operator elaborations would be useful.</p> <pre><code># Retreat Operator Elaboration\n# If there is a retreat state and there is a sound coming in a given direction, record that direction.\n# If there is a retreat state and there is radar contact with a tank, record forward direction.\n# If there is a retreat state and there is an incoming, record the direction.\n# If there is a retreat state and there is radar contact with a tank that is not in the center, record\n# that direction as a direction to avoid moving.\n\nsp {elaborate\\*retreat\\*sound\\*direction\n(state &lt;s&gt; ^name retreat\n^io.input-link.sound { &lt;&gt; silent &lt;direction&gt; })\n--&gt;\n(&lt;s&gt; ^direction &lt;direction&gt;)}\n</code></pre> <pre><code>sp {elaborate\\*retreat\\*radar\\*front\n(state &lt;s&gt; ^name retreat\n^io.input-link.radar.tank)\n--&gt;\n(&lt;s&gt; ^direction forward)}\n</code></pre> <pre><code>sp {elaborate\\*retreat\\*incoming\\*direction\n(state &lt;s&gt; ^name retreat\n^io.input-link.incoming.&lt;dir&gt; yes)\n--&gt;\n(&lt;s&gt; ^direction &lt;dir&gt;)}\n</code></pre> <pre><code>sp {elaborate\\*retreat\\*radar\\*direction\n(state &lt;s&gt; ^name retreat\n^io.input-link.radar.tank.position { &lt;dir&gt; &lt;&gt; center })\n--&gt;\n(&lt;s&gt; ^avoid-direction &lt;dir&gt;)}\n</code></pre> <p>Many of these rules may fire at the same time, and in some cases, attempt to create exactly the same working memory element, such as if sound is coming from the front and there is a tank on radar in the front. As mentioned earlier, only a single copy of an identifier, attribute, and value will be added to working memory. However, if the values will be different, such as if there is sound coming from the right when a tank is on radar in front, all elements with different values will be added to working memory.</p> <p>An important component of Soar is that if changes to working memory make these rules no longer match, the structures they create will be removed and recomputed as new sensor information becomes available.</p>"},{"location":"tutorials/soar_tutorial/03/#retreat-operator-application","title":"Retreat Operator Application","text":"<p>The retreat operator is applied through the selection of the move operators. Since the goal of the retreat operator is to get away from another tank, the move operator is selected to be a sidestep from the direction of any sensed tank. The direction of the sidestep should not be toward another tank, or in a direction that was recorded to avoid. If there are no good choices available, there are a few possibilities, but to keep things simple, just have the tank wait and be silent, and hope the other tank goes away.</p> <pre><code># Propose Move Sidestep Operator\n# If the state is named retreat then propose sidestep from the direction of a detected enemy, as\n# long as that direction is not blocked, is not the direction of another enemy or is a direction to avoid.\n#\n# Propose Wait\n# If the state is named retreat then propose wait, and make a worst preference for it.\n</code></pre> <p>Calculating the direction for the sidestep operator is similar to some of the calculations that needed to be performed in the Eater. As before, you can add a data structure to working memory. This data structure has to contain each direction, and then the two directions that are adjacent to it. For example, the forward direction would have left and right. You have a choice of creating this data structure for the top-level state when the tank is created, or creating it each time that a retreat state is generated. It is more efficient to generate it only once for the top state; however that means you need to access it via the ^superstate augmentation.</p> <pre><code>sp {elaborate\\*sidestep-directions\n(state &lt;s&gt; ^name tanksoar)\n--&gt;\n(&lt;s&gt; ^side-direction &lt;sd&gt;)\n(&lt;sd&gt; ^forward right left ^backward right left\n^right forward backward ^left forward backward)}\n</code></pre> <p>The actions of this rule have multiple values for a single attribute. This can be written in a shorthand form without repeating the attribute.</p> <pre><code>sp {retreat*propose*move\n(state &lt;s&gt; ^name retreat\n^direction &lt;dir&gt;\n^superstate.side-direction.&lt;dir&gt; &lt;ndir&gt;\n-^direction &lt;ndir&gt;\n-^avoid-direction &lt;ndir&gt;\n^io.input-link.blocked.&lt;ndir&gt; no)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move\n^actions.move.direction &lt;ndir&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#shield-control-rules","title":"Shield Control Rules","text":"<p>Turning on shields is the main defensive mechanism available to a tank. However, it is quite expensive in terms of energy, so it should be used only if under attack or when the risk of attack is high. To simplify things, you will only turn on your shields when under attack, and will turn off the shields if not under attack. Therefore turning on the shields is a reflex action that should happen as soon as possible. It does not have to be open to deliberate consideration, and therefore can be encoded as a rule instead of an operator. In a later section, you will learn how to use Soar\u2019s learning mechanism so that these can be written as operators, but then be compiled into rules.</p> <p>How should the rule for turning the shields on be written? The obvious choice is to test the incoming sensor and directly modify the output-link; however, adding directly to the output link can cause a subtle problem. The problem arises when tanks are used in competitive tournaments with the \u201cRun Until Output Generated\u201d flag set. This flag is set in the Tank Control Window, under the Tanks menu item. When set, each tank is run until it has generated output (with a limit of fifteen decisions). Usually a tank will run only a single decision, but if the tank is changing between wandering and attacking, a few decisions might be made before output is generated. However, if shields are turned on and off via actions directly to the output-link, output will be available during the first decision. In some cases, such as changing from wander to attack, another action could have been generated if the shield command waited until other output was ready. The simplest way to do this is have the shield commands piggyback on other operators that have actions. Each rule tests that the operator has an ^actions augmentation and adds its command.</p> <pre><code>sp {elaborate\\*shields-on\n(state &lt;s&gt; ^operator.actions &lt;a&gt;\n^io.input-link &lt;il&gt;)\n(&lt;il&gt; ^incoming.&lt;dir&gt; yes\n^shield-status off)\n--&gt;\n(&lt;a&gt; ^shields.switch on)}\n</code></pre> <pre><code>sp {elaborate\\*shields-off\n(state &lt;s&gt; ^operator.actions &lt;a&gt;\n^io.input-link &lt;il&gt;)\n(&lt;il&gt; -^incoming.&lt;dir&gt; yes\n^shield-status on)\n--&gt;\n(&lt;a&gt; ^shields.switch off)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#wait-operator","title":"Wait Operator","text":"<p>There is one more operator that is included in the simple tank. This is the wait operator that is in the all folder/directory, and is useful in almost every task, not just controlling toy tanks. The wait operator is proposed whenever there is a state no-change impasse. A state no-change impasse arises when no operators are proposed. This can happen because of a bug in your program. If there were no wait operator, Soar would generate a cascade of state no-change impasses. The wait operator is proposed whenever there is a state no-change.</p> <pre><code># Propose wait for a state-no-change\n\nsp {top-state*propose*wait\n(state &lt;s&gt; ^attribute state\n^choices none\n-^operator.name wait)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; +)\n(&lt;o&gt; ^name wait)}\n</code></pre> <p>This proposal tests that the state has ^attribute state and ^choices none. Those attributes on the state are created when no operator can be selected for a state \u2013 a state no-change impasse. The key to the wait operator is that it tests to see that a wait operator is not selected. Thus, once one is selected, the proposal no longer matches and retracts, but then will get reproposed during the next proposal cycle.</p>"},{"location":"tutorials/soar_tutorial/03/#review-of-simple-tank","title":"Review of Simple Tank","text":"<p>After writing your tank, it is a good idea to take a step back and do a little analysis to make sure that your have operators to cover all of the situations your tank can get into. In this section, we will examine the high-level operators, but you should also examine the sets of operators used to implement each of these operators. Here is a list of all of the conditions covered by the different operator proposals</p> <p>Wander: 1. sound silent, no tanks on radar, no incoming missile Attack: 2. not missiles-energy low, tank on radar Chase: 3. not missiles-energy low, not sound silent, no tank on radar Retreat: 4. missiles-energy low, not sound silent 5. missiles-energy low, tank on radar 6. missiles-energy low, incoming missile 7. sound silent, no tanks on radar, incoming missile</p> <p>We can map these on to a decision tree that successively splits on different conditions and see if all of the leaves of the tree are covered. This is a brute-force approach and is not practical when there are a large number of different condition elements being tested.</p> <p>The conditions include: sound, tanks on radar, incoming missiles, and missiles-energy low. Therefore we expect to have a four-level tree with sixteen leaves. Although we have only seven rules, these may cover all sixteen leaves because many rules don\u2019t test all four conditions. To build the tree, I picked the following condition ordering: missile-energy, sound silent, tank on radar, and incoming missiles. Each branch in the tree is labeled with the rules that can potentially match it. The letters in the nodes signify which operator will be selected (a=attack, c=chase, r=retreat, w=wander). The complete tree does not have to be generated if all of the remaining rules for a node propose the same operator and one of them does not test any additional features. For example, (missiles-energy low, not-sound silent) is covered by rules 4, 5, and 6, and rule 4 does not test any additional conditions.</p>"},{"location":"tutorials/soar_tutorial/03/#trace-of-a-simple-tank","title":"Trace of a Simple Tank","text":"<p>When all of the rules have been put together, you will have a tank that can wander, chase, attack, and retreat. If you have two of these fight against each other, you might get a trace like the following:</p> <p>One of the things you immediately notice is that when the tank decides to chase another tank it gives up on the next decision and goes back to wander. This is because the other tank is probably doing the same thing and stops moving for one decision, and so the sound sensor goes to silent. However, once a tank does see another, it fires a lot of missiles. Both of these should give you ideas for improving your tank. The next section explores how to avoid the problem with the disappearing sound.</p>"},{"location":"tutorials/soar_tutorial/03/#improving-sound-detection","title":"Improving Sound Detection","text":"<p>The most obvious problem with your tank is that it loses track of other tanks whenever the other tanks stop moving. To eliminate this problem, you can modify the rules in your tank so that when there is a sound, the tank creates a persistent memory of the direction of that sound so that it can chase the other tank, even if the other tank stops moving. Adding the persistent data structure requires adding new operators and changing all of the rules that test for sound directly from the input-link. Because of these extensive changes, you probably want to save you current tank and create a copy of it to modify. All of the changes in this section are incorporated in the Tutorial/simple-sound-bot agent.</p> <p>Even if you are not interested in improving your tank, you should read this section because it covers some of the complexities in Soar that arise when creating persistent data structures in subgoals.</p> <p>To create and remove the sound data structure requires at least two new operators.</p> <ul> <li>Record-sound: create the sound data structure when a new sound is     heard.</li> <li>Remove-sound: remove the sound data structure if the direction of     sound changes or if the recorded sound has expired.</li> </ul> <p>You can write an operator to directly update the sound data structure if it changes, instead of removing it and adding a new one, but the approach taken here will minimize the number of rules you need to write.</p> <p>The first step in adding these operators is to determine where sound is used and when it needs to be recorded. Sound affects the selection of the wander, retreat, and chase operators, so any persistent structure must be available on the top state. Sound needs to be recorded during wander, where it triggers a shift to chase. Thus you should add record-sound to the wander operator. Remove-sound should be selected if a sound changes directions or becomes out of date, no matter which top-level operator is selected. Thus, you should create remove-sound.soar in the all folder/directory.</p>"},{"location":"tutorials/soar_tutorial/03/#record-sound-operator","title":"Record-sound Operator","text":"<p>Proposing the record operator must test that there is a sound on the input-link.</p> <pre><code>sp {wander*propose*record-sound\n(state &lt;s&gt; ^name wander\n^io.input-link.sound &lt;&gt; silent)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + &gt; =)\n(&lt;o&gt; ^name record-sound)}\n</code></pre> <p>A best preference is used so that it will be immediately selected so the sound can be recorded.</p> <p>The rule to apply the operator must test that record-sound is the current operator and the direction of the sound. It should also test the current clock so that it can compute a time at which the sound \u201cexpires\u201d, meaning that the sound should be removed. I use 5 because it is long enough for the tank to turn around and get its radar on to hunt for the other tank. Finally, the rule needs to match the superstate because sound data structure is going to be added to it. The sound structure must be added to the superstate because the substate may disappear, destroying all structures attached to it. Below is an initial version of the apply rule.</p> <pre><code>sp {wander*apply*record-sound\n(state &lt;s&gt; ^operator.name record-sound\n^io.input-link &lt;il&gt;\n^superstate &lt;ss&gt;)\n(&lt;il&gt; ^sound &lt;direction&gt;\n^clock &lt;clock&gt;)\n--&gt;\n(&lt;ss&gt; ^sound &lt;sd&gt;)\n(&lt;sd&gt; ^direction &lt;direction&gt;\n^expire-time (+ &lt;clock&gt; 5))}\n</code></pre> <p>One problem with this rule is that it records the direction of the sound in terms of forward, left, right, or backward (that is what the sound sensor gives). This becomes a problem if the tank decides to turn and face in the direction of the sound (the tank will seem to chase its tail). A better approach is to record the absolute direction of the sound: north, east, south, or west. You can add an elaboration rule that computes the relative direction of the sound (forward, right, backward, left) in chase where it is needed.</p> <p>To compute the absolute direction requires creating a data structure in working memory that maps relative to absolute directions. This can be matched using the tanks current absolute direction (given on the direction input-link structure), and the relative direction from the sound input-link structure.</p> <pre><code>sp {elaborate\\*directions\n(state &lt;s&gt; ^superstate nil)\n--&gt;\n(&lt;s&gt; ^direction-map &lt;dm&gt;)\n(&lt;dm&gt; ^north &lt;north&gt;\n^south &lt;south&gt;\n^west &lt;west&gt;\n^east &lt;east&gt;)\n(&lt;north&gt; ^right east ^left west ^backward south ^forward north)\n(&lt;south&gt; ^right west ^left east ^backward north ^forward south)\n(&lt;west&gt; ^right north ^left south ^backward east ^forward west)\n(&lt;east&gt; ^right south ^left north ^backward west ^forward east)}\n</code></pre> <p>The direction-map structure provides a mapping between the current absolute direction, a relative direction, and a new absolution direction. For example, if a tank is facing north and the relative direction is left, then ^direction-map.north.left has value west.</p> <pre><code>sp {wander*apply*record-sound\n(state &lt;s&gt; ^operator.name record-sound\n^io.input-link &lt;il&gt;\n^superstate &lt;ss&gt;)\n(&lt;il&gt; ^sound &lt;rel-sound&gt;\n^direction &lt;direction&gt;\n^clock &lt;clock&gt;)\n(&lt;ss&gt; ^direction-map.&lt;direction&gt;.&lt;rel-sound&gt; &lt;abs-sound&gt;)\n--&gt;\n(&lt;ss&gt; ^sound &lt;sd&gt;)\n(&lt;sd&gt; ^absolute-direction &lt;abs-sound&gt;\n^expire-time (+ &lt;clock&gt; 5))}\n</code></pre> <p>Although the absolute direction of the sound is recorded, when chasing a tank, the relative direction of the sound is more useful. Since it is only needed in the implementation of chase, it only needs to be computed there. You may remember that all of the rules that propose operators to apply chase do not directly test the direction of the sound on the input-link. Instead, the input-link.sound was copied onto the chase state. Thus, to use the recorded sound, all you have to do is replace the elaboration rule in chase/elaborations.soar with one that computes the relative direction of the sound instead of copying the sound from the input-link. The direction-map structure can be used to do this calculation, which involves going from the current absolute direction of the tank, the absolute direction of the sound, to a relative direction of the sound. For example, if the tank is facing north, and the sound is known to be west, you can match: <code>direction-map.north.&lt;rel-sound&gt; west</code>, where <code>&lt;rel-sound&gt;</code> would match left.</p> <pre><code>sp {chase*elaborate*state\\*sound-direction\n(state &lt;s&gt; ^name chase\n^superstate &lt;ss&gt;)\n(&lt;ss&gt; ^sound.absolute-direction &lt;abs-sound&gt;\n^direction-map.&lt;direction&gt;.&lt;rel-sound&gt; &lt;abs-sound&gt;\n^io.input-link.direction &lt;direction&gt;)\n--&gt;\n(&lt;s&gt; ^sound-direction &lt;rel-sound&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#remove-sound-operator","title":"Remove-sound Operator","text":"<p>The sound data structure will persist on the top-state until it is removed; therefore, another operator must be created to remove it. This operator should be proposed whenever the time has expired. This could happen in almost any substate, so it is wise to store this operator in the all directory.</p> <p>Testing that the time has expired requires comparing the time stored on the sound data structure to the current clock. The proposal is simply:</p> <pre><code>sp {all*propose*remove-sound\n(state &lt;s&gt; ^name &lt;&lt; wander chase retreat attack &gt;&gt;\n^superstate.sound.expire-time &lt;clock&gt;\n^io.input-link.clock &gt; &lt;clock&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =, &gt;)\n(&lt;o&gt; ^name remove-sound)}\n</code></pre> <p>One might be tempted to not even test for the name of the state in the proposal given that it can apply in every state. However, testing the substate name indirectly influences the persistence of the result of the substate. This is a complex explanation that starts with the action of remove-sound, which is to create a reject preference for the sound data structure on the top-state. Although this action is part of the remove-sound operator, it is also a result of the substate/impasse created when a high-level operator was selected (wander, chase, retreat, or attack). When results are created, Soar computes their persistence (o-support or i-support) based on how they contribute to problem solving at the level to which they are returned. In Soar, this involves determining if the result is part of applying an operator at that level, which requires determining if an operator at that level was tested in generating the result.</p> <p>Soar determines which working memory elements were tested by recursively tracing back from the result, through all of the rules that fired in the subgoal and created structures that were tested in generating the results. The figure below shows a trace of the problem solving in the subgoal where elaboratestateoperator*name tests (S1 ^operator O7) and (O7 ^name chase) in creating (S8 ^name chase). Additional rules fire, testing the working memory elements, some of which exist in the superstate, and some which exist in the substate. Finally (S1 ^sound S5 -) is generated as a result. The trace starts with the result and proceeds backward, picking up all of the working memory elements from the superstate that were tested along the way. These are all underlined in the figure. If additional rules fired in the substate, but did not create results that contributed to the creation of (S1 ^sound S5 -), they would not be included in the trace.</p> <p>(S1 ^operator O7)</p> <p>(O7 ^name chase) (S8 ^name chase)</p> <p>From this trace, Soar generates a justification, which is essentially a rule that tests data structures that were in working memory before the impasse arose, and whose action is the result. The justification does not have any variables and includes tests for specific identifiers in working memory. (Soar\u2019s chunking mechanism replaces the identifiers in justifications with constants to build new rules.) In this case the justification would be:</p> <pre><code>(S1 ^operator O7)\n(O7 ^name chase)\n(S1 ^sound S5)\n(S5 ^expire-time 20)\n(S1 ^io I1)\n(I1 ^input-link I2)\n(I2 ^clock 21)\n--&gt;\n(S1 ^sound S5 -)\n</code></pre> <p>The justification is analyzed to determine if the result should get o-support or i-support. If the justification tests the operator, as it does in this case, then the result gets o-support. If the justification does not test the operator, the result gets i-support. If a result gets i-support, it is removed from working memory when any of the elements tested in the conditions of the justification are removed from working memory.</p> <p>Getting back to remove-sound, if the proposal for remove-sound does not test the name of the substate, the test for the operator in the superstate would not be included, making it independent of any operator application and the result would get i-support. However, if the proposal for remove-sound tests the name of the substate, the result is dependent on the selection of the operator, and the result will get o-support.</p> <p>This aspect of Soar is pretty complex and might have you wondering if you will be able to figure out how to create results with the right persistence. In general, you will find that all of the results you create in operator application substates should be o-supported, and they will as long as all of the rules that propose operators in the substate test the name of the substate. If you ever have an operator that should apply in a subgoal, but create an i-supported result, all you need to do is not test the name of the substate.</p> <p>Applying remove-sound is pretty straightforward. All that needs to be done is remove the sound data structure from the top-state, which in this case is the superstate.</p> <pre><code>sp {all*apply*remove-sound\n(state &lt;s&gt; ^operator.name remove-sound\n^superstate &lt;ss&gt;)\n(&lt;ss&gt; ^sound &lt;sd&gt;)\n--&gt;\n(&lt;ss&gt; ^sound &lt;sd&gt; -)}\n</code></pre> <p>With just the record-sound and remove-sound operators, your tank will now correctly maintain sound even when another tank stops moving. To take advantage of this requires modifying the proposal conditions for wander, retreat, and chase. For example, the original proposal for chase was:</p> <pre><code>sp {propose\\*chase\n(state &lt;s&gt; ^name tanksoar\n^io.input-link &lt;io&gt;\n-^missiles-energy low)\n(&lt;io&gt; ^sound &lt;&gt; silent\n\n-^radar.tank)\n--&gt;\n(&lt;s&gt; ^operator.name chase)}\n</code></pre> <p>The test for sound not being silent on the input-link is replaced for a test that the sound data structure exists, which involves just testing that the sound attribute is on the state.</p> <pre><code>sp {propose\\*chase\n(state &lt;s&gt; ^name tanksoar\n^sound\n-^io.input-link.radar.tank\n-^missiles-energy low)\n--&gt;\n(&lt;s&gt; ^operator.name chase)}\n</code></pre> <p>You may wish to refine the management of the sound data structure so that if the direction changes on the input-link, the sound data structure is removed. This is done by adding another proposal rule for remove-sound. This rule needs to match against the current sound direction, which is relative, and the saved sound direction, which is absolute, so some conversion is necessary.</p> <pre><code>sp {all*propose*remove-sound\\*changed-direction\n(state &lt;s&gt; ^name &lt;&lt; wander chase retreat attack &gt;&gt;\n^superstate &lt;ss&gt;\n^io.input-link &lt;il&gt;)\n(&lt;ss&gt; ^sound.absolute-direction &lt;abs-sound&gt;\n^direction-map.&lt;direction&gt;.&lt;rel-sound&gt; &lt;abs-sound&gt;)\n(&lt;il&gt; ^sound { &lt;&gt; silent &lt;&gt; &lt;rel-sound&gt; }\n^direction &lt;direction&gt;)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =, &gt;)\n(&lt;o&gt; ^name remove-sound)}\n</code></pre> <p>A further refinement you can make is to add an operator that updates the direction of the sound instead of removing the sound data structure.</p>"},{"location":"tutorials/soar_tutorial/03/#creating-a-map","title":"Creating a Map","text":"<p>As your tank wanders around, it can build a map of its world that it can later use to find the chargers or better control its radar. In this section, you will learn how to create a map. This section is less of a tutorial than an explanation of the code in the mapping-bot. The mapping-bot continually builds up the map no matter which operator is selected at the top level. The mapping-bot is the same as the simple-sound-bot, but with additional code.</p>"},{"location":"tutorials/soar_tutorial/03/#the-map-data-structure-and-initialization","title":"The Map Data Structure and Initialization","text":"<p>The map is a structure that must be stored and updated while the tank is playing the game. In the mapping-bot the map is stored in working memory as large graph structure off the top state. This approach is not the one to take to model human processing, but it is a straightforward approach for building a tank. The map consists of a 16 x 16 grid of squares. The size is 16 x 16 instead of 14 x 14 because it includes the borders as well as the spaces where the tank can move. The map is generated by the init-map operator, which is proposed and selected at the beginning of a run. It is proposed with a best preference, so that it will be preferred over the other operators. Once init-map is selected, it creates the map structure:</p> <pre><code>sp {apply\\*init-map\n(state &lt;s&gt; ^operator.name init-map)\n--&gt;\n(&lt;s&gt; ^map &lt;m&gt;)\n(&lt;m&gt; ^square &lt;s0-0&gt; &lt;s0-1&gt; &lt;s0-2&gt; \u2026)\n(&lt;s0-0&gt; ^x 0 ^y 0)\n(&lt;s0-1&gt; ^x 0 ^y 1)\n(&lt;s0-2&gt; ^x 0 ^y 2)\n\n\u2026}\n</code></pre> <p>Each square is initialized with its x and y location, which is the minimal information required to distinguish between the squares. Additional information and structure is required so that it is easy to access squares that are adjacent to the current square, and so it is easy to add information to the squares, such as that a square contains a recharger, tank, missile, or an obstacle, or that the square is clear. To make access of adjacent squares easier, we need to compute which squares are adjacent and then add augmentations between squares. The north and south adjacent squares have the same x value, but differ in y by one. Similarly the west and east adjacent squares have the same y value but differ in x by one. Thus, by adding one to the x value of every square we can find the square to the east, and by adding one to the y value, we can find the square to the south (we assume 0, 0 is in the upper left (north west) corner). We can then create east-west and north-south links between pairs of states. That is exactly what the following two rules do for east-west (there is a similar pair for north-south).</p> <pre><code>sp {top-ps*apply*init-map\\*add-adjacencies\\*east\n(state &lt;s&gt; ^operator.name init-map\n^map.square &lt;sq&gt;)\n(&lt;sq&gt; ^x { &lt; 15 &lt;x&gt; })\n--&gt;\n(&lt;sq&gt; ^east-x (+ &lt;x&gt; 1))}\n</code></pre> <pre><code>sp {top-ps*apply*init-map\\*add-adjacent\\*link\\*east\n(state &lt;s&gt; ^operator.name init-map\n^map.square &lt;sq1&gt; &lt;sq2&gt;)\n(&lt;sq1&gt; ^y &lt;y&gt; ^east-x &lt;x&gt;)\n(&lt;sq2&gt; ^y &lt;y&gt; ^x &lt;x&gt;)\n--&gt;\n(&lt;sq1&gt; ^east &lt;sq2&gt;)\n(&lt;sq2&gt; ^west &lt;sq1&gt;)}\n</code></pre> <p>Another initialization that is done at this time is to mark all of the squares that are on the border as obstacles. This is done by matching all squares with x or y coordinates of 0 or 15 and then adding the obstacle *yes* augmentation to them. Below is an example for the x with value 15:</p> <pre><code>sp {map\\*mark-obstacle\\*x15\n(state &lt;s&gt; ^operator.name init-map\n^map.square &lt;sq&gt;)\n(&lt;sq&gt; ^x 15)\n--&gt;\n(&lt;sq&gt; ^obstacle \\*yes\\*)}\n</code></pre> <p>So during init-map, the map is created and then all of the squares are linked via north, south, east, and west attributes. Needless to say, there are a large number of additions to working memory during the application of init-map.</p>"},{"location":"tutorials/soar_tutorial/03/#updating-the-map","title":"Updating the Map","text":"<p>In order to use and update the map, the agent must know which square on the map it is at. The easiest way to do this is to match the agent\u2019s current x, y location from the input-link to all of the squares and then create a link (named ^square) off the top state to the one that matches. This is a simple elaboration that is retracted and refired each time the agent moves.</p> <pre><code>sp {all\\*map\\*current-square\n(state &lt;s&gt; ^name tanksoar\n^io.input-link &lt;il&gt;\n^map.square &lt;cs&gt;)\n(&lt;il&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)\n(&lt;cs&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)\n--&gt;\n(&lt;s&gt; ^square &lt;cs&gt;)}\n</code></pre> <p>Once there is a current square, the next step is to update the internal map with any information that is available from the radar. This is a bit tricky because the radar gives information relative to the agent and does not give the absolute x, y coordinates of objects that are seen. For example, if there is a tank detected on radar, its position will be given as a distance (in the direction the agent is facing), and either left, right, or center, meaning that it is either in line (center) or one space left or right of center. A rule must translate from that type of information into x, y. This can be done by creating a data structure in working memory that contains the right information for changes in x and y for each possible heading of the agent. In the mapping-bot, it is the radar-map data structure and it is created in elaborations/top-state as part of the elaborate*directions rule. Below is the structures that are created as part of radar-map:</p> <pre><code>--&gt;\n(&lt;s&gt; ^radar-map &lt;dirp&gt;)\n(&lt;dirp&gt; ^north &lt;northp&gt;\n^south &lt;southp&gt;\n^west &lt;westp&gt;\n^east &lt;eastp&gt;)\n(&lt;northp&gt; ^center &lt;cr&gt; ^right &lt;nr&gt; ^left &lt;nl&gt; ^sx 0 ^sy -1)\n(&lt;southp&gt; ^center &lt;cr&gt; ^right &lt;sr&gt; ^left &lt;sl&gt; ^sx 0 ^sy 1)\n(&lt;westp&gt; ^center &lt;cr&gt; ^right &lt;wr&gt; ^left &lt;wl&gt; ^sx -1 ^sy 0)\n(&lt;eastp&gt; ^center &lt;cr&gt; ^right &lt;er&gt; ^left &lt;el&gt; ^sx 1 ^sy 0)\n(&lt;cr&gt; ^x 0 ^y 0)\n(&lt;nr&gt; ^x 1 ^y 0)\n(&lt;nl&gt; ^x -1 ^y 0)\n(&lt;sr&gt; ^x -1 ^y 0)\n(&lt;sl&gt; ^x 1 ^y 0)\n(&lt;wr&gt; ^x 0 ^y -1)\n(&lt;wl&gt; ^x 0 ^y 1)\n(&lt;er&gt; ^x 0 ^y 1)\n(&lt;el&gt; ^x 0 ^y -1)}\n</code></pre> <p>For each direction, there is a substructure. For that substructure, there are center, left, and right objects, each of which contains displacements for x and y so that the coordinate can be computed correctly. In addition, get direction object contains an sx and sy augmentation that is used via multiplication to determine the displacement of the distance from the agent\u2019s current position. If the agent is facing north or south, sx is 0, so there is no x component to the distance, and the sy is either 1 or \u20131 depending on whether the agent is facing south or north.</p> <p>This structure is then used in rules that compute the x, y location of objects seen on radar.</p> <pre><code>sp {map\\*mark-object\n(state &lt;s&gt; ^name tanksoar\n^map &lt;m&gt;\n^io.input-link &lt;io&gt;\n^square &lt;cs&gt;\n^radar-map.&lt;dir&gt; &lt;dirr&gt;)\n(&lt;dirr&gt; ^&lt;pos&gt; &lt;pss&gt;\n^sx &lt;sx&gt;\n^sy &lt;sy&gt;)\n(&lt;pss&gt; ^x &lt;dx&gt;\n^y &lt;dy&gt;)\n(&lt;io&gt; ^radar.{ &lt;type&gt;\n\n&lt;&lt; health energy obstacle open missiles tank &gt;&gt; } &lt;ob&gt;\n^direction &lt;dir&gt;)\n(&lt;ob&gt; ^distance &lt;d&gt;\n^position &lt;pos&gt;)\n(&lt;cs&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)\n--&gt;\n(&lt;m&gt; ^&lt;type&gt; &lt;obs&gt;)\n(&lt;obs&gt; ^x (+ (+ &lt;x&gt; (\\* &lt;sx&gt; &lt;d&gt;)) &lt;dx&gt;)\n^y (+ (+ &lt;y&gt; (\\* &lt;sy&gt; &lt;d&gt;)) &lt;dy&gt;))}\n</code></pre> <p>This creates a temporary (I-supported) structure on the map for each object seen on radar along with the x, y location.</p> <p>Following this, an additional rule can then match this structure with the squares in the map and update the map structure. This rule must make a persistent change to the map, and thus must either be part of an operator, or must use the special notation of :o-support following the name of the rule. In the rules below, :o-support is used just to illustrate its use. You could also include a test that an operator is selected <code>(^operator.name &lt;name&gt;)</code>, because this should be done no matter which operator is selected. In general, using the :o-support is not a good idea and it is easy to get carried away with it, so use it with caution.</p> <pre><code>sp {map\\*record-object\n\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^map &lt;m&gt;)\n(&lt;m&gt; ^{&lt;type&gt; &lt;&lt; obstacle health energy open tank missiles &gt;&gt;}\n&lt;obs&gt;\n^square &lt;sq&gt;)\n(&lt;sq&gt; ^x &lt;x&gt; ^y &lt;y&gt;)\n(&lt;obs&gt; ^x &lt;x&gt; ^y &lt;y&gt;)\n-(&lt;sq&gt; ^&lt;type&gt; \\*yes\\*)\n--&gt;\n(&lt;sq&gt; ^&lt;type&gt; \\*yes\\*)}\n</code></pre> <p>This marks squares with augmentations such as ^health *yes*, meaning there is a health charger on that square.</p> <p>Although obstacles and chargers are permanent, the missiles and tanks are not. Therefore, rules must be added that remove these when a square is detected to be open but not have missiles on them. The test for open is included to make sure that the radar is on and that there is something detected in that location. Otherwise, the missile would be removed whenever no missiles are detected for that square, even if it is impossible for the tank to see the square at the current time.</p> <pre><code>sp {map\\*clean\\*missiles\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^map &lt;m&gt;)\n(&lt;m&gt; ^square &lt;sq&gt;\n^open &lt;obs&gt;)\n(&lt;sq&gt; ^x &lt;x&gt;\n^y &lt;y&gt;\n^missiles \\*yes\\*)\n\n-{(&lt;m&gt; ^missiles &lt;mi&gt;)\n(&lt;mi&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)}\n(&lt;obs&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)\n--&gt;\n(&lt;sq&gt; ^missiles \\*yes\\* -)}\n</code></pre> <pre><code>sp {map\\*clean\\*tank\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^map &lt;m&gt;)\n(&lt;m&gt; ^square &lt;sq&gt;\n^open &lt;obs&gt;)\n(&lt;sq&gt; ^x &lt;x&gt;\n^y &lt;y&gt;\n^tank \\*yes\\*)\n\n-{(&lt;m&gt; ^tank &lt;mi&gt;)\n(&lt;mi&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)}\n(&lt;obs&gt; ^x &lt;x&gt;\n^y &lt;y&gt;)\n--&gt;\n(&lt;sq&gt; ^tank \\*yes\\* -)}\n</code></pre> <p>Furthermore, even if the tank doesn\u2019t have its radar on, it can remove tanks and missiles from the square that the tank occupies:</p> <pre><code>sp {map\\*clean\\*missile\\*occupied\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^square &lt;cs&gt;)\n(&lt;cs&gt; ^missiles \\*yes\\*)\n--&gt;\n(&lt;cs&gt; ^missiles \\*yes\\* -)}\n</code></pre> <pre><code>sp {map\\*clean\\*tank\\*occupied\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^square &lt;cs&gt;)\n(&lt;cs&gt; ^tank \\*yes\\*)\n--&gt;\n(&lt;cs&gt; ^tank \\*yes\\* -)}\n</code></pre> <p>We can also mark the current square to be open, as well as mark it with a charger if one is detected.</p> <pre><code>sp {map\\*record-open\\*there\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^square &lt;sq&gt;)\n(&lt;sq&gt; -^open \\*yes\\*)\n--&gt;\n(&lt;sq&gt; ^open \\*yes\\*)}\n</code></pre> <pre><code>sp {map\\*record-energy\\*there\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.energyrecharger yes\n^square &lt;sq&gt;)\n(&lt;sq&gt; -^energy \\*yes\\*)\n--&gt;\n(&lt;sq&gt; ^energy \\*yes\\*)}\n</code></pre> <pre><code>sp {map\\*record-health\\*there\n:o-support\n(state &lt;s&gt; ^name tanksoar\n^io.input-link.healthrecharger yes\n^square &lt;sq&gt;)\n(&lt;sq&gt; -^health \\*yes\\*)\n--&gt;\n(&lt;sq&gt; ^health \\*yes\\*)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/03/#using-the-map","title":"Using the Map","text":"<p>The map can be used in a variety of ways. The most obvious is to control the tank from the map instead of from radar, so that the tank only moves to squares that are open on the map and it tries to pick up missiles from the map. Thus, it can turn off the radar as soon as it sees some missiles.</p> <p>A more complex use of the map is to store in each square the distance in each direction to the first obstacle that would block the radar. In the future, this value can be used to control radar-power, thus minimizing the energy drain of the radar.</p> <p>The map can also be used to create paths to the chargers so that when a tank is low on health or energy, and has previously seen a charger, it can return to the charger. This can be a bit more challenging to implement, but it can be done.</p>"},{"location":"tutorials/soar_tutorial/03/#improving-your-tank","title":"Improving Your Tank","text":"<p>There are many ways you can modify your tank to improve its performance. The best way to do this is to watch its behavior very carefully and continually ask yourself, \u201cWhat would I do if I were the tank?\u201d</p>"},{"location":"tutorials/soar_tutorial/03/#possible-extensions","title":"Possible Extensions","text":"<p>There are many possible extensions to your tank. Here are the ones that I\u2019ve thought of, in increasing order of difficulty:</p> <ol> <li> <p>The tank picks up missiles that it sees on radar.</p> </li> <li> <p>The tank recharges at the health or energy chargers when it sees one     on radar and is low on health or energy.</p> </li> <li> <p>Radar-power is set to be only as far as the border.</p> </li> <li> <p>The tank uses different attack tactics based on how many missiles it     has (aggressive if it has lots of missiles, more conservative if it     is low on missiles).</p> </li> <li> <p>The tank uses the rwaves sensor better.</p> </li> <li> <p>The tank has more sophisticated wandering.</p> <ol> <li> <p>Turns toward the length of hall before it moves into hall so it     does not expose itself to possible attack while turning.</p> </li> <li> <p>Avoids getting stuck inside of rooms.</p> </li> <li> <p>Takes more advantage of the structure of the maps.</p> </li> </ol> </li> <li> <p>The tank has more sophisticated attacking</p> <ol> <li> <p>Tries to draw enemy fire and then get out of the way.</p> </li> <li> <p>Better attacking when radar isn\u2019t on.</p> </li> <li> <p>Better movement to attack when there are obstacles between your     tank and the enemy.</p> </li> </ol> </li> <li> <p>The tank uses the map to:</p> <ol> <li> <p>Move directly to chargers when low.</p> </li> <li> <p>Find places to hide when retreating or attacking.</p> </li> <li> <p>Turn on radar so that it will reach only as far as any blocking     obstacle.</p> </li> </ol> </li> </ol> <p>You will find that a tank that fights well and can keep moving even when it runs out of energy will do much better than a complex tank that does mapping and has other tactics but sometimes \u201cgoes dumb\u201d (starts to thrash between operators or gets a tie between operators).</p>"},{"location":"tutorials/soar_tutorial/03/#final-thoughts","title":"Final Thoughts","text":"<p>There are some other important aspects of substates in Soar not covered in this tutorial, and you should study the Soar 8 manual to learn about them. For example, Soar automatically terminates a substate if there are o-supported structures in the substate whose bases for creation in the superstate changes. Also, Soar has a learning mechanism, called chunking, that can be used to automatically learn new rules.</p> <p>Some general advice to keep you out of trouble is:</p> <ul> <li>Never combine different problem solving functions in a single rule.     For example, do not create a rule that both applies one operator and     simultaneously proposes another operator.</li> <li>Don\u2019t propose two operators in a single rule.</li> <li>Don\u2019t combine operators that create internal persistent structures.     This isn\u2019t as important as the other two; however, by keeping each     operator separate, it will be much easier to debug your code.</li> </ul>"},{"location":"tutorials/soar_tutorial/04/","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/04/#part-iv-more-simple-problem-solving","title":"Part IV: More Simple Problem Solving","text":"<p>This part of the tutorial returns to problems that are solved through internal search. You will build Soar programs for a classic AI problem: Missionaries and Cannibals. Other classic AI problems, including Blocks World, the Eight Puzzle, and Towers of Hanoi are included in the set of demonstration programs that comes with the Soar release. This is very similar to the water jug problem you did initially, but has a few interesting extensions. You will start by building the operators, state descriptions, and goal tests that are required to define each problem. You will also be introduced to more of the theory of problem solving based on search in problem spaces. In Part V, you will learn how to modify and extend programs so that they use planning and learning to solve problems.</p> <p>This problem is challenging in a different way than playing games such as Eaters and TankSoar. Eaters and TankSoar are competitive games and they require fast intelligent responses to the current situation, which can change quickly. This problem does not have dynamic environments. However, solving this problem requires selecting the one appropriate operator from a set of many at each decision point. Selecting the correct operator is not easy given the knowledge available from the problem description. The problem can be solved only through trial and error, which involves searching through the space of possible states.</p>"},{"location":"tutorials/soar_tutorial/04/#missionaries-and-cannibals-definition","title":"Missionaries and Cannibals Definition","text":"<p>Problem Statement:</p> <p>Three missionaries and three cannibals come to a river. There is a boat on their bank of the river that can be used by either one or two persons at a time. This boat must be used to cross the river in such a way that cannibals never outnumber missionaries on either bank of the river (although cannibals can be alone on one bank). How do the missionaries and cannibals successfully cross the river?</p> <p>Once again, the first step to creating a Soar program to solve this problem is to decompose it into the problem space (state representation and operators) and the problem (initial state and desired state). One interesting aspect of this problem is that it also includes failure states. If the cannibals ever outnumber the missionaries, then you have failed. Below is a partial graph (it doesn\u2019t show the last four steps) of the problem space, which shows that there are many illegal states that need to be avoided along the way to a solution.</p> <p>Below is a list of the aspects of the problem space and problem that you will define for this problem:</p> <ol> <li>The state representation. For this problem this will include the    positions of the missionaries, cannibals, and boat, relative to the    river.</li> <li>The initial state creation rule. In this problem, all the    missionaries, cannibals and the boat are on one bank of the river.</li> <li>The operator proposal rules. For this problem the operators move up    to two of the missionaries and/or cannibals across the river with    the boat.</li> <li>The operator application rules.</li> <li>The operator and state monitoring rules.</li> <li>The goal recognition rule. In this problem, the desired state is    achieved when all missionaries and cannibals have crossed the river.</li> <li>The failure recognition rule. These are rules that detect when a    state is created in which the goal cannot be achieved. In this    problem, the failure states are whenever the cannibals outnumber the    missionaries on one bank of the river.</li> <li>The search control rules.</li> </ol> <p>It may be tempting to try to incorporate the avoidance of failure states into the operators, so that operators are never proposed that lead to failure states. However that is moving an aspect of the problem into the problem space and requires some problem solving to determine what the conditions of the proposal should be. We will see in Part V how Soar can learn to rules that avoid proposing operators when they will lead to failure.</p> <p>As in the Water Jug problem, this program does not create a plan to solve the problem. Instead, when the program finishes, all of the missionaries and cannibals will have been moved across the river.</p>"},{"location":"tutorials/soar_tutorial/04/#state-representation","title":"State Representation","text":"<p>What are the parts of the problem that must be represented on the state? Everything in the problem description is important (there are no irrelevant objects are characteristics of the objects), so an initial list of objects includes three missionaries, three cannibals, a river, and the boat.</p> <p>At any point in solving the problem, it is necessary to represent which bank of the river the boat is and the banks that the missionaries and cannibals are on. One important observation is that it is not necessary to keep track of each missionary and cannibal individually. All that is important is the number of missionaries and cannibals on each bank of the river. For the purposes of this problem all cannibals are the same and all missionaries are the same. Therefore, it is not necessary to have a separate representation of each missionary or cannibal and its current position. Another observation is that you never have to represent a state where the boat has missionaries and cannibals in it \u2013 that happens only during the application of an operator. The only states that need to be represented are those with the boat on one bank of the river or the other. Therefore the important aspects of the states that need to be represented are:</p> <ul> <li>The number of missionaries on each bank of the river.</li> <li>The number of cannibals on each bank of the river.</li> <li>The bank of the river that the boat is on.</li> </ul> <p>There are many possible ways to represent this information using Soar\u2019s attributes and values. Try to come up with one on your own before looking at the representations listed below.</p> <p>In creating the representations below, the two banks of the river are named left and right, with left being the bank of the river the missionaries and cannibals start out on.</p> <p>Here is one possible representation:</p> <pre><code>(state &lt;s&gt; ^right-bank-missionaries 0-3\n  ^left-bank-missionaries 0-3\n  ^right-bank-cannibals 0-3\n  ^left-bank-cannibals 0-3\n  ^right-bank-boat 0/1\n  ^left-bank-boat 0/1)\n</code></pre> <p>Although this representation is adequate for solving the problem, it doesn\u2019t allow you to write general rules for proposing and applying operators. Using this representation, you would have to write separate proposal and application rules for when the boat is on each bank of the river. You would also have to write separate rules for moving cannibals and missionaries. When you have an attribute like right-bank-boat, the rules in Soar cannot match the different substructures, such as right-bank and boat. By representing each aspect separately using structured objects, you will find that it is possible to write very general operator proposal and application rules.</p> <p>There are two obvious structured representations to choose from. One state representation has objects on the state for the two banks of the river, with subobjects for the missionaries, cannibals, and boat on that bank. To simplify later processing, an additional attribute (other-bank) can be added to the subobjects so that opposite bank can be matched easily. Below is a representation for the initial state:</p> <pre><code>(state &lt;s&gt; ^left-bank &lt;l&gt;\n  ^right-bank &lt;r&gt;)\n  ^cannibals 3\n  ^boat 1\n  ^other-bank &lt;r&gt;)\n  ^cannibals 0\n  ^boat 0\n  ^other-bank &lt;l&gt;)\n</code></pre> <p>An alternative is to make the missionaries, cannibals, and boat the primary way of structuring the data, with the number of entities on each bank of the river as secondary.</p> <pre><code>(state &lt;s&gt; ^missionaries &lt;m&gt;\n  ^cannibals &lt;c&gt;\n  ^boat &lt;b&gt;)\n(&lt;m&gt; ^left 3\n  ^right 0)\n  ^right 0)\n(&lt;b&gt; ^left 1\n  ^right 0)\n</code></pre> <p>For this problem, both of these representations are sufficient and they are similar in terms of the ease of writing the operators and goal tests. Soar programs for both are included as demonstration programs with the Soar release. For the remainder of this section, the first representation will be used because it is closer to the physical structure of the problem.</p>"},{"location":"tutorials/soar_tutorial/04/#initial-state-creation-initialize-mac","title":"Initial State Creation: Initialize-mac","text":"<p>Just as in the Water Jug problem, you should create an initialization operator that names the state and creates all of the initial features on the state.</p> <pre><code>```Soar\nsp {mac*propose*initialize-mac\n  (state &lt;s&gt; ^superstate nil\n    -^name)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; +)\n  (&lt;o&gt; ^name initialize-mac)}\n</code></pre> <pre><code>sp {mac*apply*initialize-mac\n  (state &lt;s&gt; ^operator.name initialize-mac)\n--&gt;\n  (&lt;s&gt; ^name mac\n  ^left-bank &lt;l&gt;\n  ^right-bank &lt;r&gt;\n  ^desired &lt;d&gt;)\n  (&lt;r&gt; ^missionaries 0\n  ^cannibals 0\n  ^boat 0\n  ^other-bank &lt;l&gt;)\n  (&lt;l&gt; ^missionaries 3\n  ^cannibals 3\n  ^boat 1\n  ^other-bank &lt;r&gt;)\n  (&lt;d&gt; ^right-bank &lt;dr&gt;)\n  (&lt;dr&gt; ^missionaries 3\n  ^cannibals 3\n  ^boat 1)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/04/#operator-proposal","title":"Operator Proposal","text":"<p>The operators for this task move 1 to 2 individuals (missionaries or cannibals) across the river. In writing the proposal rules, it is easiest to break the operators into three classes:</p> <ul> <li>move one missionary or cannibal to the other bank</li> <li>test that there is at least one of the given type on the bank with     the boat</li> <li>move two missionaries or two cannibals</li> <li>test that there is at least two of the given type on the bank with     the boat</li> <li>move one missionary and one cannibal together</li> <li>test that there is at least one of each type on the bank with the     boat</li> </ul> <p>Try to write an English description of the proposal for first operator.</p> <pre><code>mac*propose*move-mac-boat*1\n</code></pre> <p>If the name of the state is mac and there is one or more cannibal or missionary on the same bank of the river as the boat, then propose moving that cannibal or missionary across the river.</p> <p>The other operator proposals are very similar:</p> <pre><code>mac*propose*move-mac-boat*2\n</code></pre> <p>If the name of the state is mac and there are two or more cannibals or missionaries on the same bank of the river as the boat, then propose moving two of that type across the river.</p> <pre><code>mac*propose*move-mac-boat*1\n</code></pre> <p>If the name of the state is mac and there is one or more cannibal and one or more missionaries on the same bank of the river as the boat, then propose moving one cannibal and one missionary across the river.</p> <p>As in the Water Jug problem, you need to decide on a representation of the operator and its parameters. For this task, the operator parameters that make sense are:</p> <ul> <li>The name of the operator: move-mac-boat.</li> <li>The type of entities being moved: cannibal or missionary.</li> <li>The number of each type of entity being moved: 1 or 2.</li> </ul> <p>The second two can be combined as a single attribute-value pair, with the type of entity being the attribute and the number being the value. This makes it easy to represent moving one or two entities of the same type as well as moving one missionary and one cannibal. To simplify later matching, you can also include the bank of the river that the boat is on. Also, for some of the reasoning, it will be useful to also represent how many different types of people are being moved, usually just one, but two when moving one missionaries and one cannibal. It is not necessary to include the bank of the river that the boat is on because it is represented in the current state.</p> <p>The operator representation for moving one cannibal (with the boat) from the bank with object l3 would be:</p> <pre><code>(&lt;o&gt; ^name move-mac-boat\n  ^cannibal 1\n  ^boat 1\n  ^bank l3\n  ^types 1)\n</code></pre> <p>Now try to write the first proposal as a Soar rule. To make it easier, a good approach is to initially write a very specific rule for one type of operator, and then attempt to generalize it by adding variables. To get started, you can try writing a proposal rule for just cannibals on the left bank of the river. That would be:</p> <pre><code>```Soar\nsp {mac*propose*move-mac-boat1\n  (state &lt;s&gt; ^name mac\n    ^left-bank &lt;bank&gt;)\n  (&lt;bank&gt; ^cannibals &gt; 0\n    ^boat 1)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; + =)\n  (&lt;o&gt; ^name move-mac-boat\n    ^bank &lt;bank&gt;\n    ^boat 1\n    ^cannibals 1\n    ^types 1)}\n</code></pre> <p>The operator is created with both an acceptable and a indifferent preference. In a later section you will explore adding search control.</p> <p>You can generalize this rule by using a variable for the bank of the river, making it so that the proposal applies no matter which bank the boat is on. To be safe, this requires introducing a disjunctive <code>(&lt;&lt; left-bank right-bank &gt;&gt;)</code> test for the attribute.</p> <pre><code>```Soar\nsp {mac*propose*move-mac-boat*1\n  (state &lt;s&gt; ^name mac\n    ^&lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n  (&lt;bank&gt; ^cannibals &gt; 0\n    ^boat 1)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; + =)\n  (&lt;o&gt; ^name move-mac-boat\n    ^bank &lt;bank&gt;\n    ^boat 1\n    ^cannibals 1\n    ^types 1)}\n</code></pre> <p>You can then further generalize the rule so that it can match against both cannibals and missionaries (but not the boat). This requires introducing a disjunctive <code>(&lt;&lt; cannibals missionaries &gt;&gt;)</code> test for the attribute of the bank object, and also a surrounding conjunctive test <code>({ &lt;&lt; cannibals missionaries &gt;&gt; &lt;type&gt; })</code> to match the entity type to the variable <code>&lt;type&gt;</code>, which can then be used in the action. The final rule is:</p> <pre><code>```Soar\nsp {mac*propose*operator*move-mac-boat1\n  (state &lt;s&gt; ^name mac\n    ^&lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n  (&lt;bank&gt; ^{ &lt;&lt; cannibals missionaries &gt;&gt; &lt;type&gt; } &gt; 0\n    ^boat 1)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-mac-boat\n  ^bank &lt;bank&gt;\n  ^&lt;type&gt; 1\n  ^boat 1\n  ^types 1)}\n</code></pre> <p>Now try to write the second proposal that moves two missionaries or two cannibals as a Soar rule. This requires only minimal changes to the first. The only changes are to test for more than one missionary or cannibal, and to increase the number being moved to 2.</p> <pre><code>```Soar\nsp {mac*propose*operator*move-mac-boat2\n  (state &lt;s&gt; ^name mac\n    ^ &lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n  (&lt;bank&gt; ^{ &lt;&lt; cannibals missionaries &gt;&gt; &lt;type&gt; } &gt; 1\n    ^boat 1)\n--&gt;\n(&lt;s&gt; ^operator &lt;o&gt; + =)\n(&lt;o&gt; ^name move-mac-boat\n^bank &lt;bank&gt;\n^&lt;type&gt; 2\n^boat 1\n^types 1)}\n</code></pre> <p>Now try to write the third proposal for moving one missionary and one cannibal.</p> <pre><code>sp {mac*propose*operator*move-mac-boat11\n  (state &lt;s&gt; ^name mac\n    ^ &lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n  (&lt;bank&gt; ^missionaries &gt; 0\n    ^cannibals &gt; 0\n    ^boat 1)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; + =)\n  (&lt;o&gt; ^name move-mac-boat\n    ^bank &lt;bank&gt;\n    ^missionaries 1\n    ^cannibals 1\n    ^boat 1\n    ^types 2)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/04/#operator-application","title":"Operator Application","text":"<p>The operator application rules must change the state to reflect the movement of the boat and the missionaries and cannibals that cross the river. As part of applying the operators, it is not necessary to represent that the missionaries and cannibals are in the boat, only that they change banks of the river. The changes that need to be made to the state are to decrease the number of missionaries and cannibals that are moving from the bank of the river that the boat is on, and increase the number on the bank the boat is moving to. Similarly, the count of the boat (0 or 1) must be changed. You might try to come up with a set of rules to do this, but because of the operator representation, a single rule can make changes for moving cannibals, missionaries and the boat from either bank of the river to the other. The rule must test for an augmentation of the operator, such as <code>^boat</code>, <code>^cannibals</code>, or <code>^missionaries</code>, and then change the corresponding subobject on the state. The rule will fire in parallel for all entities being moved, including the boat.</p> <p>Below is an English version of the required rule.</p> <pre><code># mac*apply*move-mac-boat\n# If there is a move-mac-boat operator selected for a type and number, then\n# subtract the values of that type on the current bank and add those values\n# to the other bank.\n</code></pre> <p>Converting this to a Soar rule is a bit tricky because of all of the variables. To simplify the conversion, we will start with a rule that applies the operator for moving one cannibal. Try to write this rule yourself.</p> <pre><code># mac*apply*move-mac-boat*one*cannibal\n# If there is a move-mac-boat operator selected for one cannibal, then\n# subtract one from cannibal object on the left bank and add one to the\n# cannibal object on the other bank.\n</code></pre> <pre><code>sp {apply*move-mac-boat*one*cannibal\n  (state &lt;s&gt; ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^cannibals 1\n    ^bank &lt;bank&gt;)\n  (&lt;bank&gt; ^cannibals &lt;bank-num&gt;\n    ^other-bank &lt;obank&gt;)\n  (&lt;obank&gt; ^cannibals &lt;obank-num&gt;)\n--&gt;\n  (&lt;bank&gt; ^cannibals &lt;bank-num&gt; -\n    (- &lt;bank-num&gt; 1))\n  (&lt;obank&gt; ^cannibals &lt;obank-num&gt; -\n    (+ &lt;obank-num&gt; 1))}\n</code></pre> <p>The above rule tests the operator to ensure that one cannibal is being moved <code>(&lt;o&gt; ^cannibals 1)</code> and to detect the bank of the operator. It then matches the number of cannibals on that bank, matching <code>&lt;bank-num&gt;</code>, via the other-bank attribute, matching <code>&lt;obank-num&gt;</code>. The actions of the rule modify the number of cannibals on the left bank by rejecting the current value <code>(^cannibals &lt;bank-num&gt; -)</code>, and by asserting the new value which is the original value minus one <code>(^cannibals (- &lt;bank-num&gt; 1))</code>. Arithmetic operations such as addition, subtraction, and multiplication are done in Soar using prefix notation where the operation is given first followed by the operands.</p> <p>One concern you might have about the above rule is that it will apply multiple times if there is more than one cannibal on the left bank of the river, moving each cannibal, one by one to the other bank. However, that will not happen because immediately after this rule fires (multiple times in parallel for each entity being moved) the rule that proposed the operator will no longer match, causing the operator to be removed. The operator proposal rule will no longer match because it tested the number of cannibals on the left bank of the river, which is changed by the rule. In addition, the boat will move from one bank to another at the same time, providing a second reason for the proposal rule not to match. Thus, the operator will terminate immediately after the above rule fires.</p> <p>The next step is to generalize this rule so it can apply to moving 1 or 2 cannibals. This requires replacing the test for ^cannibals 1 on the operator to <code>^cannibals &lt;number&gt;</code> and then using <code>&lt;number&gt;</code> in the actions to subtract from the current</p> <pre><code>sp {apply*move-mac-boat*cannibal\n  (state &lt;s&gt; ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^cannibals &lt;number&gt;\n    ^bank &lt;bank&gt;)\n  (&lt;bank&gt; ^cannibals &lt;bank-num&gt;\n    ^other-bank &lt;obank&gt;)\n  (&lt;obank&gt; ^cannibals &lt;obank-num&gt;)\n--&gt;\n  (&lt;bank&gt; ^cannibals &lt;bank-num&gt; -\n    (- &lt;bank-num&gt; &lt;number&gt;))\n  (&lt;obank&gt; ^cannibals &lt;obank-num&gt; -\n    (+ &lt;obank-num&gt; &lt;number&gt;))}\n</code></pre> <p>The final generalization is to replace the test for the <code>^cannibals</code> attribute of the operator with a more general test that matches cannibals, missionaries, or the boat to a variable <code>&lt;type&gt;</code>. That variable is used to match the appropriate object on the state. This rule will now fire multiple times to move the boat as well as any cannibals or missionaries that are moving.</p> <pre><code>sp {apply*move-mac-boat\n  (state &lt;s&gt; ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^{ &lt;&lt; missionaries cannibals boat &gt;&gt; &lt;type&gt; } &lt;number&gt;\n    ^bank &lt;bank&gt;)\n  (&lt;bank&gt; ^&lt;type&gt; &lt;bank-num&gt;\n    ^other-bank &lt;obank&gt;)\n  (&lt;obank&gt; ^&lt;type&gt; &lt;obank-num&gt;)\n--&gt;\n  (&lt;bank&gt; ^&lt;type&gt; &lt;bank-num&gt; -\n    (- &lt;bank-num&gt; &lt;number&gt;))\n  (&lt;obank&gt; ^&lt;type&gt; &lt;obank-num&gt; -\n    (+ &lt;obank-num&gt; &lt;number&gt;))}\n</code></pre>"},{"location":"tutorials/soar_tutorial/04/#state-and-operator-monitoring","title":"State and Operator Monitoring","text":"<p>Below are three rules that monitor the selected operator and the state (one rule for each bank that the boat is on).</p> <pre><code>sp {monitor*move-mac-boat\n  (state &lt;s&gt; ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^{ &lt;&lt; cannibals missionaries &gt;&gt; &lt;type&gt; } &lt;number&gt;)\n--&gt;\n  (write | Move | &lt;number&gt; | | &lt;type&gt;)}\n</code></pre> <pre><code>sp {monitor*state*left\n  (state &lt;s&gt; ^name mac\n    ^left-bank &lt;l&gt;\n    ^right-bank &lt;r&gt;)\n  (&lt;l&gt; ^missionaries &lt;ml&gt;\n    ^cannibals &lt;cl&gt;\n    ^boat 1)\n  (&lt;r&gt; ^missionaries &lt;mr&gt;\n    ^cannibals &lt;cr&gt;\n    ^boat 0)\n--&gt;\n  (write (crlf) | M: | &lt;ml&gt; |, C: | &lt;cl&gt; | B ~~~ |\n    | M: | &lt;mr&gt; |, C: | &lt;cr&gt; | |)}\n</code></pre> <pre><code>  sp {monitor*state*right\n  (state &lt;s&gt; ^name mac\n    ^left-bank &lt;l&gt;\n    ^right-bank &lt;r&gt;)\n  (&lt;l&gt; ^missionaries &lt;ml&gt;\n    ^cannibals &lt;cl&gt;\n    ^boat 0)\n  (&lt;r&gt; ^missionaries &lt;mr&gt;\n    ^cannibals &lt;cr&gt;\n    ^boat 1)\n--&gt;\n  (write (crlf) | M: | &lt;ml&gt; |, C: | &lt;cl&gt; | ~~~ B |\n    | M: | &lt;mr&gt; |, C: | &lt;cr&gt; | |)}\n</code></pre> <p>When you run your program, you will observe that your program runs forever and also sometimes visits states that are illegal according to the problem statement.</p>"},{"location":"tutorials/soar_tutorial/04/#desired-state-recognition","title":"Desired State Recognition","text":"<p>The next step in creating a program to solve missionaries and cannibals is creating a rule that recognizes when a desired state has been achieved. Although a rule specific to the given problem can easily be written, it might be better to write one that is more general. For example, you might assume that the desired state will always have some number of missionaries, cannibals, on one bank of the river.</p> <p>The action of the rule should be to print out a message that the problem has been solved and halt.</p> <p>Write an English version of this rule.</p> <pre><code># mac*detect*goal*achieved\n# If the name of the state is mac and the number of missionaries and\n# cannibals on one bank of the river in the desired state matches the number\n# of missionaries and cannibals on the same bank in the current state, write\n# that the problem has been solved and halt.\n```Soar\n\nTranslating this into Soar is relatively straightforward. Try to write\nyour own before looking below.\n\n```Soar\nsp {mac*detect*state*success\n  (state &lt;s&gt; ^desired &lt;d&gt;\n    ^&lt;side&gt; &lt;ls&gt;)\n  (&lt;ls&gt; ^missionaries &lt;m&gt;\n    ^cannibals &lt;c&gt;)\n  (&lt;d&gt; ^{ &lt;&lt; right-bank left-bank &gt;&gt; &lt;side&gt; } &lt;dls&gt;)\n  (&lt;dls&gt; ^missionaries &lt;m&gt;\n    ^cannibals &lt;c&gt;)\n--&gt;\n  (write (crlf) |The problem has been solved.|)\n  (halt)}\n</code></pre> <p>If you run this with the earlier rules, the program should halt at some point; however, it is likely that it will visit a failure state and thus solved the problem incorrectly.</p>"},{"location":"tutorials/soar_tutorial/04/#state-failure-detection","title":"State Failure Detection","text":"<p>The next step is creating a rule that recognizes when a failure state has been encountered. According to the problem statement, a failure state is one where the cannibals out number the missionaries on one bank of the river. One condition that is often forgotten is to test that the number of missionaries is greater than zero. The action for this rule is to print out a message that the problem has failed to be solved, and then halt. Write an English version of this rule.</p> <pre><code># mac*detect*goal*failure\n# If the name of the state is mac and there are more cannibals than\n# missionaries, and there is at least one missionary, on one bank of the\n# river, then write that the problem has failed to be solved, and halt.\n</code></pre> <p>Translating this into Soar is relatively straightforward. Try to write your own before looking below.</p> <pre><code>sp {mac*evaluate*state*failure*more*cannibals\n  (state &lt;s&gt; ^desired &lt;d&gt;\n    ^&lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n  (&lt;bank&gt; ^missionaries { &lt;n&gt; &gt; 0 }\n    ^cannibals &gt; &lt;n&gt;)\n--&gt;\n  (write (crlf) |The problem has failed.|)\n  (halt)}\n</code></pre> <p>Try running your complete program. Invariably the program will halt with failure because of the high likelihood of encountering a failure state.</p>"},{"location":"tutorials/soar_tutorial/04/#search-control-undoing-the-last-operator","title":"Search Control: Undoing the Last Operator","text":"<p>In the current problem, when a failure is reached, the program halts. One possibility is to have the program start over again from the initial state. But if you were working on the problem, you would probably notice that you reached an illegal state, and you would go back one step by undoing the last operator and try to find another path. In order to undo the last operator, you must remember what it was. You can use some of the work you did on the Water Jug where you created a memory to avoid undoing the last operator to prefer to undo an operator when a failure state is achieved.</p> <p>Given the representation of the move-mac-boat operator in working memory, you will have to write two rules to record the last operator, one that handles instances of the operator that move a single type of entity, and a second that handles instances of the operator that move one missionary and one cannibal. The action of these rules should create an augmentation of the state with information on the operator that is being applied. Try to write English versions of these rules.</p> <pre><code>mac*apply*move-mac-boat*record*last-operator*types*1\n</code></pre> <p>If an operator is selected to move one type of entity, then create an augmentation of the state (last-operator) with the bank of the boat, the type of entity being moved, the number, and that there is one type being moved.</p> <pre><code>mac*apply*move-mac-boat*record*last-operator*types*2\n</code></pre> <p>If an operator is selected to move two types of entity, then create an augmentation of the state (last-operator) with the bank of the boat and that there is two types being moved.</p> <p>These can then be converted into Soar rules:</p> <pre><code>sp {mac*apply*move-mac-boat*record*last-operator*types*1\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^bank &lt;bank&gt;\n    ^{ &lt;&lt; missionaries cannibals &gt;&gt; &lt;type&gt; } &lt;n&gt;\n    ^types 1)\n--&gt;\n  (&lt;s&gt; ^last-operator &lt;o1&gt;)\n  (&lt;o1&gt; ^types 1\n    ^bank &lt;bank&gt;\n    ^type &lt;type&gt;\n    ^number &lt;n&gt;)}\n</code></pre> <pre><code>sp {mac*apply*move-mac-boat*record*last-operator*types*2\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^bank &lt;bank&gt;\n    ^types 2)\n--&gt;\n  (&lt;s&gt; ^last-operator &lt;o1&gt;)\n  (&lt;o1&gt; ^types 2\n    ^bank &lt;bank&gt;)}\n</code></pre> <p>The rule to remove old records only has to test if the bank of the boat in the record of the last operator does not match the current bank that the boat is on because each time an operator is applied the boat changes banks.</p> <pre><code>mac*apply*move-mac-boat*remove*old*last-operator\n</code></pre> <p>If the move-mac-boat operator is selected and the bank in the last-operator is not equal to the bank of the current boat, remove the last-operator structure.</p> <p>This can then be converted into Soar a rule:</p> <pre><code>sp {mac*apply*move-mac-boat*remove*old*last-operator\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt;\n    ^&lt;lr-bank&gt;.other-bank &lt;o-bank&gt;\n    ^last-operator &lt;lo&gt;)\n  (&lt;lo&gt; ^bank &lt;o-bank&gt;)\n--&gt;\n  (&lt;s&gt; ^last-operator &lt;lo&gt; -)}\n</code></pre> <p>Once you add these rules, you can now add rules that undo an operator whenever one leads to a failure state. However, you must first modify the rule that detects failure so that it doesn\u2019t halt the program, but just augments the state with failure:</p> <pre><code># mac*detect*goal*failure\n# If the name of the state is mac and there are more cannibals than\n# missionaries, and there is at least one missionary, on one bank of the\n# river, then augment the state with failure true.\n</code></pre> <p>Translating this into Soar is relatively straightforward.</p> <pre><code>sp {mac*evaluate*state*failure*more*cannibals\n  (state &lt;s&gt; ^desired &lt;d&gt;\n    ^&lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n  (&lt;bank&gt; ^missionaries { &lt;n&gt; &gt; 0 }\n    ^cannibals &gt; &lt;n&gt;)\n--&gt;\n  (&lt;s&gt; ^failure &lt;d&gt;)}\n</code></pre> <p>Note that this rule only fires when there is an illegal state and it is not part of the application of an operator. Thus, it will retract and remove the failure augmentation automatically if the state changes and there is no longer an illegal state.</p> <p>Now you can write rules that prefer operators that undo the last operator when there is failure. Just as before, this will require two rules, one for moving a single type of entity, and one that moves one missionary and one cannibal. Below is a general English version for both rules.</p> <pre><code># mac*select*operator*prefer*inverse*failure\n# If the name of the state is mac and the current state is a failure state\n# and the last operator is the inverse of a proposed operator, then prefer\n# that operator.\n</code></pre> <pre><code>sp {mac*select*operator*prefer*inverse*failure*types*2\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt; +\n    ^failure &lt;d&gt;\n    ^last-operator &lt;lo&gt;)\n  (&lt;o&gt; ^name move-mac-boat\n    ^&lt;type&gt; &lt;number&gt;\n    ^types 1)\n  (&lt;lo&gt; ^types 1\n    ^type &lt;type&gt;\n    ^number &lt;number&gt;)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; &gt;)}\n</code></pre> <pre><code>sp {mac*select*operator*prefer*inverse*failure*types*1\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt; +\n    ^failure true\n    ^last-operator.types 2)\n  (&lt;o&gt; ^types 2)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; &gt;)}\n</code></pre> <p>After you have added these rules, your program will be able to solve the problem; however it will probably take a very indirect path to the solution. One reason is that after an operator has been successfully applied and generated a valid state, the inverse of that operator will often be selected, undoing the operator and wasting both operator applications. To avoid this, you can add two more rules that avoid undoing the last operator when the state is not a failure state.</p> <pre><code># mac*select*operator*avoid*inverse*not*failure\n# If the name of the state is mac and the current state is not a failure\n# state and the last operator is the inverse of a proposed operator, then\n# avoid that operator.\n</code></pre> <pre><code>sp {mac*select*operator*avoid*inverse*not*failure*1\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt; +\n    -^failure true\n    ^last-operator &lt;lo&gt;)\n  (&lt;o&gt; ^types 1\n    ^&lt;type&gt; &lt;number&gt;)\n  (&lt;lo&gt; ^types 1\n    ^type &lt;type&gt;\n    ^number &lt;number&gt;)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; &lt; )}\n</code></pre> <pre><code>sp {mac*select*operator*avoid*inverse*not*failure*2\n  (state &lt;s&gt; ^name mac\n    ^operator &lt;o&gt; +\n    -^failure true\n    ^last-operator &lt;lo&gt;)\n  (&lt;o&gt; ^types 2)\n  (&lt;lo&gt; ^types 2)\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; &lt; )}\n</code></pre> <p>After you have added these final rules, your program should solve the problem much quicker. However, you will notice that there is still some inefficiency. For example, at the initial state, it is possible for the program to attempt to apply the same operator to the state after it has failed with moving one or both the other missionaries. The figure below shows the initial state and the three successive states that it can cycle among. The problem is that only the most recent operator for a current state is recorded. It is not possible to associate all prior operators that applied to a state because the state is continually changing.</p> <p>In the next Part of the tutorial, you will learn how to use impasses and substates so that your programs can use look-ahead planning and solve this type of problem more directly.</p>"},{"location":"tutorials/soar_tutorial/05/","title":"Part V Planning and Learning","text":""},{"location":"tutorials/soar_tutorial/05/#under-construction","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/05/#part-v-planning-and-learning","title":"Part V: Planning and Learning","text":"<p>This part of the tutorial will teach you to build Soar programs that use subgoals to plan and learn. The type of planning that you will learn about in this section is simple look-ahead planning. Other types of planning are possible in Soar, but this is the most natural. In fact, you will need to make only minor changes and a few additions to use planning in the Water Jug and Missionaries and Cannibals problems. This type of learning is called chunking, which is a form of explanation-based generalization. Within the examples in this section, chunking speeds up problem solving by creating search-control rules. In other types of problem solving, chunking creates other types of rules including elaborations, operator proposals and operator applications.</p> <p>In simple look-ahead planning, your program will try out operators internally to evaluate them before it commits to applying them in the actual task. In the programs that you developed in Part I and Part IV, all of the problem solving was internal, so it didn\u2019t really matter if a mistake was made. For example, in the Missionaries and Cannibals problem, you added rules to backup when a failure state was reached. However, in problems that involve interaction with a world where you can\u2019t always undo an action, it is often critical to try out actions internally before executing them in the world. In addition, planning provides a way of comparing alternative operators based on the states they produce. Chunking builds rules that summarize the comparisons and evaluations that occur in the look-ahead search so that in the future the rules fire, making look-ahead search unnecessary - converting deliberation into reaction.</p> <p>Many planning systems have a two-stage cycle of planning and execution. They always plan when given a new problem and then execute the plan step by step. Our approach in Soar is different. In Soar, each decision is made with whatever knowledge is available and planning is one more source of knowledge that can be used whenever the knowledge encoded directly as rules is insufficient to make a decision. Thus, planning is used on an as-needed basis. As we will see later, planning in Soar does not create a step-by-step sequence of operators to apply blindly, but instead learns a set of context-dependent rules that prefer or avoid specific operators for states in the space. As a result, Soar\u2019s plans are more flexible so that plans learned for one problem may transfer to part of a second problem. It also makes it so that Soar only plans when it needs to.</p> <p>Our study of planning will parallel the study of problem solving. You will first modify and extend the rules you wrote for the Water Jug problem and then the Missionaries and Cannibals problem.</p>"},{"location":"tutorials/soar_tutorial/05/#the-water-jug-problem","title":"The Water Jug Problem","text":"<p>Planning in Soar arises out of its impasse detection and substate creation mechanism. Remember in TankSoar how subgoals were created when an operator was selected but there were no rules that could directly apply the operator. Soar has other impasses that arise when progress cannot be made for other reasons (see the manual for a complete description of impasses and substates). Soar automatically creates a subgoal whenever the preferences are insufficient for the decision procedure to select an operator. This is a signal that there is insufficient knowledge to make a decision and further problem solving is required. The decision procedure can choose an operator if there is either one clear winner (one operator that dominates the others based on the available preferences), or when there are multiple operators that are all indifferent. In the rules you\u2019ve written so far, there have always been indifferent preferences for every operator, so that the decision procedure always selected randomly among the preferred operators. However, indifferent preference should be used only when it is known that one operator is no better than another, instead of when it is not known which operator is best. Therefore, the first step to allow planning to be invoked is to eliminate the indifferent preference from the operator proposal rules.</p> <p>Below is the operator proposal for the fill operator in the Water Jug without the indifferent preference.</p> <pre><code>sp {water-jug*propose*fill\n   (state &lt;s&gt; ^name water-jug\n      ^jug &lt;j&gt;)\n   (&lt;j&gt; ^empty &gt; 0)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name fill\n      ^jug &lt;j&gt;)}\n</code></pre> <p>Once that indifferent preference is removed, rerun your program and step through the first decision. You will discover that Soar automatically generates a new substate in situations where the operator preferences are insufficient to pick a single operator. This is called a _tie impasse.</p> <p>When a tie impasse arises, a new substate is created that is very similar to the substate created in response to an operator no-change. Print out the substate and examine the augmentations. The key differences are that an operator tie has <code>^choices multiple</code>, <code>^impasse tie</code>, and <code>^item</code> augmentations for each of the tied operators.</p> <p>For the operator no-change impasses you used in TankSoar, the goal was to apply the selected operator to its state. This was achieved by selecting and applying operators in the substate that modify the superstate either directly (by adding or removing augmentations) or indirectly (by performing actions in the world that led to changes in the sensors that are part of the state). For a tie impasse, the goal is determine which task operator is the best to apply to the current state. This will be achieved by selecting and applying evaluation operators in the substate, one for each of the task operators. The purpose of these operators is to create an evaluation of the task operators, such as failure, success or a numeric evaluation of the likelihood of success. These evaluations will then be converted in preferences for the task operators. Once sufficient preferences have been created to select a task operator, it will be selected and the substate will automatically be removed from working memory. It is possible that after evaluating only a subset of the tied task operators, sufficient evaluations will be created so that preferences are generated that break the tie. For example, if an operator is evaluated and it is determined that it leads directly to the goal, a best preference can be created. This might be sufficient to break the tie, select an operator, and resolve the impasse.</p> <p>One way in which task operators can be evaluated is by trying them out on internal copies of the states in which the tie occurred, and then evaluating the states they create. The evaluation of states can be based on whether they are at desired state, a failure state (as in Missionaries in Cannibals), or the initial state. Many problems also lend themselves to an evaluation function that can be applied to a state that estimates how close the state is to the goal. For example, in Chess, numbers are assigned to the different pieces and you compare the value of your pieces to your opponents.</p> <p>We will call the problem of resolving a tie impasse, the Selection problem throughout the rest of the tutorial. We will treat the development of rules and operators for the selection problem just as we would treat the development of a program to solve other problems, such as the Water Jug or Missionaries and Cannibals, and go through the same steps we went through for those problems. Although coming up with good state evaluation functions for a specific problem can be challenging, the overall approach is very general and requires only a few bits of domain-specific information. In fact, we have created a set of generic Soar operators/rules that carry out the evaluation and comparison of operators using this approach. This set of generic rules can be used in a wide variety of problems for simple planning and they are available as part of the Soar release. These rules are part of the default rules that come with the Soar release in the file <code>Agents/default/selection.soar</code>. You should load these rules when you load in the Water-jug rules. You can do this by adding the following commands to your files (assuming that your program is in a subdirectory of the Agents directory):</p> <pre><code>pushd ../default\nsource selection.soar\npopd\n</code></pre> <p>By going through the rest of this section you will learn how these rules work and what you need to provide for them to be used on other problems.</p> <p>From our previous work on solving problems in Soar, here are the types of knowledge we need to consider for the selection problem:</p> <ol> <li>The state representation. This includes the representation of     evaluation objects that link evaluations with operators.</li> <li>The initial state creation rule. Since this problem arises as a     substate, an initial state is generated automatically.</li> <li>The operator proposal rules. The only operator is evaluate-operator     and it must be proposed for every tied operator.</li> <li>The operator application rules. Evaluate-operator is implemented     hierarchically, like the abstract operators in TankSoar. Therefore,     operator application involves a substate and substate operators.</li> <li>The operator and state monitoring rules. There are no special     monitoring rules for Selection.</li> <li>The desired state recognition rule. Desired state recognition is     automatic. When there are sufficient preferences, the decision     procedure selects an operator, the impasse is resolved, and the     substate is removed from working memory.</li> <li>The failure recognition rule. There are no failure states for this     problem.</li> <li>The search control rules. These rules help guide which operator     should be evaluated first.</li> </ol>"},{"location":"tutorials/soar_tutorial/05/#selection-state-representation","title":"Selection State Representation","text":"<p>For the selection problem, the operators are going to create and compare evaluations. Eventually, preferences for the superstate will be created, but those do not have to be represented in the Selection problem.</p> <p>If the evaluations had only a single value, namely the evaluation, then they could be represented as simple augmentations of the state, such as: <code>^evaluation success</code>. However, the evaluations must also include the task operator that the evaluation refers to. Moreover, we will find it useful to have different types of evaluations that can be compared in different ways, such as symbolic evaluations (success, failure) or numeric evaluations (numbers over some ordered range). We will also find it useful to create the evaluation structure before the evaluation is known, so that it will be useful to have an augmentation of the evaluation object that signifies that a value has been created. Therefore, the state should consist of a set of evaluation augmentations, with each evaluation object having the following structure:</p> <ul> <li><code>operator &lt;o&gt;</code> the identifier of the task operator being evaluated</li> <li><code>symbolic-value success/partial-success/partial-failure/failure/indifferent</code></li> <li><code>numeric-value [number]</code></li> <li><code>value true</code> indicates that there is either a symbolic or numeric value.</li> <li><code>desired &lt;d&gt;</code> the identifier of a desired state to use for evaluation if     there is one</li> </ul> <p>Another alternative to creating evaluations on the state is to create evaluations on the operators themselves. The advantage of creating evaluations on the state is that they are automatically removed when the impasse is resolved.</p>"},{"location":"tutorials/soar_tutorial/05/#selection-initial-state-creation","title":"Selection Initial State Creation","text":"<p>In the previous problems in this part, you have had to create a rule that generates the initial state. However, for the selection problem, the state is automatically created in response to an impasse. Furthermore, the evaluation objects will be created by operator applications. The one initial state elaboration rule that is necessary is one that names the state selection. This rule really isn\u2019t necessary, but will allow us to test for the name of the state instead of the impasse type in all of the remaining rules.</p> <pre><code>sp {default*selection*elaborate*name\n   :default\n   (state &lt;s&gt; ^type tie)\n--&gt;\n   (&lt;s&gt; ^name selection)}\n</code></pre> <p>This rule uses a new bit of syntax, the :default, which tells Soar that this is a default rule. Default rules do not behave any differently than other rules; however, Soar keeps separate statistics on default rules and allows you to remove all of the non-default rules easily. This rule and all others labeled default are included in the selection.soar file.</p>"},{"location":"tutorials/soar_tutorial/05/#selection-operator-proposal","title":"Selection Operator Proposal","text":"<p>The only operator in the Selection problem is evaluate-operator. This should be proposed in the Selection problem if there is an item that does not have an evaluation with a value. The operator will first create an evaluation and later compute the value.</p> <pre><code>selection*propose*evaluate-operator\n</code></pre> <p>If the state is named selection and there is an item that does not have an evaluation with a value, then propose the evaluate-operator for that item.</p> <p>The tricky part of translating this into a rule is the test that there is an item without an evaluation with a value. The item can be matched on the state as: <code>^item &lt;i&gt;</code>. The test that no evaluation exists is going to be a negation of an evaluation object <code>(&lt;s&gt; ^evaluation &lt;e&gt;)</code>. The evaluation object must also include a reference to the item, which is encoded as <code>(&lt;e&gt; ^operator &lt;i&gt;)</code>. An additional test <code>(&lt;e&gt; ^value true)</code> must be included in the negation so that the rule will match only if there does not exist an evaluate with a value, giving:</p> <pre><code>sp {selection*propose*evaluate-operator\n   :default\n   (state &lt;s&gt; ^name selection\n      ^item &lt;i&gt;)\n   -{(state &lt;s&gt; ^evaluation &lt;e&gt;)\n   (&lt;e&gt; ^operator &lt;i&gt;\n      ^value true)}\n--&gt;\n  (&lt;s&gt; ^operator &lt;o&gt; +, =)\n  (&lt;o&gt; ^name evaluate-operator\n      ^operator &lt;i&gt;)}\n</code></pre> <p>Given these conditions, once an evaluate-operator operator is selected, it will stay selected until an appropriate evaluation is created with a value. Therefore, one and only one evaluate-operator operator will be created and applied for each of the tied task operators.</p> <p>Unlike the Water Jug and Missionaries and Cannibals operators, these operators can be made indifferent. It is unlikely that it would be useful to do problem solving to decide which operator should be evaluated first. However, there might be some cases where some knowledge about the task can be used to order the evaluation of operators. For example, many Chess playing programs use iterative deepening to order the evaluation. Moreover, in a later section, we will see an example where it is useful to add some search control knowledge for evaluate-operator selection.</p>"},{"location":"tutorials/soar_tutorial/05/#selection-operator-application","title":"Selection Operator Application","text":"<p>The application of the evaluate-operator operators has two parts. The first part is the creation of the evaluation data structure, but without any value. In parallel with the creation of the evaluation structure, the operator is elaborated with additional structures to make application simpler. The end result is the following:</p> <pre><code>(&lt;s&gt; ^evaluation &lt;e&gt;\n   ^operator &lt;o&gt;)\n(&lt;e&gt; ^superoperator &lt;so&gt;\n   ^desired &lt;d&gt;)\n(&lt;o&gt; ^name evaluate-operator\n   ^superoperator &lt;so&gt;\n   ^evaluation &lt;e&gt;\n   ^superstate &lt;ss&gt;\n   ^superproblem-space &lt;sp&gt;)\n</code></pre> <p>The desired augmentation is an object that describes the desired state for the original task. In Water Jug, it was an object that described the three-gallon jug having a single gallon of water. In the Missionaries and Cannibals, it was an object that described having all of the missionaries and cannibals on the right side of the river. The desired structure is included so that the evaluation of an operator can be based on how well it helps achieve the desired state. This might be by achieving the desired state, or it might be based on a heuristic calculation of distance from the desired state to the state created by applying the operator being evaluated.</p> <p>The superproblem-space augmentation is the problem-space object of the superstate. What is a problem-space object? It is an explicit representation on the state of properties of the current problem space and can be used to cue the firing of rules relevant to the current problem space. The name augmentation of the state has served this purpose in the previous systems; however, it is insufficient in general because it contains only a single symbol, the name. By having an object, instead of just a name, additional properties of the problem space can be included. This is important in planning because the look-ahead search must use the same problem space and must copy the current state, which requires information about the structure of the problem space states..</p> <p>The second part is the calculation of the evaluation, which cannot be done directly with rules but requires its own substate. This substate is called to the evaluation problem. The original task state is copied to the evaluation substate. Then, the task operator being evaluated is applied to that state. If that new state can be evaluated, then the evaluation is returned as a result and added to the appropriate evaluation object. If no evaluation is possible, then problem solving in the task (such as the Water Jug) continues until an evaluation can be made. That may lead to more tie impasses, more substates, ... The key computations that have to be performed are:</p> <ol> <li>Creating the initial state</li> <li>Selecting the operator being evaluated</li> <li>Applying the selected operator</li> <li>Evaluating the result</li> </ol>"},{"location":"tutorials/soar_tutorial/05/#creating-the-initial-state","title":"Creating the Initial State","text":"<p>The initial state must be a copy of the state in which the tie impasse arose. Copying down all of the appropriate augmentations can be done by a few Water Jug specific rules; however, that means that with each new task, new state copy rules must also be written. To avoid this, we have written a general set of rules that can copy down the augmentations. These rules match against augmentations of the problem space to determine which state augmentations to copy. Below are the legal augmentations dealing with state copying and their meaning:</p> <ul> <li><code>default-state-copy no</code>: Do not copy any augmentations automatically.</li> <li> <p><code>one-level-attributes</code>: copies augmentations of the state and preserves     their value.</p> <p>Example:</p> <pre><code>(p1 ^one-level-attributes color) (s1 ^color c1) (c1 ^hue green) -&gt;\n(s2 ^color c1)\n</code></pre> </li> <li> <p><code>two-level-attributes</code>: copies augmentations of the state and creates     new identifiers for values. Shared identifiers replaced with same     new identifier.</p> <p>Example:</p> <pre><code>(p1 ^two-level-attributes color) (s1 ^color c1) (c1 ^hue green) -&gt;\n(s2 ^color c5) (c5 ^hue green)\n</code></pre> </li> <li> <p><code>all-attributes-at-level one</code>: copies all attributes of state as     one-level-attributes (except <code>dont-copy</code> ones and Soar created ones     such as <code>impasse</code>, <code>operator</code>, <code>superstate</code>)</p> <p>Example:</p> <pre><code>(p1 ^all-attributes-at-level one) (s1 ^color c1) (s1 ^size big) -&gt;\n(s2 ^color c1) (s2 ^size big)\n</code></pre> </li> <li> <p><code>all-attributes-at-level two</code>: copies all attributes of state as     two-level-attributes (except <code>dont-copy</code> ones and Soar created ones     such as <code>impasse</code>, <code>operator</code>, <code>superstate</code>)</p> <p>Example:</p> <pre><code>(p1 ^all-attributes-at-level two) (s1 ^color c1) (c1 ^hue green) -&gt;\n(s2 ^color c5) (c5 ^hue green)\n</code></pre> </li> <li> <p><code>dont-copy</code>: will not copy that attribute.</p> <p>Example:</p> <pre><code>(p1 ^dont-copy size)\n</code></pre> </li> <li> <p><code>dont-copy-anything</code>: will not copy any attributes</p> <pre><code>(p1 ^dont-copy-anything yes)\n</code></pre> </li> </ul> <p>If no augmentations relative to copying are included, the default is to do <code>all-attributes-at-level one</code>. The desired state is also copied over, based on the copy commands for the state.</p> <p>These rules support two levels of copying. How should you decide what level of augmentations need to be copied? In the water jug, the state has two levels of structure: the jugs and their contents, volume, and empty:</p> <pre><code>(s1 ^jug j1 j2)\n(j1 ^volume 3\n   ^contents 0\n   ^empty 3)\n(j2 ^volume 5\n   ^contents 0\n   ^empty 5)\n</code></pre> <p>Is it sufficient to copy the augmentations of the state, or do the subobjects need to be copied as well? To answer this question, you need to look closely at how the operators modify the state. In the formulation of the problem we\u2019ve been using, the operators change the augmentations of the jugs. For example, the application rule for fill is:</p> <pre><code>sp {water-jug*apply*fill\n   (state &lt;s&gt; ^operator &lt;o&gt;\n      ^jug &lt;j&gt;)\n   (&lt;o&gt; ^name fill\n      ^jug &lt;j&gt;)\n   (&lt;j&gt; ^volume &lt;volume&gt;\n      ^contents 0\n      ^empty &lt;volume&gt;)\n   --&gt;\n   (&lt;j&gt; ^contents &lt;volume&gt;\n         0 -\n      ^empty 0\n         &lt;volume&gt; - ) # (1)\n}\n</code></pre> <ol> <li>To remove a working memory element, use <code>-</code>.</li> </ol> <p>This rule modifies the contents and empty augmentations. So if this is used to apply the fill operator to the three-gallon jug using the working memory elements above, <code>(j1 ^contents 0)</code> and <code>(j1 ^empty 3)</code> will be removed from working memory and <code>(j1 ^contents 3)</code> and <code>(j1 ^empty 0)</code> will be added to working memory. The result will be that not only is the \u201ccopy\u201d modified, but also the original state. Thus, this is unacceptable because it does not make it possible to apply operators to substate without modifying the original.</p> <p>There are two possible solutions. The first is to copy two levels of attributes. This can be achieved by adding the following to the actions of original state initialization rule for Water Jug:</p> <pre><code>sp {water-jug*elaborate*problem-space\n   (state &lt;s&gt; ^name water-jug)\n   --&gt;\n   (&lt;s&gt; ^problem-space &lt;p&gt;)\n   (&lt;p&gt; ^name water-jug\n      ^default-state-copy yes\n      ^two-level-attributes jug)}\n</code></pre> <p>You could use <code>^all-attributes-at-level two</code> instead, but it is best to list exactly the attributes you need to have copied. After using this, the substate, <code>s3</code>, would have the following structure:</p> <pre><code>(s3 ^jug j3 j4)\n(j3 ^volume 3\n  ^contents 0\n  ^empty 3)\n(j4 ^volume 5\n  ^contents 0\n  ^empty 5)\n</code></pre> <p>The second approach is to change the operator applications so that they do not modify the augmentations of the jug objects but instead create completely new jug objects. For example, a modified version of fill would be:</p> <pre><code>sp {water-jug*apply*fill\n   (state &lt;s&gt; ^operator &lt;o&gt;\n      ^jug &lt;i&gt;)\n   (&lt;o&gt; ^name fill\n       ^jug &lt;i&gt;)\n   (&lt;i&gt; ^volume &lt;volume&gt;\n      ^contents 0\n      ^empty &lt;volume&gt;)\n   --&gt;\n   (&lt;s&gt; ^jug &lt;i&gt; -\n      ^jug &lt;ni&gt;)\n   (&lt;ni&gt; ^volume &lt;volume&gt;\n      ^contents &lt;volume&gt;\n      ^empty 0)}\n</code></pre> <p>The disadvantage of this approach is that it requires more changes to working memory when an operator is applied, although it requires fewer working memory elements to be copied during the creation of the initial state. This approach also is less natural in that it implies that a new jug is created as opposed to just modifying the contents of the existing jug. For these two reasons, the first approach (<code>two-level-attribute</code> copying) is preferred.</p>"},{"location":"tutorials/soar_tutorial/05/#selecting-the-operator-being-evaluated","title":"Selecting the operator being evaluated","text":"<p>Once the initial state of the evaluate-operator operator is created, a copy of the operator being evaluated needs to be selected. The reason a copy is necessary is two fold. First, the original operator may have augmentations that refer to objects in the original (non-copied) state. Therefore, a copy of the operator must be made with those new objects. In the Water Jug, the operator for fill has an augmentation for the jug being filled: (<code>&lt;o&gt; ^name fill ^jug j1</code>). The second reason is that in course of applying some operators, augmentations are added to the operator, which in this case would modify the original operator before it is applied. For these reasons, a duplicate of the operator is automatically made (unless <code>^default-operator-copy no</code> is an augmentation on the problem space). The copying replaces any identifiers in the operator structure that were changed in the state copying process (in this case <code>j1</code> would be replaced by <code>j3</code>).</p> <p>Once a copy is made, additional rules reject all of the other proposed operators so that the copy will be selected.</p>"},{"location":"tutorials/soar_tutorial/05/#applying-the-selected-operator","title":"Applying the selected operator","text":"<p>Once the operator is selected, the rules for applying it will fire and modify the copied state. You do not need to add any addition rules or modify existing rules. For tasks where the original operators involve action in an external world, such as in Eaters or TankSoar, you would have to write rules to simulate the effects of the selected operator on the state. For example, in Eaters, rules would have to be written to simulate the movement of the eater to a new square. The simulation can be only approximate because the eater does not have access to the complete world map so it cannot update sensors for squares it has not seen.</p>"},{"location":"tutorials/soar_tutorial/05/#evaluating-the-result","title":"Evaluating the result","text":"<p>Once the new state is created, an evaluation can be made. An augmentation is added to the state in parallel to the operator being applied: <code>^tried-tied-operator &lt;o&gt;</code>. This augmentation can be tested by rules to ensure that they are evaluating the result of applying the operator as opposed to the copy of the original state - although this will not work for operators that apply as a sequence of rules.</p> <p>The simplest evaluations to compute are success and failure. Success is when the goal is achieved. You have already written a rule that detects success for the Water Jug; however, this just halts the problem solving. This rule can be modified to create a working memory element that is used as an evaluation. The selection rules will automatically process an evaluation on a state in an evaluation state. The evaluation has two parts. The attribute is the type of evaluation and the value must be the identifier of the desired state. This ensures that the evaluation is done relative to the correct desired state. Therefore, the rule for detecting success should be modified to be as follows:</p> <pre><code>sp {water-jug*evaluate*state*success\n   (state &lt;s&gt; ^desired &lt;d&gt;\n      ^problem-space.name water-jug\n      ^jug &lt;j&gt;)\n   (&lt;d&gt; ^jug &lt;dj&gt;)\n   (&lt;dj&gt; ^volume &lt;v&gt; ^contents &lt;c&gt;)\n   (&lt;j&gt; ^volume &lt;v&gt; ^contents &lt;c&gt;)\n   --&gt;\n   (&lt;s&gt; ^success &lt;d&gt;)}\n</code></pre> <p>In addition to success and failure, the selection rules can process other symbolic evaluations as well as numeric evaluations. The symbolic preferences that are processed are as follows:</p> <ul> <li> <p>success: This state is the desired state. This is translated into a     best preference. It is also translated into a better preference if     another operator has a result state with an evaluation of     partial-success.</p> </li> <li> <p>partial-success: This state is on the path to success. This is     translated into a best preference.</p> </li> <li> <p>indifferent: This state is known to be neither success of failure.     This is translated into an indifference preference.</p> </li> <li> <p>failure: The desired state cannot be achieved from this state. This     is translated into a reject preference.</p> </li> <li> <p>partial-failure: All paths from this state lead to failure. This is     translated into a worst preference.</p> </li> </ul> <p>For numeric evaluations, an augmentation named <code>^numeric-value</code> should be created for the evaluation object for an operator. We will discuss numeric evaluations in more detail in a future section.</p> <p>If you include your original rules, the selection rules, and the two new rules described above (<code>water-jug*elaborate*problem-space</code>, <code>water-jug*evaluate*state*success</code>), your system will start doing a look-ahead search. You will notice that at each operator selection there is a tie and a recursive stack of substates is created. If the solution is ever found, it is only used locally to select the operator for the most recent tie impasse. As a result, it will have to rediscover the solution as it slowly \u201cbacks out\u201d of the substates. Another problem is that the system will often revisit the same state and generate an identical tie impasse deeper in the stack of states. The resolution of the first problem will wait until we introduce chunking.</p> <p>You can resolve the second problem by evaluating states that are already in the stack as failure. That means that if an operator is being evaluated, and if it produces a state that is the duplicate of a previous state (one already on the state stack), then it is considered a failure. Not only will this avoid long loops but it will also mean that the operator that undoes the most recent operator will be avoided. The good news is that by using this we can eliminate the rules for remembering the last operator.</p> <p>What does this rule need to have as its conditions? It needs to test the following:</p> <ol> <li>The desired state, which is used in the action: <code>(&lt;s1&gt; ^desired &lt;d&gt;)</code></li> <li>The contents of the state.</li> <li>That state exists after the operator has been applied in an     evaluation. Remember from earlier in this section that the correct     test for this is: <code>(&lt;s1&gt; ^tried-tied-operator)</code></li> <li>That there is a duplicate of that state that is earlier in the state     stack. There is nothing inherent in Soar that keeps track of all     earlier states - only the superstate is readily available. We need     to add rules that elaborate each state with all of its superstates     (and their superstates). We will call this the superstate-set.     Computing this requires only two rules - one that adds its     superstate to the superstate-set and one that adds all of the     superstate-set of the superstate to its superstate-set.</li> </ol> <pre><code>sp {Impasse__Operator_Tie*elaborate*superstate-set\n   (state &lt;s&gt; ^superstate &lt;ss&gt;)\n   --&gt;\n   (&lt;s&gt; ^superstate-set &lt;ss&gt;)}\n</code></pre> <pre><code>sp {Impasse__Operator_Tie*elaborate*superstate-set2\n   (state &lt;s&gt; ^superstate.superstate-set &lt;ss&gt;)\n   --&gt;\n   (&lt;s&gt; ^superstate-set &lt;ss&gt;)}\n</code></pre> <p>The rule to detect failure is then as follows:</p> <pre><code>sp {water-jug*evaluate*state*failure*duplicate\n   (state &lt;s2&gt; ^name water-jug\n      ^superstate-set &lt;s1&gt;\n      ^jug &lt;i1&gt;\n      ^jug &lt;i2&gt;\n      ^tried-tied-operator)\n   (&lt;i1&gt; ^volume 5 ^contents &lt;c1&gt;)\n   (&lt;i2&gt; ^volume 3 ^contents &lt;c2&gt;)\n   (&lt;s1&gt; ^name water-jug\n      ^desired &lt;d&gt;\n      ^jug &lt;j1&gt;\n      ^jug &lt;j2&gt;)\n   (&lt;j1&gt; ^volume 5 ^contents &lt;c1&gt;)\n   (&lt;j2&gt; ^volume 3 ^contents &lt;c2&gt;)\n   --&gt;\n   (&lt;s2&gt; ^failure &lt;d&gt;)}\n</code></pre> <p>With this rule added, the problem solving will be more directed, but it will take an excessive number of decisions to solve the problem. The problem is that as soon as a result is produced, such as that in a given state a specific operator leads to failure, it is forgotten so that the next time that state is encountered, the evaluation must be repeated. What is needed is some memory that relates a state and operator with a result, which is essentially a rule. Conceptually, the conditions that should be included in the rule are templates of the working memory elements that were tested in the processing that produced the result. This is exactly what chunking does.</p>"},{"location":"tutorials/soar_tutorial/05/#chunking","title":"Chunking","text":"<p>Chunking is invoked when a result is produced in a substate. The result will be the action of a new rule. Chunking examines the working memory elements that were matched by the rule that created the result. If any of those working memory elements are linked to superstates, they become conditions in the new rule. For each of the remaining working memory elements, chunking finds the rule and associated working memory elements that were responsible for generating it and recursively backtraces until all of the conditions are collected. Some of the working memory elements tested in conditions require special processing. For example, if one of the tied operators is tested via an item augmentation of a state is tested in a rule that leads to the inclusion of a test for an acceptable preference for that operator in the superstate.</p> <p>This process requires that Soar maintain a copy of every instantiated rule firing in a substate. Once all of the conditions have been collected, Soar converts all identifiers that were in the working memory elements into variables and adds the rule to rule memory. The rule is immediately available for matching.</p> <p>Because chunking is based on the problem solving in a subgoal, the generality of any rule is determined by what was tested by the rules that participated in producing the result. If the original rules tested working memory elements that were not necessary to produce the result, then the chunk will also test for them and the new rule will be overly specific.</p> <p>To invoke chunking, type in: <code>chunk always</code> at the prompt of the interaction window or add <code>chunk always</code> as a line in the file containing your rules. You will also want to see when chunks are created and fire, which is enabled using: <code>watch --chunks</code>. Before rerunning your program, try to predict what types of rules will be learned. There should be two different types of rules because there are two different types of results: preferences created by comparing evaluations in the selection problem, and evaluations created in the evaluation substate. Rules for the first type will test that there is an acceptable preference for the operator, as well as features of the operator and state that led to the creation of the preference. Rules of the second type will test that there is an evaluate-operator operator selected and features of the operator and state being evaluated.</p> <p>Now run and examine the trace. Print out the chunks.</p>"},{"location":"tutorials/soar_tutorial/05/#the-missionaries-and-cannibals-problem","title":"The Missionaries and Cannibals Problem","text":"<p>Now that you have done the conversion of the Water Jug to a simple planner, it should be relatively straightforward to convert the missionaries and cannibals. In this section we go through the conversion quickly, highlighting a problem, and then exploring the use of numeric evaluations in addition to symbolic evaluations.</p>"},{"location":"tutorials/soar_tutorial/05/#conversion-to-planning-and-learning","title":"Conversion to Planning and Learning","text":"<p>You should try to do the conversion yourself. There is one very subtle problem that will arise when you start to use learning. When you run into trouble, try to figure it out, and then read the rest of this section. Hint: Do not forget to alter your move-mac-boat proposals so that they no longer have an indifferent preference.</p>"},{"location":"tutorials/soar_tutorial/05/#add-selection-rules","title":"Add selection rules","text":"<p>The first step is to add the following to your program so that the selection rules are added in:</p> <pre><code>pushd ../default\nsource selection.soar\npopd\n</code></pre>"},{"location":"tutorials/soar_tutorial/05/#add-problem-space-and-state-copying-information","title":"Add problem space and state copying information","text":"<p>The second step is to add the rule that defines the problem space and specifies how the state copying should be done for evaluation. If you look back at your implementation of Missionaries and Cannibals, you will see that the operator application rules modify augmentations of the left-bank and right-bank structures, so that a two-level attribute copy is necessary.</p> <pre><code>sp {mac*elaborate*problem-space\n   (state &lt;s&gt; ^name mac)\n   --&gt;\n   (&lt;s&gt; ^problem-space &lt;p&gt;)\n   (&lt;p&gt; ^name missionaries-and-cannibals\n      ^default-state-copy yes\n      ^two-level-attributes right-bank left-bank)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/05/#modify-goal-detection","title":"Modify goal detection","text":"<p>The third step is to modify the goal detection rule so that it creates a symbolic evaluation of success instead of printing a message and halting.</p> <pre><code>sp {mac*detect*state*success\n   (state &lt;s&gt; ^desired &lt;d&gt;\n      ^&lt;bank&gt; &lt;ls&gt;)\n   (&lt;ls&gt; ^missionaries &lt;m&gt;\n      ^cannibals &lt;c&gt;)\n   (&lt;d&gt; ^{ &lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt; } &lt;dls&gt;)\n   (&lt;dls&gt; ^missionaries &lt;m&gt;\n      ^cannibals &lt;c&gt;)\n   --&gt;\n   (&lt;s&gt; ^success &lt;d&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/05/#modify-failure-detection","title":"Modify failure detection","text":"<p>Although there were no failure states in the Water Jug, there are in the Missionaries and Cannibals problem. The action of the rule that detects failure must be modified to create a symbolic value of failure.</p> <pre><code>sp {mac*evaluate*state*failure*more*cannibals\n   (state &lt;s&gt; ^desired &lt;d&gt;\n      ^&lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt;)\n   (&lt;bank&gt; ^missionaries { &lt;n&gt; &gt; 0 }\n      ^cannibals &gt; &lt;n&gt;)\n   --&gt;\n   (&lt;s&gt; ^failure &lt;d&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/05/#add-duplicate-state-detection-rule","title":"Add duplicate state detection rule","text":"<p>The fifth step is to add a rule that detects when there are duplicate states in the state stack and evaluates the most recent one as a failure.</p> <pre><code>sp {mac*evaluate*state*failure*duplicate\n   (state &lt;s1&gt; ^desired &lt;d&gt;\n      ^right-bank &lt;rb&gt;\n      ^left-bank &lt;lb&gt;)\n   (&lt;rb&gt; ^missionaries &lt;rbm&gt; ^cannibals &lt;rbc&gt; ^boat &lt;rbb&gt;)\n   (&lt;lb&gt; ^missionaries &lt;lbm&gt; ^cannibals &lt;lbc&gt; ^boat &lt;lbb&gt;)\n   (state { &lt;&gt; &lt;s1&gt; &lt;s2&gt; }\n      ^right-bank &lt;rb2&gt;\n      ^left-bank &lt;lb2&gt;\n      ^tried-tied-operator)\n   (&lt;rb2&gt; ^missionaries &lt;rbm&gt; ^cannibals &lt;rbc&gt; ^boat &lt;rbb&gt;)\n   (&lt;lb2&gt; ^missionaries &lt;lbm&gt; ^cannibals &lt;lbc&gt; ^boat &lt;lbb&gt;)\n      -(state &lt;s3&gt; ^superstate &lt;s2&gt;)\n--&gt;\n   (&lt;s2&gt; ^failure &lt;d&gt;)}\n</code></pre>"},{"location":"tutorials/soar_tutorial/05/#remove-last-operator-rules","title":"Remove last-operator rules","text":"<p>The last-operator rules are no longer necessary because the planning and duplicate state detect replace (and improve) the processing they were designed for.</p> <p>After making these six changes, your program should be able to solve the Missionaries and Cannibals problem with planning. However, just as with the Water Jugs problem, it may take a very long time. The obvious solution is to use chunking, Soar\u2019s learning mechanism. The next section describes a subtle problem that arises when chunking is used.</p>"},{"location":"tutorials/soar_tutorial/05/#subtle-chunking-problem","title":"Subtle chunking problem","text":"<p>When you run your program with chunking enabled, it might stop in the middle of solving the problem. The reason for this is that with the current rules for operator implementation, chunking can learn some control rules that are overgeneral, rejecting an operator that is on the path to the goal. Specifically, chunking can learn a rule that states:</p> <p>If the current state has the boat on the right bank and two missionaries and two cannibals, reject an operator that moves one missionary and the boat to the left.</p> <p>This rule is learned when the operator to move one missionary to the left is evaluated in a evaluation subgoal and discovered to lead to a failure state - where there is one missionary and two cannibals on the right bank. The problem with this rule is that it doesn\u2019t include a test that no cannibals are also moved. If the operator moves a cannibal at the same time it moves a missionary, it does not produce a failure state. However, with the way the application rule is written, chunking is unable to pick up any test that no cannibals are being moved. A satisfactory fix to this problem is to add a test to the operator application rules for the number of types being modified by the operator (^types).</p> <pre><code>sp {mac*apply*move-mac-boat\n   (state &lt;s&gt; ^operator &lt;o&gt;)\n   (&lt;o&gt; ^name move-mac-boat\n      ^{ &lt;&lt; missionaries cannibals boat &gt;&gt; &lt;type&gt; } &lt;num&gt;\n      ^bank &lt;bank&gt;\n      ^types &lt;types&gt;)\n   (&lt;bank&gt; ^&lt;type&gt; &lt;bank-num&gt;\n      ^other-bank &lt;obank&gt;)\n   (&lt;obank&gt; ^&lt;type&gt; &lt;obank-num&gt;)\n   --&gt;\n   (&lt;bank&gt; ^&lt;type&gt; &lt;bank-num&gt; -\n      (- &lt;bank-num&gt; &lt;num&gt;))\n   (&lt;obank&gt; ^&lt;type&gt; &lt;obank-num&gt; -\n      (+ &lt;obank-num&gt; &lt;num&gt;))}\n</code></pre> <p>Once this is included, the learned chunked changes to be:</p> <p>If the current state has the boat on the right bank and two missionaries and two cannibals, reject an operator that moves only one missionary and the boat to the left.</p> <p>Now the system should successfully solve the problem, and after chunking, solving it in the minimal number of steps.</p>"},{"location":"tutorials/soar_tutorial/05/#numeric-evaluations","title":"Numeric Evaluations","text":"<p>Without chunking, Soar takes a very long time to solve the problem because it does not get any evaluation until the problem is solved, and then must resolve the problem many times. One approach to avoid the long search is to add in some evaluations of the states that don\u2019t require the final state to be achieved. All that is needed is a good evaluation function. A very simple evaluation function is to prefer states that have more missionaries and cannibals on the desired bank of the river. Thus, the evaluation is just the sum of the number of missionaries and cannibals on the desired bank of the river, with higher numbers preferred.</p> <p>There are selection rules that do all of the domain-independent processing, such as comparing evaluations and creating the appropriate preferences. All you need to do is add a rule to compute the evaluation, and augment the desired state such that higher numbers are better. For example, the second of these changes leads to the following initialization rule:</p> <pre><code>sp {mac*apply*initialize-mac\n   (state &lt;s&gt; ^operator.name initialize-mac)\n   --&gt;\n   (&lt;s&gt; ^right-bank &lt;r&gt;\n      ^left-bank &lt;l&gt;\n      ^desired &lt;d&gt;)\n   (&lt;r&gt; ^missionaries 0\n      ^cannibals 0\n      ^boat 0\n      ^other-bank &lt;l&gt;)\n   (&lt;l&gt; ^missionaries 3\n      ^cannibals 3\n      ^boat 1\n      ^other-bank &lt;r&gt;)\n   (&lt;d&gt; ^right-bank &lt;dl&gt;\n      ^better higher) # (1)\n   (&lt;dl&gt; ^missionaries 3\n      ^cannibals 3\n      ^boat 1)}\n</code></pre> <ol> <li>New augmentation</li> </ol> <p>The rule that computes the evaluation must test the desired state to determine which bank is the desired one. It must also match the number of missionaries and cannibals on that bank, as well as test that the operator being evaluated has applied (<code>^tried-tied-operator</code>). The action of the operator is to create an augmentation on the state with the computed evaluation.</p> <pre><code>sp {mac*evaluate*state*number\n   (state &lt;s&gt; ^desired &lt;d&gt;\n      ^tried-tied-operator\n      ^&lt;bank&gt; &lt;ls&gt;)\n   (&lt;ls&gt; ^missionaries &lt;m&gt;\n      ^cannibals &lt;c&gt;)\n   (&lt;d&gt; ^{ &lt;&lt; right-bank left-bank &gt;&gt; &lt;bank&gt; } &lt;dls&gt;)\n   --&gt;\n   (&lt;s&gt; ^numeric-value (+ &lt;m&gt; &lt;c&gt;))}\n</code></pre> <p>Now run your system. Without chunking, the solution is found much faster with this rule. However, once chunking is used, an interesting thing happens. This rule actually hurts performance. The reason is that the evaluation is only a heuristic and is sometimes wrong. Chunking captures both the good and the bad aspects of the evaluation and uses them for selecting the operators. When this evaluation is not used, all of the learning is based on absolute features of the task: success and failure. There are no heuristics that are sometimes wrong, so the rules are always correct. The lesson is that chunking is only as good as the problem solving and that sometimes it is not worthwhile to put in partly correct information.</p>"},{"location":"tutorials/soar_tutorial/06/","title":"Part VI Reinforcement Learning","text":""},{"location":"tutorials/soar_tutorial/06/#under-construction","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/06/#part-vi-reinforcement-learning","title":"Part VI: Reinforcement Learning","text":"<p>Let us quickly review the type of operator preferences you have used thus far in the tutorial. First, acceptability (+): only acceptable operators are considered for application. Acceptable preferences must be further described as either relatively differentiated or indifferent. Differentiated preferences (such as &gt; and &lt;) establish a relative ordering from which Soar will choose the most preferred operator. If all preferences are labeled as indifferent (=), Soar\u2019s random operator choice can be further affected by numerical indifferent parameters.</p> <p>Reinforcement learning (RL) in Soar allows agents to alter behavior over time by dynamically changing numerical indifferent preferences in procedural memory in response to a reward signal. This learning mechanism contrasts starkly with chunking. Whereas chunking is a one-shot form of learning that increases agent execution performance by summarizing sub-goal results, RL is an incremental form of learning that probabilistically alters agent behavior.</p>"},{"location":"tutorials/soar_tutorial/06/#reinforcement-learning-in-action","title":"Reinforcement Learning in Action","text":"<p>Before we get to the nuts and bolts of RL, consider first an example of its effects. Left-Right is a simple agent that can choose to move either left or right. Unbeknownst to this agent, one direction is more preferable than the other. After deciding its destination, the agent will receive a \u201creward,\u201d or feedback regarding how good a decision it made. In this case, it will receive a reward of -1 for moving left and +1 for moving right. Using RL, the agent will learn quickly that moving right is preferable to moving left.</p>"},{"location":"tutorials/soar_tutorial/06/#the-left-right-agent","title":"The Left-Right Agent","text":"<p>Given the description above, let\u2019s begin creating the Left-Right agent. This agent will have a move operator that will choose between moving left and right. Because the agent does not know a priori which direction is better, the agent will be indifferent as to the preference between these actions. As you are unfamiliar with the particulars of RL agent design, either type the following code into your favorite editor or open the VisualSoar left-right project in the Agents directory:</p>"},{"location":"tutorials/soar_tutorial/06/#initialization","title":"Initialization","text":"<p>The agent stores directions and associated reward on the state</p> <pre><code>sp {propose*initialize-left-right\n   (state &lt;s&gt; ^superstate nil\n     -^name)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name initialize-left-right)\n}\n</code></pre> <pre><code>sp {apply*initialize-left-right\n   (state &lt;s&gt; ^operator &lt;op&gt;)\n   (&lt;op&gt; ^name initialize-left-right)\n   --&gt;\n   (&lt;s&gt; ^name left-right\n      ^direction &lt;d1&gt; &lt;d2&gt;\n      ^location start)\n   (&lt;d1&gt; ^name left ^reward -1)\n   (&lt;d2&gt; ^name right ^reward 1)\n}\n</code></pre>"},{"location":"tutorials/soar_tutorial/06/#move","title":"Move","text":"<p>The agent can move in any available direction. The chosen direction is stored on the state.</p> <pre><code>sp {left-right*propose*move\n   (state &lt;s&gt; ^name left-right\n      ^direction.name &lt;dir&gt;\n      ^location start)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; +)\n   (&lt;op&gt; ^name move\n      ^dir &lt;dir&gt;)\n}\n</code></pre> <pre><code>sp {left-right*rl*left\n   (state &lt;s&gt; ^name left-right\n      ^operator &lt;op&gt; +)\n   (&lt;op&gt; ^name move\n      ^dir left)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <pre><code>sp {left-right*rl*right\n   (state &lt;s&gt; ^name left-right\n      ^operator &lt;op&gt; +)\n   (&lt;op&gt; ^name move\n      ^dir right)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <pre><code>sp {apply*move\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^location start)\n   (&lt;op&gt; ^name move\n      ^dir &lt;dir&gt;)\n   --&gt;\n   (&lt;s&gt; ^location start - &lt;dir&gt;)\n   (write (crlf) |Moved: | &lt;dir&gt;)\n}\n</code></pre>"},{"location":"tutorials/soar_tutorial/06/#reward","title":"Reward","text":"<p>When an agent chooses a direction, it is afforded the respective reward.</p> <pre><code>sp {elaborate*reward\n   (state &lt;s&gt; ^name left-right\n      ^reward-link &lt;r&gt;\n      ^location &lt;d-name&gt;\n      ^direction &lt;dir&gt;)\n   (&lt;dir&gt; ^name &lt;d-name&gt; ^reward &lt;d-reward&gt;)\n   --&gt;\n   (&lt;r&gt; ^reward.value &lt;d-reward&gt;)\n}\n</code></pre>"},{"location":"tutorials/soar_tutorial/06/#conclusion","title":"Conclusion","text":"<p>When an agent chooses a direction, the task is over and the agent halts.</p> <pre><code>sp {elaborate*done\n   (state &lt;s&gt; ^name left-right\n      ^location {&lt;&gt; start})\n   --&gt;\n   (halt)\n}\n</code></pre> <p>You will notice a number of unexpected elements in the code above, namely the rl rules for the move operator and the reward elaboration. The reasons for these components will be made clear in later sections.</p>"},{"location":"tutorials/soar_tutorial/06/#running-the-left-right-agent","title":"Running the Left-Right Agent","text":"<p>Start the Soar Debugger and load the source for the Left-Right agent. By default, reinforcement learning is disabled. To enable this learning mechanism, enter the following commands:</p> <pre><code>rl --set learning on\nindifferent-selection \u2013-epsilon-greedy\n</code></pre> <p>Note that these commands have been added to the _firstload file of the included left-right project. The first command turns learning on, while the second sets the exploration policy (more on this later.)</p> <p>Next, click the \u201cStep\" button. This will run Soar through the first cycle. You will note initialization has been chosen, no surprise. In the debugger, execute the following command:</p> <pre><code>print --rl\n</code></pre> <p>This command shows you the numerical indifferent preferences in procedural memory subject to RL updating. The output is presented here:</p> <pre><code>left-right*rl*right 0. 0\nleft-right*rl*left 0. 0\n</code></pre> <p>This result shows that the preference for the two operator instances after 0 updates have a value of 0. Click \u201cStep\u201d two more times, then execute print --rl again, to see RL in action:</p> <pre><code>left-right*rl*right 1. 0.3\nleft-right*rl*left 0. 0\n</code></pre> <p>After applying the move operator, the numerical indifference value for the rule associated with moving right has now been updated 1 time to a value of 0.3. Note that since the move preferences are indifferent, and thus the decision process is made probabilistically, your agent may have decided to move left instead of right. In this case the <code>*left-right*rl*left*</code> preference would have been updated 1 time with a value of -0.3.</p> <p>Now click the \u201cInit-soar\u201d button. This will reinitialize the agent. Execute <code>print --rl</code>. Notice that the numeric indifferent values have not changed from the previous run. Storing these values between runs is the method by which RL agents learn. Run the agent 20 more times, clicking the \u201cInit-soar\u201d button after each halted execution. You should notice the numeric indifference value for moving right increasing, while the value for moving left decreases. Correspondingly, you should notice the agent choosing to move left less frequently.</p>"},{"location":"tutorials/soar_tutorial/06/#building-a-learning-agent","title":"Building a Learning Agent","text":"<p>Conversion of most agents to take advantage of reinforcement learning takes part in three stages: (1) use RL rules, (2) implement one or more reward rules, and (3) enable the reinforcement learning mechanism. As an example, we will update the basic Water-Jug agent from Tutorial Part I to take advantage of RL functionality. The modified code can be found in the Agents directory.</p>"},{"location":"tutorials/soar_tutorial/06/#rl-rules","title":"RL Rules","text":"<p>Rules that are recognized as updatable by the RL mechanism must abide by a specific syntax:</p> <pre><code>sp {my*proposal*rule\n   (state &lt;s&gt; ^operator &lt;op&gt; +\n      ^condition &lt;c&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 2.3)\n}\n</code></pre> <p>The name of the rule can be anything and the left-hand side (LHS) of the rule, the conditions, may take any form. However, the right-hand side (RHS) must take the following form:</p> <pre><code>(&lt;s&gt; ^operator &lt;op&gt; = number)\n</code></pre> <p>To be specific, the RHS can only have one action, asserting a single numeric indifferent preference, and number must be a numeric constant value (such as 2.3 in the example above). Any other actions, including proposing acceptability of the operator, must take place in a separate rule.</p> <p>Recalling the Water Jug problem, our goal will be to have the agent learn the best conditions under which to empty a jug (of particular volume), fill a jug (of particular volume), and pour one jug (of particular volume) to another. Thus we will modify the empty, fill, and pour operators to afford them RL updatable rules.</p> <p>Modifying the Water-Jug agent\u2019s rules to make them compatible with RL will take two steps: (a) modify the existing proposal rules and (b) creating new RL rules. Modification of the existing proposal rule is trivial: simply remove the \u201c=\u201d (equal) sign from the operator preference assertion action on the RHS:</p> <pre><code>sp {water-jug*propose*empty\n   (state &lt;s&gt; ^name water-jug\n      ^jug &lt;j&gt;)\n   (&lt;j&gt; ^contents &gt; 0)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name empty\n      ^empty-jug &lt;j&gt;)}\n</code></pre> <pre><code>sp {water-jug*propose*fill\n   (state &lt;s&gt; ^name water-jug\n      ^jug &lt;j&gt;)\n   (&lt;j&gt; ^empty &gt; 0)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name fill\n      ^fill-jug &lt;j&gt;)}\n</code></pre> <pre><code>sp {water-jug*propose*pour\n   (state &lt;s&gt; ^name water-jug\n      ^jug &lt;i&gt; { &lt;&gt; &lt;i&gt; &lt;j&gt; })\n   (&lt;i&gt; ^contents &gt; 0 )\n   (&lt;j&gt; ^empty &gt; 0)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;o&gt; +)\n   (&lt;o&gt; ^name pour\n      ^empty-jug &lt;i&gt;\n      ^fill-jug &lt;j&gt;)}\n</code></pre> <p>To be clear, these modified rules propose their respective operators with an acceptable preference. Next, we will write RL rules whose conditions detect these acceptable preferences and compliment with numeric indifferent preferences.</p> <p>The second step of agent modification can be much more laborious. In order for RL to provide feedback for each action in each state of the problem, it must have an RL rule for each state-action pair. In the Water Jug problem, a state can be represented by the volume of each of the jugs and the action (empty, fill, or pour) with one of the two jugs. As an example, one RL rule for the emptying the 3-unit jug (currently storing 2 units) when the 5-unit jug has 4 units could be written as follows:</p> <pre><code>sp {water-jug*empty*3*2*4\n   (state &lt;s&gt; ^name water-jug\n      ^operator &lt;op&gt; +\n      ^jug &lt;j1&gt; &lt;j2&gt;)\n   (&lt;op&gt; ^name empty\n      ^empty-jug.volume 3)\n   (&lt;j1&gt; ^volume 3\n      ^contents 2)\n   (&lt;j2&gt; ^volume 5\n      ^contents 4)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <p>For simple agents, like the Left-Right agent above, enumerating all state-action pair as RL rules by hand is plausible. However, the Water-Jug agent requires \\((3 \\cdot 2 \\cdot 4 \\cdot 6) = 144\\) RL rules to fully represent this space. Since we can express these rules as the output of a simple combinatorial pattern, we will use the Soar <code>gp</code> command to generate all the rules we need:</p> <pre><code>gp {rl*water-jug*empty\n   (state &lt;s&gt; ^name water-jug\n      ^operator &lt;op&gt; +\n      ^jug &lt;j1&gt; &lt;j2&gt;)\n   (&lt;op&gt; ^name empty\n      ^empty-jug.volume [3 5])\n   (&lt;j1&gt; ^volume 3\n      ^contents [0 1 2 3])\n   (&lt;j2&gt; ^volume 5\n      ^contents [0 1 2 3 4 5])\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <pre><code>gp {rl*water-jug*fill\n   (state &lt;s&gt; ^name water-jug\n      ^operator &lt;op&gt; +\n      ^jug &lt;j1&gt; &lt;j2&gt;)\n   (&lt;op&gt; ^name fill\n      ^fill-jug.volume [3 5])\n   (&lt;j1&gt; ^volume 3\n      ^contents [0 1 2 3])\n   (&lt;j2&gt; ^volume 5\n      ^contents [0 1 2 3 4 5])\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 0)\n   }\n</code></pre> <pre><code>gp {rl*water-jug*pour\n   (state &lt;s&gt; ^name water-jug\n      ^operator &lt;op&gt; +\n      ^jug &lt;j1&gt; &lt;j2&gt;)\n   (&lt;op&gt; ^name pour\n      ^empty-jug.volume [3 5])\n   (&lt;j1&gt; ^volume 3\n      ^contents [0 1 2 3])\n   (&lt;j2&gt; ^volume 5\n      ^contents [0 1 2 3 4 5])\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; = 0)\n}\n</code></pre> <p>Note that had the rules required a more complex pattern for generation, or had we not known all required rules at agent design time, we would have made use of rule templates.</p>"},{"location":"tutorials/soar_tutorial/06/#reward-rules","title":"Reward Rules","text":"<p>Reward rules are just like any other Soar rule, except that they modify the reward-link structure of the state to reflect reward associated with the agent\u2019s current operator decision. Reward values must be stored on the value element of the reward attribute of the reward-link identifier (<code>state.reward-link.reward.value</code>).</p> <p>Of significant note, Soar does not remove or modify structures within the reward-link, including old reward values. It is the agent\u2019s responsibility to maintain the reward-link structure to reflect proper feedback to the RL mechanism. In most cases, this means reward rules will be i-supported, such as to create non-persistent reward values. If an attribute remains on the reward-link structure, such as through an o-supported rule, the reward will count multiple times in the reinforcement learning.</p> <p>For the Water-Jug agent, we will provide reward only when the agent has achieved the goal. This entails making a minor modification to the goal-test rule:</p> <pre><code>sp {water-jug*detect*goal*achieved\n   (state &lt;s&gt; ^name water-jug\n      ^jug &lt;j&gt;\n      ^reward-link &lt;rl&gt;)\n   (&lt;j&gt; ^volume 3 ^contents 1)\n   --&gt;\n   (write (crlf) |The problem has been solved.|)\n   (&lt;rl&gt; ^reward.value 10)\n   (halt)}\n</code></pre> <p>Now load this code into the debugger and run it a few times (if loading your own code, remember to enable reinforcement learning). After about five runs you should find that the agent has adopted a near optimal strategy. At any point during the runs you can execute the print --rl command to see the numeric indifferent values of the RL rules generated by the gp command. You can right-click and print any of these rules to see their conditions.</p>"},{"location":"tutorials/soar_tutorial/06/#further-exploration","title":"Further Exploration","text":"<p>Consider the following output from a run (<code>watch level 0</code>) of the learning left-right agent from section 1:</p> <pre><code>run\nMoved: right\nThis Agent halted.\nAn agent halted during the run.\n\ninit-soar\nAgent reinitialized.\n\nrun\nMoved: right\nThis Agent halted.\nAn agent halted during the run.\n\ninit-soar\nAgent reinitialized.\n\nrun\nMoved: left\nThis Agent halted.\nAn agent halted during the run.\n</code></pre> <p>You should notice that at run 3 moving left is selected. By this point moving right has an obvious advantage in numerical preference values, thus why is left chosen? The answer lies with exploration policies.</p> <p>There are times in learning when exploration of operations currently considered less-than-preferred may lead you down a useful path. Soar allows you to tune your level of exploring these alternate paths using the indifferent-selection command.</p> <p>In the Soar Debugger, type <code>indifferent-selection --stats</code>. The result should look like this:</p> <pre><code>Exploration Policy: epsilon-greedy\nAutomatic Policy Parameter Reduction: off\n\nepsilon: 0.1\nepsilon Reduction Policy: exponential\nepsilon Reduction Rate (exponential/linear): 1/0\n\ntemperature: 25\ntemperature Reduction Policy: exponential\ntemperature Reduction Rate (exponential/linear): 1/0\n</code></pre> <p>This command prints the current exploration policy as well as a number of tuning parameters. There are five exploration policies: boltzmann, epsilon-greedy, softmax, first, and last. You can change the exploration policy by issuing the following command (where \u201cpolicy_name\u201d should be replaced with one of the policies above):</p> <pre><code>indifferent-selection --policy_name\n</code></pre> <p>This tutorial will only discuss the epsilon-greedy policy. For information on the other policies you should read the Soar manual. Epsilon greedy is a policy common within reinforcement learning experimentation to allow parameter-controlled exploration of operators not currently recognized as most preferred. This policy is controlled by the epsilon parameter. The policy is summarized as such:</p> <pre><code>With ( 1 - epsilon ) probability, the most preferred operator is to be\nchosen. With epsilon probability, a random selection of all indifferent\noperators is made.\n</code></pre> <p>When Soar is first started, the default exploration policy is softmax. However, the first time RL is enabled, the architecture automatically changes the exploration policy to epsilon-greedy, a policy more suitable for RL agents. The default value of epsilon is 0.1, dictating that 90% of the time the operator with greatest numerical preference value is chosen, while the remaining 10% of the time a random selection is made from all acceptable proposed operators. You can change the epsilon value by issuing the following command:</p> <pre><code>indifferent-selection --epsilon &lt;value&gt;\n</code></pre> <p>Acceptable values for epsilon are numbers between 0 and 1 (inclusive). You may note, by the definition, that a value of 0 will eliminate the chance of exploration and a value of 1 will result in a uniformly random selection.</p> <p>With this explanation, you should experiment with different values of epsilon during different runs in the agents discussed in this tutorial.</p>"},{"location":"tutorials/soar_tutorial/07/","title":"Part VII Semantic Memory","text":""},{"location":"tutorials/soar_tutorial/07/#under-construction","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/07/#part-vii-semantic-memory","title":"Part VII: Semantic Memory","text":"<p>Semantic memory (SMem) in Soar is a mechanism that allows agents to deliberately store and retrieve objects that are persistent. This information supplements what is contained in short-term working memory and other long-term memories, such as rules in procedural memory.</p>"},{"location":"tutorials/soar_tutorial/07/#the-semantic-store","title":"The Semantic Store","text":"<p>Before we delve into how an agent can use semantic memory, let\u2019s see an example of preloading knowledge and viewing the contents of the memory.</p> <p>First, open the Soar Debugger. Then, execute the following command (this can be loaded from a source file just as any other Soar command):</p> <pre><code>smem --add {\n    (&lt;a&gt; ^name alice ^friend &lt;b&gt;)\n    (&lt;b&gt; ^name bob ^friend &lt;a&gt;)\n    (&lt;c&gt; ^name charley)\n}\n</code></pre> <p>As we shall see in a moment, executing this command adds three objects to semantic memory. In general, the smem --add command is useful to preload the contents of large knowledge bases in Soar.</p> <p>We can view the contents of semantic memory using the following command:</p> <pre><code>print @\n</code></pre> <p>Which will output the following result:</p> <pre><code>(@1 ^friend @2 ^name alice [+0.000])\n(@2 ^friend @1 ^name bob [+0.000])\n(@3 ^name charley [+0.000])\n</code></pre> <p>Note first that the variables from the smem --add command have been instantiated as specific identifiers (<code>&lt;a&gt;</code> as <code>@1</code>, <code>&lt;b&gt;</code> as <code>@2</code>, and <code>&lt;c&gt;</code> as <code>@3</code>). All identifiers in semantic memory are persistent, and thus we call them long-term identifiers (or LTIs), in contrast to all other identifiers, which are short-term. When printed, long-term identifiers are prefixed by the <code>@</code> symbol and, when depicted, are shown using a double circle. The number in square brackets is the bias value of the object, used to break ties during retrievals, a topic to which we shall return later. Finally, unlike working memory and rules, the knowledge in semantic memory need not be connected, nor linked directly or indirectly, to a state.</p> <p>To pictorially view the contents of semantic memory, we can use the visualize command to render the contents of semantic memory to an image. For example, execute the following command:</p> <pre><code>visualize smem\n</code></pre> <p>If you have graphviz and DOT installed it should launch your system viewer to show a diagram similar to:</p> Example visualization of SMem <p>Now that we have seen the contents of semantic memory, you can confirm that none of this knowledge is present in any of the agent\u2019s other memories. For instance, execute the following commands to print the contents of working and procedural memories:</p> <pre><code>print --depth 100 &lt;s&gt;\nprint\n</code></pre> <p>You notice that the contents of the semantic store can be completely independent of the other memories, though, as discussed later, an agent can access and modify the store over time.</p> <p>We are now done with this example and wish to clear the semantic store. To do this we issue a special command:</p> <pre><code>smem --clear\n</code></pre> <p>The agent is now reinitialized, as you can verify by printing the contents of working memory, procedural memory, and now semantic memory.</p>"},{"location":"tutorials/soar_tutorial/07/#agent-interaction","title":"Agent Interaction","text":"<p>Agents interact with semantic memory via special structures in working memory. Soar automatically creates an smem link on each state, and each smem link has specialized substructure: a command link for agent-initiated actions and a result link for feedback from semantic memory. For instance, issue the following command:</p> <pre><code>print --depth 10 &lt;s&gt;\n</code></pre> <p>If you read the output carefully you will notice a WME that can be generally represented as (<code>&lt;state&gt; ^smem &lt;smem&gt;</code>) and two additional WMEs that can be represented as (<code>&lt;smem&gt; ^command &lt;cmd&gt;</code>) and (<code>&lt;smem&gt; ^result &lt;r&gt;</code>).</p> <p>As described in the following sections, the agent, via rules, populates and maintains the command link and the architecture populates and cleans up the result link.</p> <p>For the agent to interact with semantic memory, this mechanism must be enabled. By default, all learning mechanisms in Soar are disabled. To enable semantic memory, issue the following command:</p> <pre><code>smem --enable\n</code></pre>"},{"location":"tutorials/soar_tutorial/07/#agent-storage-and-modification","title":"Agent Storage and Modification","text":"<p>An agent stores an object to semantic memory by issuing a store command. The syntax of a store command is (<code>&lt;cmd&gt; ^store &lt;id&gt;</code>) where <code>&lt;cmd&gt;</code> is the command link of a state and <code>&lt;id&gt;</code> is an identifier.</p> <p>An agent can issue multiple store commands simultaneously, and the commands are processed at the end of the phase in which they are issued. A store command is guaranteed to succeed and the response from the architecture will be a success WME: (<code>&lt;r&gt; ^success &lt;id&gt;</code>), where <code>&lt;r&gt;</code> is the result link of the state on which the store command was issued and <code>&lt;id&gt;</code> was the value of the store command.</p> <p>A store command stores the identifier that is the result of the command, as well as any augmentations of that identifier. The command is not recursive. If the identifier to be stored was not long-term, it is changed in place to a long-term identifier. If it was already in semantic memory, the augmentations of the long-term identifier in semantic memory are overridden.</p> <p>Let\u2019s see an example. Source the following rules into the Soar Debugger (they are available in the smem-tutorial.soar file within the Agents directory).</p> <pre><code>sp {propose*init\n   (state &lt;s&gt; ^superstate nil\n      -^name)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; +)\n   (&lt;op&gt; ^name init)}\n</code></pre> <pre><code>sp {apply*init\n   (state &lt;s&gt; ^operator.name init\n      ^smem.command &lt;cmd&gt;)\n   --&gt;\n   (&lt;s&gt; ^name friends)\n   (&lt;cmd&gt; ^store &lt;a&gt; &lt;b&gt; &lt;c&gt;)\n   (&lt;a&gt; ^name alice ^friend &lt;b&gt;)\n   (&lt;b&gt; ^name bob ^friend &lt;a&gt;)\n   (&lt;c&gt; ^name charley)}\n</code></pre> <pre><code>sp {propose*mod\n   (state &lt;s&gt; ^name friends\n      ^smem.command &lt;cmd&gt;)\n   (&lt;cmd&gt; ^store &lt;a&gt; &lt;b&gt; &lt;c&gt;)\n   (&lt;a&gt; ^name alice)\n   (&lt;b&gt; ^name bob)\n   (&lt;c&gt; ^name charley)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; +)\n   (&lt;op&gt; ^name mod)}\n</code></pre> <pre><code>sp {apply*mod\n   (state &lt;s&gt; ^operator.name mod\n      ^smem.command &lt;cmd&gt;)\n   (&lt;cmd&gt; ^store &lt;a&gt; &lt;b&gt; &lt;c&gt;)\n   (&lt;a&gt; ^name alice)\n   (&lt;b&gt; ^name bob)\n   (&lt;c&gt; ^name charley)\n   --&gt;\n   (&lt;a&gt; ^name alice -)\n   (&lt;a&gt; ^name anna\n      ^friend &lt;c&gt;)\n   (&lt;cmd&gt; ^store &lt;b&gt; -)\n   (&lt;cmd&gt; ^store &lt;c&gt; -)}\n</code></pre> <p>Now click the \"Step\" button to run till the decision phase and notice that the init operator is selected. Now, click the \"Watch 5\" button and then the \"Run 1 -p\" button to watch as the operator is applied. Below is part of the trace that should be produced. If you do not see this part of this trace in your run, be sure that you enabled semantic memory (see section above).</p> <pre><code>--- apply phase ---\n--- Firing Productions (PE) For State At Depth 1 ---\nFiring apply*init\n+ (C3 ^name charley + :O ) (apply*init)\n+ (B1 ^friend A1 + :O ) (apply*init)\n+ (B1 ^name bob + :O ) (apply*init)\n+ (A1 ^friend B1 + :O ) (apply*init)\n+ (A1 ^name alice + :O ) (apply*init)\n+ (C2 ^store C3 + :O ) (apply*init)\n+ (C2 ^store B1 + :O ) (apply*init)\n+ (C2 ^store A1 + :O ) (apply*init)\n+ (S1 ^name friends + :O ) (apply*init)\n   --- Change Working Memory (PE) ---\n=&gt;WM: (25: C3 ^name charley)\n=&gt;WM: (24: B1 ^friend A1)\n=&gt;WM: (23: B1 ^name bob)\n=&gt;WM: (22: A1 ^friend B1)\n=&gt;WM: (21: A1 ^name alice)\n=&gt;WM: (20: C2 ^store A1)\n=&gt;WM: (19: C2 ^store B1)\n=&gt;WM: (18: C2 ^store C3)\n=&gt;WM: (17: S1 ^name friends)\n</code></pre> <p>Notice that the <code>apply*init</code> rule fired and added 3 store commands to working memory, where the identifiers to be stored are, initially, not long-term, and whose augmentations mirror the contents of the <code>smem --add</code> command in Part 1 of this tutorial. Then, at the end of the elaboration phase, semantic memory processed the command, converted the identifiers to long-term, and added status for each command.</p> <p>Now, try printing the contents of semantic memory using the <code>print @</code> command. You will see that semantic memory now has the same contents as after using the <code>smem --add</code> command in Part 1.</p> <p>Application of the next operator modifies the contents of semantic memory by overriding the contents of an existing long-term identifier (<code>@1</code>). Click the \"Step\" button to select the next operator (mod) and then click the \"Run 1 -p\" button to apply the operator:</p> <pre><code>Firing apply*mod\n-   (A1 ^name alice + :O ) (apply*init)\n-   (C2 ^store B1 + :O ) (apply*init)\n-   (C2 ^store C3 + :O ) (apply*init)\n+ (A1 ^friend C3 + :O ) (apply*mod)\n+ (A1 ^name anna + :O ) (apply*mod)\n--- Change Working Memory (PE) ---\n=&gt;WM: (33: A1 ^name anna)\n=&gt;WM: (32: A1 ^friend C3)\n&lt;=WM: (21: A1 ^name alice)\n&lt;=WM: (18: C2 ^store C3)\n&lt;=WM: (19: C2 ^store B1)\n</code></pre> <p>You will notice in the trace that the store commands for <code>@2</code> and <code>@3</code> are removed by the application rule, and that augmentations of <code>@1</code> are removed and added. Then, at the end of the elaboration phase, semantic memory cleans up the status information for the old store commands.</p> <p>Now, print the contents of semantic memory using the <code>print @</code> command:</p> <pre><code>(@1 ^friend @2 @3 ^name anna [+1.000])\n(@2 ^friend @1 ^name bob [+1.000])\n(@3 ^name charley [+1.000])\n</code></pre> <p>Notice that the augmentations of <code>@1</code> have indeed changed in semantic memory to reflect the new store command, while <code>@2</code> and <code>@3</code> remain unchanged.</p>"},{"location":"tutorials/soar_tutorial/07/#non-cue-based-retrieval","title":"Non-Cue-Based Retrieval","text":"<p>The first way an agent can retrieve knowledge from semantic memory is called a non-cue-based retrieval: the agent requests from semantic memory all of the augmentations of a known long-term identifier. The syntax of the command is (<code>&lt;cmd&gt; ^retrieve &lt;lti&gt;</code>) where <code>&lt;lti&gt;</code> is a short-term identifier that is linked to a long-term identifier. In other words, it is a short-term identifier that was previously used in a store command or recalled via a retrieve or query command.</p> <p>As an example, add the following three rules to our agent from Part 3 of this tutorial (these rules are already part of the smem-tutorial.soar file in the Agents directory):</p> <pre><code>sp {propose*ncb-retrieval\n   (state &lt;s&gt; ^name friends\n      ^smem.command &lt;cmd&gt;)\n   (&lt;cmd&gt; ^store &lt;a&gt;)\n   (&lt;a&gt; ^name anna\n      ^friend &lt;f&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; + =)\n   (&lt;op&gt; ^name ncb-retrieval\n      ^friend &lt;f&gt;)}\n</code></pre> <pre><code>sp {apply*ncb-retrieval*retrieve\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^smem.command &lt;cmd&gt;)\n   (&lt;op&gt; ^name ncb-retrieval\n      ^friend &lt;f&gt;)\n   (&lt;cmd&gt; ^store &lt;a&gt;)\n   --&gt;\n   (&lt;cmd&gt; ^store &lt;a&gt; -\n      ^retrieve &lt;f&gt;)}\n</code></pre> <pre><code>sp {apply*ncb-retrieval*clean\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^smem.command &lt;cmd&gt;)\n   (&lt;op&gt; ^name ncb-retrieval\n      ^friend &lt;f&gt;)\n   (&lt;f&gt; ^&lt;attr&gt; &lt;val&gt;)\n   --&gt;\n   (&lt;f&gt; ^&lt;attr&gt; &lt;val&gt; -)}\n</code></pre> <p>These rules retrieve all the information about one of <code>@1</code>\u2019s two friends (selected randomly) and remove the friend\u2019s augmentations (such as name and/or friend) from working memory.</p> <p>Unlike store commands, all retrievals are processed during the agent\u2019s output phase and only one retrieval command can be issued per state per decision.</p> <p>Now click the \"Step\" button and notice that one of the two ncb operators is selected. Click \"Run 1 -p\" to see the application rule create a retrieve command, requesting information about one of the two friends, as well as remove that friend\u2019s augmentations from working memory. Then click the \"Run 1 -p\" button again to proceed through the output phase. Finally, print the full contents of the smem link (<code>print --depth 10 L1</code>):</p> <pre><code>(L1 ^command C2 ^result R3)\n(C2 ^depth 3 ^retrieve B1 (@2))\n(R3 ^retrieved L2 (@2) ^success B1 (@2))\n(L3 ^friend L2 (@2) ^friend L4 (@3) ^name anna)\n(L2 ^friend L3 (@1) ^name bob)\n(L4 ^name charley)\n</code></pre> <p>We see that semantic memory has retrieved and added to working memory the name of the friend, as well as indicated status for this command (success). Your run may have retrieved <code>@3</code> instead, as a result of the random selection process:</p> <p>Note that had the retrieve command been issued with an identifier that was not linked to a long-term identifier, the status would have been failure and there would be no retrieved structure. Note also that retrieved knowledge is limited to the augmentations of the long-term identifier: like the store command, the retrieve command is not recursive.</p>"},{"location":"tutorials/soar_tutorial/07/#cue-based-retrieval","title":"Cue-Based Retrieval","text":"<p>The second way an agent can retrieve knowledge from semantic memory is called a cue-based retrieval: the agent requests from semantic memory all of the augmentations of an unknown long-term identifier, which is described by a subset of its augmentations. The syntax of the command is (<code>&lt;cmd&gt; ^query &lt;cue&gt;</code>), where the desired augmentations all have <code>&lt;cue&gt;</code> as their identifier.</p> <p>The augmentations of the cue form hard constraints, based upon the value of each WME. If the value of the WME is a constant (string, integer, or float) or long-term identifier, then any retrieval is required to have exactly the attribute/value pair specified. If the value of the WME is a short-term identifier, then any retrieval is required to have an augmentation that has the same attribute, but the value is unconstrained.</p> <p>As an example, add the following two rules to our agent from Part 4 of this tutorial (these rules are already part of the smem-tutorial.soar file in the Agents directory):</p> <pre><code>sp {propose*cb-retrieval\n   (state &lt;s&gt; ^name friends\n      ^smem.command &lt;cmd&gt;)\n   (&lt;cmd&gt; ^retrieve)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; + =)\n   (&lt;op&gt; ^name cb-retrieval)}\n</code></pre> <pre><code>sp {apply*cb-retrieval\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^smem.command &lt;cmd&gt;)\n   (&lt;op&gt; ^name cb-retrieval)\n   (&lt;cmd&gt; ^retrieve &lt;lti&gt;)\n   --&gt;\n   (&lt;cmd&gt; ^retrieve &lt;lti&gt; -\n      ^query &lt;cue&gt;)\n   (&lt;cue&gt; ^name &lt;any-name&gt;\n      ^friend &lt;lti&gt;)}\n</code></pre> <p>These rules retrieve an identifier that meets two constraints: (1) it has an augmentation where the attribute is \"name\", but the value can be any symbol, and (2) it has an augmentation where the attribute is \"friend\" and the value is the long-term identifier retrieved as a result of applying the operator in Part 3.</p> <p>As a reminder, all retrievals are processed during the agent\u2019s output phase and only one retrieval command can be issued per state per decision.</p> <p>So now click the \"Step\" button and then click the \"Run 1 -p\" to see the application rule create a query command, as well as remove the previous retrieve command from working memory. Then click the \"Run 1 -p\" button again to proceed through the output phase. Finally print the contents of the smem link (<code>print --depth 10 L1</code>):</p> <pre><code>(L1 ^command C2 ^result R3)\n   (C2 ^depth 3 ^query C4)\n      (C4 ^friend B1 (@2) ^name A2)\n   (R3 ^retrieved L5 (@1) ^success C4)\n      (L7 ^name charley)\n      (L6 ^friend L5 (@1) ^name bob)\n      (L5 ^friend L6 (@2) ^friend L7 (@3) ^name anna)\n</code></pre> <p>We see that semantic memory has retrieved and added to working memory the identifier <code>@1</code> and all of its augmentations, as well as indicated status for this command (success). If in Part 4 of this tutorial your agent retrieved <code>@3</code>, you may have slightly different output.</p> <p>Note that had no long-term identifier in semantic memory satisfied the constraints of the query command cue, the status would have been failure and there would be no retrieved structure. Note also that retrieved knowledge is limited to the augmentations of the long-term identifier: like the store command, retrievals are not recursive. We see this in the outputs above as one friend has augmentations (as a result of the retrieve command in Part 4), whereas the other does not.</p> <p>If multiple identifiers had satisfied the constraints of the cue (such as if the cue had only a WME with \"name\" as the attribute and a short-term identifier as the value), then the long-term identifier with the largest bias value is returned. By default, the bias value is a monotonically increasing integer, reflecting the recency of the last storage or retrieval of an object.</p> <p>It is also possible to prohibit one or more long-term identifiers from being retrieved. For more information on this any many additional capabilities of semantic memory, read the Semantic Memory chapter of the Soar Manual.</p>"},{"location":"tutorials/soar_tutorial/08/","title":"Part VIII Episodic Memory","text":""},{"location":"tutorials/soar_tutorial/08/#under-construction","title":"\ud83d\udea7 Under Construction \ud83d\udea7","text":"<p>The HTML version of the tutorial is currently under construction; in particular, the figure annotations are missing. You may wish to view the PDF version here instead.</p>"},{"location":"tutorials/soar_tutorial/08/#part-viii-episodic-memory","title":"Part VIII: Episodic Memory","text":"<p>Episodic memory (EpMem) in Soar is a mechanism that automatically captures, stores, and temporally indexes agent state and supports a content-addressable agent interface to retrieve this autobiographical prior experience. This information supplements what is contained in short-term working memory and other long-term memories, such as rules in procedural memory.</p>"},{"location":"tutorials/soar_tutorial/08/#a-short-demonstration","title":"A Short Demonstration","text":"<p>Before we delve into how an agent can use episodic memory, let's see an example of capturing an episode and viewing the contents of the memory.</p> <p>First, open the Soar Debugger. Then, execute the following command (this can be loaded from a source file just as any other Soar command):</p> <pre><code>epmem --set trigger dc\nepmem --set learning on\nwatch --epmem\n</code></pre> <p>Now, click the \"Step\" button twice. If we inspect the trace, and ignore the state no-change impasses, we see the following message:</p> <pre><code>NEW EPISODE: 1\n</code></pre> <p>This is an indication that a new episode, with id 1, has been automatically stored by the architecture within the episodic store.</p> <p>We can view the contents of episodic memory using the <code>epmem --print</code> command, which expects an episode id as an argument. For example, execute the following command:</p> <pre><code>epmem --print 1\n</code></pre> <p>Which will output the following result:</p> <pre><code>(&lt;id0&gt; ^io &lt;id1&gt; ^reward-link &lt;id2&gt; ^superstate nil ^type state)\n(&lt;id1&gt; ^input-link &lt;id4&gt; ^output-link &lt;id3&gt;)\n</code></pre> <p>To pictorially view the contents of semantic memory, we can use the visualize command to render the contents of semantic memory to an image. For example, execute the following command:</p> <pre><code>visualize epmem\n</code></pre> <p>If you have graphviz and DOT installed, it should launch your system viewer to show a diagram similar to:</p> Example visualization of episodic memory <p>From both the trace output as well as the Graphviz rendering we can see that episodic memory has stored most of the top-state of the agent\u2019s working memory at a particular moment in time. In the following sections we\u2019ll examine in more detail how to control automatic storage and how agents can retrieve episodic knowledge.</p>"},{"location":"tutorials/soar_tutorial/08/#episodic-storage","title":"Episodic Storage","text":"<p>As we saw in Part 1 of this tutorial, episodic storage is automatic and captures the top state of the agent\u2019s working memory. To enable storage, episodic memory must be enabled. By default, all learning mechanisms in Soar are disabled. To enable episodic memory, issue the following command:</p> <pre><code>epmem --set learning on\n</code></pre> <p>There are a few architectural parameters that are important to control episodic storage. The first is the event that triggers storage. By default, episodic memory stores new episodes whenever a WME is added to working memory that has the output-link as its identifier. However, Soar also supports storing episodes each decision cycle (\"dc\"), which is enabled using the following command (which we used in Part 1 of this tutorial):</p> <pre><code>epmem --set trigger dc\n</code></pre> <p>The next important parameter is the phase during which episodic memory stores episodes (and processes retrievals, as discussed later). By default, this processing occurs at the end of the output phase. However, Soar also supports this processing occurring at the end of the decision phase, which is enabled using the following command:</p> <pre><code>epmem --set phase selection\n</code></pre> <p>Finally, it is sometimes the case that certain portions of the agent\u2019s working memory should be excluded from automatic storage. Episodic memory supports specifying a set of excluded attributes: if automatic storage encounters an excluded attribute during a breadth-first walk of working memory, it does not store that WME, nor any substructure if it was the case that the value of the WME was an identifier. To view the current excluded set, issue the following command:</p> <pre><code>epmem --get exclusions\n</code></pre> <p>To change the excluded set, issue the following command:</p> <pre><code>epmem --set exclusions &lt;attribute&gt;\n</code></pre> <p>This command toggles the state of an attribute within the set: thus if this command is executed with an attribute that is already in the excluded set, it is removed from the set, otherwise it is added. By default, \"epmem\" and \"smem\" are in the excluded set, which is why we do not see these architectural links in the trace/visualization in Part 1 of this tutorial.</p> <p>In Part 1, we also enabled trace output that is useful for understanding episodic memory via the following command:</p> <pre><code>watch --epmem\n</code></pre> <p>This trace option indicates when new episodes are recorded, as well as debugging information for retrievals, as discussed later.</p>"},{"location":"tutorials/soar_tutorial/08/#agent-interaction","title":"Agent Interaction","text":"<p>Agents interact with episodic memory via special structures in working memory. Soar automatically creates an epmem link on each state, and each epmem link has specialized substructure: a command link for agent-initiated actions and a result link for feedback from episodic memory. For instance, issue the following command:</p> <pre><code>print --depth 10 &lt;s&gt;\n</code></pre> <p>If you read the output carefully you will notice a WME that can be generally represented as (<code>&lt;state&gt; ^epmem &lt;epmem&gt;</code>) and three additional WMEs that can be represented as (<code>&lt;epmem&gt; ^command &lt;cmd&gt;</code>), (<code>&lt;epmem&gt; ^result &lt;r&gt;</code>), and (<code>&lt;epmem&gt; ^present-id &lt;episode id&gt;</code>)</p> <p>As described in the following sections, the agent, via rules, populates and maintains the command link and the architecture populates and cleans up the result link. As episodes are stored, the present-id augmentation updates to indicate the current episode id, the value of which is a positive integer.</p> <p>For the agent to interact with episodic memory, this mechanism must be enabled. As mentioned in Part 2, by default, all learning mechanisms in Soar are disabled and so you must enable episodic memory via the command in Part 2.</p> <p>By default, all commands are processed during the agent\u2019s output phase (this can be changed using the phase parameter, as described in Part 2 of this tutorial) and only one command can be issued per state per decision.</p>"},{"location":"tutorials/soar_tutorial/08/#cue-based-retrieval","title":"Cue-Based Retrieval","text":"<p>The primary method that an agent can retrieve knowledge from episodic memory is called a cue-based retrieval: the agent requests from episodic memory an episode that most closely matches a cue of working-memory elements. The syntax of the command is (<code>&lt;cmd&gt; ^query &lt;cue&gt;</code>), where <code>&lt;cue&gt;</code> forms the root of the cue. Conceptually, episodic memory compares the cue to all episodes in the store, scoring each one, and returns the most recent episode with the maximal score.</p> <p>Episodes are scored based upon the leaf WMEs in the cue. A leaf WME has either a value that is a constant, a long-term identifier, or a short-term identifier with no augmentations. A leaf WME is satisfied, with respect to a particular episode, if there exists a path, or sequence of WMEs, from the episode root to that leaf WME, where the attributes of all intermediate WMEs exactly match those in the cue, and short-term identifiers in the cue variablize to consistently match identifiers in the episode. This is similar to how variables in the conditions of rules bind to specific identifiers in working memory. However, as discussed below, episode scoring is disjunctive with respect to leaf WMEs (i.e. each leaf WME is considered independently), whereas rule matching is conjunctive with respect to production conditions (i.e. a rule matches only if all conditions are satisfied). By default, the score of an episode is simply the number of satisfied leaf WMEs.</p> <p>Let us consider an example cue, composed of the following WMEs, where N1 is the value of the query command, as described above:</p> <pre><code>(N1 ^feature value\n   ^id N2)\n(N2 ^sub-feature value2\n   ^sub-id N3)\n</code></pre> <p>Or, visually:</p> Example cue <p>This cue has three leaf WMEs: (<code>N1 ^feature value</code>), (<code>N2 ^sub-feature value2</code>), and (<code>N2 ^id N3</code>). Now consider the following episode:</p> Episode to match cue <p>The first leaf WME of the cue, (<code>N1 ^feature value</code>), is not satisfied by this episode, as there is no (<code>E1 ^feature value</code>) WME: (<code>E1 ^feature2 value</code>) has a different attribute and (<code>E1 ^feature value3</code>) has a different value. Both other leaf WMEs, however, are satisfied. (<code>N2 ^sub-feature value2</code>) is satisfied by variablizing E1 as N1 and E2 as N2: (<code>E1 ^id E2</code>) and (<code>E2 ^sub-feature value2</code>). (<code>N2 ^id N3</code>) is satisfied by variablizing <code>E1</code> as <code>N1</code>, <code>E3</code> as <code>N2</code>, and <code>E5</code> as <code>N3</code>: (<code>E1 ^id E3</code>), (<code>E3 ^sub-id E5</code>). Note that the substructure of E4 in the episode matches that of N2 in the cue, but there is no WME (<code>E1 ^id E4</code>), and so <code>E4</code> is not considered. Thus, this episode, with respect to the cue, has a score of 2.</p> <p>Note, however, that it is not possible to unify the cue with the episode: there is no single identifier in the episode that, when bound as <code>N2</code> in the cue, satisfies both (<code>N2 ^sub-feature value2</code>) and (<code>N2 ^sub-id N3</code>). If an episode gets a perfect score, such that all leaf WMEs are satisfied, episodic memory attempts to graph match the cue with the episode (i.e. determine if there exists an isomorphism between the cue and the episode). So in response to a cue-based retrieval command, episodic memory will return the most recent graph-matched episode, or, if one does not exist, the most recent episode with the maximal episode score. For clarity, episode recency is directly proportional to the episode id, where larger episode id\u2019s are more recent.</p> <p>Let\u2019s see how the example above works in Soar. Run the Soar Debugger and source the following rules (these rules are already part of the epmem-tutorial.soar file in the Agents directory):</p> <pre><code>sp {propose*init\n   (state &lt;s&gt; ^superstate nil\n      -^name)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; + =)\n   (&lt;op&gt; ^name init)}\n</code></pre> <pre><code>sp {apply*init\n   (state &lt;s&gt; ^operator &lt;op&gt;)\n   (&lt;op&gt; ^name init)\n   --&gt;\n   (&lt;s&gt; ^name epmem\n      ^feature2 value\n      ^feature value3\n      ^id &lt;e2&gt;\n      ^id &lt;e3&gt;\n      ^other-id &lt;e4&gt;)\n   (&lt;e2&gt; ^sub-feature value2)\n   (&lt;e3&gt; ^sub-id &lt;e5&gt;)\n   (&lt;e4&gt; ^sub-id &lt;e6&gt;\n      ^sub-feature value2)}\n</code></pre> <pre><code>sp {epmem*propose*cbr\n   (state &lt;s&gt; ^name epmem\n      -^epmem.command.&lt;cmd&gt;)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; + =)\n   (&lt;op&gt; ^name cbr)}\n</code></pre> <pre><code>sp {epmem*apply*cbr-clean\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^feature2 &lt;f2&gt;\n      ^feature &lt;f&gt;\n      ^id &lt;e2&gt;\n      ^id &lt;e3&gt;\n      ^other-id &lt;e4&gt;)\n   (&lt;e2&gt; ^sub-feature value2)\n   (&lt;e3&gt; ^sub-id)\n   (&lt;op&gt; ^name cbr)\n   --&gt;\n   (&lt;s&gt; ^feature2 &lt;f2&gt; -\n      ^feature &lt;f&gt; -\n      ^id &lt;e2&gt; -\n      ^id &lt;e3&gt; -\n      ^other-id &lt;e4&gt; -)}\n</code></pre> <pre><code>sp {epmem*apply*cbr-query\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^epmem.command &lt;cmd&gt;)\n   (&lt;op&gt; ^name cbr)\n--&gt;\n   (&lt;cmd&gt; ^query &lt;n1&gt;)\n   (&lt;n1&gt; ^feature value\n      ^id &lt;n2&gt;)\n   (&lt;n2&gt; ^sub-feature value2\n      ^sub-id &lt;n3&gt;)}\n</code></pre> <p>Now execute the following commands:</p> <pre><code>epmem --set trigger dc\nepmem --set learning on\nwatch --epmem\n</code></pre> <p>Then click the \"Step\" button and then the \"Run 1 -p\" button. Now print out the top state of working memory (<code>print --depth 10 s1</code>). Notice that the top state contains the structures of the sample episode above (such as <code>^feature value</code>), as well as other WMEs (such as <code>^superstate nil</code>).</p> <p>Now click the \"Step\" button. You should notice in the trace that episode <code>#1</code> was stored. Click the \"Run 1 -p\" button to apply the cbr operator and print the top state of working memory (<code>print --depth 10 s1</code>). Notice that the structures of the sample episode have been removed and that the sample cue has been added to the command structure of the epmem link.</p> <p>Now click the \"Run 1 -p\" button. Episodic memory stored another episode (<code>#2</code>) and then processed the cue-based query. The trace contains the following text:</p> <pre><code>CONSIDERING EPISODE (time, cardinality, score): (1, 2, 2.000000)\nNEW KING (perfect, graph-match): (false, false)\n</code></pre> <p>The first line indicates that episodic memory compared the cue to episode <code>#1</code> (i.e. \\(time=1\\)), found that the cardinality of the set of satisfied leaf WMEs was 2, and thus the episode was scored as 2. Since this was the first considered episode, it is indicated as \"king\" . However, since the episode did not have a perfect score (2 out of 3), graph-match was not attempted and was thus not successful. Since episode <code>#2</code> did not have any features in common with the cue (application of the cbr operator removed these structures), episodic memory did not consider it as a performance optimization.</p> <p>Now print the full contents of the episodic memory link (<code>print --depth 10 e1</code>):</p> <pre><code>(E1 ^command C1 ^present-id 3 ^result R2)\n   (C1 ^query N1)\n      (N1 ^feature value ^id N2)\n         (N2 ^sub-feature value2 ^sub-id N3)\n   (R2 ^cue-size 3 ^graph-match 0 ^match-cardinality 2\n      ^match-score 2.^memory-id 1\n      ^normalized-match-score 0.6666666666666666 ^present-id 3\n      ^retrieved R4 ^success N1)\n      (R4 ^feature value3 ^feature2 value\n         ^id I5 ^id I6 ^io I4 ^name epmem\n         ^operator* O5 ^other-id O4 ^reward-link R5\n         ^superstate nil ^type state)\n         (I5 ^sub-feature value2)\n         (I6 ^sub-id S3)\n         (I4 ^input-link I7 ^output-link O6)\n         (O5 ^name cbr)\n         (O4 ^sub-feature value2 ^sub-id S4)\n</code></pre> <p>The result structure indicates that the retrieval was successful, has a link to the full episode contents (rooted at R4), and has meta-data about the cue-matching process, with respect to the retrieved episode. Details of these augmentations are in the Episodic Memory chapter of the Soar Manual. Note that a WME with an <code>operator*</code> attribute (such as: <code>R4 ^operator* R5</code>) in a retrieved episode represents an acceptable preference WME in the original episode.</p> <p>There are optional modifiers to cue-based queries, including the ability to prohibit specific episodes from being retrieved and indicating features that are not desirable in the retrieved episode. More information on this functionality is in the Episodic Memory chapter of the Soar Manual.</p>"},{"location":"tutorials/soar_tutorial/08/#temporal-progression","title":"Temporal Progression","text":"<p>Another way the agent can gain access to episodes is by retrieving the episode that came temporally before/after the last episode that was retrieved. The syntax of these commands, respectively, are (<code>&lt;cmd&gt; ^previous &lt;id&gt;</code>) and (<code>&lt;cmd&gt; ^next &lt;id&gt;</code>), where <code>&lt;id&gt;</code> is any identifier.</p> <p>As an example, add the following rules to our agent from Part 4 of this tutorial (these rules are already part of the epmem-tutorial.soar file in the Agents directory):</p> <pre><code>sp {epmem*propose*next\n   (state &lt;s&gt; ^name epmem\n      ^epmem.command.query)\n   --&gt;\n   (&lt;s&gt; ^operator &lt;op&gt; + =)\n   (&lt;op&gt; ^name next)}\n</code></pre> <pre><code>sp {epmem*apply*next\n   (state &lt;s&gt; ^operator &lt;op&gt;\n      ^epmem.command &lt;cmd&gt;)\n   (&lt;op&gt; ^name next)\n   (&lt;cmd&gt; ^query &lt;q&gt;)\n   --&gt;\n   (&lt;cmd&gt; ^query &lt;q&gt; -\n      ^next &lt;next&gt;)}\n</code></pre> <p>These rules will retrieve the episode that temporally proceeds the episode retrieved in the previous part of this tutorial.</p> <p>Click the \"Step\" button, then the \"Run 1 -p\" button. Now print the episodic memory link (<code>print --depth 10 e1</code>). Notice that the query command has been replaced with a next command. Note that the results of the previous commands are still in working memory: these will be automatically cleaned by episodic memory when the next command is processed.</p> <p>Now click the \"Run 1 -p\" button and print the episodic memory link (<code>print --depth 10 e1</code>):</p> <pre><code>(E1 ^command C1 ^present-id 4 ^result R2)\n   (C1 ^next N4)\n   (R2 ^memory-id 2 ^present-id 4 ^retrieved R6 ^success N4)\n      (R6 ^io I8 ^name epmem ^operator* O7 ^reward-link R\n         ^superstate nil ^type state)\n      (I8 ^input-link I9 ^output-link O8)\n      (O7 ^name next)\n</code></pre> <p>The result structure has been cleaned of old structures and now shows that the command was successful and episode <code>#2</code> was retrieved (with all of its original contents).</p> <p>You now have some basic understanding of using episodic memory. Read the Episodic Memory chapter of the Soar manual for additional detail and functionality.</p>"},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/","title":"Tank and Eaters Configuration","text":"","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#tank-eaters-configuration-file","title":"Tank Eaters Configuration File","text":"<p>Soar2D is a general framework that includes both Eaters and TankSoar. This document describes how to modify these environments using the configuration settings files.</p>","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#configuration-files","title":"Configuration Files","text":"<p>Soar2D configuration files are stored in the Soar2D folder. When running the soar2d jar, you may specify the configuration file to use on the command line, or run without specifying any and a dialog window will pop-up.</p> <pre><code>java -jar soar2d.jar configs/tanksoar.cnf\njava -jar soar2d.jar configs/eaters.cnf\njava -jar soar2d.jar configs/room.cnf\njava -jar soar2d.jar\n</code></pre> <p>Configuration entries are of the format:</p> <pre><code>''key'' = ''value''; # Note the trailing semicolon.\n</code></pre> <p>Use the pound sign for comments. Start them anywhere on a line.</p> <pre><code># Comments go here\nConfiguration keys are simple identifiers. Stick to alphanumeric characters and underscores.\n</code></pre> <pre><code>exampleKey = ''value'';\nexample_key = ''value'';\n</code></pre> <p>Configuration keys have an optional hierarchy separated by dots or braces. These are equivalent:</p> <pre><code>path.to.key = ''value'';\npath.to.another = ''value'';\n\npath\n{\n   to\n   {\n      key = ''value'';\n      another = ''value'';\n   }\n}\n\npath\n{\n   to\n   {\n      key = ''value'';\n   }\n}\npath.to.another = ''value'';\n</code></pre> <p>Configuration values are strings or an array of strings using the following notation:</p> <pre><code>single = data;\nsingle_element_array = [ data ];\ntrailing_comma_ok = [ data, ];\ntwo_element_array = [ data, banks ];\ntwo_element_array_with_trailer = [ data, banks, ];\n</code></pre> <p>Most whitespace is stripped out of the configuration file. These lines are all equivalent:</p> <pre><code>path.to.key = databanks;        # Value is \"databanks\"\npath.to.key = data banks;       # Value is \"databanks\"\npath . to.key = databanks;      # Value is \"databanks\"\npath.t o.key = d a t a banks;   # Value is \"databanks\"\npa th. to. k ey = \"databanks\";  # Value is \"databanks\"\npa th. to. k ey\n= \"databanks\";                  # Value is \"databanks\"\n</code></pre> <p>Preserve spaces using quotes:</p> <pre><code>path.to.key = \"data banks\";     # Value is \"data banks\" with a space.\narrays_too = [ \"data banks\", \"another value\" ]; # Values are \"data banks\" and \"another value\"\n</code></pre> <p>Don't split keys or values across lines:</p> <pre><code>crazy.                 # Syntax error\nspacing = \"databanks\"; #\ncrazy.spacing = \"data  # Value truncated\nbanks\";                # Syntax error\nOK to split other things along lines (or not). These are all legal entires:\n</code></pre> <pre><code>key1 = value1;\nkey2 =\n       value2;\nkey3 = [ value3.1, value3.2, value3.3 ];\nkey4\n=\n[ value4.1, value4.2 ];\nkey5 = [\n     value5.1,\n     value5.2,\n];\nkey6 { subkey6.1 = value6.1; subkey6.2 = value6.2; }\n</code></pre> <p>Backslash doesn't escape anything (this is a change from the original behavior).</p> <p>Code exists to easily pull out types boolean, string, int, double, or arrays of these types:</p> <pre><code>parameter = 5.434; # config.requireDouble(\"parameter\");\nswitch = false;    # config.requireBoolean(\"switch\");\ncount = 4;         # config.requireInt(\"count\");\nplayers = [7, 8]   # config.requireInts(\"players\"); // returns int [] length 2\n</code></pre> <p>Defaults can be enforced in code:</p> <pre><code>config.getInt(\"some.value.not.in.config.file\", 4); // returns 4\n</code></pre>","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#clients","title":"Clients","text":"<p>Clients are encoded in a clients block using their names for their sub block. Additionally, their names must be enumerated in an <code>active_clients</code> array. For example:</p> <pre><code>clients\n{\n   active_clients = [ \"watchdog\", \"timer\" ];\n   watchdog\n   {\n      command = \"run-watchdog.bat\";\n   }\n   timer\n   {\n      command = \"run-timer.bat\";\n   }\n   disabled # not enumerated, so it is ignored.\n   {\n      command = \"run-something-someothertime.bat\";\n   }\n}\n</code></pre> <p>Note that there is a default, hidden client named \"java-debugger\". Don't use this name or put it in the active_clients list.</p> Path Type Values Default Comment clients.active_clients string array Each active client. Clients not listed in this array but defined in this block are ignored. clients.''name''.command string Command to run from cwd clients.''name''.timeout int 0 Seconds to wait for client to report in clients.''name''.after boolean true true: spawn after all agents are created, false: spawn before all agents are created","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#eaters","title":"eaters","text":"Path Type Values Default Comment eaters.vision int number of cells 2 How far can the eater see? eaters.wall_penalty int points (negative) -5 Penalty for running in to walls eaters.jump_penalty int points (negative) -5 Penalty for executing a jump eaters.low_probability double probability 0.25 Used during random map generation eaters.high_probability double probability 0.75 Used during random map generation","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#general","title":"general","text":"Path Type Values Default Comment general.cycle_time_slice double 50 How much simulation time passes per tick (ms) general.default_points int 0 Starting points general.game string tanksoar, eaters, room, kitchen, taxi What game general.map string path Path to map file general.headless boolean false Run headless general.preferences_file string \"preferences\" Path to preferences file (used for common settings to preserve across runs such as last productions, window location). general.runs int 1 How many back-to-back runs to execute general.seed int null (random default) Seed Java and SML general.force_human boolean false Force human input, overrides agent input. Great for debugging input link.","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#soar","title":"soar","text":"Path Type Values Default Comment soar.max_memory_usage int bytes kernel default Call command max-memory-usage soar.port int valid TCP ports 12121 Connect/listen on this port soar.remote string IP address null Connect to a remote kernel at this IP soar.spawn_debuggers boolean true Spawn debuggers on agent creation soar.soar_print boolean false Log print events to file","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#players","title":"players","text":"<p>Players are encoded in a players block using arbitrary identifiers for their sub blocks. Active player IDs must be enumerated in an <code>active_players</code> array. For example, the following configuration file defines 3 players but only uses two of them for the run:</p> <pre><code>players\n{\n   active_players = [ \"obscure\", \"simple\" ];\n   obscure\n   {\n      productions = \"agents/tanksoar/obscure-bot.soar\";\n   }\n   simple\n   {\n      productions = \"agents/tanksoar/tutorial/simple-bot.soar\";\n   }\n   mapping\n   {\n      productions = \"agents/tanksoar/tutorial/mapping-bot.soar\";\n      shutdown_commands = [ \"echo shutting down\", \"print\" ];\n   }\n}\n</code></pre> <p>Do not id players with the prefix \"gui\" or \"clone\", the players created at runtime use those.</p> Path Type Values Default Comment players.''id''.name string color Agent name players.''id''.productions string null (human) Productions players.''id''.script string null (human) Do not use (yet), for testing players.''id''.color string red, blue, yellow, purple, orange, green, black random desired color players.''id''.pos int array random Starting x,y coordinate (int array, length 2) players.''id''.facing string north, south, east, west random Starting facing direction, cardinal players.''id''.points int 0 Starting points players.''id''.energy int game default Starting energy (tanksoar) players.''id''.health int game default Starting health (tanksoar) players.''id''.missiles int game default Starting missiles (tanksoar) players.''id''.shutdown_commands string array valid Soar commands null Commands to run before destroying agent","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#room","title":"room","text":"<p>There are currently no configuration options for the Room environment.</p>","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#taxi","title":"taxi","text":"Path Type Values Default Comment taxi.disable_fuel boolean false If disabled, ignore effects of fuel taxi.fuel_starting_minimum int 5 Fuel starts between this and maximum taxi.fuel_starting_maximum int 12 Fuel starts between this and minimum taxi.fuel_maximum int 14 Fuel goes to here when refueled","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#tanksoar","title":"tanksoar","text":"Path Type Values Default Comment tanksoar.max_missiles 15 Maximum missile count tanksoar.max_energy 1000 Maximum energy count tanksoar.max_health 1000 Maximum health count tanksoar.collision_penalty -100 Penalty for colliding with another tank or wall tanksoar.max_missile_packs 3 Maximum number of missile packs to spawn at a time tanksoar.missile_pack_respawn_chance 5 Chance per turn that a missile pack spawns when below max tanksoar.shield_energy_usage -20 Energy usage per turn that shields are on tanksoar.missile_hit_award 2 Points awarded when your missile connects with a tank tanksoar.missile_hit_penalty -1 Points lost when hit by a missile tanksoar.frag_award 3 Points awarded when your missile frags a tank tanksoar.frag_penalty -2 Points lost when fragged by a missile tanksoar.max_sound_distance 7 Maximum distance for the sound sensor tanksoar.missile_reset_threshold 100 Max amount of updates that can pass without a missile firing before resetting the map","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#terminals","title":"terminals","text":"Path Type Values Default Comment terminals.max_updates int 0 World cycle count limit terminals.agent_command boolean false Agent issues stop command (input-link, not stop-soar) terminals.points_remaining boolean false No more points available on map terminals.winning_score int 0 At least one agent has at least this many points terminals.food_remaining boolean false There is no more food on the map (eaters) terminals.unopened_boxes boolean false There are no unopened boxes on the map (eaters) terminals.fuel_remaining boolean false Run out of fuel (taxi) terminals.passenger_delivered boolean false Passenger successfully delivered (taxi) terminals.passenger_pick_up boolean false Passenger removed from map (taxi)","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#logging","title":"Logging","text":"<p>http://logging.apache.org/log4j/1.2/index.html</p>","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#map-files","title":"Map Files","text":"<p>Maps are now stored in the config/maps/game folder where game is the game type, such as eaters.</p>","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#map-file","title":"Map file","text":"<ul> <li><code>objects_file (string)</code><ul> <li>This file defines objects in the world, see Object File below. The path is     relative to the map file.</li> </ul> </li> <li><code>objects (string array)</code><ul> <li>This is an array of objects ids that are available for use on the map. Often     time these ids are one character so the map is easily human-readable.</li> </ul> </li> <li><code>cells (block)</code><ul> <li>This sub-block defines the cells in the map, or properties about the cells     that will be randomly generated.</li> </ul> </li> <li><code>cells.size (int)</code><ul> <li>Width and height of map.</li> </ul> </li> <li><code>cells.random_walls (boolean)</code><ul> <li>Randomly generate the walls on this map.</li> </ul> </li> <li><code>cells.random_food (boolean)</code><ul> <li>Randomly place food on the map.</li> </ul> </li> <li><code>cells.rows (block)</code><ul> <li>Cell instances</li> </ul> </li> <li><code>cells.rows.INTEGER (string array)</code><ul> <li>The rows the map, from 0 to size - 1, represented as an array of strings.     The strings maps to object ids. Separate multiple objects with dashes. Use a     single dash for an empty cell.</li> </ul> </li> </ul>","tags":["eaters"]},{"location":"tutorials/soar_tutorial/TankEatersConfigFile/#objects-file","title":"Objects File","text":"<p>Objects are under an objects sub-block, and then an id block where the name of the block is their id used in the human-readable map file. Objects need a name property, which is how they are referred to in the code and logs. The rest of the properties are mostly domain specific.</p> <pre><code># &lt;ignored&gt; means that the value is ignored, key presence is used for \"true\"\n# objects {\n#    +&lt;id&gt; {\n#       name = &lt;name&gt;;\n#       *&lt;p1&gt; = &lt;value&gt;;                     # user property\n#       *&lt;p1&gt; = [&lt;value1&gt;, &lt;value2&gt;];        # user property\n#       ?apply.points = &lt;int&gt;;               # number of points to apply\n#       ?apply.energy = &lt;int&gt;;               # amount of energy to apply\n#       ?apply.energy.shields = &lt;boolean&gt;;   # condition for energy apply\n#       ?apply.health = &lt;int&gt;;               # amount of health to apply\n#       ?apply.health.shields-down = &lt;boolean&gt;; # condition for health apply\n#       ?apply.missiles = &lt;int&gt;;             # number of missiles to apply\n#       ?apply.remove = &lt;boolean&gt;;           # remove on apply\n#       ?box-id = &lt;int&gt;;                     # this box's id number (set after load)\n#       ?apply.reward-info = &lt;boolean&gt;;      # contains reward information\n#       ?apply.reward-info.positive-id = &lt;int&gt;; # correct box id (set after load)\n#       ?apply.reward = &lt;boolean&gt;;           # is reward box\n#       ?apply.reward.correct = &lt;boolean&gt;;   # is the correct box (set randomly after load)\n#       ?apply.reward.positive = &lt;int&gt;;      # reward if correct\n#       ?apply.reward.negative = &lt;int&gt;;      # \"reward\" if incorrect, different from wrong box\n#       ?apply.reset = &lt;boolean&gt;;            # reset sim on apply\n#       ?apply.properties {                  # these get moved to top level on applyProperties call\n#          ?&lt;p1&gt; = &lt;value&gt;;                  # user apply property\n#          ?&lt;p1&gt; = [&lt;value1&gt;, &lt;value2&gt;];     # user apply property\n#       }\n#       ?update.decay = &lt;int&gt;;               # decay apply.points by this amount on update\n#       ?update.fly-missile = &lt;int&gt;;         # increment update.fly-missile phase on update\n#       ?update.linger = &lt;int&gt;;              # decrement update.linger on update, remove at 0\n#    }\n#}\n</code></pre>","tags":["eaters"]},{"location":"workshops/","title":"Soar Workshop Proceedings","text":"<ul> <li>45th Soar Workshop (2025)</li> <li>44th Soar Workshop (2024)</li> <li>43rd Soar Workshop (2023)</li> <li>42nd Soar Workshop (2022)</li> <li>41st Soar Workshop (2021)</li> <li>40th Soar Workshop (2020)</li> <li>39th Soar Workshop (2019)</li> <li>38th Soar Workshop (2018)</li> <li>37th Soar Workshop (2017)</li> <li>36th Soar Workshop (2016)</li> <li>35th Soar Workshop (2015)</li> <li>34th Soar Workshop (2014)</li> <li>33rd Soar Workshop (2013)</li> <li>32rd Soar Workshop (2012)</li> <li>31st Soar Workshop (2011)</li> <li>30th Soar Workshop (2010)</li> <li>29th Soar Workshop (2009)</li> <li>28th Soar Workshop (2008)</li> <li>27th Soar Workshop (2007)</li> <li>26th Soar Workshop (2006)</li> <li>25th Soar Workshop (2005)</li> <li>24th Soar Workshop (2004)</li> <li>23rd Soar Workshop (2003)</li> <li>22nd Soar Workshop (2002)</li> <li>21st Soar Workshop (2001)</li> <li>20th Soar Workshop (2000)</li> <li>19th Soar Workshop (1999)</li> <li>17th Soar Workshop (1997)</li> </ul>"},{"location":"workshops/17/","title":"The 17th North American Soar Workshop","text":"<p>June 27th - June 29th, 1997</p> <p>Columbus, OH</p> <p>Archived contents provided by Rick Lewis.</p> <p>Original URL: http://www.cis.ohio-state.edu/~rick/Soar17/</p>"},{"location":"workshops/17/#schedule","title":"Schedule","text":""},{"location":"workshops/17/#friday-june-27th","title":"Friday, June 27th","text":"Time Duration Presenter Title \u00a01900\u20141915 \u00a015 Rick Lewis \u00a0Introductions &amp; announcements \u00a01915\u20141925 \u00a010 Collect transparencies \u00a01925 Travel to Johnson's home for cookout"},{"location":"workshops/17/#saturday-june-28th","title":"Saturday, June 28th","text":"Time Duration Presenter Title Slides \u00a00830\u20140900 30 Breakfast Agents and I/O 0900\u20140915 15 John Laird Update on TacAir-Soar slides 0915\u20140930 15 Paul Rosenbloom RWA update slides 0930\u20140945 15 Randy Hill RWA/IFOR perception slides 0945\u20141000 15 John Laird Building agents quickly slides 1000\u20141015 15 Michael van Lent Learning hierarchical operators from observation slides 1015\u20141035 20 Break 1035\u20141050 15 Michael van Lent Creating a Soar agent to play Descent slides 1050\u20141115 25 Bob Wray Designing I/O with Soar: Possibilities, Guidelines and Interactions slides 1115\u20141140 25 John Laird Group discussion: I/O Community and System Updates I 1140\u20141155 15 Tom Head Soar 7.0.4+ Distribution Update 1155\u20141200 5 Clare Congdon Soar manual update slides 1200\u20141305 \u00a065 Lunch Human Cognition and Behavior I 1305\u20141310 5 Bonnie John HI-Soar 1310\u20141325 15 Hongbin Wang Hybrid Soar/Echo model of tactical decision making slides 1325\u20141340 15 Ron Chong Epic-Soar slides 1340\u20141355 \u00a015 Yannick Lallement ATC-Epic/Soar slides 1355\u20141410 \u00a015 Break Architecture 1410\u20141505 55 Bob Wray Operand2 slides 1505\u20141520 15 Wray/Laird Group discussion: Operand2 1520\u20141545 25 Break Subgroup sessions(see\u00a0below\u00a0for sugroup reports) 1545\u20141550 5 Organization of subgroups 1550\u20141655 65 Subgroup sessions 1655\u20141710 15 Break Architecture and system update 1710\u20141740 30 K. Coulter &amp;\u00a0Randy Jones Soar 7.1 slides 1740\u20141755 15 Randy Jones Tcl/Tk Soar Interface slides 1815\u20142000 Dinner at Taj Palace Demos at\u00a0CIS Department 2000 Travel to CIS Department 2015\u20142200 105 Demos 2200 Return to Ramada"},{"location":"workshops/17/#sunday-june-29th","title":"Sunday, June 29th","text":"Time Duration Presenter Title Slides \u00a00830 30 Breakfast Human Cognition and Behavior II 0900\u20140915 15 Tony Kalus Intelligent decision support system slides 0915\u20140930 15 Todd Johnson Memory and Learning in Act-R/Soar slides 0930\u20140950 20 Rick Lewis A new theory of working memory in sentence processing slides 0950\u20141005 15 Paul Rosenbloom Emotion slides 1005\u20141020 15 Randy Jones Constraints on the design of a high level model of cognition slides \u00a01020-1045 25 Break Agents 1045\u20141100 15 Jonathan Gratch Planning, replanning and execution 1100\u20141115 15 Lewis Johnson Update on pedagogical agents slides 1115\u20141120 5 Clare Congdon AAAI tutorial slides 1120\u20141135 15 Sayan Bhattacharyya Capability analysis Community and System Updates II 1135\u20141140 5 Mazin As-Sanie Introduction slides 1140\u20141145 5 Patrick Kenny Introduction 1145\u20141150 5 Uluc Saranli Introduction 1150\u20141200 10 Tony Kalus Soar usage in Europe slides 1200\u20141205 5 Karen Coulter Soar email addresses 1205\u20141305 60 Lunch Subgroup reports 1305\u20141320 15 Jill Lehman Cognitive modelling and psychological theory Paul Nielsen Commercialization of Soar slides Bob Wray Operand2 slides Natural Language 1320\u20141335 15 Deryle Lonsdale Generation in NL-Soar slides 1335\u20141350 15 Julie Van Dyke Second language acquisition slides Human Cognition and Behavior III 1350\u20141405 15 Erik Altmann Individual differences in attention microstrategies slides 1405\u20141420 15 Break 1420\u20141435 15 Todd Johnson Frequency learning using SCA slides Community and System Updates III 1435\u20141450 15 Karl Schwamb\u00a0(ERS) The ERS Soar Kernel API slides 1450\u20141505 15 Karl Schwamb\u00a0(ERS) KB Agent, A Commercial Version of Soar: Plans and Status slides 1505\u20141535 30 Jill Lehman Wrap-up"},{"location":"workshops/19/","title":"19th North American Soar Workshop","text":"<p>May 20th-23rd, 1999</p> <p>Ann Arbor, MI</p> Participant group photo"},{"location":"workshops/19/#schedule","title":"Schedule","text":"Presenter Title Links Emotion and Fatigue Jonathan Gratch Why You Should Buy an Emotional Planner slides Randy Jones(presented by J Laird) Real-time Modeling of Reaction Time in Soar: Support for Psychological Models of Fatigue slides Ron Chong Towards a Model of Fear in Soar slides Psychological Models Randy Hill Modeling Perceptual Attention in Virtual Humans slides Youngjun Kim How Long Does an Agent Focus on a Specific Task slides Weixiong (Wayne) Zhang Gaining Battlefield Awareness Through Entity Clustering and Classification slides Deryle Lonsdale Analogical Modeling of Language in Soar slides Architectural Comparisons Richard M. Young Brief Introduction to ACT-R for Soarers: Soar and ACT-R still have much to learn from each other slides Scott Wallace Comparing Soar with CLIPS slides Sayan Bhattacharyya Comparing Soar with BDI Architectures slides Learning Mazin Assanie Teaching an Agent via Constrained Interactive Natural Language Dialog slides Mike van Lent Learning by Observation in Complex Domains slides Gourabmoy Nath Situated Learning Approach to Designing Using Soar slides Bill Kennedy Manually Excising Soar Chunks During Long-Term Learning slides Soar Development Karen Coulter Soar Support Update slides Scott Wallace Soar Lite slides Robert Wray Benchmarking Soar: Using Soar's Timers slides Tony Kalus viSoar - an Integrated Soar Development Environment slides John Laird Visual Soar slides Mike van Lent SocketIO and You slides Planning and Teamwork Randy Hill Command and Control Modeling in Soar slides Jonathan Gratch How to Make Your Planner Rude slides Richard Whitney Soaring with Stealth slides David Pynadath Toward Team-Oriented Programming slides Weixiong (Wayne) Zhang DYNAMITE: Automated Negotiating Teams slides Soar Community Jim Rosbe Soar Technology, Inc. Update slides Karl Schwamb ExpLore Reasoning Systems, Inc. Update slides Tony Kalus Soar Usage Outside the USA slides Mike van Lent Update on the Soar/Games Project slides Russ Tedrake Soaring with Descent3 slides Takehiko Ohno Toward Modeling Real-Time Game Player with Soar slides Sergej Roytman Soar Agents for a Driving Simulator slides Mitchell Goodman\u00a0(presented by J Laird) Intelligent, Believable, Social Agents in a Real-Time 3-D World slides"},{"location":"workshops/21/","title":"21st North American Soar Workshop","text":"<p>May 20th-23rd, 2001</p> <p>Ann Arbor, MI</p> <p>Hosted by the Artificial Intelligence Laboratory of The University of Michigan and Soar Technology, Inc.</p>"},{"location":"workshops/21/#author-index","title":"Author Index","text":"Presenter Title Link Assanie, Mazin Directable Agents slides missing Bhattacharyya, Sayan Agents in Soar and UM-PRS slides Bovenkamp, Ernst Collaborative Multi-agent IVUS Image Segmentation slides Chandrasekaran, B. Multi-modal Representations as the Basis of Cognitive Architecture slides Hawkins, John Node Navigation in Quake-Soar slides Henninger, Amy New Faces at SoarTech New Faces at SoarTech Hoffman, Tim EbonSoar: Toward a Simulated Human Opponent slides James, Michael Working Memory Element Decay in Soar slides Jones, Bradley SGIO slides VisualSoar slides Jones, Randolph Graphical Visualization of Agent Thinking slides Emotional Interactive Agents slides Kennedy, Bill Long-term Learning with TankSoar slides Konik, Tolga Using Progol for Learning by Observation slides missing Laird, John Learning from Planning in TankSoar slides 10 Things I Hate About Soar slides Lewis, Rick Control Structures in Cognitive Architectures and their Relevance for Theories of Executive Function slides Lonsdale, Deryle NL-Soar Update slides LG-Soar: Parsing for Information slides Magerko, Brian Narrative Direction using Soar slides Nielsen, Paul Robust Soar Models slides Polk, Thad Building a UTC from the Brain Up slides Putzer, Henrik The COSA Framework slides Pynadath, David Revisiting Asimov's First Law: A Response to the Call slides Ritter, Frank Update on Soar FAQ slides Update on Soar SAP Evaluation slides Rosbe, Jim Soar Technology, Inc. Update slides Roytman, Sergej Soar Lint: Static Testing for Soar Code slides Smith, Phil Virtual Worlds for Soar Research slides Taylor Glenn SOF-Soar: Special Operations IFORs slides van Lent, Mike Country Conflict slides missing KnoMic slides Wallace, Scott Soar API/IO slides missing Automatic Knowledge Verification slides missing Wood, Scott New Faces at SoarTech New Faces at SoarTech Wray, Robert Soar and Multi-Agent Systems slides Categories of Persistence in Soar 8 slides A soar Technology Map slides"},{"location":"workshops/22/","title":"22nd North American Soar Workshop","text":"<p>May 30th-June 2nd, 2002</p> <p>Ann Arbor, MI</p> <p>Hosted by the Artificial Intelligence Laboratory of The University of Michigan and Soar Technology, Inc.</p>"},{"location":"workshops/22/#author-index","title":"Author Index","text":"Presenter Title Links Assanie, Mazin Directable Synthetic Characters slides Beard, Jonathan Error Detection and Diagnosis in Soar Agents slides Beisaw, James General, Maintainable, Extensible Communications slides Councill, Isaac An integrated toolset for creating agents that explain themselves slides Crossman, Jacob Meta Programming in Soar slides Harleton, Brian Current and Future Enhancements to Visual Soar slides Hawkins, John Learning Action Models from Soar Experience Traces slides James, Mike Modeling working memory decay in Soar slides Jones, Randy An analytical framework for agent architectures slides Jones, Randy Interfacing Emotional Behavior Moderators with Intelligent Synthetic Forces slides Jones, Randy An impasse-driven model of a new result on learning in problem solving slides Kalus, Tony Soar Modelling of Confrontational Analysis slides Kennedy, Bill Long-term Learning in Soar slides Kiessel, Jennifer Error Recovery in Soar Agents slides Konik, Tolga Learning by observation using Inductive Logic Programming: Recent Progress slides Laird, John Haunt Project Overview slides Lonsdale, Deryle NL-Soar and LG-Soar: ongoing work slides Magerko, Brian Interactive Drama: Soar as a Story Director slides Nielsen, Paul Robustness in Behavioral Modeling slides Nuxoll, Andrew Advancing STEAM slides Pearson, Douglas The STI: Connecting Soar's Tools slides Reece, Douglas An Approach for Using Soar with the OneSAF Modeling Infrastructure slides Ritter, Frank Task analysis of cognitive model interfaces slides Rosbe, Jim SoarTech update slides Smith, Phill Autonomous Systems Design for Combat UAV Operations slides Stokes, Devvan Connecting Soar to Unreal (with Alex Kerfoot) slides Taylor, Glenn VISTA: A Generic Toolkit for Visualizing Agent Behavior slides Taylor, Glenn Social Soar Agents slides Mike van Lent, Michael Mission Rehearsal Exercise slides Mike van Lent, Michael Perception in the Mission Rehearsal Exercise slides Mike van Lent, Michael Spatial Reasoning and Motion Graphs slides Wallace, Scott Detecting Errors in Human-Level Agents slides Waterson, Chris TinySoar: Soar on Lego Mindstorms slides Wessling, Jens Soar Kernel Interface slides Wray, Robert Thinking on Its Feet: Using Soar to Represent Human Behavior in Urban Combat slides Wray, Robert Quantitative Category Learning in Soar: Progress and Roadblocks slides"},{"location":"workshops/23/","title":"23rd Soar Workshop","text":"<p>June 23rd-27th, 2003</p> <p>Ann Arbor, Michigan</p> Participant group photo"},{"location":"workshops/23/#schedule","title":"Schedule","text":""},{"location":"workshops/23/#monday-june-23rd","title":"Monday, June 23rd","text":"Begin End Presenter Title Links 9:00am 5:00pm John Laird Beginning Tutorial: ATL slides"},{"location":"workshops/23/#tuesday-june-24th","title":"Tuesday, June 24th","text":"Begin End Presenter Title Links 9:00am 5:00pm John Laird Beginning Tutorial: ATL 10:00am 12:00pm Bob Mariner SGIO: Soar Technology SGIO tutorial, Quick Reference Guide 1:00pm 5:00pm Deryle Lonsdale, Mike Manookin NL-Soar: Soar Technology NL-Soar: Soar Technology 7:00pm 10:00pm Welcome: Pizza House"},{"location":"workshops/23/#wednesday-june-25th","title":"Wednesday, June 25th","text":"Begin End Presenter Title Links 8:45am 9:00am John Laird Welcome slides 9:00am 9:15am John Laird Soar MOUTBot update slides 9:15am 9:30am Brad Best ACT-R applied to MOUT slides 9:30am 9:45am Michael Parent Haunt 2 Soar Bots slides 9:45am 10:00am Jon Beard Cooperative Interface Agents for Networked Command and Control slides 10:00am 10:15am Brian Magerko Incorporating User Modeling into Interactive Drama slides 10:15am 10:30am Michael van Lent Commercial Platform Training Aids slides 10:30am 11:00am Break 11:00am 12:00pm James Albus 4D/RCS Reference Model Architecture for Intelligent Vehicles slides 12:00pm 1:00pm Lunch 1:00pm 1:15pm Alex Kerfoot Soar as a High Level AI with SGIO slides 1:15pm 1:30pm John Hawkins Learning Action Models through ILP slides 1:30pm 1:45pm Tolga Konik Efficient Rule Testing in Learning by Observation slides 1:45pm 2:00pm John Laird Beyond Chunking slides 2:00pm 2:15pm Andy Nuxoll Episodic Memory for Soar slides 2:15pm 2:30pm Shelley Nason Reinforcement Learning and Soar slides 2:30pm 3:30pm Learning Discussion 3:30pm 4:00pm Break 4:00pm 4:30pm Scott Wallace Validating Agent Behavior slides 4:30pm 4:45pm Scott Wallace Soar Future Discussion Topics slides 4:45pm 5:00pm Randy Jones Radical Randy Revisited slides"},{"location":"workshops/23/#thursday-june-26th","title":"Thursday, June 26th","text":"Begin End Presenter Title Links 8:45am 9:00am Sean Lisse The Phase System: Towards Modular Encapsulation in Soar slides 9:00am 9:15am Bob Mariner Soar and Related Projects Refresh on SourceForge slides 9:15am 9:40am Doug Pearson Rapid Model Building From Diagrams and Examples slides 9:40am 9:45am Bob Wray PWRUP: Playbook &amp; Whiteboard for Soar Development slides 9:45am 10:00am Sean Lisse DAML2Soar: An Ontology to Soar Translator slides 10:00am 10:15am Frank Ritter A Higher Level Behavior Representation Language 4 Soar slides 10:15am 10:20am Frank Ritter Soar-FAQ Reminder and New Book slides 10:20am 10:25am Glenn Taylor VISTA Update slides 10:25am 10:30am John Laird Visual Soar Update slides 10:30am 11:00am Break 11:00am 12:00pm Pat Langley ICARUS slides 12:00pm 1:00pm Lunch 1:00pm 1:15pm Brad Best ACT-R: Learning the Architecture, Debugging, and Creating slides 1:15pm 1:30pm David Ray SoarDoc: Soar Documentation Generator slides 1:30pm 2:30pm Usability Discussion #1 Survey Results, Usability 1, Capabilities 2:30pm 3:30pm Usability Discussion #2 Usability 2 2:30pm 3:30pm Usability Discussion #3 Usability 3 3:30pm 4:00pm Break 4:00pm 5:00pm Joint Discussions 5:00pm 6:00pm 6:00pm 7:00pm Dinner at Soar Tech 7:00pm 8:00pm John Laird Evolution of Soar slides 8:00pm 9:00pm Demos and Dessert"},{"location":"workshops/23/#friday-june-27th","title":"Friday, June 27th","text":"Begin End Presenter Title Links 8:45am 9:00am Bill Kennedy Status of Long-Term Learning In Soar slides 9:00am 9:15am Aaron Cahill Autonomous Command and Control of Unmanned Vehicles slides 9:15am 9:30am Paul Benjamin Using Soar with a Mobile Robot slides 9:15am 9:45am Steve Haynes Explanation Seeking in Soar slides 9:45am 10:00am Deryle Lonsdale NL-Soar Update slides 10:00am 10:15am Mike Manookin Attachments in NL-Soar slides 10:15am 10:30am Clint Tustison LG-Soar slides 10:30am 11:00am Break 11:00am 12:00pm Jonathon Gratch Emotion Model slides 12:00pm 1:00pm Lunch 1:00pm 1:30pm Matthias Scheutz Affective Agent Architectures slides 1:30pm 1:45pm Ron Chong Pervasive Activation: Declarative and Procedural slides 1:45pm 2:00pm Ron Chong RULEX-EM: A Category Learning Model slides 2:00pm 2:15pm Bob Wray SCA Quantitative Results slides 2:15pm 2:30pm Bob Wray Variability in Human Behavior Representation slides 2:30pm 2:45pm Emma Norling Modeling Human Variability in Computer Generated Forces slides 2:45pm 3:00pm Ryan McAlinden Human Behavior Models and Unreal Tournament slides 3:00pm 3:30pm Break 3:30pm 3:45pm Jim Rosbe Update on Soar Tech slides 3:45pm 4:00pm Bob Wray Searching for a Unifying Theory of Soar"},{"location":"workshops/27/","title":"27th Soar Workshop","text":"<p>May 21-25, 2007</p> <p>Ann Arbor, Michigan</p> Participant group photo"},{"location":"workshops/27/#schedule","title":"Schedule","text":""},{"location":"workshops/27/#tuesday-may-22","title":"Tuesday, May 22","text":"Time Duration Presenter Topic 6:30pm 120 SoarTech Pizza House"},{"location":"workshops/27/#wednesday-may-23","title":"Wednesday, May 23","text":"Time Duration Presenter Title Links 8:00-9:00 60 Registration and Bagels 9:00-10:15 75 Cognitive Architecture 15 John Laird Introductions 10 Keith Knudsen Survey Introduction and Distribution slides 30 John Laird Soar Nuggets slides 20 Robert Wray Metrics for Evaluating Cognitive Achitecture slides 10:15-10:45 30 Break 10:45-12:00 75 Cognitive Architecture 15 Jacob Crossman Aspects and Soar: A Behavior Development Model slides 20 Randolph Jones A Comparison of Modeling Idioms in ACT-R and Soar slides 30 Jacob Crossman Performance of Goal Management Techniques slides 10 Discussion 12:00-1:15 75 Lunch 1:15-2:55 100 Extensions &amp; Applications 20 Sam Wintermute The SRS Spatial Reasoning System slides 20 Unmesh Kurup Modeling Memories of Large-scale Space slides 20 Scott Lathrop Visual Imagery slides 20 Brian Stensrud Automated Air Traffic Control slides 20 Nicholas Gorski Transfer Learning Experiments with Soar &amp; the UCT slides 2:55-3:25 30 Break 3:25-5:00 95 Stories and Serious Games 20 Ben Medler Scribe: A Tool for Authoring Story-Level Goals slides 15 Brian Stensrud ISAT (Intelligent Story Architecture for Training) slides 60 Michael van Lent Serious Game AI vs. Game AI slides"},{"location":"workshops/27/#thursday-may-24","title":"Thursday, May 24","text":"Time Duration Presenter Title Links 9:00-10:15 75 Soar Kernel and Tools 10 Doug Pearson Removing gSKI from kernel slides 45 Keith Knudsen Soar IDE slides 5 Jon Voigt New Experimental Environment slides 15 Kate Harding Soar Tech Update slides 10:15-10:45 30 Break 10:45-12:00 75 Alternative Architectures 20 Doug Pearson STORM Framework slides 20 Nicholas Gorski An Example Architecture Using the Storm Framework slides 30 Bob Marinier SESAME &amp; Soar: A Comparison slides 5 Discussion 12:00-1:15 75 Lunch 1:15-2:45 90 Learning 20 Andrew Nuxoll Episodic Memory and Cognitive Capabilities slides 20 Yongjia Wang Action History in Decision Making and RL slides 15 Yongjia Wang Hierarchical Clustering and Reinforcement learning slides 15 Joseph Xu Transfer Learning using Soar slides 20 Bill Kennedy Cognitive Science and Long-term Symbolic Learning slides 2:45-3:15 30 Break 3:15-5:00 105 Cognitive Modeling 20 Bob Marinier Feeling as Intrinsic Reward slides 30 Michael Quist Toward a Hybrid Cultural Cognitive Architecture slides 10 Deryle Lonsdale Update on NL-Soar and XNL-Soar slides 15 Keith Knudsen Survey Results 30 John Laird Cognitive Architecture Challenge Problems slides 6:30-9:00 Dinner"},{"location":"workshops/28/","title":"28th Soar Workshop","text":"<p>May 4th-7th, 2008</p> <p>Ann Arbor, MI</p> Participant group photo Presenter Title Links Brian Magerko Approaching the Cognitive Modeling of Improvisational Acting slides Glenn Taylor A Toolkit for Modeling Dynamic Power Structures slides Glenn Taylor Cultural Cognitive Architecture (Update) slides Lisa Holt Intelligent Modeling for Pedagogically-Aware Cultural Training slides Olivier Georgen Can Activity Trace Databases Become Cognitive Models? slides Sam Wintermute The SVS Spatial/Visual Reasoning System slides Scott Lathrop Reasoning with Visual Depictive Representations slides Sam Wintermute Spatial Reasoning with Motion slides Deryle Lonsdale LG-Soar and (X)NL-Soar Revisited slides Geoff Morgan TEAL: Macro Learning for Robotic Command and Control slides Greg Trafton Embodied Cognition and Human-Robot Interaction slides missing Paul Benjamin ADAPT: A Cognitive Architecture for Robots slides Alan Vayda Human-Robot Collaboration for Remote Surveillance slides Andy Dallas Ground Robotics Consortium slides missing Jon Voigt Robotics Simulation Environments and Soar slides Nate Derbinsky Soar-RL: A Year of \u201cLearning\u201d slides Wilbert Grevers Soar-RL and Agent-Based Computational Economics slides Joseph Xu Chunking with Reinforcement Learning slides Nicholas Gorski Learning to Control Internal Memory slides Bob Marinier Emotion-Driven Learning in a Complex Environment slides Yongjia Wang Concept Learning for Semantic Memory slides Nate Derbinsky Episodic Memory and Databases: A Year to \u201cRemember\u201d slides Joseph Xu Transfer Learning Revisited slides Frank Ritter Update on Herbal and Applications slides Keith Knudsen Soar IDE Update slides Randy Jones Improving HBM Affordability: A High-Level Language for Cog. Arch. slides Bob Wray Perception for Realistic Cognition in Virtual Environments (PRCVE) slides Bill Kennedy Mental Simulation for a Robot Teammate slides Jon Voigt Soar 2D slides Nate Derbinsky SoarSim: An Experimentation Framework slides Glenn Taylor Low Fidelity Tactical Simulation Environment: simJr slides Dave Ray Soar Integration Lessons Learned slides Randy Jones Cost-Effective Conversion of Large Soar 7 Systems to Soar 8 slides Bob Marinier Useful Things to Know About Soar and the Java Debugger slides Jim Rosbe SoarTech Update slides John Laird Cognitive Architecture: Past, Present, and Future slides John Laird Soar Releases slides"},{"location":"workshops/29/","title":"29th Soar Workshop","text":"<p>June 22-26, 2009</p> <p>Ann Arbor, MI</p> Participant group photo Presenter Title Links Wesley Kerr Language Learning in Wubble World slides Jeremiah McGhee Update on Soar 9 and Sentence Processing slides Thomas Mielke MindModeling@Home: A Computing Resource for Cognitive Modeling slides John Laird Overview of Michigan Soar Research slides Jonathan Voigt Soar on Splinter slides Mark Yong Interfacing Soar to a Robot slides Sam Wintermute Using Imagery to Simplify Perception slides Mitchell Bloch Hierarchical Reinforcement Learning in the Taxicab Domain slides Shiwali Mohan Learning to play Mario slides Nate Derbinsky Efficiently Implementing Episodic Memory slides Nick Gorski Learning to Use Episodic Memory slides Joseph Xu Instance Based Model Learning slides Ningxuan Wang EDEE: A New Environment for Soar slides Olivier Georgeon A Soar model of Bottom-Up Learning from Activity slides Randy Jones Learning New Air Combat Tactics with Cascade slides Nate Derbinsky Soar-SMem: A Public Pilot slides Yongjia Wang Integration of Concept Memory and Probabilistic Category Learning slides Bob Marinier Deriving Appraisals from Sequence and Causal Concept Networks slides Mike van Lent Soar Tech Update slides Brian Stensrud Adaptive Tailoring of Student Learning: Notes on a Soar Approach slides Brian Magerko Empirical Findings from a Study of Cognition and Improvisation slides Dave Ray JSoar: A Pure Java Implementation of Soar slides Nate Derbinsky iSoar slides Jonathan Voigt Soar 9.0.1 slides John Laird Millions of Rules, Billions of Decisions slides Bob Marinier Thoughts on the Future of HLSR slides Sean Bittle Constrained Heuristic Search in the Soar Cognitive Architecture slides Bob Wray The Need for Architecture Simulation slides Paul Rosenbloom Graphical Models for Cognitive Architecture slides John Laird Limited Parallel Operators for Soar slides Sam Wintermute Augmenting Soar with Non-Symbolic Processing via the IO Link slides Discussion Topic Notes slides"},{"location":"workshops/30/","title":"30th Soar Workshop","text":"<p>June, 2010</p> <p>Ann Arbor, MI</p> Presenters Title Links Sean A. Bittle, Mark S. Fox Transfer Learning of Search Heuristics for Constraint Satisfaction slides Mitchell Keith Bloch MAXQ HRL in Soar slides Olivier L. Georgeon,  Frank E. Ritter Self-Motivated Hierarchical Sequence Learning slides Nicholas Gorski, John Laird An Empirical Exploration of Learning to Use Memory slides Isaiah Hines Integrating Soar with Unreal 3 slides Johnicholas Hines Towards Rogue-Soar: Combining Soar, Curses and Micropather slides William G. Kennedy Cognitive Architecture Lite for Social Simulation slides John E. Laird A Unified Approach to Diverse Forms of Action Modeling slides John E. Laird Soar Tutorial: Building Intelligent Agents Using Soar slides John E. Laird How to Build a Soar Agent slides Margaux Lhommet Soar \u2013 First impressions slides Justin Li Learning Subgoals in Hierarchical Reinforcement Learning slides Brian Magerko Fuzzy Improvisational Agents slides Shiwali Mohan, John E. Laird Reinforcement Learning in Infinite Mario slides Shiwali Mohan Learning Background Knowledge through Instruction slides Paul Rosenbloom A Graphical Memory Architecture slides Bryan Smith Representing Ontologies and Reasoning with SMem slides Katherine Tyrol A Cognitive Science Model of Playing Ms. Pac-Man slides Mike Van Lent SoarTech Update slides Jonathan Voigt Soar 9.3 slides Jonathan Voigt Sproom: Splinter Soar Room Environment slides Yongjia Wang Value Function Approximation with Hierarchical Clustering in Soar-RL slides Yongjia Wang Learning Functional Categories with Soar-RL slides Sam Wintermute Using Imagery to Simplify Perceptual Abstraction in Reinforcement Learning Agents slides Bob Wray Using Soar to Create Individualized Learning Experiences slides"},{"location":"workshops/31/","title":"31st Soar Workshop","text":"<p>June 13th-17th, 2011</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Participant group photo in front of Beyster building, 2011"},{"location":"workshops/31/#schedule","title":"Schedule","text":""},{"location":"workshops/31/#wednesday-june-15th","title":"Wednesday, June 15th","text":"Time Duration Presenter Title Links 8:30-9:00 30 Registration, Bagels, Juice, and Coffee 9:00-10:15 75 Semantic and Episodic Memory 15 Introductions 10 Nate Derbinsky Introduction to Smem and Epmem pdf, ppt 20 Nate Derbinsky Effective and Efficient Historical Memory Retrieval Bias in Smem pdf, ppt 15 Bob Marinier Playing with Semantic Memory pdf, ppt 15 John Laird Performance Evaluation of Soar's Declarative Memories pdf, ppt 10:15-10:45 30 Break 10:45-12:00 75 20 Justin Li Do's and Don't's of Episodic Memory link 20 Justin Li Supporting Delayed Intentions with Long-Term Memories link 35 Nate Derbinsky Discussion of Soar Semantic and Episodic Memories 12:00-1:30 90 Lunch 1:30-3:00 90 20 Nate Derbinsky Efficient Activation-based Working Memory Forgetting pdf, ppt 20 John Laird Impact of Working Memory Activation on Agent Design pdf, ppt 10 Discussion of Activation in Working Memory 30 Paul Rosenbloom Cognitive Architectures for Virtual Humans pdf, ppt 10 Discussion 3:00-3:30 30 Break 3:30-5:00 90 60 Milind Tambe Game Theory for Security: Lessons Learned from Deployed Applications slides missing 30 Questions and Discussion"},{"location":"workshops/31/#thursday-june-16th","title":"Thursday, June 16th","text":"Time Duration Presenter Title Links 8:30-9:00 30 Bagels, Juice, and Coffee 9:00-10:15 75 10 Miller Tinkerhess Dice Game Engine pdf, odp 20 John Laird Playing with Dice in Soar pdf, ppt 20 Nate Derbinsky Soaring to New Platforms: 2011 Update pdf, ppt 15 Bob Marinier SoarUnit pdf, ppt 10 Margaux Lhommet Enactivism and multiagent system pdf 10:15-10:45 30 Break 10:45-12:00 75 15 Randy Jones Characterizing the Performance of Applied Intelligent Agents in Soar pdf, ppt 5 Jon Voigt Soar Data Collection pdf, ppt 15 Miller Tinkerhess A New Soar Editor pdf, odp 20 Nate Derbinsky The State of Soar v9.3.1 pdf, ppt 15 Nate Derbinsky SoarQnA: Standardized Access to External Knowledge pdf, ppt 12:00-1:30 90 Lunch 1:30-2:45 75 20 Randy Jones Achieving parsimony between NGS and the Michigan approach pdf, ppt 20 Randy Jones Current Applied Soar Agent Development pdf, ppt 15 Deryle Lonsdale Robust parsing and LGSoar pdf, ppt 15 Deryle Lonsdale The XNL-Soar Sandbox pdf, ppt 5 Zarrin Chua Modeling Astronaut Decision-Making during Lunar Landing pdf, ppt 2:45-3:15 30 Break 3:15-5:00 105 10 Nick Gorski Introduction to Soar-RL pdf, ppt 20 Shiwali Mohan Modular Reinforcement Learning in Soar pdf 20 Mitchell Bloch Improving Off-Policy Hierarchical Reinforcement Learning in Soar pdf 20 Nick Gorski Learning to Use Memory pdf, ppt 35 Nick Gorski Discussion of Soar-RL pdf, ppt 6:30-9:00 150 John Laird Dinner at 311 Windycrest Drive"},{"location":"workshops/31/#friday-june-17th","title":"Friday, June 17th","text":"Time Duration Presenter Title Links 8:30-9:00 30 Bagels, Juice, and Coffee 9:00-10:20 80 15 Michael van Lent SoarTech Update slides missing 25 Joseph Xu Overview of SVS pdf, ppt 5 Miller Tinkerhess Introduction to Robot Domain 15 Miller Tinkerhess A Simulated Environment for Instruction pdf, odp 20 Shiwali Mohan An Architecture for Learning with Instruction pdf 10:20-10:50 30 Break 10:50-12:00 70 15 Keegan Kinkade SLAM for Soar pdf 20 Joseph Xu Integrating action modeling into SVS pdf, ppt 20 Glenn Taylor Multi-Modal Human-Robot Interaction slides missing 15 Miller Tinkerhess Robotics discussion pdf, odp"},{"location":"workshops/32/","title":"32nd Soar Workshop","text":"<p>June 18th-22nd, 2012</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> <p>Room 1670</p> Participant group photo in front of Beyster building with arms raised (making waves), 2012"},{"location":"workshops/32/#schedule","title":"Schedule","text":""},{"location":"workshops/32/#wednesday-june-20th","title":"Wednesday, June 20th","text":"Time Duration Presenter Title Links 8:30-9:00 30 Registration, Bagels, Juice, and Coffee 9:00-10:15 75 15 Introductions 20 John Laird Selection Space pdf, ppt 20 John Laird Using Background Knowledge in RL pdf, ppt 20 Mitchell Bloch Tie Impasses for Numeric Preferences pdf 10:15-10:45 30 Break 10:45-12:00 75 20 Nate Derbinsky Competence-Preserving Retention of Learned Knowledge in Soar Memories pdf, ppt 20 Nate Derbinsky Multi-Domain Evaluation of Scaling in Soar's Episodic Memory pdf, ppt 20 Justin Li Functional Interactions between Memory and Recognition Judgments pdf 15 Nate Derbinsky Next Steps in Memory Research pdf, ppt 12:00-1:30 90 Lunch 1:30-3:05 95 15 Joseph Xu Soar 9.3.2 and Changes to the Soar Compilation Process pdf, ppt 15 Johnicholas Hines Delimited Continuations in Soar pdf, ppt 15 Joseph Xu How to use the new Soar Visual System (SVS) pdf, ppt 20 Keegan Kinkade Soar Robot Unleashed pdf 30 Joseph Xu Learning Relational and Continuous Action Models pdf, ppt 3:05-3:35 30 Break 3:35-4:30 55 15 Mike van Lent SoarTech Overview slides missing 10 Mike van Lent Soar in DARPA's SSIM program slides missing 10 Mike van Lent Would you trust a Soar agent with your life? slides missing 30 Discussion 6:30-8:30 120 Pizza House, 618 Church Street"},{"location":"workshops/32/#thursday-june-21st","title":"Thursday, June 21st","text":"Time Duration Presenter Title Links 8:30-9:00 30 Bagels, Juice, and Coffee 9:00-10:20 80 15 John Laird Overview of BOLT (Grounded Language Acquisition) pdf 15 Robert Goeddel \"Kinecting\" the Dots: How Bolt Sees the World pdf 20 Sam Wintermute Leveraging Cognitive Context for Language Processing in Soar pdf, ppt 15 Shiwali Mohan Mixed Initiative Interaction for Learning pdf 15 Aaron Mininger Learning Nouns and Adjectives in Bolt pdf 10:20-10:50 30 Break 10:50-12:00 70 15 James Kirk Learning Prepositions for Spatial Relations in BOLT pdf, ppt 15 Shiwali Mohan Situated Comprehension of Verb Commands pdf 15 Shiwali Mohan Learning new Actions with Retrospective Projection pdf 25 Discussion 12:00-1:30 90 Lunch 1:30-3:00 90 15 Deryle Lonsdale XNL-Soar: Where we are and where we're headed pdf, ppt 5 Nathan Glenn Japanese and Optimality Theory pdf, ppt 15 John Hale Rational Parsing pdf 20 Rick Lewis Language Processing as Bounded Optimal Control of Memory, Perception pdf 15 Glenn Taylor Natural Human-Robot Interaction slides missing 20 Discussion 3:00-3:30 30 Break 3:30-4:30 60 15 Randy Jones Interpreted Declarative Representations of Task Knowledge pdf, ppt 15 Randy Jones Achieving parsimony between NGS and the Michigan approach pdf, ppt 30 Discussion 7:30-9:00 150 Demos Soar Technology, Green Road"},{"location":"workshops/33/","title":"33rd Soar Workshop","text":"<p>June 3rd-6th, 2013</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> <p>Room 1670</p> Participant group photo in front of Beyster building, 2013 Participant group photo in front of Beyster building with arms raised (making waves), 2013"},{"location":"workshops/33/#schedule","title":"Schedule","text":""},{"location":"workshops/33/#wednesday-june-3rd","title":"Wednesday, June 3rd","text":"Time Duration Presenter Title Links 8:30-9:00 30 Registration, Bagels, Juice, and Coffee 9:00-10:15 75 5 Introductions 20 Justin Li Prospective Memory as a Computational Problem slides 15 Justin Li Preemptive Strategies for Overcoming the Forgetting of Goals slides 20 Steven Furtwangler Integrated Episodic and Semantic Memory in Robotics slides 15 Aaron Mininger Methods of Partitioning a Parallel Episodic Memory slides 10:15-10:45 30 Break 10:45-12:00 75 15 Ryan Kaulakis Strategic Approximation of Human Algorithms: A Request for Comments on a Thesis slides 20 Nate Derbinsky The Three\u2010Weight Algorithm: A Flexible Platform for Integrating Knowledge and Optimization slides 20 Brian Magerko Gestural Constraints in an AI\u2010based Interactive Installation 5 Justin Permar Leaving the Script: A Blending Approach to the Generation of Pretend Play Activities slides 15 Michael van Lent SoarTech Company Update slides 12:00-1:30 90 Lunch 1:30-3:00 90 10 Sven Brueckner Soar Agents &amp; Emergence: Lessons Learned from Dealing with Large\u2010Scale Agent Systems slides 15 Scott Hastings Real\u2010time IO\u2010oriented Soar Agent for Base Station\u2010Mobile Control slides 15 Jim Thomas Using Soar to Teach Probabilistic Reasoning slides 15 Isaiah Hines Modeling with Graph-Based Version Spaces in Soar slides 20 Michael van Lent Explaining the Benefits of Soar to non-Soar Experts slides 15 Discussion 3:00-3:30 30 Break 3:30-5:00 90 60 Christian Lebiere Symbolic and Statistical Approaches to Generalization 30 Discussion 6:30-8:30 120 Welcome Dinner Arbor Brewing Company, 114 E Washington St. Sponsored by Soar Tech"},{"location":"workshops/33/#thursday-june-4th","title":"Thursday, June 4th","text":"Time Duration Presenter Title Links 8:30-9:00 30 Bagels, Juice, and Coffee 9:00-10:15 75 15 Tory S. Anderson Syntax Stories: Episodic Memory for Language Processing slides 15 Peter Lindes OntoSoar: Soar Finds Facts in Text slides 15 Deryle Lonsdale Installing and Running XNL-Soar slides 15 Shiwali Mohan Resolving References using Situated Contexts slides 15 Shiwali Mohan Learning to Ground Verbs in Actions slides 10:15-10:40 25 Break 10:40-12:00 80 20 James Kirk Learning Game Formulations in a Physically Instantiated Environment slides 15 Scott Hanford Using Soar for Mobile Robots slides 30 Joseph Xu Learning Integrated Symbolic and Continuous Action Models slides 15 John Laird Unification of Activation in Soar slides 12:00-1:30 90 Lunch 1:30-3:00 90 20 Bob Marinier JSoar Update slides 35 Mazin Assanie More Expressive and Knowledgeable Chunking slides 15 Mazin Assanie Soar 9.4 slides 5 Mitchell Bloch Soar\u2010RL Trace slides 15 Joseph Xu SVS Beta Release slides 3:00-3:30 30 Break 3:30-5:00 90 20 Alex Turner Soar and StarCraft slides 10 Aaron Mininger Improving the Soar Debugger slides 20 Mitchell Bloch Online Value Function Improvement slides 5 Mazin Assanie Memory Consolidation: Some Initial Exploration slides 15 Jon Voigt SimRadio slides 15 Braden Phillips Soar on a Chip slides 5 Discussion"},{"location":"workshops/33/#attendees","title":"Attendees","text":"Name Institution Miguel Adan Tory S. Anderson Brigham Young University Mazin Assanie University of Michigan Ben Bachelor Soar Technology, Inc. Mitchell Bloch University of Michigan Sven Brueckner Soar Technology, Inc. Jacob Crossman Soar Technology, Inc. Henry Culver Colorado Technical University David Daniel L-3 Communications Nate Derbinsky Disney Research Steven Furtwangler Soar Technology, Inc. Osama Haddadin L-3 Communications Scott Hanford Applied Research Lab/ Penn State Scott Hastings L-3 Communications Isaiah Hines University of Michigan Marc Huber Soar Technology, Inc. Steven Jones University of Michigan Ryan Kaulakis Penn State Applied Cognitive Science Lab Christopher Kawatsu Soar Technology, Inc. James Kirk University of Michigan John Laird University of Michigan Matthew Lanting Soar Technology, Inc. Christian Lebiere Carnegie Mellon University Justin Li University of Michigan Peter Lindes Brigham Young University Deryle Lonsdale Brigham Young University Brian Magerko Georgia Tech Bob Marinier Soar Technology, Inc. Aaron Mininger University of Michigan Shiwali Mohan University of Michigan Alex Nickels Soar Technology, Inc. Van Parunak Soar Technology, Inc. Justin Permar Georgia Institute of Technology Ben Purman Soar Technology, Inc. Brian Stensrud Soar Technology, Inc. Glenn Taylor Soar Technology, Inc. Jim Thomas Soar Technology, Inc. Bob Touchton Applied Research Lab - Penn State Alex Turner University of Michigan Mike van Lent Soar Technology, Inc. Jonathan Voigt Soar Technology, Inc. Joseph Xu University of Michigan Jonathan Yedidia Disney Research Boston Fumin Zhang Georgia Institute of Technology"},{"location":"workshops/34/","title":"34th Soar Workshop","text":"<p>June 16th-20th, 2014</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Participant group photo in front of Beyster building, 2014 Participant group photo in front of Beyster building with arms raised (making waves), 2014"},{"location":"workshops/34/#schedule","title":"Schedule","text":""},{"location":"workshops/34/#wednesday-june-18th","title":"Wednesday, June 18th","text":"Presenter Duration Title Links Mazin Assanie 15 2014 Soar Releases slides Aaron Mininger 15 Soar Visual System Release slides Bob Marinier 10 JSoar Update slides Mazin Assanie 20 Generalized Chunking slides John Laird 15 Interactive Task Learning as an AI Research Problem slides Shiwali Mohan 20 Learning Hierarchical Tasks from Situated Interactive Instruction slides James Kirk 20 Learning Tasks through Situated Interactive Instruction slides Mike van Lent 15 Dynamic Tailoring for Teaching Social Skills slides Mikhail Jacob 15 Viewpoints AI - Improvisational Dance / Contemporary Movement AI slides Mikhail Jacob 15 Computational Representations of Pretend Play slides Alex Turner 15 Michigan Liar's Dice slides Nate Derbinsky 15 The Boundary Forest Algorithm for Fast Online Learning of High-Dimensional Data slides Scott Hanford 15 Autonomous Mission Management for UUVs slides Aaron Mininger 20 Using Top-Down Knowledge in Soar to Maintain Object Identity slides Jesse Frost 15 Perceptual Hierachical Grouping using Soar slides Mike van Lent 15 Soar Tech Overview slides"},{"location":"workshops/34/#thursday-june-19th","title":"Thursday, June 19th","text":"Duration Presenter Title Links 15 Jesse Frost The Street Engine: A Hardware Architecture for Parallel Production Systems slides 30 Mitchell Bloch Rete for Relational Reinforcement Learning slides 20 Justin Li Tradeoffs Between Procedural and Preemptive Strategies for Goal Reactivation slides 20 Peter Lindes Soar and Construction Grammar slides 20 John Laird A Construction Grammar Parser in Soar slides 15 Justin Li Retracing the Rational Analysis of Memory slides 15 Alex Nickels Extending Semantic Memory with Math Queries slides 20 Steven Jones Activation Current and Future Work slides 10 Steven Jones SMem debugging commands slides 20 Jesse Frost Realising Soar Long Term Memory in Hardware slides 25 Group SMEM Discussion slides"},{"location":"workshops/34/#friday-june-20th","title":"Friday, June 20th","text":"Duration Presenter Title Links 15 Andrew Nuxoll Efficient Episode Recall and Consolidation slides 15 Jesse Frost Episodic Memory Search as a Constraint Satisfaction Problem slides 15 Bob Marinier Planned Extensions to Episodic Memory slides 30 Group Episodic Memory Discussion slides 15 Randy Jones A Modular Soar Agent for a Naval Decision-Making Simulation slides 15 Van Parunak SC2RAM: A Deployable Cognitive Model of a Cyber-Attacker slides 20 Randy Jones Design Patterns for Balancing Behavior Responsiveness slides 10 Jacob Crossman Preliminary look at comparing Soar to other modeling methods in TankSoar slides"},{"location":"workshops/34/#attendees","title":"Attendees","text":"Name Affiliation Aaron Mininger University of Michigan Adam Sypniewski Soar Technology Inc. Alex Nickles Soar Technology Inc. Alex Turner Soar Group/University of Michigan Andrew Nuxoll University of Portland Arthur Wandzel University of Michigan Ben Bachelor Soar Technology Inc. Bob Marinier Soar Technology Inc. Brad Norris General Dynamics C4 Systems Braden Phillips University of Adelaide Brian Stensrud Deryle Lonsdale Brigham Young University Dylan Schmorrow Soar Technology Farhad Mofidi Hira Khan Jack Zaientz Soar Technology Inc. Jacob Crossman Soar Technology Inc. James Kirk University of Michigan Jay Hiserote Synopsys Inc. Jesse Frost University of Adelaide John Laird University of Michigan John Sauter Soar Technology Inc. John Sustersic The Pennslyvania State University Justin Li University of Michigan Justin Storms University of Michigan Marc Huber Mark Rothgeb Penn State Applied Research Lab Mazin Assanie University of Michigan Michael Horta U.S. Navy Mike van Lent Soar Technology Inc. Mikhail Jacob Georgia Institute of Technology Mitchell Bloch University of Michigan - Soar Group Nate Derbinsky Disney Research, Boston Patrick DeHaan Soar Technology Inc. Peng Wang Peter Lindes Brigham Young University Randolph Jones Soar Technology Roger Cote Corporate Lexoris Learning Ryan O'Grady Soar Technology Inc. Scott Hanford Penn State Applied Research Lab Sharad Sundararajan Shiwali Mohan University of Michigan Shreya Amin Steven Jones University of Michigan CSE Van Parunak Soar Technology, Inc."},{"location":"workshops/35/","title":"35th Soar Workshop","text":"<p>June 1st-5th, 2015</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Participant group photo in front of Beyster building with arms raised (making waves), 2015"},{"location":"workshops/35/#schedule","title":"Schedule","text":""},{"location":"workshops/35/#thursday-june-4th","title":"Thursday, June 4th","text":"Presenter Duration Title Links Steven Jones 15 Spreading Activation in Soar slides Jay Ricco 15 The Efficiency of Contextualized Long Term Memory through Spreading Activation slides Justin Li 10 Spontaneous Retrieval for Prospective Memory slides Nate Derbinsky 20 Mining Episodic Memory slides Michell Bloch 15 Relational Blocks World Experiments in Carli slides Michell Bloch 20 Supporting GQ(\u03bb) for Reinforcement Learning in Soar slides Alex Turner 20 Liar's Dice 2.0 slides Deryle Lonsdale 15 Update from the Y slides John Laird 15 Update on Natural Language Understanding for Rosie slides James Kirk 15 Extending Interactive Task Learning with one-shot Goal demonstrations slides Shiwali Mohan 15 Intelligent Agents for Health-behavior Change slides Pedro Marcal 15 Automatic conversion of Text to Expert System Rules slides"},{"location":"workshops/35/#friday-june-5th","title":"Friday, June 5th","text":"Presenter Duration Title Links Bob Marinier 15 Soar Programmer's Guide slides Bob Marinier 30 JSoar Update 2015 slides Bob Marinier 20 Soar IDE Update slides Mazin Assanie 20 Explanation-Based Chunking slides Mike van Lent 20 Soar Technology Company Update slides Scott Hanford 15 Soar and unmanned vehicles slides Lizzie Mamantov 15 Top-down influence for motor behavior slides Aaron Mininger 20 Going Mobile: The Future of the Rosie Project slides John Sustersic 10 Cognitive Autonomy using Soar slides Ucheoma Ukah 20 Non-linear decision making for role based autonomy slides Ben Bachelor 25 Soar Tech Snackbot slides"},{"location":"workshops/35/#attendees","title":"Attendees","text":"First Last Affiliation Peter Lindes University of Michigan Jose Nazario Soar Technology Paul Young University of Michigan Andrew Dunn University of Michigan Matthew Cover University of Michigan Shiwali Mohan University of Michigan Mazin Assanie University of Michigan Benjamin Bachelor Soar Technology Bob Bechtel Soar Technology, Inc. Mitchell Bloch University of Michigan Kaley Chicoine Penn State Applied Research Lab Roger Cote Lexoris Learning (private corporation) Jacob Crossman Soar Technology Dave Daniszewski US Army TARDEC Nate Derbinsky Wentworth Institute of Technology Anthony Deschamps Soar Technology Andrew Dunn Department of Defense Christopher Fedor Pennsylvania State University Timothy Forbes NGC Hassen Gharbi Fulbright Visiting Scholar at Carnegie Mellon University Rob Goeddel UofM April Lab James Grimplin Northrop Grumman Scott Hanford Penn State Applied Research Lab Marilyn Jarriel Northrop Grumman Steven Jones University of Michigan - Computer Science and Engineering Chris Kawatsu SoarTech James Kirk University of Michigan John Laird University of Michigan Justin Li University of Michigan Deryle Lonsdale Brigham Young University Lizzie Mamantov Michigan Jeremy Mange TARDEC Pedro marcal MPACT Corp. Bob Marinier SoarTech Aaron Mininger University of Michigan Shiwali Mohan Palo Alto Research Center Denise Nicholson Soar Technology Ryan O'Grady Soar Technology Inc. Sara Pace TARDEC Jay Ricco Dylan Schmorrow Soar Technology, Inc. Andrew Smith Bryan Stearns University of Michigan John Sustersic Penn State University Adam Sypniewski Soar Technology, Inc. Michael Sypniewski University of Michigan Glenn Taylor SoarTech Robert Thome Pennsylvania State Applied Research Lab Alex Turner University of Michigan Ucheoma Ukah Mike van Lent SoarTech Ryan Wails Applied Research Laboratory, Pennsylvania State University Arthur Wandzel University of Michigan Bethany Young Paul Young US Navy"},{"location":"workshops/36/","title":"36th Soar Workshop","text":"<p>June 6th-10th, 2016</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Participant group photo in front of Beyster building with arms raised (making waves), 2016"},{"location":"workshops/36/#schedule","title":"Schedule","text":"Presenter Affiliation Duration Title Links Mazin Assanie University of Michigan 20 Improving Dynamic Procedural Knowledge Learning slides Mazin Assanie University of Michigan 15 Explaining the Learner slides Mazin Assanie University of Michigan 5 Visualizing Soar slides Mazin Assanie University of Michigan 5 Soar 9.5.1 Release Overview slides Mitchell Bloch University of Michigan 20 Automatic Value Function Refinement &amp; Unrefinement for Relational Reinforcement Learning slides Mohamed Elbanani University of Michigan 15 Perception, Attention and Problem Solving on the Block Design Task slides Scott Hanford Penn State University Applied Research Lab 15 Managing Competing Objectives in Soar slides Sara Jamshidi Penn State University Applied Research Lab Creating and Combining Neural Networks slides Steven Jones University of Michigan 20 Spreading Activation in Soar - An Update slides Jong-Wook Kim Dong-A University 20 Introduction of Artificial Moral Agent Incorporating Soar and Global Optimization Methods slides James Kirk University of Michigan 20 Learning General and Efficient Representations of Novel Games Through Interactive Instruction slides John Laird University of Michigan 20 Interactive Task Learning: Language Processing for Rosie slides Scott Lathrop Soar Technology, Inc. 20 Trustworthy Autonomy slides Daniel Lugo Air Force Institute of Technology 15 Development of agents to be used in military simulations slides Bob Marinier Soar Technology, Inc. 20 Soar IDE 2.0 slides Aaron Mininger University of Michigan 20 Interactively Learning Strategies for Handling References to Unseen or Unknown Objects slides Aaron Mininger University of Michigan 15 Extending Rosie to a Mobile Robot slides Aaron Mininger University of Michigan 15 SVS Discussion slides Denise Nicholson Soar Technology, Inc. 20 Use of SOAR for Modeling Cyber Operations slides Andrew Nuxoll University of Portland 20 Learning from Bare Bones with Episodic Memory slides Preeti Ramaraj University of Michigan 5 Understanding agent knowledge through conversation slides Bryan Stearns University of Michigan 15 Modeling Primitive Skill Elements in Soar slides John Sustersic Penn State University 20 Multi-Agent Architecture for Natural and Trusted Autonomy (MANTA) slides missing Michael van Lent Soar Technology, Inc. 15 SoarTech Update slides Alex Yahja University of Illinois at Urbana-Champaign 15 Soaring Network Reticulation slides"},{"location":"workshops/37/","title":"37th Soar Workshop","text":"<p>June 5th-9th, 2017</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Participant group photo in front of Beyster building, 2017 Participant group photo in front of Beyster building with arms raised (making waves), 2017"},{"location":"workshops/37/#schedule","title":"Schedule","text":"Duration Presenter Title Links 20 John Laird Learning Fast and Slow slides 20 James Kirk Learning the Problem Space from Primitives slides 20 Aaron Mininger Extending Task Learning in Rosie slides 20 Peter Lindes Language Comprehension in Rosie slides 15 Preeti Ramaraj How can Rosie tell me what it can do for me? slides 15 Lauren Naylor Introducing Ethical Constraints into a Soar Agent slides 15 Lizzie Mamantov ROSie: A new robotic platform for the Rosie project slides 10 Mohamed El Banani {Human, Soar} in the loop: Visual guidance through reasoning slides 15 Jacob Crossman Coordinating UGV Movement with Human Teams using SoarSimulation-based behavior videoSquadMATE overview video slides missing video video 15 Bob Wray Turning Level Design Concepts into Adaptive Plans slides 15 Arthur Wandzel Symbols for Hierarchical Robot Planning slides 20 Jacob Crossman An Introduction to New Goal System 4 slides 15 Timothy Saucer New Goal System 4 demo with Tank Soar slides 30 Mazin Assanie Soar 9.6.0 slides 20 Steven Jones Spreading Activation with Edge Weights slides 20 Jule Schatz Word Association with Semantic Memory slides 20 Bryan Stearns Applying Primitive Elements Theory for Procedural Transfer in Soar slides 15 Steven Jones Episodic Memory Consolidation slides 15 Bob Wray Learning to Soar slides 20 John Laird A Standard Model of the Mind slides 20 John Sustersic MANTA Cognitive Autonomy Update slides missing"},{"location":"workshops/38/","title":"38th Soar Workshop","text":"<p>May 14th-17th, 2018</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Duration Presenter Title Links 15 Bob Bixler Modeling Cyberspace Operations slides 20 Mitchell Bloch Computationally Efficient Relational Reinforcement Learning slides 15 Nate Derbinsky Enabling Dynamic Agent-Defined Learning Problems in Soar slides 20 Steven Jones A Human Episodic Memory Primer slides 20 Steven Jones Towards Improving Soar's Episodic Memory slides 20 James Kirk Learning the Task Definition of Games through ITL slides 15 James Kirk Games Learnable by Rosie slides 15 John Laird Update on Common Model of Cognition slides 20 Peter Lindes Cognitive Language Comprehension in Rosie slides 15 Lizzie Mamantov Rethinking motion control for Rosie slides 20 Aaron Mininger Interactively Learning a Blend of Goal-Based and Procedural Tasks slides 15 Aaron Mininger Expanding the Scope of Tasks that Rosie can Learn slides 5 Aaron Mininger Soar IDE for Vim slides 15 Alex Nickels The CyCog System slides 15 Neha Rajan Eight Queens with Fuzzy Constraint Satisfation Problem using Soar slides 20 Preeti Ramaraj Learning Instructor Expectations in ITL Agent Interaction slides 15 Jule Schatz Remote Associates Test slides 15 Jule Schatz Learning to Play Atari Games slides 15 Bryan Stearns A Task-General Learning Model Part 1: Power-law learning with gradual chunking slides 15 Bryan Stearns A Task-General Learning Model Part 2: Task control using spreading activation slides 15 Michael van Lent SoarTech Update slides 15 Bob Wray Story Matching slides missing 15 Bob Wray Using RL for pilot control Y2 slides missing 20 Zhao Reinforcement Learning for Modeling Large-Scale Cognitive Reasoning Using Soar slides missing"},{"location":"workshops/39/","title":"39th Soar Workshop","text":"<p>May 6th-10th, 2019</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> Duration Presenter Title Links 20 Mitchell Bloch ConcRete Road slides 15 James Boggs Cozmo Soar Interface slides 5 Nate Derbinsky Design-ReSOARpe: A Challenge Problem slides 5 Anthony Deschamps Soar Language Server slides 20 Randolph Jones (Still Trying To) Learn To Soar slides 15 Steven Jones Event Memory from Psychology slides 15 Steven Jones Event Memory in Soar slides 20 James Kirk Ambiguity and Knowledge Transfer in Interactive Task Learning slides 20 James Kirk ITL Game archive slides 20 John Laird Taxonomy of Learning and Performance Integration slides 15 Peter Lindes Analysis of Lucia: A Cognitive Model of Language Comprehension slides 15 Peter Lindes Lucia and the Brain: The Lucia Model Compared to Brain Data slides 20 Lizzie Mamantov MAST: A motion planning strategy for Soar and friends slides 20 Aaron Mininger New Task Learning Capabilities in Rosie slides 20 Preeti Ramaraj Exploring Transparency Mechanisms for Identification of Interaction Failures in HRI slides 20 Tim Saucer Taking Soar to the OpenAI Gym slides 15 Jule Schatz An Architectural Approach to Modeling the Remote Associates Test slides 15 Jule Schatz Learning to Play Atari Like Games slides 20 Bryan Stearns Separating Goal Structure from Proposal Rules slides 20 Bryan Stearns Cognitive Model Timing: Retrievals vs Reasoning slides 15 Michael van Lent SoarTech Update slides"},{"location":"workshops/40/","title":"40th Soar Workshop","text":"<p>June 3rd, 2020</p> <p>Held virtually via Zoom due to COVID-19</p> <p>YouTube Playlist</p>"},{"location":"workshops/40/#schedule","title":"Schedule","text":"Time (EDT) Duration Title Presenter Links 10:00 AM \u2014 11:50 AM 30 min Introduction to Soar John Laird video 30 min Learning Tasks with Diverse Action Types Aaron Mininger video 20 min James Kirk Learning Task Definitions video 15 min Jule Schatz Learning Causal Relationships video 15 min Charles Newton Transformers in Soar video 12:30 PM \u2014 2:20 PM 20 min Peter Lindes Progress in Language Comprehension video 20 min Peter Lindes Explorations with Attention and SA video 20 min Bryan Stearns Soar Model of Human Learning and Transfer video 20 min Bryan Stearns Soar PSCM as Model of Neural Task Sets video 2:30 PM \u2014 4:05 PM 20 min Lizzie Goeddel Moving Forward with Motion Planning for Soar video 20 min Steven Jones Mechanisms for Event Cognition video 20 min Ion Juvina Empirical Guidance for Computational Models of Interactive Learning video 15 min Bob Marinier JSoar 4 x Update video 20 min Bob Marinier Soar LSP Cross Editor Soar Support video 20 min Michael van Lent Soar Tech Update video 4:15 PM \u2014 ... 30 min Discussion video"},{"location":"workshops/41/","title":"41st Soar Workshop","text":"<p>June 14th-15th, 2021</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> <p>Also attended virtually via Zoom</p> Participant group photo (Zoom screenshot) with arms raised (making waves), 2021"},{"location":"workshops/41/#schedule","title":"Schedule","text":"Time Duration Presenter Title Links June 14, 2021 125 10:00am-12:05pm 5 John Laird Introduction slides 20 Jule Schatz Modeling the RAT as Retrievals from Semantic Memory slides 30 Bryan Stearns 20 Questions Revisited: Narrowing the Search Space for Models of Human Cognition slides 20 Peter Lindes A Model of Attention in Working Memory slides 20 Peter Lindes Ideas for Modeling Language Acquisition slides 30 Aaron C Wacker Soar and NLP for reading comprehension, strategy generation, and experience based language solutions and precision semantics for health care. slides 85 1:00pm-2:25pm 10 Bob Wray Introducing the Center for Integrated Cognition slides 15 Bob Wray Integrating Cognitive Architecture and Neural Generative Language Models slides 20 Bob Wray Incorporating Abstract Behavioral Constraints in the Performance of Agent Tasks slides 20 John Laird Learning from Multiple Sources of Knowledge for Atari Games slides 20 Bryan Stearns The PROPs Development Kit for Building Soar Agents slides 120 3:00pm-5:00pm 20 James Boggs Integrating Visual Reasoning into a Cognitive Architecture slides 20 Steven J. Jones Event Memory Mechanisms in Soar's Episodic Memory slides 20 Steven J. Jones A Simple Action Model Learning Example slides 20 Lizzie Goeddel An update on motor control through SVS slides 20 Preeti Ramaraj Building robots that help humans build better mental models of robots slides 20 Discussion June 15, 2021 120 10:00am-12:00pm 20 Michael van Lent SoarTech Update slides 20 Michael van Lent AI for high stakes, human-in-the-loop, data-sparse problems slides 10 Randolph M Jones F-WASP Update slides 30 John Sustersic Towards a Unified Model of Deep Cognition for Autonomy slides 40 Discussion"},{"location":"workshops/42/","title":"42nd Soar Workshop","text":"<p>May 24th-25th, 2022</p> <p>1014 Herbert H. Dow building, North Campus, University of Michigan</p> <p>Original announcement page</p>"},{"location":"workshops/43/","title":"43rd Soar Workshop","text":"<p>June 14-15, 2023</p> <p>University of Michigan\u2019s North Campus in Ann Arbor, MI</p> <p>Also attended virtually via Zoom</p> <p>Guest Speakers:</p> <ul> <li>Dr. Melanie Mitchell the Davis Professor of Complexity at the Santa Fe Institute and an alum of the University of Michigan.</li> <li>Dr. Paul Rosenbloom, Prof. Emeritus of the Thomas Lord Department of Computer Science, USC</li> <li>Dr. Ying Zhao, Research Professor, Information Sciences Department, Naval Postgraduate School</li> </ul>"},{"location":"workshops/44/","title":"44th Soar Workshop","text":"<p>May 29th, 2024</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> <p>Also attended virtually via Zoom</p>"},{"location":"workshops/44/#schedule","title":"Schedule","text":"Time Duration Presenter Title Links 9:00am-10:30pm 20 John Laird Introductions 5 Paul Schuricht Using Soar with Simulink for Pilot Decision Making slides 15 Moritz Schmidt Soar as Cognitive Control Unit for a Robot Task Delegation Interface based on ROS2 slides 25 Lizzie Goeddel Flexible motion control through SVS: New features and example agents slides 25 James Boggs Progress on Visual-Symbolic Reasoning in Soar slides 10:30am-11:00am 30 BREAK 11:00am-12:00pm 15 Andrew Nuxoll Visual Soar Update slides 15 Jonathan de Jong \"pip install soar-sml\": packaging Soar for Python slides 15 Nathan Glenn 2024 Soar Update slides 15 Peter Lindes Representing Ontologies in Soar slides 12:00-1:00pm 60 Lunch 1:00pm-2:40pm 25 Paul Rosenbloom A Proposal for Extending the Common Model of Cognition to Emotion slides 25 Christian Lebiere Summary of Symposium on Integrating Cognitive Architecture and Generative Models slides 25 Peter Lindes Language in Soar slides 25 John Laird Thor-Soar: A New Soar Agent for Interactive Task Learning slides 2:40pm-3:00pm 20 BREAK 3:00pm-5:00pm 15 Robert Wray Eliciting Problem Specifications via Large Language Models slides 15 Siyu Wu LLAMA-ACT-R, a Neuro-Symbolic Architecture (ACT-R) for LLM Decision Making slides 25 James Kirk Improving Knowledge Extraction from LLMs for Task Learning through Agent Analysis slides 15 Steven J. Jones Goals from Partial Grounding of Constraints slides 20 Steven J. Jones Toward Constraint Compliant Planning and Goal Formulation slides 30 John Laird Final Discussion"},{"location":"workshops/45/","title":"45th Soar Workshop","text":"<p>May 5, 2025</p> <p>3270 Beyster Building, North Campus, University of Michigan</p> <p>Also attended virtually via Zoom</p> <p>Guest speaker: Professor Jonathan Cohen of Princeton Neuroscience Institute</p> <p>YouTube playlist</p> Zoom screenshot of participants with arms raised (making waves), 2025 Participant group photo with arms raised (making waves), 2025"},{"location":"workshops/45/#schedule","title":"Schedule","text":"Time Duration Presenter(s) Title Links 9:00am-10:15am 75 15 John Laird Introductions 15 Nathan Glenn 2025 Soar Update pdf pptx 15 Moritz Schmidt Building Soar with CMake and Conan pdf video 15 Bob Wray Exploring Continuous RL Algorithms for Soar-RL pdf video 15 Siyu Wu From Cognitive Models to Language Models in Decision Making video 10:15am-10:30am 15 BREAK 10:30am-12:00pm 90 45 Jonathan Cohen Toward an Understanding of Symbol Processing in Neural Network Architectures pdf video 45 Christian Lebiere, Paul S. Rosenbloom, Andrea Stocco Panel and Discussion video 12:00pm-1:00pm 60 LUNCH 1:00pm-2:50pm 110 15 John Laird Extending the CMC with Metacognition pdf video 10 James Kirk Metareasoning for Comprehensive Troubleshooting pdf pptx video 15 Robert Wray Responding to Situations Outside of an Agent's Design Scope (OODS) pdf video 15 Steven J. Jones How Different Sources of Knowledge Shape Normative Decision-making pdf pptx video 20 Robert Wray Cognitive Design Patterns and Agentic LLM Architectures pdf video 15 Robert Wray Soar-inspired Agentic LLM Capabilities: Hierarchical Decomposition &amp; Knowledge Compilation pdf video 20 Bryan Stearns Agentic AI - Industry Definitions pdf pptx video 2:50pm-3:05pm 15 BREAK 3:05pm-5:00pm 115 15 James Boggs Towards Solving Visual Puzzles using Visual Knowledge Representations in Soar pdf pptx video 15 Jim Beyer, Nathan Glenn Integrating Soar and AI2-THOR pdf pptx video 20 John Laird Thor-Soar Agent Update pdf pptx video 15 Aaron Mininger Adding Interactive Task Learning to Thor-Soar pdf video 5 James Kirk Pysoarlib Language Model Connector pdf pptx video 15 James Kirk Hierarchical Logic Graphs for Grounding Goals and Answering Queries pdf pptx video 20 Peter Lindes Soar Learning to Make Breakfast pdf pptx video 10 Wrap-up and Discussion video"},{"location":"workshops/20/","title":"20th North American Soar Workshop","text":"<p>May 11th-14th, 2000</p> <p>Los Angeles, CA</p> <p>Original Proceedings Page</p> Participant group photo"},{"location":"workshops/20/#schedule","title":"Schedule","text":""},{"location":"workshops/20/#thursday-may-11th","title":"Thursday, May 11th","text":"<p>Tutorials/Introduction to Soar</p>"},{"location":"workshops/20/#friday-may-12th","title":"Friday, May 12th","text":"Time Presenter Topic Soar 8 for Soarers Creating a Simulation Environment 7:00pm Dinner from Abbot's Pizza Co. Introductions and Collect Speaker Materials 8:00pm ISD Demos Frank Ritter Eye and Hand in Soar Andrew Scholer Learning in STEVE Randy Hill Immersadesk Helicopter Lewis Johnson CARTE Jonathan Gratch Creepy Emotive Faces"},{"location":"workshops/20/#saturday-may-13th","title":"Saturday, May 13th","text":"Time Presenter Topic Links 8:00 - 9:00 Registration &amp; Breakfast ENTERTAINMENT TONIGHT 9:00 - 9:15 Jonathan Gratch Soar Goes Hollywood slides 9:15 - 9:30 Jeff Rickel ICT Mission Rehearsal slides 9:30 - 9:45 John Laird Lessons Learned from the Computer Game Industry slides 9:45 - 10:00 Mike Van Lent Report from the AAI Spring Symposium on AI &amp; Interactive Entertainment slides NATURAL LANGUAGE 10:00 - 10:15 Deryle Lonsdale Integrating Wordnet with NL-Soar slides 10:15 - 10:30 Anton Rytting Using Worldnet to Build Semantic Representation slides 10:30 - 10:45 Barry Brian WergerYoung Jun Kim Integrating Soar with Physical Robots &amp; Behavior-Based Control slides 10:45 - 11:00 Break COGNITIVE MODELING &amp; BELIEVABILITY 11:00 - 11:15 Mazin Assaine Integrating Direction in Soar Believable Synthetic Characters slides 11:15 - 11:20 Brian Magerko An Introduction to a Grad Student slides 11:20 - 11:35 Jonathan Gratch Modeling Bad TV Actors in Soar slides 11:35 - 11:50 John Laird Anticipation in the Soar Quakebot slides 11:50 - 12:00 John Laird The Humanity of the Soar Quakebot slides 12:00 - 1:00 Lunch SOAR DEVELOPMENT 1:00 - 1:10 Karen Coulter Soar Update slides 1:10 - 1:20 Mazin Assanie New Debugging Tools in TSI 3.0 slides 1:20 - 1:30 Glenn Taylor SDB: A Soar Debugger slides 1:30 - 1:40 Mazin Assanie The Soar Blank Environment: A Skeletal System for Building Tcl-based Soar Environments slides 1:40 - 1:55 Mike van Lent Application Interface Development slides 1:55 - 2:10 Bradley Jones Visual Soar slides 2:10 - 2:25 Break SOAR COMMUNITY 2:25 - 2:35 Jim Rosbe Life in the \"Real World\" slides 2:35 - 2:45 Tony Kalus The Soar FAQ &amp; DERA Report slides SENSING &amp; INTERPRETATION 2:50 - 3:05 Frank Ritter SOAR/TcL-PM: Including a Widely Applicable Eye &amp; Hand in Soar slides 3:05 - 3:20 Ernst Bovenkamp Vision-Soar: Multi-Agent Image Interpretation of Medical Images slides 3:20 - 3:35 Wayne ZhangRandy Hill A Template-Based &amp; Pattern-Driven Approach to Situtaion Awareness &amp; Assessment slides 3:35 - 3:45 Randy Jones Interactive Visualization of Situational Awareness slides 3:45 - 4:00 Break 4:00 - 5:15 Break-out SessionsPossible topics:<ul><li>The Reusability of Soar Code Across Applications?</li><li>Soar Interfaces</li><li>Soar &amp; Psychology</li><li>Future Development Tools</li><li>Multi-Agent Support</li><li>Modeling Emotions and Personality</li><li>Working with the Entertainment Industry XS</li></ul> 5:15 - 5:45 Discussions Summary 6:00 7241 W. Manchester Avenue, (310) 641-7600 Dinner at Siam"},{"location":"workshops/20/#sunday-may-14th","title":"Sunday, May 14th","text":"Time Presenter Topic Links 8:00 - 9:00 Breakfast Machine Learning 9:00 - 9:15 Mike van Lent Learning Task Performance Knowledge by Observation slides Soar Architecture 9:15 - 9:25 Ronald Chong Using Working Memory in Decay in an EPIC-Soar Model of En Route Air Traffic Controller Behavior 9:25 - 9:55 Ronald Chong Forgetting in Soar: An Architectural Implementation of Working Memory Decay 9:55 - 10:10 Scott Wallace Soar Lite: Designed for Speed slides 10:10 - 10:25 Scott Wallace AI Architecture: Evaluation &amp; the Soar Lite Project slides 10:25 - 10:35 Sayan Bhattacharyya Comparing Soar &amp; UM-PRS at the Symbol and Knowledge Levels slides 10:35 - 11:00 Break 11:00 - 11:10 Randy Jones TacAir-Soar at Sea: Deployment in BFTT slides 11:10 - 11:30 David PynadathMilind Tambe Electronic Elves slides 11:30 - 11:40 Hyuckchul Jung Collaborative Negotiation Through Argumentation slides 11:40 - 12:00 Closing Remarks 12:00 - 1:00 Lunch 1:00 Go Play"},{"location":"workshops/24/","title":"24th Soar Workshop","text":"<p>June 7-11, 2004</p> <p>Ann Arbor, MI</p> <p>Original announcement page</p> Participant group photo"},{"location":"workshops/24/#schedule","title":"Schedule","text":""},{"location":"workshops/24/#tuesday-june-8th","title":"Tuesday, June 8th","text":"<p>6:30pm PIZZA HOUSE Social Gathering and Slide Collection</p>"},{"location":"workshops/24/#wednesday-june-9th","title":"Wednesday, June 9th","text":"Time Duration Presenter Title Links 8:00-9:00 60 Registration Registration and Bagels 9:00-10:15 75 Infrastructure 15 John Laird Welcome 5 Mark Cohen An Update on the Soar FAQ slides 10 Jon Voigt Soar Bugzilla slides 30 Jens Wesling gSKI/TgDI slides 15 Bob Marinier AsmL Soar Specification slides 10:15-10:45 30 Break Break 10:45-12:00 75 Tools 15 Andrew Nuxoll Visual Soar Update slides 5 Timothy Jasko Eclipse-Soar Plugin 10 Mazin Assanie TSDebugger 15 Doug Pearson Java Soar Debugger slides 10 Jon Voigt Soar 8.5.1 &amp; 8.6 Releases slides 20 Laird &amp; Rosbe Soar Consortium: Soar Support post-8.6 12:00-1:00 60 Lunch Lunch 1:00-2:45 105 Tools &amp; Applications 25 Tolga Konik Inspecting Recorded Behavior History slides 15 Paul Brobst Tactical AI, Soar, and Full Spectrum Command slides 15 Ramesh Saran Terrain Representation in \"Full Spectrum Command\" 25 Phill Smith Soar Agents for Unmanned Air &amp; Ground Vehicles slides 25 Syed Enam-ur-Rehman Auto-Mate: A Framework for Process Automation slides 2:45-3:15 30 Break Break 3:15-5:00 105 Applications 15 Randy Jones Knowledge-intensive Soar agents in Defense M&amp;S slides 60 Smith, Jones, van Lent Panel: Soar for Real Applications slides 30 Laird &amp; Rosbe Discussion of Soar Consortium (Principles) (Procedures) Principles, Procedures"},{"location":"workshops/24/#thursday-june-10th","title":"Thursday, June 10th","text":"Time Duration Presenter Title Links 9:00-10:15 70 Architecture 25 Simon Willcox Hardware Architectures For Distributed Agents slides 30 Matthew Scarpino Soar Processing w/ Field Programmable Gate Arrays slides 15 Syed Enam-ur-Rehman DynaSoar: A High Performance Soar Architecture slides 10:15-10:45 30 Break Break 10:45-12:00 75 Architecture 15 Mike van Lent The Integrating Architecture slides 15 Bob Wray Goal Dependency Set Primer slides 15 Jacob Crossman Large LT Declarative Memory: Issues and Ideas slides 30 Sean Lisse The STGS Approach - A Forest of Goals slides 12:00-1:00 60 Lunch Lunch 1:00-2:45 105 Knowledge Specification 15 Mark Cohen Herbal: A High-Level Language &amp; Viewer for Soar slides 30 Andrea Macklem Spec. of Cog. Models using Patterns and Conflicts slides 30 Glenn Taylor Behavior Design Patterns slides 30 Jacob Crossman A High Level Symbolic Representation slides 2:45-3:15 30 Break Break 3:15-5:00 105 Knowledge Specification 30 Douglas Pearson Redux - Rapid Model Building slides 15 Tolga Konik Update on Learning by Observation slides 60 Robert Wray Knowledge Specification Discussions 6:00-7:00 60 Dinner Dinner 7:00-8:00 60 John Anderson ACT-R"},{"location":"workshops/24/#friday-june-11th","title":"Friday, June 11th","text":"Time Duration Presenter Title Links 9:00-10:15 75 Cognitive Modeling 25 Deryle Lonsdale Ongoing Work on Soar Linguistic Applications slides 30 Robert Marinier Soar-Emote slides 15 Syed Enam-ur-Rehman Confidence Modeling for Humanoid Decisions slides 5 Steven Solomon Ideas for Explainable AI slides 10:15-10:45 30 Break Break 10:45-12:00 75 AI Methods &amp; Applications 15 Jonathan T. Beard Heur. Form. for Temporal-Spatial Qual. Reasoning slides 20 Soar Tech HBM Video 30 Brian Magerko Soar as a Story Director slides 15 Jim Rosbe Soar Tech update slides 12:00-1:00 60 Lunch Lunch 1:00-2:35 95 Learning 5 Bill Kennedy Continuing Studies of Long-term Learning w/ Soar slides 30 Andrew Nuxoll Episodic Memory for Soar Agents slides 30 Shelley Nason Reinforcement Learning and Soar slides 30 John Laird A Soar's Eye View of ACT-R slides 2:35-3:05 30 Break Break 3:05-4:15 70 Discussion Discussion of ACT-R and Soar"},{"location":"workshops/25/","title":"25th Soar Workshop","text":"<p>June 13th-17th, 2005</p> <p>Ann Arbor, MI</p> <p>Original announcement page</p> Participant group photo"},{"location":"workshops/25/#schedule","title":"Schedule","text":""},{"location":"workshops/25/#wednesday-june-15","title":"Wednesday, June 15","text":"Time Duration Presenter Title Links 8:00-9:00 60 Registration and Bagels 9:00-10:15 75 Architecture &amp; Cognitive Modeling 15 John Laird Welcome 25 John Laird Cognitive Architecture &amp; Human-level AI ppt, pdf 15 Bob Wray Architectures for Cognitive Information Processing pdf 20 Bob Marinier Situation Comprehension and Emotion ppt, pdf 10:15-10:45 30 Break 10:45-12:00 75 Cognitive Modeling 5 Lisa S. Holt Inviting Research Ideas &amp; Collaborations pdf 5 Bill Kennedy New Digs: Postdoc at NRL ppt, pdf 20 Deryle Lonsdale Progress on NL-Soar, and Introducing XNL-Soar ppt, pdf 25 B. Chandrasekaran Augmenting Cognitive State with Diagrams ppt, pdf 20 Discussion 12:00-1:15 75 Lunch 1:15-2:45 90 Learning 20 Andrew Nuxoll Episodic Memory for Soar ppt, pdf 20 Yongjia Wang Soar Semantic Memory ppt, pdf 20 Shelley Nason Reinforcement Learning and Soar ppt, pdf 15 John Laird Chunking with Confidence ppt, pdf 15 Discussion 2:45-3:15 30 Break 3:15-5:00 105 Cognitive Modeling 60 Dave Kieras Next Generation Model of Perception and Action 45 Discussion 6:00-9:00 180 Dinner/Party at John Laird's House"},{"location":"workshops/25/#thursday-june-16","title":"Thursday, June 16","text":"Time Duration Presenter Title Links 9:00-10:15 75 Applications 15 Brian Magerko Director Agent ppt, pdf 15 Brian Magerko Interactive Storytelling Architecture for Training ppt, pdf 15 Paul Carpenter Intelligent Forces for JFETS pdf 15 Randolph M. Jones Soar Agents in Government Applications pdf 15 Bill Kennedy Counting in Soar ppt, pdf 10:15-10:45 30 Break 10:45-12:00 75 Applications &amp; Tools 15 Geoffrey Morgan dTank: An Environment for Agent Architectures ppt, pdf 15 Bob Wray Control Options for Computer-Game AIs pdf 25 Randolph M. Jones Tools to Support Knowledge Design and Explanation pdf 15 Frank Ritter Herbal and the Herbal Viewer ppt, pdf 5 Jonathan Voigt Soar Wiki ppt, pdf 12:00-1:15 75 Lunch 1:15-2:45 90 Tools 15 Douglas Pearson A New Soar Debugger in Java ppt, pdf 15 Devvan Stokes TIELT/Soar ppt, pdf 15 Douglas Pearson Redux Update ppt, pdf 15 Tolga Konik Inductive Learning from Abstract Behavior Descriptions ppt 15 Sean Lisse Onto2Soar - An Ontology to Soar Knowledge Interface pdf 15 Tim Darr Self-Learning Ontologies ppt, pdf 2:45-3:15 30 Break 3:15-5:00 105 Tools, Etc. 15 Randolph M. Jones Fast, Flexible (and Inefficient?) Message Parsing pdf 15 Jim Rosbe Soar Technology Update pdf 15 John Laird Soar Consortium/Soar Foundation 60 Discussions"},{"location":"workshops/25/#friday-june-17","title":"Friday, June 17","text":"Time Duration Presenter Title Links 9:00-12:00 180 Soar 8.6 45 Douglas Pearson SML: A New Interface into Soar ppt, pdf 15 Jonathan Voigt Command Line Interface ppt, pdf 30 Karen Coulter Implementation of the Soar Kernel ppt, pdf 15 Douglas Pearson The Inside Story on the Java Debugger ppt, pdf 15 Devvan Stokes IMP: InputLink Manipulation Plug-in ppt, pdf"},{"location":"workshops/26/","title":"26th Soar Workshop","text":"<p>MAY 22-26, 2006</p> <p>Ann Arbor, Michigan</p> <p>Original announcement page</p> Participant group photo"},{"location":"workshops/26/#schedule","title":"Schedule","text":""},{"location":"workshops/26/#wednesday-may-24-2006","title":"Wednesday, May 24, 2006","text":"Time Duration Presenter Title Links 8:00-9:00 60 Registration and Bagels 9:00-10:15 75 Cognitive Modeling 15 John Laird Introductions 30 Bob Marinier Unifying Cognitive Functions and Emotional Appraisal slides 15 Deryle Lonsdale Update on Soar-based language processing slides 10:15-10:45 30 Break 10:45-12:00 75 Learning and Memory 15 Andrew Nuxoll Steps toward a Domain Independent Episodic Memory slides 15 Yongjia Wang Integrating Semantic Memory in Soar slides 15 Shelley Nason Hierarchical Reinforcement Learning in Soar slides 15 Nick Gorski Methods for Transfer Learning Using Soar slides 15 Discussion 12:00-1:15 75 Lunch 1:15-2:45 90 Learning and Advanced Capabilities 5 David Ray Soar Technology Community Liaison slides 5 Alan Vayda Self Introduction slides 5 Jong Kim Soar FAQ slides 15 Elyon DeKoven Participatory scenario design and simulation on the ICF testbed slides 30 Joseph Xu ORTS: A Case Study of Multi-Tasking in Soar slides 15 Sam Wintermute Visual Attention for a Real-Time Strategy Game Game slides 15 Discussion 2:45-3:15 30 Break 3:15-5:00 105 Advanced Capabilities 30 Scott Lathrop Incorporating Visual Imagery into a Cognitive Architecture slides 30 Jonathan Beard Spatial &amp; Temporal Reasoning (SPAT-R) slides 25 Brian Magerko Player Modeling in IDA slides 20 Discussion"},{"location":"workshops/26/#thursday-may-25-2006","title":"Thursday, May 25, 2006","text":"Time Duration Presenter Title Links 9:00-10:15 75 Applications 20 Brian Magerko Interactive Storytelling Architecture for Training slides 15 Jim Rosbe Soar Technology Update slides 25 Brian Stensrud IF-Soar: An Autonomous Fire Direction Center slides 15 Jonathan T. Beard Joint Fires &amp; Effects Training System slides 10:15-10:45 30 Break 10:45-12:00 75 Soar Architecture 15 John Laird A Proposal For Changing Soar\u2019s Decision Procedure slides 45 Douglas Pearson What\u2019s New in Soar 8.6.2 slides 15 Discussion 12:00-1:15 75 Lunch 1:15-2:45 90 Soar from an AI perspective 15 Scott Wallace S-Assess: Self-Assessment with Soar slides 15 Robert Wray Relevance Estimation for Evidence Marshalling slides 30 Randolph Jones HLSR: Compiling to Soar slides 15 Robert Wray Modularity in Soar-based Applications slides 15 Jacob Crossman SoarML: A Graphical Modeling Language for Agents slides 2:45-3:15 30 Break 3:15-4:30 75 Control and Architecture 15 John Laird Pyramid Problems in Soar &amp; ACT-R slides 15 Rick Lewis Control and Metacognition: A View from EPIC, Soar and ACT-R slides 30 Rick Lewis Cognitive Constraint Modeling: An Alternative to Traditional Architectures slides 15 Discussion"},{"location":"workshops/26/#friday-may-26-2006","title":"Friday, May 26, 2006","text":"Time Duration Presenter Title Links 9:00-10:15 75 Brain inspired computation 15 John Laird BICA: Biologically-Inspired Cognitive Architecture slides 60 Rick Granger Principles of Brain Computation 10:15-10:45 30 Break 10:45-12:00 75 Brain inspired computation 15 Lee Newman Clusters, Symbols and Cortical Topography slides 15 Yongjia Wang Integrating Clustering and Semantic Memory in Soar slides 30 Thad Polk Biologically-Inspired Control in Problem Solving slides 15 Discussion"}]}